

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>重学Binder - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="重学Binder">
              
                重学Binder
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-05-19 10:22" pubdate>
        2020年5月19日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      185
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">重学Binder</h1>
            
            <div class="markdown-body">
              <!--基于先前的学习内容，重新进行Binder理论知识的整理-->
<h2 id="Linux传统的进程间通信原理"><a href="#Linux传统的进程间通信原理" class="headerlink" title="Linux传统的进程间通信原理"></a>Linux传统的进程间通信原理</h2><p><img src="/images/Linux-IPC-Basics.png" srcset="/img/loading.gif" alt="Linux进程结构"></p>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><blockquote>
<p>保护系统中进程互不干扰。在操作系统中，进程之间数据是不互通的，相互之间无法访问数据，保证数据的安全星。</p>
</blockquote>
<p>在<code>进程隔离</code>的条件下，需要通过<code>IPC(Inter Process Communication)机制</code>进行进程间的通信。</p>
<h3 id="进程空间划分"><a href="#进程空间划分" class="headerlink" title="进程空间划分"></a>进程空间划分</h3><blockquote>
<p>操作系统的核心是<strong>内核</strong>，独立于普通的应用程序，可以访问受保护的内存空间以及底层的硬件设备。</p>
</blockquote>
<p>为了使用户进程不能操作内核，保证内核的安全性。所以操作系统将虚拟空间划分为两部分：</p>
<ul>
<li><p><strong>内核空间</strong>(一般占1GB)</p>
<p>系统内核运行的空间</p>
</li>
<li><p><strong>用户空间</strong>(一般占3GB)</p>
<p>用于用户程序执行的空间</p>
</li>
</ul>
<p><strong>用户空间在不同进程之间不能共享，内核空间是各个进程之间共享的。</strong></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><blockquote>
<p>用户空间的权限低于内核空间，导致用户空间无法直接访问内核资源(例如文件操作、网络访问等)，就需要借助<strong>系统调用</strong>实现内核资源访问。</p>
</blockquote>
<p><strong>系统调用</strong>是用户空间访问内核的唯一方式，保证了所有资源访问都是在内核的控制下进行，避免用户程序对系统资源的越级访问，提升系统的安全和稳定性。</p>
<p>Linux采用两级保护机制：</p>
<ul>
<li>0级供系统内核使用</li>
<li>3级供用户程序使用</li>
</ul>
<p>当进程使用<code>系统调用</code>执行内核代码时，进程就进入了<strong>内核态</strong>，此时处理器处于<code>0级·</code>；当进程执行自己的代码时，进程就进入<strong>用户态</strong>，此时处理器位于<code>3级·</code>。</p>
<p><code>系统调用</code>主要通过以下两个函数实现：</p>
<ul>
<li><code>copy_from_user</code>：将数据从用户空间拷贝到内核空间</li>
<li><code>copy_to_user</code>：将数据从内核空间拷贝到用户空间</li>
</ul>
<h3 id="传统IPC功能实现"><a href="#传统IPC功能实现" class="headerlink" title="传统IPC功能实现"></a>传统IPC功能实现</h3><p><img src="/images/Linux-IPC.png" srcset="/img/loading.gif" alt="Linux-IPC"></p>
<ol>
<li>发送进程通过<code>系统调用 copy_from_user·</code>把自己的<code>内存缓存区(发送进程)</code>的数据拷贝到<code>内核缓存区</code>中</li>
<li>内核程序通过<code>系统调用 copy_to_user</code>把内核缓存区的数据拷贝到接收进程的<code>内存缓存区</code>中</li>
</ol>
<p>传统IPC通信过程中暴露了两个明显的缺点：</p>
<ol>
<li><strong>性能低下</strong>，需要经历两次数据拷贝过程：<code>发送进程内存缓存区 -&gt; 内核缓存区 -&gt; 接收进程内存缓存区</code></li>
<li><strong>空间、时间浪费</strong>，接收方需要事先开辟一块内存空间准备接受发送方的数据，由于不能确定数据的大小。所以只能开辟一块较大的空间(<code>空间浪费</code>)或者先行获取发送数据的大小(<code>时间浪费</code>)。</li>
</ol>
<h3 id="传统Linux进程通信手段"><a href="#传统Linux进程通信手段" class="headerlink" title="传统Linux进程通信手段"></a>传统Linux进程通信手段</h3><ul>
<li>管道</li>
<li>消息队列</li>
<li><strong>共享内存</strong>：无需复制，共享缓冲区直接附加到进程的虚拟地址，速度快。<em>但是无法解决进程间同步问题</em></li>
<li><strong>套接字(Socket)</strong>：接口通用，但是传输效率低，主要用于不同机器间的通信</li>
<li><strong>信号量(semaphore)</strong>：作为一种锁机制，防止某进程正在访问共享资源时，其他进程也在访问该资源。</li>
<li>信号</li>
</ul>
<h2 id="Binder基本原理"><a href="#Binder基本原理" class="headerlink" title="Binder基本原理"></a>Binder基本原理</h2><h3 id="动态内核可加载模块"><a href="#动态内核可加载模块" class="headerlink" title="动态内核可加载模块"></a>动态内核可加载模块</h3><p><code>模块</code>是具有独立功能的程序，可以被单独编译但是无法独立运行。利用<code>动态内核可加载模块</code>机制，动态的添加一个内核模块到内核空间内，用户进程就可以通过这个模块实现通信。</p>
<p><strong>在Android系统中，加载进内核空间的模块就是<code>Binder驱动</code>。</strong></p>
<h3 id="内存映射-mmap"><a href="#内存映射-mmap" class="headerlink" title="内存映射-mmap"></a>内存映射-mmap</h3><p><code>Binder驱动</code>添加完毕后，就需要开始进程间通信。接下来就需要用到<code>mmap()——内存映射</code>。</p>
<p><code>mmap</code>用于文件或者其他对象映射进内存，通常用在有物理介质的文件系统上的，比如磁盘之类。</p>
<p>在Binder中，通过<code>mmap</code>将用户空间内的一块内存区域映射进内存空间，当映射关系建立完毕后，任何一方对内存区域的改动都会被反映到另一方。</p>
<p>Binder建立了一个虚拟设备<code>/dev/binder</code>，然后在内核空间创建了一块数据接收的缓冲区，这块<code>数据接收缓冲区</code>与<code>内核缓冲区</code>和<code>接收数据的用户空间</code>建立映射，减少了一次<em>数据拷贝</em>。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><img src="/images/Binder-IPC.png" srcset="/img/loading.gif" alt="Binder流程"></p>
<ol>
<li><code>Binder驱动</code>在<code>内核空间</code>建立一个<code>数据接收缓存区</code></li>
<li>接着在<code>内核空间</code>开辟一块<code>内核缓存区</code>，建立起<code>内核缓存区和内核数据接收缓存区</code>之间的映射关系，以及<code>数据接收缓存区和用户空间</code>的映射关系</li>
<li>发送方进程通过<code>系统调用copy_from_user</code>将数据复制到<code>内核缓存区</code>，由于各自之间存在映射，等价于<code>直接把数据传递到了接收进程</code>。</li>
</ol>
<h3 id="Binder优势"><a href="#Binder优势" class="headerlink" title="Binder优势"></a>Binder优势</h3><ul>
<li><p>性能</p>
<blockquote>
<p>Linux上的通信方式例如<code>管道、Socket</code>都需要复制两次数据。而Binder只要一次</p>
<p>拷贝两次过程：发送方数据通过<code>系统调用copy_from_user</code>拷贝到<code>内核缓存区</code>，再由<code>内核缓存区</code>调用<code>系统调用copy_to_user</code>拷贝至接收方。</p>
<p>Binder执行过程：在内核中建立数<code>据接收缓存区</code>，发送方数据通过<code>系统调用copy_from_user</code>拷贝到<code>内核缓存区</code>，此时<code>内核缓存区</code>已与<code>数据接收缓存区</code>和<code>接收进程数据缓存区</code>建立映射，相当于发送方的数据直接到接收方。</p>
</blockquote>
</li>
<li><p>安全性</p>
<blockquote>
<p>传统的Linux通信是不包含通信双方的身份验证，Binder自带身份验证，提高了安全性。</p>
<p><a href="#Binder权限验证">Binder权限验证</a></p>
</blockquote>
</li>
<li><p>稳定性</p>
<blockquote>
<p>Binder基于CS架构，Client的需求都交与Server去完成，职责明确。</p>
</blockquote>
</li>
</ul>
<h2 id="Binder通信模型"><a href="#Binder通信模型" class="headerlink" title="Binder通信模型"></a>Binder通信模型</h2><p><img src="/images/Binder通信模型.png" srcset="/img/loading.gif" alt="Binder通信模型"></p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><blockquote>
<p>客户端进程</p>
</blockquote>
<p><code>Client</code>负责向<code>Service Mananger</code>查询所需Service，并且获得一个<code>Binder代理对象</code>，再通过<code>Binder代理对象</code>向<code>Server</code>发起请求</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><blockquote>
<p>服务端进程</p>
</blockquote>
<p><code>Server</code>进程启动时，会通过<code>Binder驱动</code>注册自身的服务到<code>Service Manager</code>中，并且启动一个<code>Binder线程池</code>，用来接收<code>Client</code>的请求。</p>
<h3 id="Service-Manager"><a href="#Service-Manager" class="headerlink" title="Service Manager"></a>Service Manager</h3><blockquote>
<p>服务的管理者，指代的是<code>Native</code>层的<code>ServiceManager</code>，是整个 Binder通信机制的 大管家，也是Android进程间通信的守护进程。</p>
</blockquote>
<p>主要有以下功能</p>
<ul>
<li><code>Service</code>通过<code>Binder驱动</code>向<code>ServiceManager</code>注册Binder，表示可以对外提供服务。</li>
<li><code>Client</code>通过<code>Binder驱动</code>从<code>ServiceManager</code>获取Binder的引用。</li>
</ul>
<p><code>Service Manager</code>就是一个进程，内部维护了一张表，维护了<code>名字+Binder实体的引用</code>。</p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p><code>Service Manager</code>进程是在开机时启动的</p>
<ol>
<li>init进程解析<code>servicemanager.rc</code>之后，找到对应可执行程序<code>/system/bin/servicemanager</code></li>
<li>继续执行到<code>service_manager.c</code>的<code>main()</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">//frameworks/native/cmds/servicemanager/service_manager.c<br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)<br>&#123;<br>    struct binder_state *bs;<br>    <span class="hljs-keyword">union</span> selinux_callback cb;<br>    <span class="hljs-keyword">char</span> *driver;<br><br>    <span class="hljs-keyword">if</span> (argc &gt; 1) &#123;<br>        driver = argv[1];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        driver = "/dev/binder";<br>    &#125;<br><br>    bs = binder_open(driver, 128*1024);<br><br>    <span class="hljs-keyword">if</span> (binder_become_context_manager(bs)) &#123;<br>        ALOGE("cannot become context manager (%s)\n", strerror(errno));<br>        <span class="hljs-keyword">return</span> -1;<br>    &#125;<br>  <br>#ifdef VENDORSERVICEMANAGER<br>    sehandle = selinux_android_vendor_service_context_handle();<br>#<span class="hljs-keyword">else</span><br>    sehandle = selinux_android_service_context_handle();<br>#endif<br>    selinux_status_open(<span class="hljs-literal">true</span>);<br><br>    binder_loop(bs, svcmgr_handler);<br><br>    <span class="hljs-keyword">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open()"></a>binder_open()</h5><blockquote>
<p>打开设备驱动，位置为<code>/dev/binder</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">//frameworks/native/cmds/servicemanager/binder.c<br>struct binder_state *binder_open(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* driver, size_t mapsize)<br>&#123;<br>    struct binder_state *bs;<br>    struct binder_version vers;<br><br>    bs = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*bs));<br>    <span class="hljs-keyword">if</span> (!bs) &#123;<br>        errno = ENOMEM;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>   //打开Binder设备驱动<br>    bs-&gt;fd = open(driver, O_RDWR | O_CLOEXEC);<br><br>    bs-&gt;mapsize = mapsize;<br>  //进行内存映射<br>    bs-&gt;mapped = mmap(<span class="hljs-literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);<br><br>    <span class="hljs-keyword">return</span> bs;<br><br>fail_map:<br>    close(bs-&gt;fd);<br>fail_open:<br>    <span class="hljs-built_in">free</span>(bs);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>bidner_open()</code>总共执行了三步：</p>
<ol>
<li><code>open()</code>打开<code>/dev/binder</code>设备节点，最终调用到内核中的<code>binder驱动</code>，同样执行到<code>binder_open()</code>，创建了<code>binder_proc</code>，再放入<code>binder_procs</code>中</li>
<li>调用<code>mmap()</code>进行内存映射，映射大小为<code>128k</code>，主要在<code>binder驱动</code>创建<code>Binder_buffer</code>对象</li>
<li>返回<code>binder_state</code>，记录着如下变量：<ul>
<li>fd：打开了<code>/dev/binder</code>的文件描述符</li>
<li>mapsize：内存映射大小</li>
<li>mapped：内存映射地址</li>
</ul>
</li>
</ol>
<h5 id="binder-become-context-manager"><a href="#binder-become-context-manager" class="headerlink" title="binder_become_context_manager()"></a>binder_become_context_manager()</h5><blockquote>
<p>注册成为大管家。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> binder_become_context_manager(struct binder_state *bs)<br>&#123;<br>    <span class="hljs-keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>ioctl</code>向<code>binder驱动</code>发出<code>BINDER_SET_CONTEXT_MGR</code>请求，成为上下文的管理者。</p>
<p><strong>向Binder驱动注册，它的handle句柄固定为0.</strong>这个binder的引用固定为0。</p>
<p>一个Server若要向<code>Service Manager</code>注册自己的Binder就必需通过0这个引用号和<code>Service Manager</code>的Binder通信。<em>所有需要注册自己的Server对于Service Manager来说都是Client</em></p>
<h5 id="binder-loop"><a href="#binder-loop" class="headerlink" title="binder_loop()"></a>binder_loop()</h5><blockquote>
<p>不断循环，等待客户请求</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">//frameworks/native/cmds/servicemanager/binder.c<br><span class="hljs-keyword">void</span> binder_loop(struct binder_state *bs, binder_handler func)<br>&#123;<br>    <span class="hljs-keyword">int</span> res;<br>    struct binder_write_read bwr;<br>    uint32_t readbuf[32];<br><br>    bwr.write_size = 0;<br>    bwr.write_consumed = 0;<br>    bwr.write_buffer = 0;<br><br>    readbuf[0] = BC_ENTER_LOOPER;<br>  //向Binder驱动发送 BC_ENTER_LOOPER 协议，让Service Manager进入循环状态<br>    binder_write(bs, readbuf, <span class="hljs-keyword">sizeof</span>(uint32_t));<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        bwr.read_size = <span class="hljs-keyword">sizeof</span>(readbuf);<br>        bwr.read_consumed = 0;<br>       //读取Binder的数据 就会写到 readbuf中，此时就可以进行解析操作<br>        bwr.read_buffer = (uintptr_t) readbuf;<br>       //使Service Manager进入内核态<br>        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);<br>       //等待解析Client的请，收到消息切换用户态<br>        res = binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Service Manager</code>通过<code>binder_write()</code>向<code>binder驱动</code>发送<code>BC_ENTER_LOOPER</code>协议，然后<code>Service Manager</code>进入循环状态。开启for循环，接着通过<code>ioctl()</code>发送<code>BINDER_WRITE_READ</code>请求到<code>Binder驱动</code>，使<code>Service Manager</code>进入<code>内核态</code>，开始等待<code>Client</code>发起请求。未收到请求时，处于等待状态。收到请求后调用<code>binder_parse()</code>解析接收到的请求并切换到<code>用户态</code>。</p>
<p><code>BINDER_WRITE_READ</code>：向<code>Binder驱动</code>进行<code>读取或写入操作</code>，参数分为两部分<code>write_size</code>和<code>read_size</code></p>
<ul>
<li><code>write_size</code>不为空，取出<code>write_buffer</code>的数据写入到<code>Binder</code>里。</li>
<li><code>read_size</code>不为空，<code>Binder</code>写数据到<code>read_buffer</code>。<code>read_buffer</code>没有数据，就处于等待状态。</li>
</ul>
<p><code>binder_write()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> binder_write(struct binder_state *bs, <span class="hljs-keyword">void</span> *data, size_t len)<br>&#123;<br>    struct binder_write_read bwr;<br>    <span class="hljs-keyword">int</span> res;<br><br>    bwr.write_size = len;<br>    bwr.write_consumed = 0;<br>    bwr.write_buffer = (uintptr_t) data;<br>    bwr.read_size = 0;<br>    bwr.read_consumed = 0;<br>    bwr.read_buffer = 0;<br>    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);<br>    <span class="hljs-keyword">if</span> (res &lt; 0) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,"binder_write: ioctl failed (%s)\n",<br>                strerror(errno));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>binder_write()</code>实质调用<code>ioctl()</code>，负责的是向<code>Binder驱动</code>写入数据。除了<code>BC_ENTER_LOOP</code>，还有其他类型的命令(<code>以BC_开头</code>)</p>
<p><code>BC</code>可以<strong>理解为向Binder写入数据</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">enum</span> binder_driver_command_protocol &#123;<br>  BC_TRANSACTION = _IOW('c', 0, struct binder_transaction_data), //Client向Server 发送请求数据，向Binder写入请求数据<br>  BC_REPLY = _IOW('c', 1, struct binder_transaction_data), //Server 向Client 返回数据，向Binder写入回复数据<br>  BC_ACQUIRE_RESULT = _IOW('c', 2, __s32),<br>  BC_FREE_BUFFER = _IOW('c', 3, binder_uintptr_t),//释放一块mmap映射的内存<br>  BC_INCREFS = _IOW('c', 4, __u32),<br>  BC_ACQUIRE = _IOW('c', 5, __u32),<br>  BC_RELEASE = _IOW('c', 6, __u32),<br>  BC_DECREFS = _IOW('c', 7, __u32),<br>  BC_INCREFS_DONE = _IOW('c', 8, struct binder_ptr_cookie),<br>  BC_ACQUIRE_DONE = _IOW('c', 9, struct binder_ptr_cookie),<br>  BC_ATTEMPT_ACQUIRE = _IOW('c', 10, struct binder_pri_desc),<br>  BC_REGISTER_LOOPER = _IO('c', 11),<br>  BC_ENTER_LOOPER = _IO('c', 12),<br>  BC_EXIT_LOOPER = _IO('c', 13),<br>  BC_REQUEST_DEATH_NOTIFICATION = _IOW('c', 14, struct binder_handle_cookie),<br>  BC_CLEAR_DEATH_NOTIFICATION = _IOW('c', 15, struct binder_handle_cookie),<br>  BC_DEAD_BINDER_DONE = _IOW('c', 16, binder_uintptr_t),<br>  BC_TRANSACTION_SG = _IOW('c', 17, struct binder_transaction_data_sg),<br>  BC_REPLY_SG = _IOW('c', 18, struct binder_transaction_data_sg),<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>binder_parse()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> binder_parse(struct binder_state *bs, struct binder_io *bio,<br>                 uintptr_t ptr, size_t size, binder_handler func)<br>&#123;<br>    <span class="hljs-keyword">int</span> r = 1;<br>    uintptr_t end = ptr + (uintptr_t) size;<br><br>    <span class="hljs-keyword">while</span> (ptr &lt; end) &#123;<br>        <span class="hljs-keyword">switch</span>(cmd) &#123;<br>       ...<br>        <span class="hljs-keyword">case</span> BR_TRANSACTION: &#123;<br>          //当前是Binder驱动向 ServiceManager 发送请求数据，例如获取服务、注册服务<br>            struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr;<br>            <span class="hljs-keyword">if</span> ((end - ptr) &lt; <span class="hljs-keyword">sizeof</span>(*txn)) &#123;<br>                ALOGE("parse: txn too small!\n");<br>                <span class="hljs-keyword">return</span> -1;<br>            &#125;<br>            binder_dump_txn(txn);<br>            <span class="hljs-keyword">if</span> (func) &#123; //func 指的就是 ServiceManager初始化的时候 传进来的 svcmgr_handler 函数<br>                <span class="hljs-keyword">unsigned</span> rdata[256/4];<br>                struct binder_io msg;<br>                struct binder_io reply;<br>                <span class="hljs-keyword">int</span> res;<br><br>                bio_init(&amp;reply, rdata, <span class="hljs-keyword">sizeof</span>(rdata), 4);<br>                bio_init_from_txn(&amp;msg, txn);<br>                res = func(bs, txn, &amp;msg, &amp;reply);<br>                <span class="hljs-keyword">if</span> (txn-&gt;flags &amp; TF_ONE_WAY) &#123;<br>                    binder_free_buffer(bs, txn-&gt;data.ptr.buffer);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);//返回应答数据<br>                &#125;<br>            &#125;<br>            ptr += <span class="hljs-keyword">sizeof</span>(*txn);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> BR_REPLY: &#123;<br>          //当前是Binder驱动 向 ServiceManager发送 回复数据<br>            struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr;<br>            <span class="hljs-keyword">if</span> ((end - ptr) &lt; <span class="hljs-keyword">sizeof</span>(*txn)) &#123;<br>                ALOGE("parse: reply too small!\n");<br>                <span class="hljs-keyword">return</span> -1;<br>            &#125;<br>            binder_dump_txn(txn);<br>            <span class="hljs-keyword">if</span> (bio) &#123;<br>                bio_init_from_txn(bio, txn);<br>                bio = 0;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                /* todo FREE BUFFER */<br>            &#125;<br>            ptr += <span class="hljs-keyword">sizeof</span>(*txn);<br>            r = 0;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> BR_DEAD_BINDER: &#123;<br>            struct binder_death *death = (struct binder_death *)(uintptr_t) *(binder_uintptr_t *)ptr;<br>            ptr += <span class="hljs-keyword">sizeof</span>(binder_uintptr_t);<br>            death-&gt;func(bs, death-&gt;ptr);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>binder_parse()</code>负责解析<code>read_buffer</code>读取到的数据。</p>
<p><code>binder_parse()</code>主要就是解析<code>BR_</code>开头的指令，上面重要的就是<code>BR_TRANSACTION</code>和<code>BR_REPLY</code>。除此之外还有其他的<code>BR_</code>指令</p>
<p><code>BR</code>可以<strong>理解为从Binder读取数据</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">enum</span> binder_driver_return_protocol &#123;<br>  BR_ERROR = _IOR('r', 0, __s32),//发生内部错误<br>  BR_OK = _IO('r', 1), //操作完成<br>  BR_TRANSACTION = _IOR('r', 2, struct binder_transaction_data), //读取请求数据，从Binder读取请求数据 然后发送到Server<br>  BR_REPLY = _IOR('r', 3, struct binder_transaction_data), //读取回复数据，从Binder读取回复数据 然后发送到Client<br>  BR_ACQUIRE_RESULT = _IOR('r', 4, __s32),<br>  BR_DEAD_REPLY = _IO('r', 5), //对方进程或线程已死<br>  BR_TRANSACTION_COMPLETE = _IO('r', 6),<br>  BR_INCREFS = _IOR('r', 7, struct binder_ptr_cookie),<br>  BR_ACQUIRE = _IOR('r', 8, struct binder_ptr_cookie),<br>  BR_RELEASE = _IOR('r', 9, struct binder_ptr_cookie),<br>  BR_DECREFS = _IOR('r', 10, struct binder_ptr_cookie),<br>  BR_ATTEMPT_ACQUIRE = _IOR('r', 11, struct binder_pri_ptr_cookie),<br>  BR_NOOP = _IO('r', 12),<br>  BR_SPAWN_LOOPER = _IO('r', 13),<br>  BR_FINISHED = _IO('r', 14),<br>  BR_DEAD_BINDER = _IOR('r', 15, binder_uintptr_t),//向持有Binder引用的进程通知Binder已死<br>  BR_CLEAR_DEATH_NOTIFICATION_DONE = _IOR('r', 16, binder_uintptr_t),<br>  BR_FAILED_REPLY = _IO('r', 17),<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>其中<code>BR_TRANSACTION</code>需要进行特殊处理，实现<code>对外提供服务</code>功能。例如提供<code>获取服务、注册服务功能</code>。<em>后面会简单的讲解</em></p>
<p>当<code>binder_parse()</code>收到<code>BR_TRANSACTION</code>之后，就会执行到<code>svcmgr_handler()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c">//frameworks/native/cmds/servicemanager/service_manager.c<br><span class="hljs-keyword">int</span> svcmgr_handler(struct binder_state *bs,<br>                   struct binder_transaction_data *txn,<br>                   struct binder_io *msg,<br>                   struct binder_io *reply)<br>&#123; <br>    struct svcinfo *si;//记录着 服务信息<br>    uint16_t *s;<br>    size_t len;<br>    uint32_t handle;<br>    uint32_t strict_policy;  <br>  ...<br>    <span class="hljs-keyword">switch</span>(txn-&gt;code) &#123;<br>    <span class="hljs-keyword">case</span> SVC_MGR_GET_SERVICE:<br>    <span class="hljs-keyword">case</span> SVC_MGR_CHECK_SERVICE://获取服务 一般是Client发起获取服务请求<br>        s = bio_get_string16(msg, &amp;len);//服务名<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> -1;<br>        &#125;<br>        handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);//获取对应服务<br>        <span class="hljs-keyword">if</span> (!handle)<br>            <span class="hljs-keyword">break</span>;<br>        bio_put_ref(reply, handle);<br>        <span class="hljs-keyword">return</span> 0;<br><br>    <span class="hljs-keyword">case</span> SVC_MGR_ADD_SERVICE://添加服务 一般是Server发起注册服务请求<br>        s = bio_get_string16(msg, &amp;len);<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> -1;<br>        &#125;<br>        handle = bio_get_ref(msg);<br>        allow_isolated = bio_get_uint32(msg) ? 1 : 0;<br>        dumpsys_priority = bio_get_uint32(msg);<br>        <span class="hljs-keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority,<br>                           txn-&gt;sender_pid))//注册服务<br>            <span class="hljs-keyword">return</span> -1;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> SVC_MGR_LIST_SERVICES: &#123; //列举所有注册的服务<br>        uint32_t n = bio_get_uint32(msg);<br>        uint32_t req_dumpsys_priority = bio_get_uint32(msg);<br><br>        <span class="hljs-keyword">if</span> (!svc_can_list(txn-&gt;sender_pid, txn-&gt;sender_euid)) &#123;<br>            ALOGE("list_service() uid=%d - PERMISSION DENIED\n",<br>                    txn-&gt;sender_euid);<br>            <span class="hljs-keyword">return</span> -1;<br>        &#125;<br>        si = svclist;<br>        // walk through the <span class="hljs-built_in">list</span> of services n times skipping services that<br>        // <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> support the requested priority<br>        <span class="hljs-keyword">while</span> (si) &#123;<br>            <span class="hljs-keyword">if</span> (si-&gt;dumpsys_priority &amp; req_dumpsys_priority) &#123;<br>                <span class="hljs-keyword">if</span> (n == 0) <span class="hljs-keyword">break</span>;<br>                n--;<br>            &#125;<br>            si = si-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (si) &#123;<br>            bio_put_string16(reply, si-&gt;name);<br>            <span class="hljs-keyword">return</span> 0;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -1;<br>    &#125;<br>    <span class="hljs-keyword">default</span>:<br>        ALOGE("unknown code %d\n", txn-&gt;code);<br>        <span class="hljs-keyword">return</span> -1;<br>    &#125;<br><br>    bio_put_uint32(reply, 0);<br>    <span class="hljs-keyword">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>svcmgr_handler()</code>主要提供服务相关的功能，根据不同的<code>code</code>有对应的功能：</p>
<ul>
<li><code>SVG_MGR_GET_SERVICE</code>，<code>SVC_MGR_CHECK_SERVICE</code>：获取服务</li>
<li><code>SVC_MGR_ADD_SERVICE</code>：注册服务</li>
<li><code>SVC_MGR_LIST_SERVICES</code>：列举所有服务</li>
</ul>
<p><code>Service Manager</code>存储的是一个<code>svclist</code>的一个链表结构，里面存储的对象为<code>svcinfo</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">struct svcinfo<br>&#123;<br>    struct svcinfo *next; //下一个注册服务<br>    uint32_t handle; //服务的 句柄<br>    struct binder_death death;<br>    <span class="hljs-keyword">int</span> allow_isolated;<br>    uint32_t dumpsys_priority;<br>    size_t len;<br>    uint16_t name[0]; //服务名<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="/images/5-2-2.start_service_manager.jpg" srcset="/img/loading.gif" alt="ServiceManager启动过程"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>ServiceManager</code>启动过程主要执行以下几步：</p>
<ol>
<li><code>binder_open()</code>：打开驱动，<code>/dev/binder</code></li>
<li><code>binder_become_context_manager()</code>：成为管家，并准备进入循环</li>
<li><code>binder_loop()</code>：开启循环，等待新消息并处理</li>
</ol>
<p><img src="/images/ServiceManager初始化.png" srcset="/img/loading.gif" alt="ServiceManager初始化"></p>
<h4 id="获取Service-Manager代理对象"><a href="#获取Service-Manager代理对象" class="headerlink" title="获取Service Manager代理对象"></a>获取Service Manager代理对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/libs/binder/IServiceManager.cpp<br>[[clang::no_destroy]] <span class="hljs-keyword">static</span> sp&lt;IServiceManager&gt; gDefaultServiceManager;<br><br>sp&lt;IServiceManager&gt; defaultServiceManager()<br>&#123;<br>    <span class="hljs-keyword">if</span> (gDefaultServiceManager != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> gDefaultServiceManager;<br><br>    &#123;<br>        AutoMutex _l(gDefaultServiceManagerLock);<br>        <span class="hljs-keyword">while</span> (gDefaultServiceManager == <span class="hljs-literal">NULL</span>) &#123;<br>            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(<br>                ProcessState::self()-&gt;getContextObject(<span class="hljs-literal">NULL</span>));<br>            <span class="hljs-keyword">if</span> (gDefaultServiceManager == <span class="hljs-literal">NULL</span>)<br>                sleep(1);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> gDefaultServiceManager;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>gDefaultServiceManager</code>的创建过程主要分为以下几步：</p>
<h5 id="ProcessState-self"><a href="#ProcessState-self" class="headerlink" title="ProcessState::self()"></a><code>ProcessState::self()</code></h5><blockquote>
<p>用于创建<code>ProcessState</code>对象，每个进程有且只有一个</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/libs/binder/ProcessState.cpp<br>#define DEFAULT_BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)<br>#define DEFAULT_MAX_BINDER_THREADS 15<br><br>sp&lt;ProcessState&gt; ProcessState::self()<br>&#123;<br>    Mutex::Autolock _l(gProcessMutex);<br>    <span class="hljs-keyword">if</span> (gProcess != <span class="hljs-literal">NULL</span>) &#123;//采用单例模式，保证只有一个<br>        <span class="hljs-keyword">return</span> gProcess;<br>    &#125;<br>    gProcess = <span class="hljs-keyword">new</span> ProcessState(DEFAULT_BINDER_VM_SIZE);//实例化ProcessState<br>    <span class="hljs-keyword">return</span> gProcess;<br>&#125;<br><br>ProcessState::ProcessState(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *driver)<br>    : mDriverName(String8(driver))<br>    , mDriverFD(open_driver(driver)) //1⃣️ 打开binder驱动<br>    , mVMStart(MAP_FAILED)<br>    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)<br>    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)<br>    , mExecutingThreadsCount(0)<br>    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)<br>    , mStarvationStartTimeMs(0)<br>    , mThreadPoolStarted(<span class="hljs-literal">false</span>)<br>    , mThreadPoolSeq(1)<br>    , mCallRestriction(CallRestriction::NONE)<br>&#123;<br><br>    <span class="hljs-keyword">if</span> (mDriverFD &gt;= 0) &#123;<br>        //3⃣️ 通过mmap 在 binder驱动映射一块内存，用来接收事务<br>        mVMStart = mmap(<span class="hljs-literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);<br>        <span class="hljs-keyword">if</span> (mVMStart == MAP_FAILED) &#123;<br>            // *sigh*<br>            ALOGE("Using %s failed: unable to mmap transaction memory.\n", mDriverName.c_str());<br>            close(mDriverFD);<br>            mDriverFD = -1;<br>            mDriverName.clear();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> open_driver(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *driver)<br>&#123;<br>    <span class="hljs-keyword">int</span> fd = open(driver, O_RDWR | O_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (fd &gt;= 0) &#123;<br>        <span class="hljs-keyword">int</span> vers = 0;<br>      //获取Binder驱动版本<br>        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);<br>        <span class="hljs-keyword">if</span> (result == -1) &#123;<br>            ALOGE("Binder ioctl to obtain version failed: %s", strerror(errno));<br>            close(fd);<br>            fd = -1;<br>        &#125;<br><br>        size_t maxThreads = DEFAULT_MAX_BINDER_THREADS;<br>      //2⃣️ 通过 ioctl为 binder驱动设置 最大线程数，默认为15<br>        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);<br>        <span class="hljs-keyword">if</span> (result == -1) &#123;<br>            ALOGE("Binder ioctl to <span class="hljs-built_in">set</span> max threads failed: %s", strerror(errno));<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ALOGW("Opening '%s' failed: %s\n", driver, strerror(errno));<br>    &#125;<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ProcessState</code>可以保证每个进程打开<code>binder设备</code>一次，通过<code>mDriverFd</code>记录<code>binder驱动</code>的fd，可以用于后续访问Binder设备。</p>
<p><code>ProcessState</code>的初始化过程主要执行了以下几步：</p>
<ol>
<li>1⃣️<code>open_driver()</code>：打开<code>binder驱动</code>设备，并且验证binder驱动版本是否一致。</li>
<li>2⃣️<code>ioctl()</code>：为<code>binder驱动</code>设置最大线程数，默认为<code>15</code>。加上主binder线程，所以最多为<code>16</code>个。</li>
<li>3⃣️<code>mmap()</code>：在<code>binder驱动</code>中分配一块<code>1016KB</code>大小的空间，用于处理事务。</li>
</ol>
<h5 id="getContextObject"><a href="#getContextObject" class="headerlink" title="getContextObject()"></a><code>getContextObject()</code></h5><blockquote>
<p>主要为了获取<code>BpBinder对象</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; /*caller*/)<br>&#123;<br>  //打开handle 为 0 的IBinder对象<br>    sp&lt;IBinder&gt; context = getStrongProxyForHandle(0);<br><br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>获取<code>handle==0</code>的IBinder对象，实际就是<code>ServiceManager</code>的<code>BpBinder</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)<br>&#123;<br>    sp&lt;IBinder&gt; result;<br><br>    AutoMutex _l(mLock);<br>   //根据 handle 查找对应的 handle_entry<br>    handle_entry* e = lookupHandleLocked(handle);<br><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">nullptr</span>) &#123;<br>        IBinder* b = e-&gt;binder;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">nullptr</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="hljs-keyword">this</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (handle == 0) &#123;<br><br>                IPCThreadState* ipc = IPCThreadState::self();<br><br>                CallRestriction originalCallRestriction = ipc-&gt;getCallRestriction();<br>                ipc-&gt;setCallRestriction(CallRestriction::NONE);<br><br>                Parcel data;<br>              //验证binder是否就绪<br>                status_t status = ipc-&gt;transact(<br>                        0, IBinder::PING_TRANSACTION, data, <span class="hljs-literal">nullptr</span>, 0);<br><br>                ipc-&gt;setCallRestriction(originalCallRestriction);<br><br>                <span class="hljs-keyword">if</span> (status == DEAD_OBJECT)<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>           //handle值对应的 IBinder不存在或无效时，新建一个 BpBinder对象<br>            b = BpBinder::create(handle);<br>            e-&gt;binder = b;<br>            <span class="hljs-keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();<br>            result = b;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result.force_set(b);<br>            e-&gt;refs-&gt;decWeak(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>getContextObj()</code>主要执行了以下几步：</p>
<ol>
<li><code>getStrongProxyforHandle()</code>：获取<code>handle==0</code>的IBinder对象</li>
<li><code>IPCThreadState::self()-&gt;transact()</code>：向<code>Binder驱动</code>传递对象，判断<code>Binder驱动</code>是否就绪</li>
<li><code>BpBinder::create()</code>：创建<code>ServiceManager</code>的<code>BpBinder</code>对象</li>
</ol>
<h5 id="interface-cast"><a href="#interface-cast" class="headerlink" title="interface_cast()"></a><code>interface_cast()</code></h5><blockquote>
<p>创建BpServiceManager对象</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">// IInterface.h<br><span class="hljs-keyword">inline</span> sp&lt;INTERFACE&gt; interface_cast(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; obj)<br>&#123;<br>    <span class="hljs-keyword">return</span> INTERFACE::asInterface(obj);<br>  //等价于 IServiceManager::asInterface<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>interface_cast()</code>是一个模板函数，经过操作后最后得到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> android::String16 IServiceManager::descriptor(“android.os.IServiceManager”);<br><br><span class="hljs-keyword">const</span> android::String16&amp; IServiceManager::getInterfaceDescriptor() <span class="hljs-keyword">const</span><br>&#123;<br>     <span class="hljs-keyword">return</span> IServiceManager::descriptor;<br>&#125;<br><br> android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(<span class="hljs-keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)<br>&#123;<br>       android::sp&lt;IServiceManager&gt; intr;<br>        <span class="hljs-keyword">if</span>(obj != <span class="hljs-literal">NULL</span>) &#123;<br>           intr = <span class="hljs-keyword">static_cast</span>&lt;IServiceManager *&gt;(<br>               obj-&gt;queryLocalInterface(IServiceManager::descriptor).get());<br>           <span class="hljs-keyword">if</span> (intr == <span class="hljs-literal">NULL</span>) &#123;<br>               intr = <span class="hljs-keyword">new</span> BpServiceManager(obj); //创建BpServiceManager对象<br>            &#125;<br>        &#125;<br>       <span class="hljs-keyword">return</span> intr;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时初始化<code>BpServiceManager</code>对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">explicit</span> BpServiceManager(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; impl)<br>        : BpInterface&lt;IServiceManager&gt;(impl)<br>    &#123;<br>    &#125;<br><br>// IInterface.h<br><span class="hljs-keyword">inline</span> BpRefBase&lt;IServiceManager&gt;::BpInterface(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; remote)<br>    :BpRefBase(remote)<br>&#123;    &#125;<br><br>// Binder.cpp<br>BpRefBase::BpRefBase(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; o)<br>    : mRemote(o.get()), mRefs(<span class="hljs-literal">NULL</span>), mState(0)<br>&#123;<br>    extendObjectLifetime(OBJECT_LIFETIME_WEAK);<br>    <span class="hljs-keyword">if</span> (mRemote) &#123;<br>        mRemote-&gt;incStrong(<span class="hljs-keyword">this</span>);<br>        mRefs = mRemote-&gt;createWeak(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>BpServiceManager</code>初始化过程中，依次调用<code>BpRefBase</code>，<code>BpRefBase</code>，<code>BpServiceManager</code>的构造函数，赋予BpRefBase的mRemote的值为BpBinder(0)。</p>
<p>最后可知<strong>defaultServiceManager 等价于 new BpServiceManager(new BpBinder(0))</strong></p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/5-2-4-get_service_manager.jpg" srcset="/img/loading.gif" alt="获取ServiceManager代理"></p>
<ul>
<li>open: 创建binder_proc</li>
<li>BINDER_SET_MAX_THREADS: 设置proc-&gt;max_threads</li>
<li>mmap: 创建创建binder_buffer</li>
</ul>
<h5 id="javaObjectForIBinder"><a href="#javaObjectForIBinder" class="headerlink" title="javaObjectForIBinder()"></a><code>javaObjectForIBinder()</code></h5><blockquote>
<p>主要为了获取<code>BinderProxy</code>对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/base/core/jni/android_util_Binder.cpp<br>//负责创建一个 BinderProxy对象<br>jobject javaObjectForIBinder(JNIEnv* env, <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; val)<br>&#123;<br><br>    BinderProxyNativeData* nativeData = <span class="hljs-keyword">new</span> BinderProxyNativeData();<br>    nativeData-&gt;mOrgue = <span class="hljs-keyword">new</span> DeathRecipientList;<br>    nativeData-&gt;mObject = val;<br><br>    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,<br>            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());<br>    <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) &#123;<br>        // In the exception <span class="hljs-keyword">case</span>, getInstance still took ownership of nativeData.<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);<br>    <span class="hljs-keyword">if</span> (actualNativeData == nativeData) &#123;<br>        // Created a <span class="hljs-keyword">new</span> Proxy<br>        uint32_t numProxies = gNumProxies.fetch_add(1, <span class="hljs-built_in">std</span>::memory_order_relaxed);<br>        uint32_t numLastWarned = gProxiesWarned.load(<span class="hljs-built_in">std</span>::memory_order_relaxed);<br>        <span class="hljs-keyword">if</span> (numProxies &gt;= numLastWarned + PROXY_WARN_INTERVAL) &#123;<br>            // Multiple threads can get here, make sure only one of them gets to<br>            // update the warn counter.<br>            <span class="hljs-keyword">if</span> (gProxiesWarned.compare_exchange_strong(numLastWarned,<br>                        numLastWarned + PROXY_WARN_INTERVAL, <span class="hljs-built_in">std</span>::memory_order_relaxed)) &#123;<br>                ALOGW("Unexpectedly many live BinderProxies: %d\n", numProxies);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> nativeData;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行完成后<code>BinderInternal.getContextObject()</code>得到<code>BinderProxy</code></p>
<p>继续调用到<code>ServiceManagerNative.asInterface()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">//frameworks/base/core/java/android/os/ServiceManagerNative.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IServiceManager asInterface(IBinder obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;<br>            return <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        // ServiceManager is never local<br>        return new ServiceManagerProxy(obj);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>等价于最后生成的代理对象就是<code>ServiceManagerProxy</code>。</p>
<h4 id="Service-Manager-注册服务"><a href="#Service-Manager-注册服务" class="headerlink" title="Service Manager 注册服务"></a>Service Manager 注册服务</h4><blockquote>
<p>Service 向 Service Manager 注册服务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">//ServiceManager.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> addService(String name, IBinder service, <span class="hljs-keyword">boolean</span> allowIsolated,<br>            <span class="hljs-keyword">int</span> dumpPriority) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            getIServiceManager().addService(name, service, allowIsolated, dumpPriority);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            Log.e(TAG, "error in addService", e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IServiceManager getIServiceManager() &#123;<br>        <span class="hljs-keyword">if</span> (sServiceManager != <span class="hljs-keyword">null</span>) &#123;<br>            return sServiceManager;<br>        &#125;<br><br>        // Find the service manager<br>        sServiceManager = ServiceManagerNative<br>                .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));<br>        return sServiceManager;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>sServiceManager</code>最后得到的就是上节中的<code>BpServiceManager</code>对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/libs/binder/IServiceManager.cpp<br><span class="hljs-keyword">virtual</span> status_t addService(<span class="hljs-keyword">const</span> String16&amp; name, <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; service,<br>                                <span class="hljs-keyword">bool</span> allowIsolated, <span class="hljs-keyword">int</span> dumpsysPriority) &#123;<br>        Parcel data, reply;<br>        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());<br>        data.writeString16(name);//服务的name<br>        data.writeStrongBinder(service);//具体 服务<br>        data.writeInt32(allowIsolated ? 1 : 0);<br>        data.writeInt32(dumpsysPriority);<br>  //remote 表示 BpBinder对象<br>        status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);<br>        <span class="hljs-keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>addService()</code>具体就是向<code>Service Manager</code>注册服务，将相关数据封装到<code>Parcel</code>对象。</p>
<p>接下来通过<code>BpBinder</code>调用<code>transact()</code>传输数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/libs/binder/BpBinder.cpp<br>status_t BpBinder::transact(<br>    uint32_t code, <span class="hljs-keyword">const</span> Parcel&amp; data, Parcel* reply, uint32_t flags)<br>&#123;<br>    // Once a binder has died, it will never come back to life.<br>    <span class="hljs-keyword">if</span> (mAlive) &#123;<br>        status_t status = IPCThreadState::self()-&gt;transact(<br>            mHandle, code, data, reply, flags);<br>        <span class="hljs-keyword">if</span> (status == DEAD_OBJECT) mAlive = 0;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> DEAD_OBJECT;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="IPCThreadState-gt-transact"><a href="#IPCThreadState-gt-transact" class="headerlink" title="IPCThreadState-&gt;transact"></a>IPCThreadState-&gt;transact</h5><blockquote>
<p>初始化IPCThreadState之后，向<code>Binder驱动</code>发送数据</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/libs/binder/IPCThreadState.cpp<br>IPCThreadState* IPCThreadState::self()<br>&#123;<br>    <span class="hljs-keyword">if</span> (gHaveTLS) &#123;<br>restart:<br>        <span class="hljs-keyword">const</span> pthread_key_t k = gTLS;<br>        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);<br>        <span class="hljs-keyword">if</span> (st) <span class="hljs-keyword">return</span> st;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IPCThreadState;//初始IPCThreadState<br>    &#125;<br><br>    pthread_mutex_lock(&amp;gTLSMutex);<br>    <span class="hljs-keyword">if</span> (!gHaveTLS) &#123;<br>        <span class="hljs-keyword">int</span> key_create_value = pthread_key_create(&amp;gTLS, threadDestructor);<br>        <span class="hljs-keyword">if</span> (key_create_value != 0) &#123;<br>            pthread_mutex_unlock(&amp;gTLSMutex);<br>            ALOGW("IPCThreadState::self() unable to create TLS key, expect a crash: %s\n",<br>                    strerror(key_create_value));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        gHaveTLS = <span class="hljs-literal">true</span>;<br>    &#125;<br>    pthread_mutex_unlock(&amp;gTLSMutex);<br>    <span class="hljs-keyword">goto</span> restart;<br>&#125;<br><br>IPCThreadState::IPCThreadState()<br>    : mProcess(ProcessState::self()),<br>      mStrictModePolicy(0),<br>      mLastTransactionBinderFlags(0)<br>&#123;<br>    pthread_setspecific(gTLS, <span class="hljs-keyword">this</span>);<br>    clearCaller();<br>    mIn.setDataCapacity(256);<br>    mOut.setDataCapacity(256);<br>&#125;<br><br><span class="hljs-keyword">void</span> IPCThreadState::clearCaller()<br>&#123;<br>    mCallingPid = getpid(); //初始化PID<br>    mCallingUid = getuid(); //初始化UID<br>&#125;<br></code></pre></td></tr></table></figure>
<p>每个线程都有一个<code>IPCThreadState</code>，内部包含如下参数：</p>
<ul>
<li><code>mIn</code>：接收来自Binder设备的数据</li>
<li><code>mOut</code>：存储发送Binder设备的数据</li>
<li><code>mProcess</code>：当前进程的<code>ProcessState</code></li>
<li><code>mCallingPid</code>：当前进程的Pid</li>
<li><code>mCallingUid</code>：当前进程的Uid</li>
</ul>
<p>接下来执行<code>transact()</code>传输数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp">status_t IPCThreadState::transact(int32_t handle,<br>                                  uint32_t code, <span class="hljs-keyword">const</span> Parcel&amp; data,<br>                                  Parcel* reply, uint32_t flags)<br>&#123;<br>    status_t err;<br><br>    flags |= TF_ACCEPT_FDS;<br>   //传输数据<br>    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span> ((flags &amp; TF_ONE_WAY) == 0) &#123;<br><br>        <span class="hljs-keyword">if</span> (reply) &#123;<br>          //等待响应<br>            err = waitForResponse(reply);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          //直接返回null<br>            Parcel fakeReply;<br>            err = waitForResponse(&amp;fakeReply);<br>        &#125;<br>      <br>        IF_LOG_TRANSACTIONS() &#123;<br>            TextOutput::Bundle _b(alog);<br>            alog &lt;&lt; "BR_REPLY thr " &lt;&lt; (<span class="hljs-keyword">void</span>*)pthread_self() &lt;&lt; " / hand "<br>                &lt;&lt; handle &lt;&lt; ": ";<br>            <span class="hljs-keyword">if</span> (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">else</span> alog &lt;&lt; "(none requested)" &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      //直接返回null<br>        err = waitForResponse(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>transact()</code>主要过程：</p>
<ol>
<li><p>执行<code>writeTransactionData()</code>向<code>Parcel</code>中的<code>mOut</code>写入数据</p>
<p>写入的数据主要是<code>BC_TRANSACTION</code>协议以及<code>binder_transaction_data</code>数据。</p>
</li>
<li><p>执行<code>waitForResponse()</code>循环执行，等待应答消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)<br>&#123;<br>    int32_t cmd;<br>    int32_t err;<br>    <span class="hljs-keyword">while</span> (1) &#123;<br>        <span class="hljs-keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="hljs-keyword">break</span>;<br>        ...<br>        <span class="hljs-keyword">if</span> (mIn.dataAvail() == 0) <span class="hljs-keyword">continue</span>;<br><br>        cmd = mIn.readInt32();<br>        <span class="hljs-keyword">switch</span> (cmd) &#123;<br>            <span class="hljs-keyword">case</span> BR_TRANSACTION_COMPLETE:<br>            //如果是 oneway 的请求方式，直接结束即可<br>                <span class="hljs-keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="hljs-keyword">goto</span> finish;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> BR_DEAD_REPLY: ...<br>            <span class="hljs-keyword">case</span> BR_FAILED_REPLY: ...<br>            <span class="hljs-keyword">case</span> BR_ACQUIRE_RESULT: ...<br>            <span class="hljs-keyword">case</span> BR_REPLY: ...<br>              //完整的执行一次通信过程<br>                <span class="hljs-keyword">goto</span> finish;<br><br>            <span class="hljs-keyword">default</span>:<br>                err = executeCommand(cmd);<br>                <span class="hljs-keyword">if</span> (err != NO_ERROR) <span class="hljs-keyword">goto</span> finish;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="IPCThreadState-talkWithDrive"><a href="#IPCThreadState-talkWithDrive" class="headerlink" title="IPCThreadState.talkWithDrive()"></a>IPCThreadState.talkWithDrive()</h5><blockquote>
<p>负责与 <code>Binder驱动</code>进行通信</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp">status_t IPCThreadState::talkWithDriver(<span class="hljs-keyword">bool</span> doReceive)<br>&#123;<br>    ...<br>    binder_write_read bwr;<br>    //当mDataSize &lt;= mDataPos，则有数据可读<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();<br>    <span class="hljs-keyword">const</span> size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;<br><br>    bwr.write_size = outAvail;<br>    bwr.write_buffer = (uintptr_t)mOut.data(); // mData地址<br><br>    <span class="hljs-keyword">if</span> (doReceive &amp;&amp; needRead) &#123;<br>        //接收数据缓冲区信息的填充。如果以后收到数据，就直接填在mIn中。<br>        bwr.read_size = mIn.dataCapacity();<br>        bwr.read_buffer = (uintptr_t)mIn.data();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        bwr.read_size = 0;<br>        bwr.read_buffer = 0;<br>    &#125;<br>    //当读缓冲和写缓冲都为空，则直接返回<br>    <span class="hljs-keyword">if</span> ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) <span class="hljs-keyword">return</span> NO_ERROR;<br><br>    bwr.write_consumed = 0;<br>    bwr.read_consumed = 0;<br>    status_t err;<br>    <span class="hljs-keyword">do</span> &#123;<br>        //通过ioctl不停的读写操作，跟Binder Driver进行通信<br>        <span class="hljs-keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)<br>            err = NO_ERROR;<br>        ...<br>    &#125; <span class="hljs-keyword">while</span> (err == -EINTR);<br>    ...<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl()"></a>binder_ioctl()</h5><blockquote>
<p>与<code>Binder驱动进行通信</code></p>
</blockquote>
<ul>
<li>binder_ioctl()过程解析ioctl参数BINDER_WRITE_READ，则调用binder_ioctl_write_read()方法；</li>
<li>binder_ioctl_write_read()过程将用户空间binder_write_read结构体拷贝到内核空间, 写缓存中存在数据，则调用binder_thread_write()方法；</li>
<li>binder_thread_write()过程解析到传输协议为BC_TRANSACTION，则调用binder_transaction()方法；</li>
<li>binder_transaction()过程将用户空间binder_transaction_data结构体拷贝到内核空间，内核创建一个binder_transaction结构体，</li>
</ul>
<p><img src="/images/5-3-5-add_service.jpg" srcset="/img/loading.gif" alt="服务注册过程"></p>
<h5 id="binder-parse"><a href="#binder-parse" class="headerlink" title="binder_parse()"></a>binder_parse()</h5><blockquote>
<p>解析<code>Binder驱动</code>返回的数据</p>
</blockquote>
<p>前面讲到<code>Service Manager</code>的启动时，就介绍到在<code>binder_loop()</code>中负责接收消息，收到消息后通过<code>binder_parse</code>进行解析。</p>
<p>收到的指令为<code></code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">case</span> BR_TRANSACTION: &#123;<br>    struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr;<br>    <span class="hljs-keyword">if</span> ((end - ptr) &lt; <span class="hljs-keyword">sizeof</span>(*txn)) &#123;<br>        ALOGE("parse: txn too small!\n");<br>        <span class="hljs-keyword">return</span> -1;<br>    &#125;<br>    binder_dump_txn(txn);<br>    <span class="hljs-keyword">if</span> (func) &#123;<br>        <span class="hljs-keyword">unsigned</span> rdata[256/4];<br>        struct binder_io msg;<br>        struct binder_io reply;<br>        <span class="hljs-keyword">int</span> res;<br><br>        bio_init(&amp;reply, rdata, <span class="hljs-keyword">sizeof</span>(rdata), 4);<br>        bio_init_from_txn(&amp;msg, txn);<br>        res = func(bs, txn, &amp;msg, &amp;reply);<br>        <span class="hljs-keyword">if</span> (txn-&gt;flags &amp; TF_ONE_WAY) &#123;<br>            binder_free_buffer(bs, txn-&gt;data.ptr.buffer);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);<br>        &#125;<br>    &#125;<br>    ptr += <span class="hljs-keyword">sizeof</span>(*txn);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> svcmgr_handler(struct binder_state *bs,<br>                   struct binder_transaction_data *txn,<br>                   struct binder_io *msg,<br>                   struct binder_io *reply)<br>&#123;<br>  ...<br>        <span class="hljs-keyword">case</span> SVC_MGR_ADD_SERVICE:<br>        s = bio_get_string16(msg, &amp;len);<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> -1;<br>        &#125;<br>        handle = bio_get_ref(msg);<br>        allow_isolated = bio_get_uint32(msg) ? 1 : 0;<br>        dumpsys_priority = bio_get_uint32(msg);<br>        <span class="hljs-keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority,<br>                           txn-&gt;sender_pid))<br>            <span class="hljs-keyword">return</span> -1;<br>        <span class="hljs-keyword">break</span>;<br><br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="do-add-service"><a href="#do-add-service" class="headerlink" title="do_add_service()"></a>do_add_service()</h5><blockquote>
<p>向Service Manager添加服务</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> do_add_service(struct binder_state *bs, <span class="hljs-keyword">const</span> uint16_t *s, size_t len, uint32_t handle,<br>                   uid_t uid, <span class="hljs-keyword">int</span> allow_isolated, uint32_t dumpsys_priority, pid_t spid) &#123;<br>    struct svcinfo *si;<br><br>    //ALOGI("add_service('%s',%x,%s) uid=%d\n", str8(s, len), handle,<br>    //        allow_isolated ? "allow_isolated" : "!allow_isolated", uid);<br><br>    <span class="hljs-keyword">if</span> (!handle || (len == 0) || (len &gt; 127))<br>        <span class="hljs-keyword">return</span> -1;<br><br>    <span class="hljs-keyword">if</span> (!svc_can_register(s, len, spid, uid)) &#123;<br>        ALOGE("add_service('%s',%x) uid=%d - PERMISSION DENIED\n",<br>             str8(s, len), handle, uid);<br>        <span class="hljs-keyword">return</span> -1;<br>    &#125;<br><br>    si = find_svc(s, len);<br>    <span class="hljs-keyword">if</span> (si) &#123;<br>        <span class="hljs-keyword">if</span> (si-&gt;handle) &#123;<br>            ALOGE("add_service('%s',%x) uid=%d - ALREADY REGISTERED, OVERRIDE\n",<br>                 str8(s, len), handle, uid);<br>            svcinfo_death(bs, si);<br>        &#125;<br>        si-&gt;handle = handle;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        si = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*si) + (len + 1) * <span class="hljs-keyword">sizeof</span>(uint16_t));<br>        <span class="hljs-keyword">if</span> (!si) &#123;<br>            ALOGE("add_service('%s',%x) uid=%d - OUT OF MEMORY\n",<br>                 str8(s, len), handle, uid);<br>            <span class="hljs-keyword">return</span> -1;<br>        &#125;<br>        si-&gt;handle = handle;<br>        si-&gt;len = len;<br>        <span class="hljs-built_in">memcpy</span>(si-&gt;name, s, (len + 1) * <span class="hljs-keyword">sizeof</span>(uint16_t));<br>        si-&gt;name[len] = '\0';<br>        si-&gt;death.func = (<span class="hljs-keyword">void</span>*) svcinfo_death;<br>        si-&gt;death.ptr = si;<br>        si-&gt;allow_isolated = allow_isolated;<br>        si-&gt;dumpsys_priority = dumpsys_priority;<br>        si-&gt;next = svclist;//svcList保存服务<br>        svclist = si;<br>    &#125;<br><br>    binder_acquire(bs, handle);<br>    binder_link_to_death(bs, handle, &amp;si-&gt;death);<br>    <span class="hljs-keyword">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Java-注册服务"><a href="#Java-注册服务" class="headerlink" title="Java 注册服务"></a>Java 注册服务</h4><p>上面讲的都是Native层的相关过程，接下来简单分析下<code>Java层 如何注册服务</code></p>
<p>一般都是通过<code>ServiceManager.addService()</code>去在<code>Service Manager</code>注册服务，这一类方式主要面向的是<code>系统服务</code>。</p>
<p><code>系统服务</code>相关的分析完毕后，会简单介绍开发者自定义Service的注册过程。</p>
<p>注册服务的操作都是由<code>Server</code>执行的，所以下面的流程基本都是在<code>Server端操作的</code>。</p>
<h5 id="系统服务-SystemServer-注册服务"><a href="#系统服务-SystemServer-注册服务" class="headerlink" title="系统服务(SystemServer) 注册服务"></a>系统服务(SystemServer) 注册服务</h5><blockquote>
<p>系统服务：一般指的是由<code>SystemServer</code>进程启动的服务，例如<code>InputManagerService</code>、<code>WindowManagerService</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">//SystemServer.java<br>            inputManager = new InputManagerService(context);<br>            ServiceManager.addService(Context.INPUT_SERVICE, inputManager,<br>                    /* allowIsolated= */ <span class="hljs-keyword">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);<br></code></pre></td></tr></table></figure>
<p>都是通过<code>ServiceManager.addService()</code>进行注册</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">//core/java/android/os/ServiceManager.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> addService(String name, IBinder service, <span class="hljs-keyword">boolean</span> allowIsolated,<br>            <span class="hljs-keyword">int</span> dumpPriority) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            getIServiceManager().addService(name, service, allowIsolated, dumpPriority);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            Log.e(TAG, "error in addService", e);<br>        &#125;<br>    &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IServiceManager getIServiceManager() &#123;<br>        <span class="hljs-keyword">if</span> (sServiceManager != <span class="hljs-keyword">null</span>) &#123;<br>            return sServiceManager;<br>        &#125;<br><br>        // Find the service manager<br>        sServiceManager = ServiceManagerNative<br>                .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));<br>        return sServiceManager;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IServiceManager asInterface(IBinder obj)<br>    &#123;<br>      //obj 为 BinderProxy对象<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;<br>            return <span class="hljs-keyword">null</span>;<br>        &#125;<br>        IServiceManager in =<br>            (IServiceManager)obj.queryLocalInterface(descriptor);<br>        <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>) &#123;<br>            return in;<br>        &#125;<br><br>        return new ServiceManagerProxy(obj);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>前面有讲到具体的处理过程，这边直接贴一个结论：</p>
<p><code>sServiceManager</code>最后得到的是<code>ServiceManagerProxy</code>对象，且<code>IBinder</code>对象为<code>BinderProxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">//core/java/android/os/ServiceManagerNative.java<br>class ServiceManagerProxy implements IServiceManager &#123;<br>    <span class="hljs-keyword">public</span> ServiceManagerProxy(IBinder remote) &#123;<br>        mRemote = remote;<br>    &#125;    <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> addService(String name, IBinder service, <span class="hljs-keyword">boolean</span> allowIsolated, <span class="hljs-keyword">int</span> dumpPriority)<br>            <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        Parcel data = Parcel.obtain();<br>        Parcel reply = Parcel.obtain();<br>        data.writeInterfaceToken(IServiceManager.descriptor);<br>        data.writeString(name);<br>        data.writeStrongBinder(service);<br>        data.writeInt(allowIsolated ? 1 : 0);<br>        data.writeInt(dumpPriority);<br>  //mRemote为 BinderProxy对象<br>        mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);<br>        reply.recycle();<br>        data.recycle();<br>    &#125;<br></code></pre></td></tr></table></figure>
<h6 id="writeStrongBinder"><a href="#writeStrongBinder" class="headerlink" title="writeStrongBinder()"></a><code>writeStrongBinder()</code></h6><blockquote>
<p>将<code>Binder实体</code>写入<code>Parcel</code>中，就可以传递到对端。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> writeStrongBinder(IBinder val) &#123;<br>    nativeWriteStrongBinder(mNativePtr, val);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">//core/jni/android_os_Parcel.cpp<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> android_os_Parcel_writeStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)<br>&#123;<br>    Parcel* parcel = <span class="hljs-keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);<br>    <span class="hljs-keyword">if</span> (parcel != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">const</span> status_t err = parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object));<br>        <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;<br>            signalExceptionForError(env, clazz, err);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ibinderForJavaObject()</code></p>
<blockquote>
<p>将<code>Binder(Java)</code>转化成<code>Binder(c++)</code>对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//core/jni/android_util_Binder.cpp<br>sp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj)<br>&#123;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    // Java层的Binder对象<br>    <span class="hljs-keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123;<br>        JavaBBinderHolder* jbh = (JavaBBinderHolder*)<br>            env-&gt;GetLongField(obj, gBinderOffsets.mObject);<br>        <span class="hljs-keyword">return</span> jbh-&gt;get(env, obj);<br>    &#125;<br><br>    // Java层的BinderProxy对象<br>    <span class="hljs-keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123;<br>        <span class="hljs-keyword">return</span> getBPNativeData(env, obj)-&gt;mObject;<br>    &#125;<br><br>    ALOGW("ibinderForJavaObject: %p is <span class="hljs-keyword">not</span> a Binder object", obj);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sp&lt;JavaBBinder&gt; get(JNIEnv* env, jobject obj)<br>&#123;<br>    AutoMutex _l(mLock);<br>    sp&lt;JavaBBinder&gt; b = mBinder.promote();<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">NULL</span>) &#123;<br>        b = <span class="hljs-keyword">new</span> JavaBBinder(env, obj);<br>        mBinder = b;<br>        ALOGV("Creating JavaBinder %p (refs %p) <span class="hljs-keyword">for</span> Object %p, weakCount=%" PRId32 "\n",<br>             b.get(), b-&gt;getWeakRefs(), obj, b-&gt;getWeakRefs()-&gt;getWeakCount());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>iBinderForJavaObject()</code>最后转换出一个<code>JavaBBinder</code>对象</p>
<p><img src="/images/Java-Binder与Native-Binder" srcset="/img/loading.gif" alt="Java-Binder与Native-Binder"></p>
<p><code>parcel-&gt;writeStrongBinder()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/libs/binder/Parcel.cpp<br>status_t Parcel::writeStrongBinder(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; val)<br>&#123;<br>    <span class="hljs-keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="hljs-keyword">this</span>);<br>&#125;<br><br>status_t flatten_binder(<span class="hljs-keyword">const</span> sp&lt;ProcessState&gt;&amp; /*proc*/,<br>    <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)<br>&#123;<br>    flat_binder_object obj;<br><br>    <span class="hljs-keyword">if</span> (IPCThreadState::self()-&gt;backgroundSchedulingDisabled()) &#123;<br>        /* minimum priority <span class="hljs-keyword">for</span> all nodes is nice 0 */<br>        obj.flags = FLAT_BINDER_FLAG_ACCEPTS_FDS;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        /* minimum priority <span class="hljs-keyword">for</span> all nodes is MAX_NICE(19) */<br>        obj.flags = 0x13 | FLAT_BINDER_FLAG_ACCEPTS_FDS;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (binder != <span class="hljs-literal">NULL</span>) &#123;<br>        IBinder *local = binder-&gt;localBinder();//本地bidner对象<br>        <span class="hljs-keyword">if</span> (!local) &#123;<br>            BpBinder *proxy = binder-&gt;remoteBinder();//远程Binder对象<br>            <span class="hljs-keyword">if</span> (proxy == <span class="hljs-literal">NULL</span>) &#123;<br>                ALOGE("null proxy");<br>            &#125;<br>            <span class="hljs-keyword">const</span> int32_t handle = proxy ? proxy-&gt;handle() : 0;<br>            obj.hdr.type = BINDER_TYPE_HANDLE;<br>            obj.binder = 0; /* Don't pass uninitialized <span class="hljs-built_in">stack</span> data to a remote process */<br>            obj.handle = handle;<br>            obj.cookie = 0;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            obj.hdr.type = BINDER_TYPE_BINDER;<br>            obj.binder = <span class="hljs-keyword">reinterpret_cast</span>&lt;uintptr_t&gt;(local-&gt;getWeakRefs());<br>            obj.cookie = <span class="hljs-keyword">reinterpret_cast</span>&lt;uintptr_t&gt;(local);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        obj.hdr.type = BINDER_TYPE_BINDER;<br>        obj.binder = 0;<br>        obj.cookie = 0;<br>    &#125;<br><br>  //写入 flat_binder_object到 out<br>    <span class="hljs-keyword">return</span> finish_flatten_binder(binder, obj, out);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>writeStrongBinder()</code>负责转换<code>IBinder</code>对象到<code>flat_bidner_object</code></p>
<h6 id="mRemote-transact-ADD-SERVICE-TRANSACTION"><a href="#mRemote-transact-ADD-SERVICE-TRANSACTION" class="headerlink" title="mRemote.transact(ADD_SERVICE_TRANSACTION)"></a><code>mRemote.transact(ADD_SERVICE_TRANSACTION)</code></h6><blockquote>
<p>通过<code>BinderProxy</code>传输<code>Binder对象</code>到<code>Binder驱动</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0);<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">//core/java/android/os/Binder.java<br><span class="hljs-keyword">final</span> class BinderProxy implements IBinder &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> transact(<span class="hljs-keyword">int</span> code, Parcel data, Parcel reply, <span class="hljs-keyword">int</span> flags) <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        //检测 data 的数据是否大于 800k<br>        Binder.checkParcel(<span class="hljs-keyword">this</span>, code, data, "Unreasonably large binder buffer");<br><br><br>        <span class="hljs-keyword">try</span> &#123;<br>          //通过Native层 向 Binder驱动传递消息<br>            return transactNative(code, data, reply, flags);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (tracingEnabled) &#123;<br>                Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);<br>            &#125;<br>        &#125;<br>    &#125;<br>  <br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> transactNative(<span class="hljs-keyword">int</span> code, Parcel data, Parcel reply,<br>            <span class="hljs-keyword">int</span> flags) <span class="hljs-keyword">throws</span> RemoteException;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//core/jni/android_util_Binder.cpp<br><span class="hljs-keyword">static</span> jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,<br>        jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException<br>&#123;<br><br>  //解析传递数据<br>    Parcel* data = parcelForJavaObject(env, dataObj);<br>  //解析返回数据<br>    Parcel* reply = parcelForJavaObject(env, replyObj);<br><br>  //target 为 BpBinder<br>    IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get();<br><br>    //<span class="hljs-built_in">printf</span>("Transact from Java code to %p sending: ", target); data-&gt;print();<br>  //向 Binder驱动发送数据<br>    status_t err = target-&gt;transact(code, *data, reply, flags);<br>    //<span class="hljs-keyword">if</span> (reply) <span class="hljs-built_in">printf</span>("Transact from Java code to %p received: ", target); reply-&gt;print();<br><br>    signalExceptionForError(env, obj, err, <span class="hljs-literal">true</span> /*canThrowRemoteException*/, data-&gt;dataSize());<br>    <span class="hljs-keyword">return</span> JNI_FALSE;<br>&#125;<br><br><br>BinderProxyNativeData* getBPNativeData(JNIEnv* env, jobject obj) &#123;<br>    <span class="hljs-keyword">return</span> (BinderProxyNativeData *) env-&gt;GetLongField(obj, gBinderProxyOffsets.mNativeData);<br>&#125;<br><br>struct BinderProxyNativeData &#123;<br>    // Both fields are constant <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> null once javaObjectForIBinder returns <span class="hljs-keyword">this</span> as<br>    // part of a BinderProxy.<br><br>    // The native IBinder proxied by <span class="hljs-keyword">this</span> BinderProxy.<br>    sp&lt;IBinder&gt; mObject;<br><br>    // Death recipients <span class="hljs-keyword">for</span> mObject. Reference counted only because DeathRecipients<br>    // hold a weak reference that can be temporarily promoted.<br>    sp&lt;DeathRecipientList&gt; mOrgue;  // Death recipients <span class="hljs-keyword">for</span> mObject.<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>继续执行的就是<a href="#IPCThreadState-&gt;transact">IPCThreadState-&gt;transact</a></p>
<h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h6><p><code>ServiceManager.addService()</code>主要执行了以下几步：</p>
<ol>
<li><code>Parcel.obtain()</code>：构建Native层的<code>Parcel</code>对象</li>
<li><code>parcel.writeStrongBinder()</code>：构造<code>JavaBBinder</code>对象写入到<code>falt_binder_object</code>，准备传到<code>Binder驱动</code></li>
<li><code>BpBinder.transact(ADD_SERVICE_TRANSACTION)</code>：通过<code>IPCThreadState.talkWithDriver()</code>发送数据到<code>Binder驱动</code></li>
</ol>
<h5 id="自定义服务-CustomServer-注册服务"><a href="#自定义服务-CustomServer-注册服务" class="headerlink" title="自定义服务(CustomServer) 注册服务"></a>自定义服务(CustomServer) 注册服务</h5><blockquote>
<p><code>ServiceManager.addService()</code>主要面向的是系统服务，应用自定义服务是无法通过这种方式注册的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/cmds/servicemanager/service_manager.c<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> svc_can_register(<span class="hljs-keyword">const</span> uint16_t *name, size_t name_len, pid_t spid, uid_t uid)<br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *perm = "add";<br><br>    <span class="hljs-keyword">if</span> (multiuser_get_app_id(uid) &gt;= AID_APP) &#123; // AID_APP 为 10000<br>        <span class="hljs-keyword">return</span> 0; /* Don't allow apps to <span class="hljs-keyword">register</span> services */<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>自定义Service被分配到的<code>uid</code>都是大于<code>10000</code>的，当自定义Service执行到的时候，会在这一步被拒绝。</p>
<p>一般情况下通过<code>startService()</code>启动服务，<code>bindService()</code>来绑定服务并与其他Service进行交互。</p>
<h4 id="Service-Manager-获取服务"><a href="#Service-Manager-获取服务" class="headerlink" title="Service Manager 获取服务"></a>Service Manager 获取服务</h4><blockquote>
<p>Client 向 Service Manager 获取服务</p>
</blockquote>
<p><code>获取服务</code>流程大致与<code>注册服务</code>流程一致</p>
<p>只是最后执行的<code>do_find_service()</code>方法，从<code>Service Manager</code>获取注册的服务。</p>
<p><img src="/images/5-4-2-get_service.jpg" srcset="/img/loading.gif" alt="查询服务"></p>
<h4 id="Java-获取服务"><a href="#Java-获取服务" class="headerlink" title="Java 获取服务"></a>Java 获取服务</h4><blockquote>
<p>一般通过<code>ServiceManager.getService()</code>获取服务。</p>
<p>由于<code>ServiceManager</code>无法被直接调用，就需要通过底层进行调用。</p>
</blockquote>
<h5 id="Context-getSystemService"><a href="#Context-getSystemService" class="headerlink" title="Context#getSystemService"></a>Context#getSystemService</h5><blockquote>
<p>最常用的就是<code>getSystemService</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">//Context.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> @Nullable Object getSystemService(@ServiceName @NonNull String name);<br><br>//ContextImpl.java Context实现类<br>    @Override<br>    <span class="hljs-keyword">public</span> Object getSystemService(String name) &#123;<br>        return SystemServiceRegistry.getSystemService(<span class="hljs-keyword">this</span>, name);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>接下来就切换到<code>SystemServiceRegistry</code>执行<code>SystemService</code>相关流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java">//base/core/java/android/app/SystemServiceRegistry.java<br>//缓存 SystemServerName 与 ServiceFetcher映射关系<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =<br>            new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> interface ServiceFetcher&lt;T&gt; &#123;<br>        T getService(ContextImpl ctx);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>      ...<br>        registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,<br>                new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;<br>            @Override<br>            <span class="hljs-keyword">public</span> LayoutInflater createService(ContextImpl ctx) &#123;<br>                return new PhoneLayoutInflater(ctx.getOuterContext());<br>            &#125;&#125;);<br>      ...<br>        registerService(Context.CONNECTIVITY_SERVICE, ConnectivityManager.class,<br>                new StaticApplicationContextServiceFetcher&lt;ConnectivityManager&gt;() &#123;<br>            @Override<br>            <span class="hljs-keyword">public</span> ConnectivityManager createService(Context context) <span class="hljs-keyword">throws</span> ServiceNotFoundException &#123;<br>                IBinder b = ServiceManager.getServiceOrThrow(Context.CONNECTIVITY_SERVICE);<br>                IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);<br>                return new ConnectivityManager(context, service);<br>            &#125;&#125;);<br>      ...<br>        registerService(Context.WIFI_P2P_SERVICE, WifiP2pManager.class,<br>                new StaticServiceFetcher&lt;WifiP2pManager&gt;() &#123;<br>            @Override<br>            <span class="hljs-keyword">public</span> WifiP2pManager createService() <span class="hljs-keyword">throws</span> ServiceNotFoundException &#123;<br>                IBinder b = ServiceManager.getServiceOrThrow(Context.WIFI_P2P_SERVICE);<br>                IWifiP2pManager service = IWifiP2pManager.Stub.asInterface(b);<br>                return new WifiP2pManager(service);<br>            &#125;&#125;);<br>      ...<br>        <br>    &#125;<br>    //注册系统服务 在SYSTEM_SERVICE_FETCHERS 添加<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> registerService(String serviceName, Class&lt;T&gt; serviceClass,<br>            ServiceFetcher&lt;T&gt; serviceFetcher) &#123;<br>        SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);<br>        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object getSystemService(ContextImpl ctx, String name) &#123;<br>        ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);<br>        return fetcher != <span class="hljs-keyword">null</span> ? fetcher.getService(ctx) : <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>根据上述源码得知<code>ServiceFetcher</code>主要有以下3种实现类</p>
<ul>
<li><code>CachedServiceFetcher</code>：进程内部缓存<code>SystemService</code>，切换进程需要重新获取</li>
<li><code>StaticServiceFetcher</code>：系统内部缓存，所有进程获取的都是同一个<code>SystemService</code></li>
<li><code>StaticApplicationContextServiceFetcher</code>：应用内部缓存<code>SystemService</code>，其他应用需要重新获取。</li>
</ul>
<p>在<code>ServiceFetcher</code>的实现类中，需要实现<code>createService()</code>，其中内部调用到了<code>ServiceManager.getServiceOrThrow()</code></p>
<h5 id="ServiceManager-getService"><a href="#ServiceManager-getService" class="headerlink" title="ServiceManager#getService()"></a>ServiceManager#getService()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">//core/java/android/os/ServiceManager.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IBinder getServiceOrThrow(String name) <span class="hljs-keyword">throws</span> ServiceNotFoundException &#123;<br>        <span class="hljs-keyword">final</span> IBinder binder = getService(name);<br>        <span class="hljs-keyword">if</span> (binder != <span class="hljs-keyword">null</span>) &#123;<br>            return binder;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            throw new ServiceNotFoundException(name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IBinder getService(String name) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          //缓存直接获取<br>            IBinder service = sCache.get(name);<br>            <span class="hljs-keyword">if</span> (service != <span class="hljs-keyword">null</span>) &#123;<br>                return service;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <br>                return Binder.allowBlocking(rawGetService(name));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            Log.e(TAG, "error in getService", e);<br>        &#125;<br>        return <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IBinder rawGetService(String name) <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start = sStatLogger.getTime();<br><br>        <span class="hljs-keyword">final</span> IBinder binder = getIServiceManager().getService(name);<br>      ...<br>         &#125;<br></code></pre></td></tr></table></figure>
<p><code>getIServiceManager()</code>最后指向的就是<code>ServiceManagerProxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">//core/java/android/os/ServiceManagerNative.java<br>    <span class="hljs-keyword">public</span> IBinder getService(String name) <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        Parcel data = Parcel.obtain();<br>        Parcel reply = Parcel.obtain();<br>        data.writeInterfaceToken(IServiceManager.descriptor);<br>        data.writeString(name);<br>        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);<br>      //读取Binder对象<br>        IBinder binder = reply.readStrongBinder();<br>        reply.recycle();<br>        data.recycle();<br>        return binder;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="mRemote-transact-GET-SERVICE-TRANSACTION"><a href="#mRemote-transact-GET-SERVICE-TRANSACTION" class="headerlink" title="mRemote.transact(GET_SERVICE_TRANSACTION)"></a><code>mRemote.transact(GET_SERVICE_TRANSACTION)</code></h5><p>通过<code>IPCThreadState.talkWithDriver()</code>发送数据<code>GET_SERVICE_TRANSACTION</code>到<code>Binder驱动</code></p>
<h5 id="readStrongBinder"><a href="#readStrongBinder" class="headerlink" title="readStrongBinder()"></a><code>readStrongBinder()</code></h5><p>基本就是<code>writeStrongBinder()</code>的逆向过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr)<br>&#123;<br>    Parcel* parcel = <span class="hljs-keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);<br>    <span class="hljs-keyword">if</span> (parcel != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> javaObjectForIBinder(env, parcel-&gt;readStrongBinder());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/libs/binder/Parcel.cpp<br>sp&lt;IBinder&gt; Parcel::readStrongBinder() <span class="hljs-keyword">const</span><br>&#123;<br>    sp&lt;IBinder&gt; val;<br>    // Note that a lot of code in Android reads binders by hand with <span class="hljs-keyword">this</span><br>    // method, <span class="hljs-keyword">and</span> that code has historically been ok with getting <span class="hljs-literal">nullptr</span><br>    // back (<span class="hljs-keyword">while</span> ignoring error codes).<br>    readNullableStrongBinder(&amp;val);<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><br>status_t Parcel::readNullableStrongBinder(sp&lt;IBinder&gt;* val) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> unflattenBinder(val);<br>&#125;<br><br>status_t Parcel::unflattenBinder(sp&lt;IBinder&gt;* out) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">const</span> flat_binder_object* flat = readObject(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">if</span> (flat) &#123;<br>        <span class="hljs-keyword">switch</span> (flat-&gt;hdr.type) &#123;<br>            <span class="hljs-keyword">case</span> BINDER_TYPE_BINDER: &#123;<br>                sp&lt;IBinder&gt; binder = <span class="hljs-keyword">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);<br>                <span class="hljs-keyword">return</span> finishUnflattenBinder(binder, out);<br>            &#125;<br>            <span class="hljs-keyword">case</span> BINDER_TYPE_HANDLE: &#123;<br>                sp&lt;IBinder&gt; binder =<br>                    ProcessState::self()-&gt;getStrongProxyForHandle(flat-&gt;handle);<br>                <span class="hljs-keyword">return</span> finishUnflattenBinder(binder, out);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> BAD_TYPE;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从<code>flat_binder_obj</code>读取得到<code>IBinder</code>对象，实质就是<code>BpBinder</code>对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//core/jni/android_util_Binder.cpp<br>jobject javaObjectForIBinder(JNIEnv* env, <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; val)<br>&#123;<br>    <span class="hljs-keyword">if</span> (val == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;<br>        // It's a JavaBBinder created by ibinderForJavaObject. Already has Java object.<br>        jobject object = <span class="hljs-keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();<br>        LOGDEATH("objectForBinder %p: it's our own %p!\n", val.get(), object);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    // For the rest of the function we will hold <span class="hljs-keyword">this</span> lock, to serialize<br>    // looking/creation/destruction of Java proxies <span class="hljs-keyword">for</span> native Binder proxies.<br>    AutoMutex _l(gProxyLock);<br><br>    BinderProxyNativeData* nativeData = gNativeDataCache;<br>    <span class="hljs-keyword">if</span> (nativeData == <span class="hljs-literal">nullptr</span>) &#123;<br>        nativeData = <span class="hljs-keyword">new</span> BinderProxyNativeData();<br>    &#125;<br>    // gNativeDataCache is now logically empty.<br>    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,<br>            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());<br>    <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) &#123;<br>        // In the exception <span class="hljs-keyword">case</span>, getInstance still took ownership of nativeData.<br>        gNativeDataCache = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);<br>    <span class="hljs-keyword">if</span> (actualNativeData == nativeData) &#123;<br>        // New BinderProxy; we still have exclusive access.<br>        nativeData-&gt;mOrgue = <span class="hljs-keyword">new</span> DeathRecipientList;<br>        nativeData-&gt;mObject = val;<br>        gNativeDataCache = <span class="hljs-literal">nullptr</span>;<br>        ++gNumProxies;<br>        <span class="hljs-keyword">if</span> (gNumProxies &gt;= gProxiesWarned + PROXY_WARN_INTERVAL) &#123;<br>            ALOGW("Unexpectedly many live BinderProxies: %d\n", gNumProxies);<br>            gProxiesWarned = gNumProxies;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // nativeData wasn't used. Reuse it the next time.<br>        gNativeDataCache = nativeData;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>经过<code>javaObjectForIBinder()</code>之后转换<code>BpBinder</code>对象到<code>BinderProxy</code>对象.</p>
<p>通过<code>ServiceManager.getService()</code>最后<code>Client</code>持有的就是<code>BinderProxy</code>对象。</p>
<h3 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h3><p><em>下面源码分析基于<code>android-goldfish-4.4-dev</code>内核版本</em></p>
<blockquote>
<p>Android专用，主要以<code>misc</code>设备进行注册，节点是<code>/dev/binder</code>，直接操作设备内存。</p>
</blockquote>
<p><code>Binder驱动</code>源码位于<code>内核</code>，具体代码路径位于<code>/drivers/android/binder.c</code></p>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><h5 id="Binder初始化-binder-init"><a href="#Binder初始化-binder-init" class="headerlink" title="Binder初始化-binder_init()"></a>Binder初始化-binder_init()</h5><blockquote>
<p>注册misc设备</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//drivers/android/binder.c<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init binder_init(<span class="hljs-keyword">void</span>)<br>&#123;<br>	<span class="hljs-keyword">int</span> ret;<br>	<span class="hljs-keyword">char</span> *device_name, *device_names;<br>	struct binder_device *device;<br>	struct hlist_node *tmp;<br><br>	binder_alloc_shrinker_init();<br><br>	atomic_set(&amp;binder_transaction_log.cur, ~0U);<br>	atomic_set(&amp;binder_transaction_log_failed.cur, ~0U);<br>  //构建工作队列<br>	binder_deferred_workqueue = create_singlethread_workqueue("binder");<br>	<span class="hljs-keyword">if</span> (!binder_deferred_workqueue)<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br><br>	<span class="hljs-keyword">while</span> ((device_name = strsep(&amp;device_names, ","))) &#123;<br>    //注册bidner设备<br>		ret = init_binder_device(device_name);<br>		<span class="hljs-keyword">if</span> (ret)<br>			<span class="hljs-keyword">goto</span> err_init_binder_device_failed;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> ret;<br>  <br>  //执行过程异常处理<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init init_binder_device(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)<br>&#123;<br>	<span class="hljs-keyword">int</span> ret;<br>	struct binder_device *binder_device;<br><br>	binder_device-&gt;miscdev.fops = &amp;binder_fops;<br>	binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;<br>	binder_device-&gt;miscdev.name = name;<br><br>	binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;<br>	binder_device-&gt;context.name = name;<br>	mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock);<br><br>  //注册misc设备<br>	ret = misc_register(&amp;binder_device-&gt;miscdev);<br><br>	hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);<br><br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>misc_register</code>注册Binder设备，具体配置如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">miscdev.fops = &amp;binder_fops;<br>miscdev.minor = MISC_DYNAMIC_MINOR;<br>miscdev.name = name //name为以下三个 binder hwbinder cdvbinder<br>  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> struct file_operations binder_fops = &#123;<br>	.owner = THIS_MODULE,<br>	.poll = binder_poll,<br>	.unlocked_ioctl = binder_ioctl,<br>	.compat_ioctl = binder_ioctl,<br>	.mmap = binder_mmap,<br>	.open = binder_open,<br>	.flush = binder_flush,<br>	.release = binder_release,<br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="打开Binder设备-binder-open"><a href="#打开Binder设备-binder-open" class="headerlink" title="打开Binder设备-binder_open()"></a>打开Binder设备-binder_open()</h5><blockquote>
<p>打开binder驱动设备</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> binder_open(struct inode *nodp, struct file *filp)<br>&#123;<br>	struct binder_proc *proc;<br>	struct binder_device *binder_dev;<br><br>	binder_debug(BINDER_DEBUG_OPEN_CLOSE, "binder_open: %d:%d\n",<br>		     current-&gt;group_leader-&gt;pid, current-&gt;pid);<br><br>	proc = kzalloc(<span class="hljs-keyword">sizeof</span>(*proc), GFP_KERNEL);<br>	<span class="hljs-keyword">if</span> (proc == <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br>	spin_lock_init(&amp;proc-&gt;inner_lock);<br>	spin_lock_init(&amp;proc-&gt;outer_lock);<br>	get_task_struct(current-&gt;group_leader);<br>	proc-&gt;tsk = current-&gt;group_leader;<br>	INIT_LIST_HEAD(&amp;proc-&gt;todo);<br>  //记录进程优先级<br>	<span class="hljs-keyword">if</span> (binder_supported_policy(current-&gt;policy)) &#123;<br>		proc-&gt;default_priority.sched_policy = current-&gt;policy;<br>		proc-&gt;default_priority.prio = current-&gt;normal_prio;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		proc-&gt;default_priority.sched_policy = SCHED_NORMAL;<br>		proc-&gt;default_priority.prio = NICE_TO_PRIO(0);<br>	&#125;<br><br>	binder_dev = container_of(filp-&gt;private_data, struct binder_device,<br>				  miscdev);<br>	proc-&gt;context = &amp;binder_dev-&gt;context;<br>	binder_alloc_init(&amp;proc-&gt;alloc);<br><br>	binder_stats_created(BINDER_STAT_PROC);<br>	proc-&gt;pid = current-&gt;group_leader-&gt;pid;<br>	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);<br>	INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads);<br>	filp-&gt;private_data = proc;<br><br>	mutex_lock(&amp;binder_procs_lock);<br>	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);//创建好的binder_proc对象插入到 binder_procs中<br>	mutex_unlock(&amp;binder_procs_lock);<br><br><br>	<span class="hljs-keyword">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建<code>binder_proc</code>对象，并保存当前进程信息，内部结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">struct binder_proc &#123;<br>	struct hlist_node proc_node;<br>	struct rb_root threads; //对应的binder线程<br>	struct rb_root nodes; //binder节点<br>	struct rb_root refs_by_desc;<br>	struct rb_root refs_by_node;<br>	struct list_head waiting_threads;<br>	<span class="hljs-keyword">int</span> pid;<br>	struct task_struct *tsk;<br>	struct hlist_node deferred_work_node;<br>	<span class="hljs-keyword">int</span> deferred_work;<br>	<span class="hljs-keyword">bool</span> is_dead;<br><br>	struct list_head todo;//当前进程的任务<br>	struct binder_stats stats;<br>	struct list_head delivered_death;<br>	<span class="hljs-keyword">int</span> max_threads; //最大并发线程数<br>	<span class="hljs-keyword">int</span> requested_threads;<br>	<span class="hljs-keyword">int</span> requested_threads_started;<br>	<span class="hljs-keyword">int</span> tmp_ref;<br>	struct binder_priority default_priority;<br>	struct dentry *debugfs_entry;<br>	struct binder_alloc alloc;<br>	struct binder_context *context;<br>	spinlock_t inner_lock;<br>	spinlock_t outer_lock;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="/images/binder_procs.png" srcset="/img/loading.gif" alt="binder_procs"></p>
<h5 id="Binder内存映射-binder-mmap"><a href="#Binder内存映射-binder-mmap" class="headerlink" title="Binder内存映射-binder_mmap()"></a>Binder内存映射-binder_mmap()</h5><blockquote>
<p>首先申内核申请虚拟地址空间，申请一块与用户虚拟内存(<code>*vma</code>)相同大小的内存；<br>再申请一个1个page大小的物理内存，再将同一块物理内存分别映射到<code>内核虚拟地址空间</code>和<code>用户虚拟内存空间</code>。</p>
<p>从而实现了用户空间和内核空间的<code>buffer</code>同步操作。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">//drivers/android/binder.c<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> binder_mmap(struct file *filp/*Bidner驱动的fd*/, struct vm_area_struct *vma/*用户虚拟内存*/)<br>&#123;<br>	<span class="hljs-keyword">int</span> ret;<br>	struct binder_proc *proc = filp-&gt;private_data;<br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *failure_string;<br><br>  //保证映射内存大小不会超过4M<br>	<span class="hljs-keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)<br>		vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;<br><br>	vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;<br>	vma-&gt;vm_ops = &amp;binder_vm_ops;<br>	vma-&gt;vm_private_data = proc;<br><br>  <br>	ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma);<br><br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> binder_alloc_mmap_handler(struct binder_alloc *alloc,<br>			      struct vm_area_struct *vma)<br>&#123;<br>	mutex_lock(&amp;binder_alloc_mmap_lock);<br>	<span class="hljs-keyword">if</span> (alloc-&gt;buffer) &#123;<br>		ret = -EBUSY;<br>		failure_string = "already mapped";<br>		<span class="hljs-keyword">goto</span> err_already_mapped;<br>	&#125;<br>//分配一个连续的内核虚拟空间<br>	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);<br>  ...<br>    //分配物理页的指针数组<br>	alloc-&gt;pages = kzalloc(<span class="hljs-keyword">sizeof</span>(alloc-&gt;pages[0]) *<br>				   ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE),<br>			       GFP_KERNEL);<br>	<span class="hljs-keyword">if</span> (alloc-&gt;pages == <span class="hljs-literal">NULL</span>) &#123;<br>		ret = -ENOMEM;<br>		failure_string = "alloc page <span class="hljs-built_in">array</span>";<br>		<span class="hljs-keyword">goto</span> err_alloc_pages_failed;<br>	&#125;<br>	alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;<br><br>	buffer = kzalloc(<span class="hljs-keyword">sizeof</span>(*buffer), GFP_KERNEL);<br>	<span class="hljs-keyword">if</span> (!buffer) &#123;<br>		ret = -ENOMEM;<br>		failure_string = "alloc buffer struct";<br>		<span class="hljs-keyword">goto</span> err_alloc_buf_struct_failed;<br>	&#125;<br><br>	buffer-&gt;data = alloc-&gt;buffer;<br>	list_add(&amp;buffer-&gt;entry, &amp;alloc-&gt;buffers);<br>	buffer-&gt;<span class="hljs-built_in">free</span> = 1;<br>  //<br>	binder_insert_free_buffer(alloc, buffer);<br>  //异步可用空间大小为 buffer总大小的一半<br>	alloc-&gt;free_async_space = alloc-&gt;buffer_size / 2;<br>	barrier();<br>	alloc-&gt;vma = vma;<br>	alloc-&gt;vma_vm_mm = vma-&gt;vm_mm;<br>	/* Same as mmgrab() in later kernel versions */<br>	atomic_inc(&amp;alloc-&gt;vma_vm_mm-&gt;mm_count);<br><br>	<span class="hljs-keyword">return</span> 0;    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>当把同一块物理页面同时映射到进程空间和内核空间时，当需要在两者之间传递数据时，只需要其中任意一方把数据拷贝到物理页面，另一方直接读取即可，也就是说，数据的跨进程传递，只需要一次拷贝就可以完成。</p>
<h5 id="Binder内存管理-binder-ioctl"><a href="#Binder内存管理-binder-ioctl" class="headerlink" title="Binder内存管理-binder_ioctl()"></a>Binder内存管理-binder_ioctl()</h5><blockquote>
<p>负责在两个进程间收发<code>IPC 数据</code>和<code>IPC Reply</code>数据。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> binder_ioctl(struct file *filp/*binder驱动的fd*/, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd/*ioctl命令*/, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg/*数据类型*/)<br>&#123;<br>...<br><span class="hljs-keyword">switch</span> (cmd) &#123;<br>	<span class="hljs-keyword">case</span> BINDER_WRITE_READ:<br>		ret = binder_ioctl_write_read(filp, cmd, arg, thread);<br>		<span class="hljs-keyword">if</span> (ret)<br>			<span class="hljs-keyword">goto</span> err;<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> BINDER_SET_MAX_THREADS: &#123;<br>		<span class="hljs-keyword">int</span> max_threads;<br><br>		<span class="hljs-keyword">if</span> (copy_from_user(&amp;max_threads, ubuf,<br>				   <span class="hljs-keyword">sizeof</span>(max_threads))) &#123;<br>			ret = -EINVAL;<br>			<span class="hljs-keyword">goto</span> err;<br>		&#125;<br>		binder_inner_proc_lock(proc);<br>		proc-&gt;max_threads = max_threads;<br>		binder_inner_proc_unlock(proc);<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br>	<span class="hljs-keyword">case</span> BINDER_SET_CONTEXT_MGR:<br>		ret = binder_ioctl_set_ctx_mgr(filp);<br>		<span class="hljs-keyword">if</span> (ret)<br>			<span class="hljs-keyword">goto</span> err;<br>		<span class="hljs-keyword">break</span>;<br>    <br>&#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>binder驱动</code>将业务分为多种不同的命令，再根据具体的命令执行不同的业务。常用命令有以下几种：</p>
<ul>
<li><p><strong><code>BINDER_WRITE_READ</code></strong>：负责收发<code>Binder IPC</code>数据</p>
<p>使用场景：<code>Service Manager</code>通过发送<code>BINDER_WRITE_READ</code>命令向<code>Binder驱动</code>读写数据</p>
</li>
<li><p><code>BINDER_SET_MAX_THREADS</code>：设置进程最大binder线程个数</p>
<p>使用场景：在<code>ProcessState</code>初始化的时候，会设置当前进程支持的最大个数，默认为15，设置的命令为<code>BINDER_SET_MAX_THREADS</code></p>
</li>
<li><p><code>BINDER_SET_CONTEXT_MGR</code>：设置Service Manager为大管家。</p>
<p>使用场景：ServiceManager启动过程中调用<code>binder_become_context_manager()</code>命令为<code>BINDER_SET_CONTEXT_MGR</code></p>
</li>
</ul>
<p>使用最频繁的就是<code>BINDER_WRITE_READ</code>，下面简单的分析一下流程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> binder_ioctl(struct file *filp, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)<br>&#123;<br>  ...<br>	<span class="hljs-keyword">switch</span> (cmd) &#123;<br>	<span class="hljs-keyword">case</span> BINDER_WRITE_READ:<br>		ret = binder_ioctl_write_read(filp, cmd, arg, thread);<br>		<span class="hljs-keyword">if</span> (ret)<br>			<span class="hljs-keyword">goto</span> err;<br>		<span class="hljs-keyword">break</span>;<br>      ...<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> binder_ioctl_write_read(struct file *filp,<br>				<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg,<br>				struct binder_thread *thread)<br>&#123;<br>	<span class="hljs-keyword">int</span> ret = 0;<br>	struct binder_proc *proc = filp-&gt;private_data;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size = _IOC_SIZE(cmd);<br>	<span class="hljs-keyword">void</span> __user *ubuf = (<span class="hljs-keyword">void</span> __user *)arg;<br>	struct binder_write_read bwr;<br><br>	<span class="hljs-keyword">if</span> (size != <span class="hljs-keyword">sizeof</span>(struct binder_write_read)) &#123;<br>		ret = -EINVAL;<br>		<span class="hljs-keyword">goto</span> out;<br>	&#125;<br>  //从用户空间拷贝数据到 bwr(内核空间)<br>	<span class="hljs-keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="hljs-keyword">sizeof</span>(bwr))) &#123;<br>		ret = -EFAULT;<br>		<span class="hljs-keyword">goto</span> out;<br>	&#125;<br>  <br>	<span class="hljs-keyword">if</span> (bwr.write_size &gt; 0) &#123;<br>    //存在写数据时，执行binder写操作<br>		ret = binder_thread_write(proc, thread,<br>					  bwr.write_buffer,<br>					  bwr.write_size,<br>					  &amp;bwr.write_consumed);<br>		trace_binder_write_done(ret);<br>		<span class="hljs-keyword">if</span> (ret &lt; 0) &#123;<br>			bwr.read_consumed = 0;<br>			<span class="hljs-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr)))<br>				ret = -EFAULT;<br>			<span class="hljs-keyword">goto</span> out;<br>		&#125;<br>	&#125;<br>  <br>	<span class="hljs-keyword">if</span> (bwr.read_size &gt; 0) &#123;<br>    //存在读数据，执行binder读操作<br>		ret = binder_thread_read(proc, thread, bwr.read_buffer,<br>					 bwr.read_size,<br>					 &amp;bwr.read_consumed,<br>					 filp-&gt;f_flags &amp; O_NONBLOCK);<br>		trace_binder_read_done(ret);<br>		binder_inner_proc_lock(proc);<br>		<span class="hljs-keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo))<br>			binder_wakeup_proc_ilocked(proc);<br>		binder_inner_proc_unlock(proc);<br>		<span class="hljs-keyword">if</span> (ret &lt; 0) &#123;<br>			<span class="hljs-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr)))<br>				ret = -EFAULT;<br>			<span class="hljs-keyword">goto</span> out;<br>		&#125;<br>	&#125;<br><br>  //将内核数据 bwr 拷贝回 用户空间<br>	<span class="hljs-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr))) &#123;<br>		ret = -EFAULT;<br>		<span class="hljs-keyword">goto</span> out;<br>	&#125;<br>out:<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>binder_write_read</code>时<code>内核层</code>定义的结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">struct binder_write_read &#123;//用在binder内部<br>	binder_size_t		write_size;	//用户空间写入数据的size<br>	binder_size_t		write_consumed;	//Binder读取了多少数据<br>	binder_uintptr_t	write_buffer;//用户空间写入数据<br>	binder_size_t		read_size;	//binder写入数据的size<br>	binder_size_t		read_consumed;	//用户空间读取了多少数据<br>	binder_uintptr_t	read_buffer; //Binder写入数据<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="/images/binder_transaction_data.jpg" srcset="/img/loading.gif" alt="binder_transaction_data"></p>
<p><code>binder_ioctl_write_read()</code>主要执行以下几步：</p>
<ol>
<li>通过<code>copy_from_user()</code>拷贝<code>用户空间数据</code>到<code>内核空间</code></li>
<li>存在<code>write_size &gt; 0</code>，意味着外部有数据传入，需要执行<code>binder_thread_write()</code>，读取外部传入数据</li>
<li>存在<code>read_size &gt; 0</code>，意味着有数据要传出，需要执行<code>binder_thread_read()</code>，写入数据准备传到外部</li>
<li>最后执行<code>copy_to_user()</code>拷贝<code>内核空间数据</code>到<code>用户空间</code></li>
</ol>
<p><img src="/images/Binder_binder_ioctl_write_read.png" srcset="/img/loading.gif" alt="Binder_write_read过程"></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/Binder驱动加载过程.png" srcset="/img/loading.gif" alt="Binder驱动加载"></p>
<h2 id="Binder通信过程"><a href="#Binder通信过程" class="headerlink" title="Binder通信过程"></a>Binder通信过程</h2><p><img src="/images/binder_ipc_process.jpg" srcset="/img/loading.gif" alt="binder_ipc_process"></p>
<h3 id="Binder权限验证"><a href="#Binder权限验证" class="headerlink" title="Binder权限验证"></a>Binder权限验证</h3><p><code>进程A</code>通过Binder调用<code>进程B</code>，然后<code>进程B</code>又Binder调用<code>进程C</code>，此时进程C中的<code>IPCThreadState</code>存储的就是<code>进程A</code>的<code>PID和UID</code>。此时假如<code>进程B</code>想调用<code>进程C</code>，就会抛出异常<code>Bad call: specified package com.providers.xxx under uid 10032 but it is really 10001</code>。</p>
<p><em>Binder的权限验证回导致进程A调用进程B后，进程B调用原进程方法时失败。</em></p>
<p>上述流程就是<code>Binder权限验证</code>的流程。</p>
<p><code>在被调用时进程回去检测是否与自身IPCThreadState存储的uid与pid一致，只有一致才会请求成功。否则抛出异常</code></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> origId = Binder.clearCallingIdentity();<br>//远程调用过程<br>Binder.restoreCallingIdentity(origId);<br></code></pre></td></tr></table></figure>
<p><code>clearCallingIndetity()</code></p>
<blockquote>
<p>在当前线程中重置到来的IPC标识(<code>uid/pid</code>)，然后设置<code>mCallingUid</code>和<code>mCallingPid</code>为当前进程的值</p>
</blockquote>
<p><code>restoreCallingIdentity(id)</code></p>
<blockquote>
<p>还原前面存储的初始调用者的<code>mCallingPid</code>和<code>mCallingUid</code></p>
</blockquote>
<h2 id="Binder-AIDL"><a href="#Binder-AIDL" class="headerlink" title="Binder-AIDL"></a>Binder-AIDL</h2><blockquote>
<p>全称为<code>Android Interface Definition Language</code>——Android接口定义语言。</p>
</blockquote>
<p><code>Messenger</code>是基于<code>AIDL</code>的，不过只能处理串行的消息，存在大量消息需要同时处理时，也只能一个个处理，这时就需要使用AIDL来处理多消息的情况。</p>
<p><code>AIDL</code>本质就是系统提供的一种快速实现<code>Binder</code>的工具，不一定需要依赖<code>AIDL</code>去实现功能。</p>
<h3 id="AIDL支持的数据类型"><a href="#AIDL支持的数据类型" class="headerlink" title="AIDL支持的数据类型"></a>AIDL支持的数据类型</h3><ul>
<li>基本数据类型：<code>byte、int、long、float、double、boolean，char</code></li>
<li>String 和 CharSequence</li>
<li>ArrayList，HashMap(<strong>包括key，每个元素必须可以被AIDL支持</strong>)</li>
<li>实现了Parcelabe接口的对象 <strong>必须要显示Import进来</strong></li>
<li>所有AIDL接口本身也会被调用<strong>必须要显示Import进来</strong></li>
</ul>
<h3 id="定向tag"><a href="#定向tag" class="headerlink" title="定向tag"></a>定向tag</h3><blockquote>
<p>除了基本数据类型，其他类型的参数必须加上方向 <strong>in,out,inout</strong>，用于表示在跨进程通信中的数据流向。</p>
</blockquote>
<ul>
<li><code>in</code>：表示数据只能由客户端流向服务端。服务端会收到这个对象的完整数据，<strong>但在服务端对对象进行修改不会对客户端传递进来的对象造成影响。</strong></li>
<li><code>out</code>：表示数据只能由服务端传递到客户端。服务端会接受到这个对象的空对象，<strong>但在服务端接收到的空对象有任何修改之后客户端会同步发生变化。</strong></li>
<li><code>inout</code>：表示数据可以在服务端和客户端之间双向流通。服务端会收到这个对象的完整数据，<strong>且客户端会同步服务端对该对象的任何改动。</strong></li>
</ul>
<h3 id="关键类与方法"><a href="#关键类与方法" class="headerlink" title="关键类与方法"></a>关键类与方法</h3><p><code>AIDL</code>文件代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">interface BookManager &#123;<br>    <span class="hljs-keyword">int</span> getResult(<span class="hljs-keyword">int</span> a,out List&lt;String&gt; b,inout List&lt;String&gt; c ,in String d);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>AIDL</code>文件便已完成后会得到一个Java文件，生成内容主要如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> interface BookManager extends IInterface &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> class Stub extends Binder implements BookManager &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BookManager asInterface(IBinder obj) &#123;<br>            <span class="hljs-keyword">if</span> ((obj == <span class="hljs-keyword">null</span>)) &#123;<br>                return <span class="hljs-keyword">null</span>;<br>            &#125;<br>          //寻找本地的Binder对象<br>            IInterface iin = obj.queryLocalInterface(DESCRIPTOR);<br>            <span class="hljs-keyword">if</span> (((iin != <span class="hljs-keyword">null</span>) &amp;&amp; (iin <span class="hljs-keyword">instanceof</span> BookManager))) &#123;<br>              //本地Binder对象存在，表示当前 Client与 Server处于同一进程，直接调用对应方法即可<br>                return ((BookManager) iin);<br>            &#125;<br>          //不存在本地Binder对象，生成代理对象进行远程调用<br>            return new Proxy(obj);<br>        &#125;<br>    <br>       //返回当前Binder对象<br>   // IBinder 这个代表了一种跨进程通信的能力。只要实现了这个接口，这个对象就可以跨进程传输。Client和Server进程都要实现该接口。<br>        @Override<br>        <span class="hljs-keyword">public</span> android.os.IBinder asBinder() &#123;<br>            return <span class="hljs-keyword">this</span>;<br>        &#125;<br>    <br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> onTransact(<span class="hljs-keyword">int</span> code, Parcel data, Parcel reply, <span class="hljs-keyword">int</span> flags) <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            <span class="hljs-keyword">switch</span> (code) &#123;<br>                <span class="hljs-keyword">case</span> TRANSACTION_getResult: &#123;<br>                    data.enforceInterface(descriptor);<br>                    <span class="hljs-keyword">int</span> _arg0;<br>                    _arg0 = data.readInt();<br>                    java.util.List&lt;java.lang.String&gt; _arg1;<br>                    _arg1 = new java.util.ArrayList&lt;java.lang.String&gt;();<br>                    java.util.List&lt;java.lang.String&gt; _arg2;<br>                    _arg2 = data.createStringArrayList();<br>                    java.lang.String _arg3;<br>                    _arg3 = data.readString();<br>                    <span class="hljs-keyword">int</span> _result = <span class="hljs-keyword">this</span>.getResult(_arg0, _arg1, _arg2, _arg3);<br>                    reply.writeNoException();<br>                    reply.writeInt(_result);<br>                    reply.writeStringList(_arg1);<br>                    reply.writeStringList(_arg2);<br>                    return <span class="hljs-keyword">true</span>;<br>                &#125;   <br>            &#125;<br>        &#125;<br>    <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> class Proxy implements BookManager &#123;<br>            <span class="hljs-keyword">private</span> android.os.IBinder mRemote;<br><br>            Proxy(android.os.IBinder remote) &#123;<br>                mRemote = remote;<br>            &#125;<br><br>            @Override<br>            <span class="hljs-keyword">public</span> android.os.IBinder asBinder() &#123;<br>                return mRemote;<br>            &#125;    <br>          <br>            @Override<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getResult(<span class="hljs-keyword">int</span> a, java.util.List&lt;java.lang.String&gt; b, java.util.List&lt;java.lang.String&gt; c, java.lang.String d) <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;<br>                android.os.Parcel _data = android.os.Parcel.obtain();<br>                android.os.Parcel _reply = android.os.Parcel.obtain();<br>                <span class="hljs-keyword">int</span> _result;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    _data.writeInterfaceToken(DESCRIPTOR);<br>                    _data.writeInt(a);//<span class="hljs-keyword">int</span> a 默认为 in<br>                    _data.writeStringList(c);//inout c <br>                    _data.writeString(d);//in String d<br>                  //客户端调用 该方法传参到 服务端<br>                    mRemote.transact(Stub.TRANSACTION_getResult, _data, _reply, 0);<br>                    _reply.readException();<br>                    _result = _reply.readInt();<br>                    _reply.readStringList(b);//out b<br>                    _reply.readStringList(c);//inout c<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    _reply.recycle();<br>                    _data.recycle();<br>                &#125;<br>                return _result;<br>            &#125;<br>          <br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRANSACTION_getResult = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);          <br>  &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getResult(<span class="hljs-keyword">int</span> a, List&lt;String&gt; b, List&lt;String&gt; c, String d) <span class="hljs-keyword">throws</span> RemoteException;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据上述生成的代码：</p>
<h4 id="类-接口"><a href="#类-接口" class="headerlink" title="类/接口"></a>类/接口</h4><p><code>IInterface</code></p>
<p>表示<code>Server</code>进程需要具备什么功能，对应的就是<code>Client</code>进程可以调用的方法。</p>
<p><code>Stub</code></p>
<p>一个跨进程调用对象，继承自<code>Binder</code>，表示为<code>Server进程的本地Binder对象</code>，需要实现<code>Server</code>进程可以提供的功能。</p>
<p><code>Proxy</code></p>
<p>Binder代理对象，位于<code>Client</code>进程，由其发起<code>transcat()</code>与Binder驱动进行通信。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>asBinder()</code></p>
<p>返回当前进程的Binder对象。</p>
<ul>
<li>对于<code>Client</code>进程：返回远端进程的<code>BinderProxy</code>代理对象</li>
<li>对于<code>Server</code>进程：返回当前进程的IBinder对象</li>
</ul>
<p><code>asInterface()</code></p>
<p>通常用在<code>bindService()</code>之后，继续在<code>onServiceConnected()</code>调用该方法，就可以把<code>IBinder</code>对象转换成<code>IInterface</code>，就可以直接调用对应<code>Server</code>进程的方法。</p>
<p><code>onTrancast(int code, Parcel data, Parcel reply, int flags)</code></p>
<p>参数说明：</p>
<ul>
<li><code>code</code>：根据<code>code</code>确定<code>Client</code>端请求的方法</li>
<li><code>data</code>：<code>Client</code>方法请求参数</li>
<li><code>reply</code>：<code>Server</code>方法返回参数</li>
<li><code>flags</code>：设置IPC模式。<ul>
<li>0：双向流通(默认值)</li>
<li>1：单向流程</li>
</ul>
</li>
</ul>
<p>对应的就是<code>Proxy</code>中各个方法内部调用的<code>mRemote.transcat()</code>传递的参数。</p>
<p>//TODO 关系图</p>
<p>根据上述生成代码，可以大致分析出AIDL内部代码的工作机制</p>
<p><img src="/images/Binder-workflow.png" srcset="/img/loading.gif" alt="Binder工作机制"></p>
<ul>
<li>Client调用<code>远程Binder对象</code>，然后<code>Client</code>挂起，等待<code>Server</code>响应数据</li>
<li><code>Binder代理对象</code>将请求发送给<code>Binder驱动</code></li>
<li><code>Binder驱动</code>转发请求给Server</li>
<li><code>Server</code>处理完请求后，返回结果到<code>Binder驱动</code>，再回到<code>Client</code>并唤醒</li>
</ul>
<h2 id="Binder-系统调用"><a href="#Binder-系统调用" class="headerlink" title="Binder-系统调用"></a>Binder-系统调用</h2><p><code>system_call</code>的实现位于内核之中，。</p>
<p>各个地方调用<code>ioctl</code>如何控制可以准确的调用到对应的方法？</p>
<p>通过<code>system_call()</code>，其中第一个参数表示的是<code>对应构造函数的参数个数</code>，第二个就表示可<code>对应要调用的方法</code></p>
<h2 id="Binder拓展知识"><a href="#Binder拓展知识" class="headerlink" title="Binder拓展知识"></a>Binder拓展知识</h2><h3 id="Binder传输数据上限，以及超出会如何？"><a href="#Binder传输数据上限，以及超出会如何？" class="headerlink" title="Binder传输数据上限，以及超出会如何？"></a>Binder传输数据上限，以及超出会如何？</h3><blockquote>
<p>Binder传输数据的最大限制为<code>1016KB</code>(默认情况下)，如果是异步执行，最多只有<code>508KB</code>。</p>
</blockquote>
<p>调用<code>mmap</code>映射的大小就为<code>1016KB</code>，如果超出这块区域，<code>Binder驱动</code>就无法处理Binder调用，然后会抛出<code>DeadObjectException</code>异常。</p>
<h3 id="每个进程最大Binder线程数，以及超出会如何？"><a href="#每个进程最大Binder线程数，以及超出会如何？" class="headerlink" title="每个进程最大Binder线程数，以及超出会如何？"></a>每个进程最大Binder线程数，以及超出会如何？</h3><blockquote>
<p>每个进程最多可以运行<code>16</code>个Binder线程</p>
</blockquote>
<p>当所有的16个binder线程都在工作时，就会出现线程饥饿状态。如果此时有新的binder线程请求，就会进入阻塞状态。</p>
<h3 id="oneway的作用"><a href="#oneway的作用" class="headerlink" title="oneway的作用"></a><code>oneway</code>的作用</h3><p><strong>异步调用和串行化处理</strong></p>
<ul>
<li><code>异步调用</code>:应用向<code>Binder驱动</code>发送数据后不需要挂起线程等待<code>Binder驱动</code>的回复，接收到<code>BR_TRANSACTION_COMPLETE</code>之后就直接结束。</li>
<li><code>串行化处理</code>：所有<code>oneway</code>方法不会同时执行，<code>Binder驱动</code>会进行串行化处理，保证一个个执行。</li>
</ul>
<blockquote>
<p><code>oneway</code>都是需要等待<code>BR_TRANSACTION_COMPLETE</code>消息。</p>
<p>不过<code>oneway</code>的请求方式在收到<code>BR_TRANSACTION_COMPLETE</code>消息后，立即返回；</p>
<p><code>非oneway</code>的请求方式，还需要等到<code>BR_REPLY</code>之后才返回。此时<code>线程就会处于Sleep状态</code>，底层调用的就是<code>wait_event_interruptible()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">//XX.aidl<br>interface IXX &#123;<br>  //定义该方法调用 为 oneway<br>  oneway <span class="hljs-keyword">void</span> xx();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.hacktivesecurity.com/index.php?controller=post&amp;action=view&amp;id_post=48" target="_blank" rel="noopener">Binder介绍</a></p>
<p><a href="http://gityuan.com/" target="_blank" rel="noopener">Binder系列讲解</a></p>
<p><a href="https://www.cnblogs.com/samchen2009/p/3316001.html" target="_blank" rel="noopener">图解Android - Binder 和 Service</a></p>
<p><a href="https://blog.csdn.net/happylishang/article/details/62234127" target="_blank" rel="noopener">深入理解Binder通信原理及面试问题</a></p>
<p><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Binder设计与实现-设计篇</a></p>
<p><a href="https://juejin.cn/post/6844904113046568973" target="_blank" rel="noopener">Bidner｜内存拷贝的本质和变迁</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/05/30/View的刷新机制/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android屏幕的刷新机制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/05/02/Java线程相关合集整理/">
                        <span class="hidden-mobile">Java线程相关合集整理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
