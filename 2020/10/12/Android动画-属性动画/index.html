

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Android动画-属性动画 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/solarized-light.min.css">
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
                Android动画-属性动画
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-12 14:28" pubdate>
        2020年10月12日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      90
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Android动画-属性动画</h1>
            
            <div class="markdown-body" id="post-body">
              <blockquote>
<p>对作用对象进行了扩展，可以对任何对象做动画，甚至可以没有对象。</p>
</blockquote>
<h2 id="1-与View动画进行比较"><a href="#1-与View动画进行比较" class="headerlink" title="1.与View动画进行比较"></a>1.与View动画进行比较</h2><ul>
<li>View动画的作用对象<code>只能是View</code>，属性动画可以作用于<code>所有Java对象</code></li>
<li>View动画并没有改变View的属性，只是改变了View的视觉效果，并不具有交互性(<em>例如：无法响应动画后的点击事件。</em>)；属性动画是真正的对View的属性进行了修改，可以方便后续的交互操作。</li>
<li>View动画的效果比较单一，只能实现一些<code>平移，缩放，旋转等简单动画效果</code>，复杂的效果可能就需要<code>自定义View动画</code>去实现；属性动画拓展性强，可以基本实现所有的动画效果。</li>
</ul>
<h2 id="2-使用属性动画"><a href="#2-使用属性动画" class="headerlink" title="2.使用属性动画"></a>2.使用属性动画</h2><blockquote>
<p>使用XML方式</p>
</blockquote>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">set</span>
  <span class="hljs-attr">android:ordering</span>=<span class="hljs-string">[</span>"<span class="hljs-attr">together</span>" | "<span class="hljs-attr">sequentially</span>"]&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">objectAnimator</span>
        <span class="hljs-attr">android:propertyName</span>=<span class="hljs-string">"string"</span>
        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"int"</span>
        <span class="hljs-attr">android:valueFrom</span>=<span class="hljs-string">"float | int | color"</span>
        <span class="hljs-attr">android:valueTo</span>=<span class="hljs-string">"float | int | color"</span>
        <span class="hljs-attr">android:startOffset</span>=<span class="hljs-string">"int"</span>
        <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">"int"</span>
        <span class="hljs-attr">android:repeatMode</span>=<span class="hljs-string">[</span>"<span class="hljs-attr">repeat</span>" | "<span class="hljs-attr">reverse</span>"]
        <span class="hljs-attr">android:valueType</span>=<span class="hljs-string">[</span>"<span class="hljs-attr">intType</span>" | "<span class="hljs-attr">floatType</span>"]/&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">animator</span>
        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"int"</span>
        <span class="hljs-attr">android:valueFrom</span>=<span class="hljs-string">"float | int | color"</span>
        <span class="hljs-attr">android:valueTo</span>=<span class="hljs-string">"float | int | color"</span>
        <span class="hljs-attr">android:startOffset</span>=<span class="hljs-string">"int"</span>
        <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">"int"</span>
        <span class="hljs-attr">android:repeatMode</span>=<span class="hljs-string">[</span>"<span class="hljs-attr">repeat</span>" | "<span class="hljs-attr">reverse</span>"]
        <span class="hljs-attr">android:valueType</span>=<span class="hljs-string">[</span>"<span class="hljs-attr">intType</span>" | "<span class="hljs-attr">floatType</span>"]/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre>
<p><code>&lt;set&gt;</code>：表示动画集合，对应<code>AnimatorSet</code></p>
<p><code>android:ordering</code>：表示子动画的播放顺序</p>
<ul>
<li><code>together</code>：子动画同时播放</li>
<li><code>sequentially</code>：子动画按照定义顺序先后播放</li>
</ul>
<h3 id="使用ObjectAnimator实现"><a href="#使用ObjectAnimator实现" class="headerlink" title="使用ObjectAnimator实现"></a>使用<code>ObjectAnimator</code>实现</h3><blockquote>
<p>XML方式</p>
</blockquote>
<p><code>&lt;objectAnimator&gt;</code>：对象动画，对应<code>ObjectAnimator</code></p>
<ul>
<li><p><code>android:propertyName</code>：属性动画作用的属性名称</p>
<p>| 属性         | 作用                   | 数值类型 |<br>| ———— | ———————- | ——– |<br>| alpha        | 控制View的透明度       | float    |<br>| translationX | 控制View的水平方向位移 | float    |<br>| translationY | 控制View的竖直方向位移 | float    |<br>| rotation     | 控制View的Z轴旋转度数  | float    |<br>| rotationX    | 控制View的X轴旋转度数  | float    |<br>| rotationY    | 控制View的Y轴旋转度数  | float    |<br>| scaleX       | 控制View的X轴缩放倍数  | float    |<br>| scaleY       | 控制View的Y轴缩放倍数  | float    |</p>
</li>
<li><p><code>android:duration</code>： 动画持续时长。</p>
</li>
<li><p><code>android:startOffset</code>：设置动画执行之前的等待时长。</p>
</li>
<li><p><code>android:repeatCount</code>：动画重复执行的次数。</p>
<ul>
<li>默认为<strong>0</strong>，表示只播放一次。</li>
<li>设置为<strong>-1或infinite</strong>，表示无限重复。</li>
</ul>
</li>
<li><p><code>android:repeatMode</code>：动画重复执行的模式。可选值：</p>
<ul>
<li><strong>restart</strong>：表示连续重复，为默认值。</li>
<li><strong>reverse</strong> ：表示逆向重复。</li>
</ul>
</li>
<li><p><code>android:valueFrom</code>：动画初始值。</p>
</li>
<li><p><code>android:valueTo</code>：动画结束值。</p>
</li>
<li><p><code>android:valueType</code>：动画值类型。可选值：</p>
<ul>
<li>intType：表示属性的类型为 整形</li>
<li>floatType：表示属性的类型为浮点型 <em>默认值</em></li>
<li>不设置：如果表示颜色，无需设置</li>
</ul>
</li>
</ul>
<blockquote>
<p>Java创建</p>
</blockquote>
<pre><code class="hljs java">ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(view,propertyName<span class="hljs-comment">/*对应属性操作，可以为任意值*/</span>,<span class="hljs-keyword">float</span>... values<span class="hljs-comment">/*动画的初始值以及结束值，不定长度*/</span>);

mObjectAnimator.setDuration(duration);
mObjectAnimator.setStartDelay(delay);
mObjectAnimator.setRepeatCount(repeatCount);
mObjectAnimator.setRepeatMode(repeatMode);
mObjectAnimator.start();</code></pre>
<h5 id="应用代码"><a href="#应用代码" class="headerlink" title="应用代码"></a>应用代码</h5><blockquote>
<p>XML方式</p>
</blockquote>
<pre><code class="hljs xml">// objectAnim.xml
<span class="hljs-tag">&lt;<span class="hljs-name">objectAnimator</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>  
    <span class="hljs-attr">android:valueFrom</span>=<span class="hljs-string">"1"</span>   // 初始值
    <span class="hljs-attr">android:valueTo</span>=<span class="hljs-string">"0"</span>  // 结束值
    <span class="hljs-attr">android:valueType</span>=<span class="hljs-string">"floatType"</span>  // 变化值类型 ：<span class="hljs-attr">floatType</span> &amp; <span class="hljs-attr">intType</span>
    <span class="hljs-attr">android:propertyName</span>=<span class="hljs-string">"alpha"</span> // 对象变化的属性名称

/&gt;</span></code></pre>
<pre><code class="hljs java"><span class="hljs-comment">// 载入XML动画</span>
Animator animator = AnimatorInflater.loadAnimator(context, R.animator.objectAnim);  
<span class="hljs-comment">// 设置执行动画对象</span>
animator.setTarget(view);  
animator.start();</code></pre>
<blockquote>
<p>Java方式</p>
</blockquote>
<pre><code class="hljs java">ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(view,<span class="hljs-string">"alpha"</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);

mObjectAnimator.setDuration(<span class="hljs-number">1000</span>);
mObjectAnimator.setStartDelay(<span class="hljs-number">100</span>);
mObjectAnimator.setRepeatCount(<span class="hljs-number">0</span>);
mObjectAnimator.setRepeatMode(ValueAnimator.RESTART);
mObjectAnimator.start();</code></pre>
<h3 id="使用ValueAnimator实现"><a href="#使用ValueAnimator实现" class="headerlink" title="使用ValueAnimator实现"></a>使用<code>ValueAnimator</code>实现</h3><p><code>&lt;animator&gt;</code>：对应<code>ValueAnimator</code></p>
<p>相比于<code>&lt;objectAnimator&gt;</code>少了一个<code>android:propertyName</code>，其他含义相同。</p>
<blockquote>
<p>Java创建</p>
</blockquote>
<pre><code class="hljs java">ValueAnimator anim = ValueAnimator.ofInt(<span class="hljs-keyword">int</span>... values);
<span class="hljs-comment">//ValueAnimator anim = ValueAnimator.ofFloat(float... values);</span>
<span class="hljs-comment">//ValueAnimator anim = ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values);</span>

anim.setDuration(duration);
anim.setStartDelay(delay);
anim.setRepeatCount(repeatCount);
anim.setRepeatMode(repeatMode);
anim.start();</code></pre>
<h5 id="应用代码-1"><a href="#应用代码-1" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs java">ValueAnimator anim = ValueAnimator.ofInt(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
        <span class="hljs-comment">// 设置动画运行的时长</span>
        anim.setDuration(<span class="hljs-number">500</span>);       
        <span class="hljs-comment">// 设置动画延迟播放时间</span>
        anim.setStartDelay(<span class="hljs-number">500</span>);
        <span class="hljs-comment">// 设置动画重复播放次数 = 重放次数+1    </span>
        anim.setRepeatCount(<span class="hljs-number">0</span>); 
        anim.setRepeatMode(ValueAnimator.RESTART);
        anim.addUpdateLinstener(<span class="hljs-keyword">new</span> ValueAnimator.AnimatorUpdateListener()&#123;
  				<span class="hljs-meta">@Override</span>
  				<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span></span>&#123;
    				<span class="hljs-keyword">int</span> currentValue = (Integer)animation.getAnimatedValue；
            <span class="hljs-comment">//在其中对View进行相关属性设置 利用currentValue</span>
              ...
            view.requestLayout();
  				&#125;
				&#125;)
        anim.start();</code></pre>
<h3 id="使用动画集合AnimatiorSet实现"><a href="#使用动画集合AnimatiorSet实现" class="headerlink" title="使用动画集合AnimatiorSet实现"></a>使用动画集合<code>AnimatiorSet</code>实现</h3><blockquote>
<p>利用集合类<code>AnimatorSet</code>，内部可以随意组合继承<code>Animator类</code>的子类，而且可以定制顺序。</p>
</blockquote>
<h5 id="应用代码-2"><a href="#应用代码-2" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs java"><span class="hljs-comment">// 平移动画</span>
ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, <span class="hljs-string">"translationX"</span>, curTranslationX, <span class="hljs-number">300</span>,curTranslationX);  
<span class="hljs-comment">// 旋转动画</span>
ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, <span class="hljs-string">"rotation"</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">360f</span>);  
<span class="hljs-comment">// 透明度动画</span>
ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, <span class="hljs-string">"alpha"</span>, <span class="hljs-number">1f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>);  

AnimatorSet animSet = <span class="hljs-keyword">new</span> AnimatorSet();  
<span class="hljs-comment">// 设置动画执行顺序</span>
animSet.play(translation).with(rotate).before(alpha);  
animSet.setDuration(<span class="hljs-number">5000</span>);  
animSet.start();</code></pre>
<h3 id="使用ViewPropertyAnimator实现"><a href="#使用ViewPropertyAnimator实现" class="headerlink" title="使用ViewPropertyAnimator实现"></a>使用<code>ViewPropertyAnimator</code>实现</h3><blockquote>
<p>专门针对VIew操作的属性动画，可以直接由view进行调用，相当于一个简单的实现方式。</p>
</blockquote>
<h5 id="应用代码-3"><a href="#应用代码-3" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs java"><span class="hljs-comment">//设置View 透明度以及平移</span>
view.animate().alpha(<span class="hljs-number">0</span>).translationX(<span class="hljs-number">100</span>).setDuration(<span class="hljs-number">500</span>).start();</code></pre>
<h3 id="注意内存泄露"><a href="#注意内存泄露" class="headerlink" title="注意内存泄露"></a>注意内存泄露</h3><blockquote>
<p>在使用属性动画中的无限循环动画(<code>setRepeatCount(ValueAnimator.INFINITE)</code>)时，需要在合适的场合(<code>Activity关闭、View的detach</code>)取消动画</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">super</span>.onDestroy();
    <span class="hljs-keyword">if</span>(animator.isRunning())&#123;
      animator.cancel();
    &#125;
&#125;</code></pre>
<h3 id="对于View可用属性"><a href="#对于View可用属性" class="headerlink" title="对于View可用属性"></a>对于View可用属性</h3><ul>
<li><code>alpha</code>：更改View的不透明度</li>
<li><code>x</code>、<code>y</code>、<code>translationX</code>、<code>translationY</code>：更改View的位置</li>
<li><code>scaleX</code>、<code>scaleY</code>：更改View的缩放</li>
<li><code>rotation</code>、<code>rotationX</code>、<code>rotationY</code>：更改View在3D空间的方向</li>
<li><code>pivotX</code>、<code>pivotY</code>：更改View的转换原点</li>
</ul>
<h2 id="3-理解插值器和估值器"><a href="#3-理解插值器和估值器" class="headerlink" title="3.理解插值器和估值器"></a>3.理解插值器和估值器</h2><h3 id="1-插值器-Interpolator"><a href="#1-插值器-Interpolator" class="headerlink" title="1.插值器(Interpolator)"></a>1.插值器(<code>Interpolator</code>)</h3><blockquote>
<p>根据时间流逝的百分比计算出当前属性值改变的百分比。确定了动画效果变化的模式，如匀速变化、加速变化等。</p>
</blockquote>
<p>系统内部预置了一些常用的插值器：</p>
<ul>
<li><code>LinearInterpolator</code> : 线性插值器 - 匀速运动</li>
<li><code>AccelerateDecelerateInterpolator</code>：加速减速插值器 - 两头慢中间快</li>
<li><code>DecelerateInterpolator</code>：减速插值器 - 越来越慢</li>
</ul>
<p>可以应用的对象：</p>
<ul>
<li>View动画： 上文有提到，对应设置属性为<code>android:interpolator</code></li>
<li>属性动画：实现<em>非匀速运动</em>的方法</li>
</ul>
<p>自定义插值器：</p>
<blockquote>
<p>可以高度定制化自己需要的运行轨迹。</p>
</blockquote>
<p>实现：需要实现<code>Interpolator/TimeInterpolator</code>接口并复写<code>getInterpolation()</code>方法。</p>
<blockquote>
<ol>
<li>补间动画 实现 <code>Interpolator</code>接口；属性动画实现<code>TimeInterpolator</code>接口</li>
<li><code>TimeInterpolator</code>接口是属性动画中新增的，用于兼容<code>Interpolator</code>接口，这使得所有过去的<code>Interpolator</code>实现类都可以直接在属性动画使用。</li>
</ol>
</blockquote>
<p>接口说明：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TimeInterpolator</span> </span>&#123;    
    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">getInterpolation</span><span class="hljs-params">(<span class="hljs-keyword">float</span> input)</span></span>;  
&#125;  

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interpolator</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">TimeInterpolator</span></span>&#123;  
&#125;

input 变化范围为<span class="hljs-number">0</span>~<span class="hljs-number">1</span> 
返回值<span class="hljs-keyword">float</span>型的  用于估值器计算的</code></pre>
<p>实现示例：<em>自定义插值器的关键在于<code>input</code>根据动画的进度(0%~100%)通过逻辑计算，得到当前属性值改变的百分比。</em></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecelerateAccelerateInterpolator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TimeInterpolator</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getInterpolation</span><span class="hljs-params">(<span class="hljs-keyword">float</span> input)</span> </span>&#123;
        <span class="hljs-keyword">float</span> result;
        <span class="hljs-keyword">if</span> (input &lt;= <span class="hljs-number">0.5</span>) &#123;
            result = (<span class="hljs-keyword">float</span>) (Math.sin(Math.PI * input)) / <span class="hljs-number">2</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            result = (<span class="hljs-keyword">float</span>) (<span class="hljs-number">2</span> - Math.sin(Math.PI * input)) / <span class="hljs-number">2</span>;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;</code></pre>
<h3 id="2-估值器-Evaluator"><a href="#2-估值器-Evaluator" class="headerlink" title="2.估值器(Evaluator)"></a>2.估值器(<code>Evaluator</code>)</h3><blockquote>
<p>根据当前属性改变的百分比来计算改变后的属性值</p>
</blockquote>
<p>系统提供了一些估值器：</p>
<ul>
<li><code>IntEvaluator</code>：整形估值器</li>
<li><code>FloatEvaluator</code>：浮点型估值器</li>
<li><code>ArgbEvaluator</code>：Color属性估值器</li>
</ul>
<p>可以应用的对象：</p>
<p><strong>属性动画专属</strong></p>
<p>使用方法：</p>
<pre><code class="hljs java">ValueAnimator anim = ValueAnimator.ofInt(<span class="hljs-keyword">int</span>... values);  <span class="hljs-comment">//使用的是 IntEvaluator</span>
ValueAnimator anim = ValueAnimator.ofFloat(<span class="hljs-keyword">float</span>... values); <span class="hljs-comment">//使用的是 FloatEvaluator</span>
ValueAnimator anim = ValueAnimator.ofArgb(<span class="hljs-keyword">int</span>... values);<span class="hljs-comment">// 使用的是 ArgbEvaluator</span>
<span class="hljs-comment">//需要自定义 估值器</span>
ValueAnimator anim = ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values);</code></pre>
<p>自定义估值器：</p>
<blockquote>
<p>除了<code>int,float,color</code>类型之外的类型做动画，需要用到自定义估值器</p>
</blockquote>
<p>接口说明：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TypeEvaluator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-comment">/**
    * <span class="hljs-doctag">@param</span> fraction   估值小数 插值器的返回值
    * <span class="hljs-doctag">@param</span> startValue 起始值
    * <span class="hljs-doctag">@param</span> endValue   结束值
    */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction, T startValue, T endValue)</span></span>;
&#125;</code></pre>
<p>实现实例：</p>
<p>先定义自定义对象</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;
    <span class="hljs-comment">// 设置两个变量用于记录坐标的位置</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> x;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> y;

    <span class="hljs-comment">// 构造方法用于设置坐标</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.x = x;
        <span class="hljs-keyword">this</span>.y = y;
    &#125;

    <span class="hljs-comment">// get方法用于获取坐标</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> x;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> y;
    &#125;
&#125;</code></pre>
<p>定义估值器</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointEvaluator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TypeEvaluator</span>&lt;<span class="hljs-title">Point</span>&gt; </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Point <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction, Point startValue, Point endValue)</span> </span>&#123;
        <span class="hljs-keyword">float</span> x = startValue.getX() + fraction * (endValue.getX() - startValue.getX());
        <span class="hljs-keyword">float</span> y = startValue.getY() + fraction * (endValue.getY() - startValue.getY());
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Point(x, y);
    &#125;
&#125;</code></pre>
<p>使用估值器</p>
<pre><code class="hljs java">Point startPoint = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<span class="hljs-comment">// 初始点为圆心(100, 100)</span>
Point endPoint = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<span class="hljs-comment">// 结束点为(300, 300)</span>
ValueAnimator anim = ValueAnimator.ofObject(<span class="hljs-keyword">new</span> PointEvaluator(), startPoint, endPoint);
anim.setDuration(<span class="hljs-number">5000</span>);
anim.start();</code></pre>
<h2 id="4-属性动画监听器"><a href="#4-属性动画监听器" class="headerlink" title="4.属性动画监听器"></a>4.属性动画监听器</h2><blockquote>
<p>可以监听属性动画的播放过程，包括<code>起始，结束，取消，重复</code>。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnimatorListener</span> </span>&#123;
  <span class="hljs-comment">//动画开始</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(Animation animation)</span></span>;
  <span class="hljs-comment">//动画结束</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationEnd</span><span class="hljs-params">(Animation animation)</span></span>;
  <span class="hljs-comment">//动画取消</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationCancel</span><span class="hljs-params">(Animation animation)</span></span>;
  <span class="hljs-comment">//动画重复</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationRepeat</span><span class="hljs-params">(Animation animation)</span></span>;
&#125;

调用方式
animator.addListener(<span class="hljs-keyword">new</span> AnimatorListener()&#123;
 ...
&#125;)；</code></pre>
<p>拓展：</p>
<h4 id="AnimatorListenerAdapter：AnimatorListener的适配器类，主要为了解决实现接口繁琐的问题。在大多数情况下，我们可能只要监听动画的开始和结束事件。如果直接继承AnimatorListener接口，就需要实现额外的方法。"><a href="#AnimatorListenerAdapter：AnimatorListener的适配器类，主要为了解决实现接口繁琐的问题。在大多数情况下，我们可能只要监听动画的开始和结束事件。如果直接继承AnimatorListener接口，就需要实现额外的方法。" class="headerlink" title="AnimatorListenerAdapter：AnimatorListener的适配器类，主要为了解决实现接口繁琐的问题。在大多数情况下，我们可能只要监听动画的开始和结束事件。如果直接继承AnimatorListener接口，就需要实现额外的方法。"></a><code>AnimatorListenerAdapter</code>：<code>AnimatorListener</code>的适配器类，主要为了解决<strong>实现接口繁琐</strong>的问题。在大多数情况下，我们可能只要监听动画的开始和结束事件。如果直接继承<code>AnimatorListener</code>接口，就需要实现额外的方法。</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimatorListenerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animator</span>.<span class="hljs-title">AnimatorListener</span>,
        <span class="hljs-title">Animator</span>.<span class="hljs-title">AnimatorPauseListener</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationCancel</span><span class="hljs-params">(Animator animation)</span> </span>&#123;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationEnd</span><span class="hljs-params">(Animator animation)</span> </span>&#123;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationRepeat</span><span class="hljs-params">(Animator animation)</span> </span>&#123;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(Animator animation)</span> </span>&#123;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationPause</span><span class="hljs-params">(Animator animation)</span> </span>&#123;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationResume</span><span class="hljs-params">(Animator animation)</span> </span>&#123;
    &#125;
&#125;

使用方式
animator.addListener(<span class="hljs-keyword">new</span> AnimatorListenerAdapter()&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(Animator animation)</span> </span>&#123;
      <span class="hljs-comment">//只实现开始监听</span>
    &#125;
&#125;)</code></pre>
<h4 id="AnimatorUpdateListener：监听整个动画过程，每播放一帧，就会回调一次。"><a href="#AnimatorUpdateListener：监听整个动画过程，每播放一帧，就会回调一次。" class="headerlink" title="AnimatorUpdateListener：监听整个动画过程，每播放一帧，就会回调一次。"></a><code>AnimatorUpdateListener</code>：监听整个动画过程，每播放一帧，就会回调一次。</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnimatorUpdateListener</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span>；
&#125;</span></code></pre>
<p>利用这个特性，我们可以去对得到的数据进行处理。</p>
<p>上文中，自定义估值器，我们设置了一个<code>Point</code>对象，它的动画过程就是<code>Point</code>对象内部<code>x,y</code>变化的过程，我们就可以利用这个接口实时的去获取内部<code>x,y</code>进行操作。利用<code>ValueAnimator.getAnimatedValue()</code>就可以获取到对应的对象。</p>
<h2 id="5-对任意属性做动画"><a href="#5-对任意属性做动画" class="headerlink" title="5.对任意属性做动画"></a>5.对任意属性做动画</h2><p>上文中我们提到<code>android:propertyName</code>里面填的就是 属性动画可以支持的属性，假如我们要对View的宽度做动画，应该如何实现？</p>
<p><strong>属性动画的原理：属性动画要求动画作用的对象必须提供该属性的<code>get()和set()</code>方法，属性动画根据外界传递的该属性的初始值和结束值，以动画的效果多次去调用<code>set()</code>，每次传入的值不一样，随着时间推移，会越来越接近结束值。</strong></p>
<p>根据上述原理，我们可以得出一个结果。要想动画生效，必须支持两个条件：</p>
<ul>
<li><code>Object</code>必须提供<code>set()</code>，如果动画没有传递初始值，那么还要提供<code>get()</code>，因为系统要去获取初始值，计算最终值。（<em>不满足则直接Crash</em>）</li>
<li><code>Object</code>设置的<code>set()</code>必须可以让View产生变化，比如UI上会发生变化。(<em>不满足则不会发生变化</em>)</li>
</ul>
<p>针对上述条件，可以有3种解决方法：</p>
<ol>
<li><h4 id="给你的对象加上get-set-，如果你有权限的话"><a href="#给你的对象加上get-set-，如果你有权限的话" class="headerlink" title="给你的对象加上get(),set()，如果你有权限的话"></a>给你的对象加上<code>get(),set()</code>，如果你有权限的话</h4><blockquote>
<p>继承原始类，直接给继承类加上<code>get(),set()</code>，从而实现给对象加上该属性的<code>get(),set()</code></p>
</blockquote>
</li>
<li><h4 id="用一个类来包装原始对象，间接提供get-set"><a href="#用一个类来包装原始对象，间接提供get-set" class="headerlink" title="用一个类来包装原始对象，间接提供get(),set()"></a>用一个类来包装原始对象，间接提供<code>get(),set()</code></h4><blockquote>
<p>本质上是采用了设计模式中的装饰模式，即通过包装拓展对象的功能。</p>
</blockquote>
<p>示例：一开始就提到了对View的宽度进行动画效果，用这种方案就是找一个类来进行包装。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;
  ImageView imageView;
  ViewWrapper wrapper;
  
  <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        imageView = (ImageView) findViewById(R.id.imageView);        
        <span class="hljs-comment">// 创建包装类,并传入动画作用的对象</span>
        wrapper = <span class="hljs-keyword">new</span> ViewWrapper(imageView);        
        imageView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;
                ObjectAnimator.ofInt(wrapper, <span class="hljs-string">"width"</span><span class="hljs-comment">/*对应我们设置的getWidth()和setWidth()*/</span>, <span class="hljs-number">500</span>).setDuration(<span class="hljs-number">3000</span>).start();
            &#125;
        &#125;);
    &#125;
  
    <span class="hljs-comment">// 提供ViewWrapper类,用于包装View对象</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewWrapper</span> </span>&#123;
        <span class="hljs-keyword">private</span> View mTarget;

        <span class="hljs-comment">// 构造方法:传入需要包装的对象</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewWrapper</span><span class="hljs-params">(View target)</span> </span>&#123;
            mTarget = target;
        &#125;

        <span class="hljs-comment">// 为宽度设置get（） &amp; set（）</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> mTarget.getLayoutParams().width;
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width)</span> </span>&#123;
            mTarget.getLayoutParams().width = width;
            <span class="hljs-comment">//对View重新布局</span>
            mTarget.requestLayout();
        &#125;
    &#125;
&#125;</code></pre>
</li>
<li><h4 id="采用ValueAnimator，监听动画过程，利用返回值动态调整View属性"><a href="#采用ValueAnimator，监听动画过程，利用返回值动态调整View属性" class="headerlink" title="采用ValueAnimator，监听动画过程，利用返回值动态调整View属性"></a>采用<code>ValueAnimator</code>，监听动画过程，利用返回值动态调整View属性</h4><blockquote>
<p><code>ValueAnimator</code>本身不作用于任何对象，直接使用它不会有任何效果。做到的就是对一个View的属性进行变化。在动画过程中修改属性值，就类似于对对象做了动画。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span></span>&#123;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>&#123;
    setContentView(R.layout.main);
    view.post(<span class="hljs-keyword">new</span> Runnable()&#123;
      <span class="hljs-meta">@Override</span>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;
        performAnimator(view,view.getWidth,<span class="hljs-number">500</span>);
      &#125;
    &#125;)
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performAnimatior</span><span class="hljs-params">(<span class="hljs-keyword">final</span> View target,<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start,<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end)</span></span>&#123;
    ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);
    valueAnimator.addUpdateListener(<span class="hljs-keyword">new</span> AnimatorUpdateListener()&#123;
       <span class="hljs-keyword">private</span> IntEvaluator mEvaluator = <span class="hljs-keyword">new</span> IntEvaluator();
       <span class="hljs-meta">@Override</span>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animator)</span></span>&#123;
        <span class="hljs-keyword">int</span> currentValue = (Integer)animator.getAnimatedValue();
        <span class="hljs-keyword">float</span> fraction = animator.getAnimatedFraction();
        target.getLayoutParams().width = mEvaluator.evaluate(fraction,start,end);
        target.requestLayout();
      &#125;
    &#125;);
    valueAnimator.setDuration(<span class="hljs-number">5000</span>).start();
  &#125;
&#125;</code></pre>
</li>
</ol>
<h2 id="6-属性动画工作原理"><a href="#6-属性动画工作原理" class="headerlink" title="6.属性动画工作原理"></a>6.属性动画工作原理</h2><blockquote>
<p>属性动画要求动画作用的对象必须提供该属性的<code>set()</code>方法，属性动画就会根据你传递的该属性的初始值和最终值，以动画的效果多次去调用<code>set()</code>。每次传递给<code>set()</code>的值都不一样，确切的来说是随着时间的推移，传递的值越来越接近最终值。如果动画不提供初始值，那就需要定义<code>get()</code>，以供系统去获取初始值。</p>
</blockquote>
<p>接下来就从入口处开始分析。</p>
<p><code>ObjectAnimator.ofFloat(view,&quot;alpha&quot;,0f,1f).start()</code>意味着动画开始。</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/animation/ObjectAnimator.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-comment">//如果动画已经执行，则停止动画</span>
  AnimationHandler.getInstace().autoCancelBasedOn(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">super</span>.start()
&#125;</code></pre>
<p><code>super.start()</code>就调用到父类<code>ValueAnimator.start()</code></p>
<h3 id="ValueAnimator-start"><a href="#ValueAnimator-start" class="headerlink" title="ValueAnimator.start()"></a>ValueAnimator.start()</h3><blockquote>
<p>属性动画执行</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/animation/ValueAnimator.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;
  start(<span class="hljs-keyword">false</span>);
&#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> playBackwards)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (Looper.myLooper() == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AndroidRuntimeException(<span class="hljs-string">"Animators may only be run on Looper threads"</span>);
        &#125;
        mReversing = playBackwards;
        mSelfPulse = !mSuppressSelfPulseRequested;
        <span class="hljs-comment">// Special case: reversing from seek-to-0 should act as if not seeked at all.</span>
        <span class="hljs-keyword">if</span> (playBackwards &amp;&amp; mSeekFraction != -<span class="hljs-number">1</span> &amp;&amp; mSeekFraction != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> (mRepeatCount == INFINITE) &#123;
                <span class="hljs-comment">// Calculate the fraction of the current iteration.</span>
                <span class="hljs-keyword">float</span> fraction = (<span class="hljs-keyword">float</span>) (mSeekFraction - Math.floor(mSeekFraction));
                mSeekFraction = <span class="hljs-number">1</span> - fraction;
            &#125; <span class="hljs-keyword">else</span> &#123;
                mSeekFraction = <span class="hljs-number">1</span> + mRepeatCount - mSeekFraction;
            &#125;
        &#125;
        mStarted = <span class="hljs-keyword">true</span>;
        mPaused = <span class="hljs-keyword">false</span>;
        mRunning = <span class="hljs-keyword">false</span>;
        mAnimationEndRequested = <span class="hljs-keyword">false</span>;
        mLastFrameTime = -<span class="hljs-number">1</span>;
        mFirstFrameTime = -<span class="hljs-number">1</span>;
        mStartTime = -<span class="hljs-number">1</span>;
        addAnimationCallback(<span class="hljs-number">0</span>);

        <span class="hljs-keyword">if</span> (mStartDelay == <span class="hljs-number">0</span> || mSeekFraction &gt;= <span class="hljs-number">0</span> || mReversing) &#123;
            startAnimation();<span class="hljs-comment">//开始动画并回调`onAnimationStart`</span>
            <span class="hljs-keyword">if</span> (mSeekFraction == -<span class="hljs-number">1</span>) &#123;
                setCurrentPlayTime(<span class="hljs-number">0</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                setCurrentFraction(mSeekFraction);
            &#125;
        &#125;
    &#125;</code></pre>
<h4 id="startAnimation"><a href="#startAnimation" class="headerlink" title="startAnimation()"></a>startAnimation()</h4><blockquote>
<p>初始化一些变量以及回调<code>onAnimationStart()</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startAnimation</span><span class="hljs-params">()</span> </span>&#123;
    ...
    mAnimationEndRequested = <span class="hljs-keyword">false</span>;
    initAnimation();
    mRunning = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span> (mSeekFraction &gt;= <span class="hljs-number">0</span>) &#123;
        mOverallFraction = mSeekFraction;
    &#125; <span class="hljs-keyword">else</span> &#123;
        mOverallFraction = <span class="hljs-number">0f</span>;
    &#125;
    <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-keyword">null</span>) &#123;
        notifyStartListeners();
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyStartListeners</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-keyword">null</span> &amp;&amp; !mStartListenersCalled) &#123;
        ArrayList&lt;AnimatorListener&gt; tmpListeners =
                (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();
        <span class="hljs-keyword">int</span> numListeners = tmpListeners.size();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;
            tmpListeners.get(i).onAnimationStart(<span class="hljs-keyword">this</span>, mReversing);<span class="hljs-comment">//回调onAnimationStart</span>
        &#125;
    &#125;
    mStartListenersCalled = <span class="hljs-keyword">true</span>;
&#125;</code></pre>
<h3 id="addAnimationCallback-0"><a href="#addAnimationCallback-0" class="headerlink" title="addAnimationCallback(0)"></a>addAnimationCallback(0)</h3><blockquote>
<p>真正执行动画的部分代码</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAnimationCallback</span><span class="hljs-params">(<span class="hljs-keyword">long</span> delay)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!mSelfPulse) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    getAnimationHandler().addAnimationFrameCallback(<span class="hljs-keyword">this</span>, delay);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> AnimationHandler <span class="hljs-title">getAnimationHandler</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> AnimationHandler.getInstance();
&#125;</code></pre>
<h4 id="addAnimationFrameCallback"><a href="#addAnimationFrameCallback" class="headerlink" title="addAnimationFrameCallback()"></a>addAnimationFrameCallback()</h4><pre><code class="hljs java"><span class="hljs-comment">//AnimationHandler.java</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="hljs-keyword">new</span> Choreographer.FrameCallback() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTimeNanos)</span> </span>&#123;
            doAnimationFrame(getProvider().getFrameTime());
            <span class="hljs-keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//回调为0时候</span>
                getProvider().postFrameCallback(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//注册下一次的刷新事件监听</span>
            &#125;
        &#125;
    &#125;;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAnimationFrameCallback</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AnimationFrameCallback callback, <span class="hljs-keyword">long</span> delay)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mAnimationCallbacks.size() == <span class="hljs-number">0</span>) &#123;
            getProvider().postFrameCallback(mFrameCallback);
        &#125;
        <span class="hljs-keyword">if</span> (!mAnimationCallbacks.contains(callback)) &#123;
            mAnimationCallbacks.add(callback);
        &#125;

        <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span>) &#123;
            mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> AnimationFrameCallbackProvider <span class="hljs-title">getProvider</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mProvider == <span class="hljs-keyword">null</span>) &#123;
            mProvider = <span class="hljs-keyword">new</span> MyFrameCallbackProvider();
        &#125;
        <span class="hljs-keyword">return</span> mProvider;
    &#125;</code></pre>
<p>注册<code>mFrameCallback</code>到<code>Choreographer</code>的待执行队列里，并向底层注册一个屏幕刷新信号事件<code>onVsync()</code></p>
<p>此时的<code>mAnimationCallbacks</code>持有的是<code>ValueAnimator</code>集合</p>
<h4 id="postFrameCallback"><a href="#postFrameCallback" class="headerlink" title="postFrameCallback()"></a>postFrameCallback()</h4><blockquote>
<p>注册监听</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//AnimationHandler.java</span>
    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFrameCallbackProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AnimationFrameCallbackProvider</span> </span>&#123;

        <span class="hljs-keyword">final</span> Choreographer mChoreographer = Choreographer.getInstance();

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postFrameCallback</span><span class="hljs-params">(Choreographer.FrameCallback callback)</span> </span>&#123;
            mChoreographer.postFrameCallback(callback);
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCommitCallback</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;
            mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, <span class="hljs-keyword">null</span>);
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getFrameTime</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> mChoreographer.getFrameTime();
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getFrameDelay</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> Choreographer.getFrameDelay();
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFrameDelay</span><span class="hljs-params">(<span class="hljs-keyword">long</span> delay)</span> </span>&#123;
            Choreographer.setFrameDelay(delay);
        &#125;
    &#125;</code></pre>
<p><code>AnimationHandler</code>通过<code>Choreographer</code>向底层注册监听下一个<code>屏幕刷新信号</code>，接收到信号时<code>mFrameCallback</code>执行，调用<code>doAnimationFrame()</code>。如果还有动画未执行完毕，继续注册监听下一个<code>屏幕刷新信号</code>。</p>
<h3 id="Choreographer-postFrameCallback"><a href="#Choreographer-postFrameCallback" class="headerlink" title="Choreographer.postFrameCallback()"></a>Choreographer.postFrameCallback()</h3><blockquote>
<p>动画的核心类</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//Choreographer.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postFrameCallback</span><span class="hljs-params">(FrameCallback callback)</span> </span>&#123;
        postFrameCallbackDelayed(callback, <span class="hljs-number">0</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postFrameCallbackDelayed</span><span class="hljs-params">(FrameCallback callback, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (callback == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"callback must not be null"</span>);
        &#125;

        postCallbackDelayedInternal(CALLBACK_ANIMATION,
                callback, FRAME_CALLBACK_TOKEN, delayMillis);
    &#125;</code></pre>
<p>其中<code>postCallbackDelayedInternal()</code>内部相关的代码可以参考<a href="/2020/05/30/View的刷新机制/" title="Android屏幕的刷新机制">Android屏幕的刷新机制</a></p>
<h3 id="AnimationHandler-doAnimationFrame"><a href="#AnimationHandler-doAnimationFrame" class="headerlink" title="AnimationHandler.doAnimationFrame()"></a>AnimationHandler.doAnimationFrame()</h3><blockquote>
<p>每次在<code>Vsync</code>信号来临时会执行到<code>doFrame()</code>对应执行到<code>doAnimationFrame()</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAnimationFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTime)</span> </span>&#123;
    <span class="hljs-keyword">long</span> currentTime = SystemClock.uptimeMillis();
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = mAnimationCallbacks.size();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;
        <span class="hljs-keyword">final</span> AnimationFrameCallback callback = mAnimationCallbacks.get(i);
        <span class="hljs-keyword">if</span> (callback == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">continue</span>;
        &#125;
        <span class="hljs-keyword">if</span> (isCallbackDue(callback, currentTime)) &#123;
            callback.doAnimationFrame(frameTime);
            <span class="hljs-keyword">if</span> (mCommitCallbacks.contains(callback)) &#123;
                getProvider().postCommitCallback(<span class="hljs-keyword">new</span> Runnable() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                        commitAnimationFrame(callback, getProvider().getFrameTime());
                    &#125;
                &#125;);
            &#125;
        &#125;
    &#125;
    cleanUpList();
&#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCommitCallback</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;
        mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, <span class="hljs-keyword">null</span>);
    &#125;</code></pre>
<h4 id="cleanUpList"><a href="#cleanUpList" class="headerlink" title="cleanUpList()"></a>cleanUpList()</h4><blockquote>
<p>清理已经执行完毕的动画</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanUpList</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (mListDirty) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mAnimationCallbacks.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
            <span class="hljs-keyword">if</span> (mAnimationCallbacks.get(i) == <span class="hljs-keyword">null</span>) &#123;
                mAnimationCallbacks.remove(i);
            &#125;
        &#125;
        mListDirty = <span class="hljs-keyword">false</span>;
    &#125;
&#125;</code></pre>
<h4 id="ValueAnimator-commitAnimationFrame"><a href="#ValueAnimator-commitAnimationFrame" class="headerlink" title="ValueAnimator.commitAnimationFrame()"></a>ValueAnimator.commitAnimationFrame()</h4><blockquote>
<p><code>callback</code>有效时，执行对应callback的<code>commitAnimationFrame()</code>，此时<code>callback</code>为<code>ValueAnimator</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitAnimationFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTime)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!mStartTimeCommitted) &#123;
        mStartTimeCommitted = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">long</span> adjustment = frameTime - mLastFrameTime;
        <span class="hljs-keyword">if</span> (adjustment &gt; <span class="hljs-number">0</span>) &#123;
            mStartTime += adjustment;
            <span class="hljs-keyword">if</span> (DEBUG) &#123;
                Log.d(TAG, <span class="hljs-string">"Adjusted start time by "</span> + adjustment + <span class="hljs-string">" ms: "</span> + toString());
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p><strong>为了修正动画的第一帧时间</strong></p>
<p><code>Choreographer</code>内部持有多个队列，分别是<code>CALLBACK_INPUT(输入事件)</code>、<code>CALLBACK_ANIMATION(动画事件)</code>、<code>CALLBACK_TRAVERSAL(绘制事件)</code>，<code>CALLBACK_COMMIT(完成后的提交操作)</code>。此时<code>commitAnimationFrame()</code>执行在<code>CALLBACK_COMMIT</code>队列中，位于最后。</p>
<p>当有事件来后，先执行的是<code>动画事件</code>，如果页面太复杂，导致绘制时间过长，就可能导致下一个<code>Vsync</code>信号到来时，动画执行时会丢失前面几帧，利用<code>commitAnimationFrame</code>就可以及时修正第一帧的时间，使动画完整执行。</p>
<h3 id="ValueAnimator-doAnimationFrame"><a href="#ValueAnimator-doAnimationFrame" class="headerlink" title="ValueAnimator.doAnimationFrame()"></a>ValueAnimator.doAnimationFrame()</h3><blockquote>
<p><code>callback</code>有效时，执行对应callback的<code>doAnimationFrame()</code>，此时<code>callback</code>为<code>ValueAnimator</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//ValueAnimator.java </span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doAnimationFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTime)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mStartTime &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// First frame. If there is start delay, start delay count down will happen *after* this</span>
            <span class="hljs-comment">// frame.</span>
            mStartTime = mReversing <span class="hljs-comment">//动画是否反复</span>
                    ? frameTime
                    : frameTime + (<span class="hljs-keyword">long</span>) (mStartDelay * resolveDurationScale());
        &#125;

        <span class="hljs-comment">// Handle pause/resume</span>
        <span class="hljs-keyword">if</span> (mPaused) &#123;
            mPauseTime = frameTime;
            removeAnimationCallback();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mResumed) &#123;
            mResumed = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">if</span> (mPauseTime &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// Offset by the duration that the animation was paused</span>
                mStartTime += (frameTime - mPauseTime);
            &#125;
        &#125;

        <span class="hljs-comment">//动画尚未执行时</span>
        <span class="hljs-keyword">if</span> (!mRunning) &#123;
            <span class="hljs-comment">// If not running, that means the animation is in the start delay phase of a forward</span>
            <span class="hljs-comment">// running animation. In the case of reversing, we want to run start delay in the end.</span>
            <span class="hljs-keyword">if</span> (mStartTime &gt; frameTime &amp;&amp; mSeekFraction == -<span class="hljs-number">1</span>) &#123;
                <span class="hljs-comment">// This is when no seek fraction is set during start delay. If developers change the</span>
                <span class="hljs-comment">// seek fraction during the delay, animation will start from the seeked position</span>
                <span class="hljs-comment">// right away.</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// If mRunning is not set by now, that means non-zero start delay,</span>
                <span class="hljs-comment">// no seeking, not reversing. At this point, start delay has passed.</span>
                mRunning = <span class="hljs-keyword">true</span>;
                startAnimation();<span class="hljs-comment">//开始动画</span>
            &#125;
        &#125;

        <span class="hljs-keyword">if</span> (mLastFrameTime &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> (mSeekFraction &gt;= <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">long</span> seekTime = (<span class="hljs-keyword">long</span>) (getScaledDuration() * mSeekFraction);
                mStartTime = frameTime - seekTime;
                mSeekFraction = -<span class="hljs-number">1</span>;
            &#125;
            mStartTimeCommitted = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// allow start time to be compensated for jank</span>
        &#125;
        mLastFrameTime = frameTime;
        <span class="hljs-comment">// The frame time might be before the start time during the first frame of</span>
        <span class="hljs-comment">// an animation.  The "current time" must always be on or after the start</span>
        <span class="hljs-comment">// time to avoid animating frames at negative time intervals.  In practice, this</span>
        <span class="hljs-comment">// is very rare and only happens when seeking backwards.</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> currentTime = Math.max(frameTime, mStartTime);<span class="hljs-comment">//判断当前动画执行的时间</span>
        <span class="hljs-keyword">boolean</span> finished = animateBasedOnTime(currentTime);<span class="hljs-comment">//动画是否执行完毕</span>

        <span class="hljs-keyword">if</span> (finished) &#123;
            endAnimation();
        &#125;
        <span class="hljs-keyword">return</span> finished;
    &#125;</code></pre>
<h4 id="endAnimation"><a href="#endAnimation" class="headerlink" title="endAnimation()"></a>endAnimation()</h4><blockquote>
<p>动画执行完毕后的清理工作，并且回调<code>onAnimationEnd</code>监听</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endAnimation</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mAnimationEndRequested) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        removeAnimationCallback();

        mAnimationEndRequested = <span class="hljs-keyword">true</span>;
        mPaused = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">boolean</span> notify = (mStarted || mRunning) &amp;&amp; mListeners != <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">if</span> (notify &amp;&amp; !mRunning) &#123;
            <span class="hljs-comment">// If it's not yet running, then start listeners weren't called. Call them now.</span>
            notifyStartListeners();
        &#125;
        mRunning = <span class="hljs-keyword">false</span>;
        mStarted = <span class="hljs-keyword">false</span>;
        mStartListenersCalled = <span class="hljs-keyword">false</span>;
        mLastFrameTime = -<span class="hljs-number">1</span>;
        mFirstFrameTime = -<span class="hljs-number">1</span>;
        mStartTime = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (notify &amp;&amp; mListeners != <span class="hljs-keyword">null</span>) &#123;
            ArrayList&lt;AnimatorListener&gt; tmpListeners =
                    (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();
            <span class="hljs-keyword">int</span> numListeners = tmpListeners.size();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;
                tmpListeners.get(i).onAnimationEnd(<span class="hljs-keyword">this</span>, mReversing);<span class="hljs-comment">//回调 onAnimationEnd</span>
            &#125;
        &#125;
        <span class="hljs-comment">// mReversing needs to be reset *after* notifying the listeners for the end callbacks.</span>
        mReversing = <span class="hljs-keyword">false</span>;
    &#125;

<span class="hljs-comment">//AnimationHelper.java</span>
<span class="hljs-comment">//移除动画执行监听</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeCallback</span><span class="hljs-params">(AnimationFrameCallback callback)</span> </span>&#123;
        mCommitCallbacks.remove(callback);
        mDelayedCallbackStartTime.remove(callback);
        <span class="hljs-keyword">int</span> id = mAnimationCallbacks.indexOf(callback);
        <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span>) &#123;
            mAnimationCallbacks.set(id, <span class="hljs-keyword">null</span>);
            mListDirty = <span class="hljs-keyword">true</span>;
        &#125;
    &#125;</code></pre>
<h4 id="ValueAnimator-animateBasedOnTime"><a href="#ValueAnimator-animateBasedOnTime" class="headerlink" title="ValueAnimator.animateBasedOnTime()"></a>ValueAnimator.animateBasedOnTime()</h4><blockquote>
<p>根据当前时间计算并实现当前帧的动画</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">animateBasedOnTime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> currentTime)</span> </span>&#123;
    <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (mRunning) &#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> scaledDuration = getScaledDuration();
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> fraction = scaledDuration &gt; <span class="hljs-number">0</span> ?
                (<span class="hljs-keyword">float</span>)(currentTime - mStartTime) / scaledDuration : <span class="hljs-number">1f</span>; 
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> lastFraction = mOverallFraction;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> newIteration = (<span class="hljs-keyword">int</span>) fraction &gt; (<span class="hljs-keyword">int</span>) lastFraction;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> lastIterationFinished = (fraction &gt;= mRepeatCount + <span class="hljs-number">1</span>) &amp;&amp;
                (mRepeatCount != INFINITE);
        <span class="hljs-keyword">if</span> (scaledDuration == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 0 duration animator, ignore the repeat count and skip to the end</span>
            done = <span class="hljs-keyword">true</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newIteration &amp;&amp; !lastIterationFinished) &#123;
            <span class="hljs-comment">// Time to repeat</span>
            <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-keyword">int</span> numListeners = mListeners.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;
                    mListeners.get(i).onAnimationRepeat(<span class="hljs-keyword">this</span>);
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastIterationFinished) &#123;
            done = <span class="hljs-keyword">true</span>;
        &#125;
        mOverallFraction = clampFraction(fraction);
        <span class="hljs-keyword">float</span> currentIterationFraction = getCurrentIterationFraction(
                mOverallFraction, mReversing);
        animateValue(currentIterationFraction);
    &#125;
    <span class="hljs-keyword">return</span> done;
&#125;</code></pre>
<h5 id="clampFraction"><a href="#clampFraction" class="headerlink" title="clampFraction()"></a>clampFraction()</h5><blockquote>
<p>根据当前时间以及动画第一帧时间还有动画持续的时长来计算当前的动画进度。</p>
<p>确保动画进度的取值在<code>0-1</code>之间。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> <span class="hljs-title">clampFraction</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (fraction &lt; <span class="hljs-number">0</span>) &#123;
        fraction = <span class="hljs-number">0</span>;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mRepeatCount != INFINITE) &#123;
        fraction = Math.min(fraction, mRepeatCount + <span class="hljs-number">1</span>);<span class="hljs-comment">//得到重复执行后的累加进度</span>
    &#125;
    <span class="hljs-keyword">return</span> fraction;
&#125;

<span class="hljs-comment">//保证返回值位于 0-1之间</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getCurrentIterationFraction</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction, <span class="hljs-keyword">boolean</span> inReverse)</span> </span>&#123;
    fraction = clampFraction(fraction);
    <span class="hljs-keyword">int</span> iteration = getCurrentIteration(fraction);
    <span class="hljs-keyword">float</span> currentFraction = fraction - iteration;
    <span class="hljs-keyword">return</span> shouldPlayBackward(iteration, inReverse) ? <span class="hljs-number">1f</span> - currentFraction : currentFraction;
&#125;</code></pre>
<h3 id="ValueAnimator-animateValue"><a href="#ValueAnimator-animateValue" class="headerlink" title="ValueAnimator.animateValue()"></a>ValueAnimator.animateValue()</h3><blockquote>
<p>前面计算得到当前动画进度后，需要应用该值到View上</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">animateValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;
    fraction = mInterpolator.getInterpolation(fraction);
    mCurrentFraction = fraction;
    <span class="hljs-keyword">int</span> numValues = mValues.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numValues; ++i) &#123;
        mValues[i].calculateValue(fraction);
    &#125;
    <span class="hljs-keyword">if</span> (mUpdateListeners != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">int</span> numListeners = mUpdateListeners.size();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;
            mUpdateListeners.get(i).onAnimationUpdate(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//通知动画的监听回调</span>
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="getInterpolation"><a href="#getInterpolation" class="headerlink" title="getInterpolation()"></a>getInterpolation()</h4><blockquote>
<p>根据设置的插值器获取应当达到的进度</p>
</blockquote>
<h3 id="PropertyValuesHolder-calculateValue"><a href="#PropertyValuesHolder-calculateValue" class="headerlink" title="PropertyValuesHolder.calculateValue()"></a>PropertyValuesHolder.calculateValue()</h3><blockquote>
<p>根据进度计算最终需要用到的数值</p>
</blockquote>
<pre><code class="hljs java">Keyframes mKeyframes = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//关键帧   </span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculateValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;
    Object value = mKeyframes.getValue(fraction);
    mAnimatedValue = mConverter == <span class="hljs-keyword">null</span> ? value : mConverter.convert(value);
&#125;</code></pre>
<p>在执行<code>ObjectAnimator.start()</code>之前，需要先执行<code>ObjectAnimator.ofFloat(float... values)</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//ValueAnimator.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFloatValues</span><span class="hljs-params">(<span class="hljs-keyword">float</span>... values)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (values == <span class="hljs-keyword">null</span> || values.length == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span> (mValues == <span class="hljs-keyword">null</span> || mValues.length == <span class="hljs-number">0</span>) &#123;
            setValues(PropertyValuesHolder.ofFloat(<span class="hljs-string">""</span>, values));
        &#125; <span class="hljs-keyword">else</span> &#123;
            PropertyValuesHolder valuesHolder = mValues[<span class="hljs-number">0</span>];
            valuesHolder.setFloatValues(values);
        &#125;
        <span class="hljs-comment">// New property/values/target should cause re-initialization prior to starting</span>
        mInitialized = <span class="hljs-keyword">false</span>;
    &#125;

<span class="hljs-comment">//PropertyValuesHolder.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFloatValues</span><span class="hljs-params">(<span class="hljs-keyword">float</span>... values)</span> </span>&#123;
        mValueType = <span class="hljs-keyword">float</span>.class;
        mKeyframes = KeyframeSet.ofFloat(values);
    &#125;</code></pre>
<p>所以<code>mKeyFrames.getValue(XX)</code>中的<code>mKeyFrames</code>为<code>KeyframeSet.ofFloat()</code></p>
<h4 id="KeyframeSet-ofFloat"><a href="#KeyframeSet-ofFloat" class="headerlink" title="KeyframeSet.ofFloat()"></a>KeyframeSet.ofFloat()</h4><blockquote>
<p><code>KeyframeSet</code>关键帧集合，根据传入的节点，生成<code>FloatkeyframeSet</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//KeyframeSet.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> KeyframeSet <span class="hljs-title">ofFloat</span><span class="hljs-params">(<span class="hljs-keyword">float</span>... values)</span> </span>&#123;
        <span class="hljs-keyword">boolean</span> badValue = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">int</span> numKeyframes = values.length;
        FloatKeyframe keyframes[] = <span class="hljs-keyword">new</span> FloatKeyframe[Math.max(numKeyframes,<span class="hljs-number">2</span>)];<span class="hljs-comment">//关键帧集合</span>
        <span class="hljs-keyword">if</span> (numKeyframes == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//只有一个关键帧，生成两个一致的帧</span>
            keyframes[<span class="hljs-number">0</span>] = (FloatKeyframe) Keyframe.ofFloat(<span class="hljs-number">0f</span>);
            keyframes[<span class="hljs-number">1</span>] = (FloatKeyframe) Keyframe.ofFloat(<span class="hljs-number">1f</span>, values[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">if</span> (Float.isNaN(values[<span class="hljs-number">0</span>])) &#123;
                badValue = <span class="hljs-keyword">true</span>;
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//超过一个关键帧，按照传入数量，生成对应数量的帧集合</span>
            keyframes[<span class="hljs-number">0</span>] = (FloatKeyframe) Keyframe.ofFloat(<span class="hljs-number">0f</span>, values[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; numKeyframes; ++i) &#123;
                keyframes[i] =
                        (FloatKeyframe) Keyframe.ofFloat((<span class="hljs-keyword">float</span>) i / (numKeyframes - <span class="hljs-number">1</span>), values[i]);
                <span class="hljs-keyword">if</span> (Float.isNaN(values[i])) &#123;
                    badValue = <span class="hljs-keyword">true</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (badValue) &#123;
            Log.w(<span class="hljs-string">"Animator"</span>, <span class="hljs-string">"Bad value (NaN) in float animator"</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FloatKeyframeSet(keyframes);
    &#125;</code></pre>
<h4 id="FloatKeyframeSet-getValue"><a href="#FloatKeyframeSet-getValue" class="headerlink" title="FloatKeyframeSet.getValue()"></a>FloatKeyframeSet.getValue()</h4><blockquote>
<p>根据当前进度，返回关键帧数值</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//FloatKeyframeSet.java</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FloatKeyframeSet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">KeyframeSet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Keyframes</span>.<span class="hljs-title">FloatKeyframes</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FloatKeyframeSet</span><span class="hljs-params">(FloatKeyframe... keyframes)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(keyframes);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;
        <span class="hljs-keyword">return</span> getFloatValue(fraction);
    &#125;

   <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getFloatValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (fraction &lt;= <span class="hljs-number">0f</span>) &#123;<span class="hljs-comment">//初始点</span>
            <span class="hljs-keyword">final</span> FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//第一帧</span>
            <span class="hljs-keyword">final</span> FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(<span class="hljs-number">1</span>);<span class="hljs-comment">//第二帧</span>
            ...
            <span class="hljs-keyword">return</span> mEvaluator == <span class="hljs-keyword">null</span> ?
                    prevValue + intervalFraction * (nextValue - prevValue) :
                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
                            floatValue();
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fraction &gt;= <span class="hljs-number">1f</span>) &#123;<span class="hljs-comment">//终点</span>
            <span class="hljs-keyword">final</span> FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - <span class="hljs-number">2</span>);<span class="hljs-comment">//倒数第二帧</span>
            <span class="hljs-keyword">final</span> FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - <span class="hljs-number">1</span>);<span class="hljs-comment">//倒数第一帧</span>
            ...
            <span class="hljs-keyword">return</span> mEvaluator == <span class="hljs-keyword">null</span> ?
                    prevValue + intervalFraction * (nextValue - prevValue) :
                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
                            floatValue();
        &#125;
        FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; mNumKeyframes; ++i) &#123;<span class="hljs-comment">//其中位置</span>
            FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(i);
            <span class="hljs-keyword">if</span> (fraction &lt; nextKeyframe.getFraction()) &#123;
                ...
                <span class="hljs-keyword">return</span> mEvaluator == <span class="hljs-keyword">null</span> ?
                        prevValue + intervalFraction * (nextValue - prevValue) :
                        ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
                            floatValue();
            &#125;
            prevKeyframe = nextKeyframe;
        &#125;
        <span class="hljs-comment">// shouldn't get here</span>
        <span class="hljs-keyword">return</span> ((Number)mKeyframes.get(mNumKeyframes - <span class="hljs-number">1</span>).getValue()).floatValue();
    &#125;
  
  ...
&#125;</code></pre>
<p><code>getFloatValue()</code>根据以下情况返回不同结果：</p>
<ul>
<li><code>起点</code>：取出第一和第二帧，得到对应进度</li>
<li><code>终点</code>：取出倒数第二和第一帧，得到对应进度</li>
<li><code>中间点</code>：遍历找到输入进度<code>fraction</code>位于第一帧和第几关键帧之间，然后计算关键帧转换得到的进度</li>
</ul>
<h3 id="ObjectAnimator-animateValue"><a href="#ObjectAnimator-animateValue" class="headerlink" title="ObjectAnimator.animateValue()"></a>ObjectAnimator.animateValue()</h3><blockquote>
<p><code>ValueAnimator</code>子类<code>ObjectAnimator</code>重写了该方法</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">animateValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;
    <span class="hljs-keyword">final</span> Object target = getTarget();
    <span class="hljs-keyword">if</span> (mTarget != <span class="hljs-keyword">null</span> &amp;&amp; target == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// We lost the target reference, cancel and clean up. Note: we allow null target if the</span>
        <span class="hljs-comment">/// target has never been set.</span>
        cancel();
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">super</span>.animateValue(fraction);
    <span class="hljs-keyword">int</span> numValues = mValues.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numValues; ++i) &#123;
        mValues[i].setAnimatedValue(target);
    &#125;
&#125;</code></pre>
<p><code>super.animaterValue()</code>指的就是前面的<code>ValueAnimator.animateValue()</code>，在计算得到进度之后，<code>ObjectAnimator</code>是对对象生效的，接下来</p>
<p>需要将值赋予<code>target</code></p>
<h4 id="PropetryValuesHolder-setAnimatedValue"><a href="#PropetryValuesHolder-setAnimatedValue" class="headerlink" title="PropetryValuesHolder.setAnimatedValue()"></a>PropetryValuesHolder.setAnimatedValue()</h4><blockquote>
<p>针对<code>target</code>进行赋值操作</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAnimatedValue</span><span class="hljs-params">(Object target)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (mProperty != <span class="hljs-keyword">null</span>) &#123;
        mProperty.set(target, getAnimatedValue());
    &#125;
    <span class="hljs-keyword">if</span> (mSetter != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">try</span> &#123;
            mTmpValueArray[<span class="hljs-number">0</span>] = getAnimatedValue();
            mSetter.invoke(target, mTmpValueArray);
        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;
            Log.e(<span class="hljs-string">"PropertyValuesHolder"</span>, e.toString());
        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;
            Log.e(<span class="hljs-string">"PropertyValuesHolder"</span>, e.toString());
        &#125;
    &#125;
&#125;</code></pre>
<p>拿<code>ObjectAnimator.ofFloat(view,View.SCALE_X,0f,1f)</code>为例，分析<code>setAnimatedValue()</code>执行结果</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupSetter</span><span class="hljs-params">(Class targetClass)</span> </span>&#123;
    Class&lt;?&gt; propertyType = mConverter == <span class="hljs-keyword">null</span> ? mValueType : mConverter.getTargetType();
    mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, <span class="hljs-string">"set"</span>, propertyType);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> Method <span class="hljs-title">setupSetterOrGetter</span><span class="hljs-params">(Class targetClass,
        HashMap&lt;Class, HashMap&lt;String, Method&gt;&gt; propertyMapMap,
        String prefix, Class valueType)</span> </span>&#123;
  ...
    setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);
  ...
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> Method <span class="hljs-title">getPropertyFunction</span><span class="hljs-params">(Class targetClass, String prefix, Class valueType)</span> </span>&#123;
    Method returnVal = <span class="hljs-keyword">null</span>;
    String methodName = getMethodName(prefix, mPropertyName); <span class="hljs-comment">//方法名setScaleX() </span>
    ... <span class="hljs-comment">//反射获取方法</span>
   
&#125;</code></pre>
<blockquote>
<p><code>PropertyValuesHolder</code>负责<strong>保存动画过程中所需要操作的属性和值</strong>。<code>ObjectAnimator.ofFloat(Object target,String propertyName.float... values)</code>内部的参数会被封装成<code>PropertyValuesHolder</code>实例。</p>
</blockquote>
<p><img src="/images/属性动画执行过程.jpg" srcset="/img/loading.gif" alt="属性动画执行过程"></p>
<h2 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7.参考链接"></a>7.参考链接</h2><p><a href="http://gityuan.com/2015/09/06/android-anaimator-4/" target="_blank" rel="noopener">源码解读Android属性动画</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/09/Android性能优化-网络优化详解/">
                        <span class="hidden-mobile">Android性能优化-网络优化详解</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
