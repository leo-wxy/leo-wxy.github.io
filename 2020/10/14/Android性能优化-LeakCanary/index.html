

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
  <title>Android性能优化-LeakCanary - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.10","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android性能优化-LeakCanary">
              
                Android性能优化-LeakCanary
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-14 14:45" pubdate>
        2020年10月14日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      77
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android性能优化-LeakCanary</h1>
            
            <div class="markdown-body">
              <blockquote><p>LeakCanary主要用来<strong>进行内存泄漏检测</strong>，并且可以直观的展示泄漏的路径</p>
</blockquote>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  // debugImplementation because LeakCanary should only run <span class="hljs-keyword">in</span> debug builds.<br>  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.5'<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置完成后，<code>LeakCanary</code>通过<code>ContentProvider</code>进行注册以及初始化。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//AppWatcherInstaller.kt<br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> AppWatcherInstaller : ContentProvider() &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> onCreate(): <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> application = context!!.applicationContext <span class="hljs-keyword">as</span> Application<br>    AppWatcher.manualInstall(application)<br>    return <span class="hljs-literal">true</span><br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>涉及的部分Activity启动过程源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">//ActivityThread.java<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> handleBindApplication(AppBindData data) &#123;<br>  ...<br>  //获取LoaderApk对象<br>  data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);<br>  //创建进程对应的Android运行环境ContextImpl<br>  <span class="hljs-keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="hljs-keyword">this</span>, data.info);<br>  ...<br>  <span class="hljs-keyword">try</span> &#123;<br>            //准备创建Application对象<br>            Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);<br>            mInitialApplication = app;<br>            ...<br>             //加载对应进程中的ContentProvider<br>            installContentProviders(app, data.providers);<br>            <span class="hljs-keyword">try</span> &#123;<br>                mInstrumentation.onCreate(data.instrumentationArgs);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                throw new RuntimeException(<br>                    "Exception thrown in onCreate() of "<br>                    + data.instrumentationName + ": " + e.toString(), e);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                //调用Application的onCreate方法<br>                mInstrumentation.callApplicationOnCreate(app);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>                    throw new RuntimeException(<br>                        "Unable to create application " + app.getClass().getName()<br>                        + ": " + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            StrictMode.setThreadPolicy(savedPolicy);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>handleBindApplication()</code>进行<code>ContentProvider</code>的启动，此时<code>AppWatcherInstaller</code>会在此时启动。</p>
<p>向下调用到<code>AppWatcher.manualInstall(application)</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//AppWatcher.kt<br>  <span class="hljs-keyword">fun</span> manualInstall(application: Application) &#123;<br>    InternalAppWatcher.install(application)<br>  &#125;<br><br>//InternalAppWatcher.kt<br>//开始了初始化流程<br>  <span class="hljs-keyword">fun</span> install(application: Application) &#123;<br>    //初始化<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>到此基本的<code>LeakCanary</code>初始化完毕</p>
<h3 id="主动添加内存泄漏监控"><a href="#主动添加内存泄漏监控" class="headerlink" title="主动添加内存泄漏监控"></a>主动添加内存泄漏监控</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">AppWatcher.objectWatcher.watch(watchObject,reason)<br></code></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h3><p>在初始化过程执行的<code>注册监听</code>过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//InternalAppWatcher.kt<br>//开始了初始化流程<br>  <span class="hljs-keyword">fun</span> install(application: Application) &#123;<br>    checkMainThread()<br>    <span class="hljs-keyword">if</span> (this::application.isInitialized) &#123;<br>      return<br>    &#125;<br>    InternalAppWatcher.application = application<br>    <span class="hljs-keyword">if</span> (isDebuggableBuild) &#123;<br>      SharkLog.logger = DefaultCanaryLog()<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> configProvider = &#123; AppWatcher.config &#125;<br>    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)<br>    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)<br>    onAppWatcherInstalled(application)<br>  &#125;<br></code></pre></td></tr></table></figure>
<h4 id="监听Activity"><a href="#监听Activity" class="headerlink" title="监听Activity"></a>监听Activity</h4><p><code>ActivityDestroyWatcher.install</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> ActivityDestroyWatcher <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> objectWatcher: ObjectWatcher,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> configProvider: () -&gt; Config<br>) &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> onActivityDestroyed(activity: Activity) &#123;<br>        //监听Activity onDestroy()生命周期<br>        <span class="hljs-keyword">if</span> (configProvider().watchActivities) &#123;<br>          objectWatcher.watch(<br>              activity, "$&#123;activity::<span class="hljs-keyword">class</span>.java.name&#125; received Activity#onDestroy() callback"<br>          )<br>        &#125;<br>      &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-keyword">fun</span> install(<br>      application: Application,<br>      objectWatcher: ObjectWatcher,<br>      configProvider: () -&gt; Config<br>    ) &#123;<br>      <span class="hljs-keyword">val</span> activityDestroyWatcher =<br>        ActivityDestroyWatcher(objectWatcher, configProvider)<br>      //往Application添加Activity生命周期回调监听<br>      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要是为了注册Activity的生命周期回调，监测到<code>onActivityDestroyed()</code>之后，将Activity加入到<code>objectWatcher</code>中</p>
<h4 id="监听Fragment"><a href="#监听Fragment" class="headerlink" title="监听Fragment"></a>监听Fragment</h4><p><code>FragmentDestroyWatcher.install</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> FragmentDestroyWatcher &#123;<br>  <br>  //AndroidX fragment相关配置<br>    <span class="hljs-keyword">private</span> const <span class="hljs-keyword">val</span> ANDROIDX_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"<br>    <span class="hljs-keyword">private</span> const <span class="hljs-keyword">val</span> ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =<br>    "leakcanary.<span class="hljs-keyword">internal</span>.AndroidXFragmentDestroyWatcher"<br>  <br>  <br>  //supprt fragment相关配置<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> ANDROID_SUPPORT_FRAGMENT_CLASS_NAME =<br>    StringBuilder("android.").append("support.v4.app.Fragment")<br>        .toString()<br>  <span class="hljs-keyword">private</span> const <span class="hljs-keyword">val</span> ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =<br>    "leakcanary.<span class="hljs-keyword">internal</span>.AndroidSupportFragmentDestroyWatcher"<br><br>  <br>  ...<br>   <span class="hljs-keyword">fun</span> install(<br>    application: Application,<br>    objectWatcher: ObjectWatcher,<br>    configProvider: () -&gt; AppWatcher.Config<br>  ) &#123;<br>    <span class="hljs-keyword">val</span> fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; <span class="hljs-built_in">Unit</span>&gt;()<br><br>     //Android 8.0及以上 直接构造 AndroidOFragmentDestroyWatcher<br>    <span class="hljs-keyword">if</span> (SDK_INT &gt;= O) &#123;<br>      fragmentDestroyWatchers.add(<br>          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)<br>      )<br>    &#125;<br><br>     //androidx fragment对象 <br>    getWatcherIfAvailable(<br>        ANDROIDX_FRAGMENT_CLASS_NAME,<br>        ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<br>        objectWatcher,<br>        configProvider<br>    )?.let &#123;<br>      fragmentDestroyWatchers.add(it)<br>    &#125;<br><br>     //fragment相关配置<br>    getWatcherIfAvailable(<br>        ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,<br>        ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<br>        objectWatcher,<br>        configProvider<br>    )?.let &#123;<br>      fragmentDestroyWatchers.add(it)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fragmentDestroyWatchers.size == 0) &#123;<br>      return<br>    &#125;<br><br>    application.registerActivityLifecycleCallbacks(<span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> onActivityCreated(<br>        activity: Activity,<br>        savedInstanceState: Bundle?<br>      ) &#123;<br>        //在Activity创建时 添加Fragment的监听<br>        <span class="hljs-keyword">for</span> (watcher <span class="hljs-keyword">in</span> fragmentDestroyWatchers) &#123;<br>          //调用到 对应的 invoke()<br>          watcher(activity)<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据上述源码，<code>FragmentDestroyWatcher</code>按照三种情况进行区分：</p>
<ul>
<li>Android O 及以上版本的fragment：<code>AndroidOFragmentDestroyWatcher</code></li>
<li>AndroidX 的fragment：<code>AndroidXFragmentDestroyWatcher</code></li>
<li>Android support 的 fragment：<code>AndroidSupportFragmentDestroyWatcher</code></li>
</ul>
<p>上述三种实现基本一致，只是对引用的<code>fragment</code>进行了区分，下面拿<code>AndroidSupportFragmentDestroyWatcher</code>进行分析</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//AndroidSupportFragmentDestroyWatcher.kt<br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> AndroidSupportFragmentDestroyWatcher(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> objectWatcher: ObjectWatcher,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> configProvider: () -&gt; Config<br>) : (Activity) -&gt; <span class="hljs-built_in">Unit</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentLifecycleCallbacks = <span class="hljs-keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> onFragmentViewDestroyed(<br>      fm: FragmentManager,<br>      fragment: Fragment<br>    ) &#123;<br>      //添加了对fragment引用的View的泄漏监听<br>      <span class="hljs-keyword">val</span> view = fragment.view<br>      <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span> &amp;&amp; configProvider().watchFragmentViews) &#123;<br>        objectWatcher.watch(<br>            view, "$&#123;fragment::<span class="hljs-keyword">class</span>.java.name&#125; received Fragment#onDestroyView() callback " +<br>            "(references to its views should be cleared to prevent leaks)"<br>        )<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> onFragmentDestroyed(<br>      fm: FragmentManager,<br>      fragment: Fragment<br>    ) &#123;<br>      <span class="hljs-keyword">if</span> (configProvider().watchFragments) &#123;<br>        //添加对 fragment的泄漏监听<br>        objectWatcher.watch(<br>            fragment, "$&#123;fragment::<span class="hljs-keyword">class</span>.java.name&#125; received Fragment#onDestroy() callback"<br>        )<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> invoke(activity: Activity) &#123;<br>    <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">is</span> FragmentActivity) &#123;<br>      //针对 fragmentManager 添加 fragmentlifecyclecallback监听<br>      <span class="hljs-keyword">val</span> supportFragmentManager = activity.supportFragmentManager<br>      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="hljs-literal">true</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要是在<code>FragmentManager</code>调用<code>registerFragmentLifecycleCallbacks()</code>添加生命周期监听。</p>
<ul>
<li>在<code>onFragmentViewDestroyed()</code>添加<code>View</code>的监听</li>
<li>在<code>onFragmentDestroyed()</code>添加<code>Fragment</code>的监听</li>
</ul>
<p>最后在<code>registerActivityLifecycleCallbacks()</code>的每个Activity的<code>onActivityCreated()</code>中执行<code>Fragment</code>的生命周期监听。</p>
<p>此时<code>objectWatcher</code>对象就已经监听到了如下实例：</p>
<ul>
<li>Activity</li>
<li>Fragment</li>
<li>Fragment中的View</li>
</ul>
<h4 id="InternalLeakCanary"><a href="#InternalLeakCanary" class="headerlink" title="InternalLeakCanary"></a>InternalLeakCanary</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//InternalappWatcher.kt<br>  init &#123;<br>    <span class="hljs-keyword">val</span> internalLeakCanary = <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> leakCanaryListener = Class.forName("leakcanary.<span class="hljs-keyword">internal</span>.InternalLeakCanary")<br>      leakCanaryListener.getDeclaredField("INSTANCE")<br>          .<span class="hljs-keyword">get</span>(<span class="hljs-literal">null</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>      NoLeakCanary<br>    &#125;<br>    @kotlin.Suppress("UNCHECKED_CAST")<br>    onAppWatcherInstalled = internalLeakCanary <span class="hljs-keyword">as</span> (Application) -&gt; <span class="hljs-built_in">Unit</span><br>  &#125;<br></code></pre></td></tr></table></figure>
<p>最后执行的<code>onAppWatcherInstalled()</code>的实现类就是<code>InternalLeakCanary</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//InternalLeakCanary.kt<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> invoke(application: Application) &#123;<br>    _application = application<br><br>    checkRunningInDebuggableBuild()<br><br>    //注册监听对象 可能泄漏的消息<br>    AppWatcher.objectWatcher.addOnObjectRetainedListener(this)<br><br>    <span class="hljs-keyword">val</span> heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application))<br><br>    <span class="hljs-keyword">val</span> gcTrigger = GcTrigger.Default<br><br>    <span class="hljs-keyword">val</span> configProvider = &#123; LeakCanary.config &#125;<br><br>    <span class="hljs-keyword">val</span> handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)<br>    handlerThread.start()<br>    <span class="hljs-keyword">val</span> backgroundHandler = Handler(handlerThread.looper)<br><br>    //dump内存<br>    heapDumpTrigger = HeapDumpTrigger(<br>        application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,<br>        configProvider<br>    )<br>    application.registerVisibilityListener &#123; applicationVisible -&gt;<br>      this.applicationVisible = applicationVisible<br>      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)<br>    &#125;<br>    registerResumedActivityListener(application)<br>    //添加桌面的快捷入口<br>    addDynamicShortcut(application)<br><br>    // We post so that the log happens after Application.onCreate()<br>    Handler().post &#123;<br>      SharkLog.d &#123;<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()) &#123;<br>          <span class="hljs-keyword">is</span> Yup -&gt; application.getString(R.string.leak_canary_heap_dump_enabled_text)<br>          <span class="hljs-keyword">is</span> Nope -&gt; application.getString(<br>              R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()<br>          )<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>InternalLeakCanary</code>主要负责接收<code>objectWatcher</code>通知的<code>可能存在的内存泄漏</code>消息并驱动<code>heapDumpTrigger</code>进行<code>Dump</code>过程。</p>
<p>得到最终产出的<code>Hprof文件</code>去进行分析的流程。</p>
<p><img src="/images/LeakCanary初始化.jpg" srcset="/img/loading.gif" lazyload="" alt="LeakCanary初始化"></p>
<h3 id="泄漏检测"><a href="#泄漏检测" class="headerlink" title="泄漏检测"></a>泄漏检测</h3><p>根据上节分析可知，所有需要监控的对象都会通过<code>objectWatcher.watch()</code>进行对象监听</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//监测引用队列间隔<br><span class="hljs-keyword">val</span> watchDurationMillis: <span class="hljs-built_in">Long</span> = TimeUnit.SECONDS.toMillis(5),<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkRetainedExecutor = Executor &#123;<br>    mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)<br>  &#125;<br><br><span class="hljs-keyword">val</span> objectWatcher = ObjectWatcher(<br>      clock = clock,<br>      checkRetainedExecutor = checkRetainedExecutor,<br>      isEnabled = &#123; <span class="hljs-literal">true</span> &#125;<br>  )<br></code></pre></td></tr></table></figure>
<p>实现类是<code>ObjectWatcher</code></p>
<h4 id="ObjectWatcher"><a href="#ObjectWatcher" class="headerlink" title="ObjectWatcher"></a>ObjectWatcher</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> ObjectWatcher <span class="hljs-keyword">constructor</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clock: Clock,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkRetainedExecutor: Executor,<br>  /**<br>   * Calls to [watch] will be ignored <span class="hljs-keyword">when</span> [isEnabled] returns <span class="hljs-literal">false</span><br>   */<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> isEnabled: () -&gt; <span class="hljs-built_in">Boolean</span> = &#123; <span class="hljs-literal">true</span> &#125;<br>) &#123;<br>  //需要监听的弱引用对象实例<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()<br>  //引用队列<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> queue = ReferenceQueue&lt;Any&gt;()<br>  <br>  ...<br>  <br>    @Synchronized <span class="hljs-keyword">fun</span> watch(<br>    watchedObject: Any,<br>    description: String<br>  ) &#123;<br>    <span class="hljs-keyword">if</span> (!isEnabled()) &#123;<br>      return<br>    &#125;<br>    removeWeaklyReachableObjects()<br>    <span class="hljs-keyword">val</span> key = UUID.randomUUID()<br>        .toString()<br>    <span class="hljs-keyword">val</span> watchUptimeMillis = clock.uptimeMillis()<br>      //将需要监听的对象 构建一个弱引用实例<br>    <span class="hljs-keyword">val</span> reference =<br>      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)&#123;&#125;<br><br>    watchedObjects[key] = reference<br>      //执行 checkExecutor任务<br>    checkRetainedExecutor.execute &#123;<br>      moveToRetained(key)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用<code>watch()</code>之后，将需要监听的对象添加弱引用(<code>WeakReference</code>)，再通过关联一个引用队列(<code>ReferenceQueue</code>)判断监听对象是否被回收。</p>
<blockquote>
<p>为什么选用弱引用？</p>
<p>除了强引用不会被回收外，还存在着<code>软引用</code>和<code>虚引用</code>。其中<code>软引用</code>必须在内存将满时才会被回收并加入到<code>ReferenceQueue</code>中，而<code>虚引用</code>在加入到<code>ReferenceQueue</code>时，内置的引用无法被清空。</p>
</blockquote>
<p>包装成弱引用对象后，执行<code>checkRetainedExecutor</code>的线程池，本质上执行的是<strong>等待5s后执行对象是否回收的判断。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">@Synchronized <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> moveToRetained(key: String) &#123;<br>  removeWeaklyReachableObjects()<br>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]<br>  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;<br>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> removeWeaklyReachableObjects() &#123;<br>  // WeakReferences are enqueued <span class="hljs-keyword">as</span> soon <span class="hljs-keyword">as</span> the <span class="hljs-keyword">object</span> to which they point to becomes weakly<br>  // reachable. This <span class="hljs-keyword">is</span> before finalization or garbage collection has actually happened.<br>  <span class="hljs-keyword">var</span> ref: KeyedWeakReference?<br>  <span class="hljs-keyword">do</span> &#123;<br>    ref = queue.poll() <span class="hljs-keyword">as</span> KeyedWeakReference?<br>    <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;<br>      watchedObjects.remove(ref.key)<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (ref != <span class="hljs-literal">null</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>watchedObjects</code>存放的就是<code>被观察的对象引用</code>，每次调用<code>watch()</code>都会发送一个延时5s的消息。</p>
<p>延时消息主要执行<code>moveToRetained()</code>，内部主要执行如下过程：</p>
<ol>
<li>遍历<code>queue(引用队列)</code>，将其中存在的对象从<code>watchedObjects</code>中移除，因为已经被回收</li>
<li>如果对象没有从<code>watchedObjects</code>中移除，就表示该对象发生了<code>内存泄漏</code></li>
</ol>
<h3 id="Dump出Hprof文件"><a href="#Dump出Hprof文件" class="headerlink" title="Dump出Hprof文件"></a>Dump出Hprof文件</h3><p>如果存在未被回收的对象，此时就会回调到<code>OnObjectRetainedListener.onObjectRetained()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> InternalLeakCanary : (Application) -&gt; <span class="hljs-built_in">Unit</span>, OnObjectRetainedListener &#123;<br>  ...<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> invoke(application: Application) &#123;<br>      //添加回调监听注册<br>      AppWatcher.objectWatcher.addOnObjectRetainedListener(this)<br>      ...<br>    &#125;<br>  <br>  //实现的方法<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> onObjectRetained() = scheduleRetainedObjectCheck()  <br>  <br>  <br>  <span class="hljs-keyword">fun</span> scheduleRetainedObjectCheck() &#123;<br>    //初始化完毕<br>    <span class="hljs-keyword">if</span> (this::heapDumpTrigger.isInitialized) &#123;<br>      heapDumpTrigger.scheduleRetainedObjectCheck()<br>    &#125;<br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>切换到<code>HeapDumpTrigger</code>继续执行</p>
<h4 id="HeapDumpTrigger"><a href="#HeapDumpTrigger" class="headerlink" title="HeapDumpTrigger"></a>HeapDumpTrigger</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//HeapDumpTrigger.kt <br><span class="hljs-keyword">fun</span> scheduleRetainedObjectCheck(<br>    delayMillis: <span class="hljs-built_in">Long</span> = 0L<br>  ) &#123;<br>    <span class="hljs-keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt<br>    <span class="hljs-keyword">if</span> (checkCurrentlyScheduledAt &gt; 0) &#123;<br>      return<br>    &#125;<br>    checkScheduledAt = SystemClock.uptimeMillis() + delayMillis<br>    backgroundHandler.postDelayed(&#123;<br>      checkScheduledAt = 0<br>      checkRetainedObjects()<br>    &#125;, delayMillis)<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> checkRetainedObjects() &#123;<br>   ... <br>    //获取未释放的对象数<br>    <span class="hljs-keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount<br><br>    <span class="hljs-keyword">if</span> (retainedReferenceCount &gt; 0) &#123;<br>      //手动执行一次GC<br>      gcTrigger.runGc()<br>      //在获取一次 <br>      retainedReferenceCount = objectWatcher.retainedObjectCount<br>    &#125;<br><br>    //判断是否超过阈值，避免重复调用dump<br>    <span class="hljs-keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return<br>    <br>    //dump内存生成 Hprof文件<br>        dumpHeap(retainedReferenceCount, retry = <span class="hljs-literal">true</span>)<br>    <br>  &#125;<br><br>//GcTrigger.kt<br>  <span class="hljs-keyword">object</span> Default : GcTrigger &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> runGc() &#123;<br>      Runtime.getRuntime()<br>          .gc()<br>      enqueueReferences()<br>      System.runFinalization()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> enqueueReferences() &#123;<br>      // Hack. We don't have a programmatic way to wait <span class="hljs-keyword">for</span> the reference queue daemon to move<br>      // references to the appropriate queues.<br>      <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(100)<br>      &#125; <span class="hljs-keyword">catch</span> (e: InterruptedException) &#123;<br>        <span class="hljs-keyword">throw</span> AssertionError()<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>scheduleRetainedObjectCheck()</code>并不是直接去dump，而是先手动调用一次GC，然后再触发GC后等待<code>100ms</code>之后再去检测一次是否有对象未被回收。</p>
<p>其中判断过程还添加了<code>阈值(5)</code>，避免频繁触发<code>dumpHeap()</code>导致卡顿。</p>
<h4 id="dumpHeap"><a href="#dumpHeap" class="headerlink" title="dumpHeap()"></a>dumpHeap()</h4><p>主要负责dump 出 Hprof文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//InternalLeakCanary.kt<br>    <span class="hljs-keyword">val</span> heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application))<br><br>//HeapDumpTrigger.kt<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> dumpHeap(<br>    retainedReferenceCount: <span class="hljs-built_in">Int</span>,<br>    retry: <span class="hljs-built_in">Boolean</span><br>  ) &#123;<br>    saveResourceIdNamesToMemory()<br>    <span class="hljs-keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()<br>    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis<br>    //开始执行dump过程<br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> heapDumpResult = heapDumper.dumpHeap()) &#123;<br>      <span class="hljs-keyword">is</span> NoHeapDump -&gt; &#123;<br>        ...<br>      &#125;<br>      <span class="hljs-keyword">is</span> HeapDump -&gt; &#123;<br>        lastDisplayedRetainedObjectCount = 0<br>        lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()<br>        //生成hprof文件<br>        objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)<br>        //hprof文件生成完毕后，发送到HeapAnalyzeSerview<br>        HeapAnalyzerService.runAnalysis(<br>            context = application,<br>            heapDumpFile = heapDumpResult.file,<br>            heapDumpDurationMillis = heapDumpResult.durationMillis<br>        )<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>AndroidHeapDumper</code>去执行dump过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//AndroidHeapDumper.kt<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> dumpHeap(): DumpHeapResult &#123;<br>    ...<br>     return <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> durationMillis = measureDurationMillis &#123;<br>        //执行dump过程<br>        Debug.dumpHprofData(heapDumpFile.absolutePath)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (heapDumpFile.length() == 0L) &#123;<br>        SharkLog.d &#123; "Dumped heap file <span class="hljs-keyword">is</span> 0 byte length" &#125;<br>        NoHeapDump<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        HeapDump(file = heapDumpFile, durationMillis = durationMillis)<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>      SharkLog.d(e) &#123; "Could not dump heap" &#125;<br>      // Abort heap dump<br>      NoHeapDump<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      cancelToast(toast)<br>      notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)<br>    &#125;<br>    <br>  &#125;<br></code></pre></td></tr></table></figure>
<p>主要是执行<code>Debug.dumpHprofData()</code>得到<code>Hprof文件</code>去进行内存分析。</p>
<h4 id="HeapAnalyzerService-runAnalysis"><a href="#HeapAnalyzerService-runAnalysis" class="headerlink" title="HeapAnalyzerService.runAnalysis()"></a>HeapAnalyzerService.runAnalysis()</h4><p>主要负责去分析Hprof文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//HeapAnalyzerService.kt<br>    <span class="hljs-keyword">fun</span> runAnalysis(<br>      context: Context,<br>      heapDumpFile: File,<br>      heapDumpDurationMillis: <span class="hljs-built_in">Long</span>? = <span class="hljs-literal">null</span><br>    ) &#123;<br>      <span class="hljs-keyword">val</span> intent = Intent(context, HeapAnalyzerService::<span class="hljs-keyword">class</span>.java)<br>      //携带文件地址 到 HeapAnalyzerService去进行分析<br>      intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)<br>      heapDumpDurationMillis?.let &#123;<br>        intent.putExtra(HEAPDUMP_DURATION_MILLIS, heapDumpDurationMillis)<br>      &#125;<br>      startForegroundService(context, intent)<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>接下来切换到<code>HeapAnalyzerService</code>开始进行Hprof文件解析流程。</p>
<h3 id="Hprof解析"><a href="#Hprof解析" class="headerlink" title="Hprof解析"></a>Hprof解析</h3><p>在<code>HeapAnalyzerService</code>收到传过来的Hprof文件地址后，就要开始解析</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//HeapAnalyzerService  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> analyzeHeap(<br>    heapDumpFile: File,<br>    config: Config<br>  ): HeapAnalysis &#123;<br>    <span class="hljs-keyword">val</span> heapAnalyzer = HeapAnalyzer(this)<br><br>    <span class="hljs-keyword">val</span> proguardMappingReader = <span class="hljs-keyword">try</span> &#123;<br>      ProguardMappingReader(assets.<span class="hljs-keyword">open</span>(PROGUARD_MAPPING_FILE_NAME))<br>    &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>      <span class="hljs-literal">null</span><br>    &#125;<br>    return heapAnalyzer.analyze(<br>        heapDumpFile = heapDumpFile,<br>        leakingObjectFinder = config.leakingObjectFinder,<br>        referenceMatchers = config.referenceMatchers,<br>        computeRetainedHeapSize = config.computeRetainedHeapSize,<br>        objectInspectors = config.objectInspectors,<br>        metadataExtractor = config.metadataExtractor,<br>        proguardMapping = proguardMappingReader?.readProguardMapping()<br>    )<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>解析前需要了解一下<a href="/2020/12/14/Hprof文件解析/" title="Hprof结构">Hprof结构</a>，在此基础上进行Hprof解析的相关流程分析。</p>
<blockquote>
<p>简单说明一下Hprof的相关结构</p>
<p>主要分为两部分：</p>
<ul>
<li>Header：主要包含一些元信息，例如<code>文件协议的版本</code>、<code>开始</code>和<code>结束的时间戳</code>，以及<code>标识符大小</code></li>
<li>Record：主要结构为<code>TAG</code>、<code>TIME</code>、<code>LENGTH(BODY数据长度)</code>和<code>BODY</code><ul>
<li>TAG：表示<code>Record</code>类型，重要的有<code>HEAP_DUMP_SEGMENT</code>和<code>STRING</code>等</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="Shark-HeapAnalyzer"><a href="#Shark-HeapAnalyzer" class="headerlink" title="Shark.HeapAnalyzer"></a>Shark.HeapAnalyzer</h4><blockquote>
<p><code>Shark</code>是一款分析<code>Hprof文件</code>的工具，性能高且占用内存少，非常适合手机端的Hprof文件解析功能。</p>
<p>目的是<strong>提供快速解析Hprof文件和分析的能力。</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//HeapAnalyzer.kt <br><span class="hljs-keyword">fun</span> analyze(<br>    heapDumpFile: File,<br>    leakingObjectFinder: LeakingObjectFinder,<br>    referenceMatchers: List&lt;ReferenceMatcher&gt; = emptyList(),<br>    computeRetainedHeapSize: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,<br>    objectInspectors: List&lt;ObjectInspector&gt; = emptyList(),<br>    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,<br>    proguardMapping: ProguardMapping? = <span class="hljs-literal">null</span><br>  ): HeapAnalysis &#123;<br>    ...<br>    return <span class="hljs-keyword">try</span> &#123;<br>      listener.onAnalysisProgress(PARSING_HEAP_DUMP)<br>      <span class="hljs-keyword">val</span> sourceProvider = ConstantMemoryMetricsDualSourceProvider(FileSourceProvider(heapDumpFile))<br>      sourceProvider.openHeapGraph(proguardMapping).use &#123; graph -&gt;<br>       //                                                  <br>        <span class="hljs-keyword">val</span> helpers =<br>          FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)<br>        <span class="hljs-keyword">val</span> result = helpers.analyzeGraph(<br>            metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime<br>        )<br>        result.copy(metadata = result.metadata + ("Stats" to stats))<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (exception: Throwable) &#123;<br><br>    &#125;  <br>    <br>  &#125;<br></code></pre></td></tr></table></figure>
<h5 id="openHeapGraph"><a href="#openHeapGraph" class="headerlink" title="openHeapGraph"></a>openHeapGraph</h5><p>主要用来按照格式解析Hprof文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//HprofHeapGraph.kt<br>    <span class="hljs-keyword">fun</span> DualSourceProvider.openHeapGraph(<br>      proguardMapping: ProguardMapping? = <span class="hljs-literal">null</span>,<br>      indexedGcRootTypes: Set&lt;HprofRecordTag&gt; = HprofIndex.defaultIndexedGcRootTags()<br>    ): CloseableHeapGraph &#123;<br>      //主要负责解析 Hprof head部分的数据<br>      <span class="hljs-keyword">val</span> header = openStreamingSource().use &#123; HprofHeader.parseHeaderOf(it) &#125;<br>      <span class="hljs-keyword">val</span> index = HprofIndex.indexRecordsOf(this, header, proguardMapping, indexedGcRootTypes)<br>      return index.openHeapGraph()<br>    &#125;<br><br>//HprofIndex.kt<br>    <span class="hljs-keyword">fun</span> indexRecordsOf(<br>      hprofSourceProvider: DualSourceProvider,<br>      hprofHeader: HprofHeader,<br>      proguardMapping: ProguardMapping? = <span class="hljs-literal">null</span>,<br>      indexedGcRootTags: Set&lt;HprofRecordTag&gt; = defaultIndexedGcRootTags()<br>    ): HprofIndex &#123;<br>      <span class="hljs-keyword">val</span> reader = StreamingHprofReader.readerFor(hprofSourceProvider, hprofHeader)<br>      <span class="hljs-keyword">val</span> index = HprofInMemoryIndex.indexHprof(<br>          reader = reader,<br>          hprofHeader = hprofHeader,<br>          proguardMapping = proguardMapping,<br>          indexedGcRootTags = indexedGcRootTags<br>      )<br>      return HprofIndex(hprofSourceProvider, hprofHeader, index)<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>将Hprof中的<code>Record</code>解析成<code>HprofMemoryIndex</code>，将Record按照Tag进行分析和计数，并通过特定规则进行排序。</p>
<p>最终通过<code>openHeapGraph()</code>组合得到<code>HprofHeapGraph</code>对象，等价于<code>Hprof文件</code>转换成了<code>HprofHeapGraph</code>对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//HprofHeapGraph.kt<br><span class="hljs-keyword">class</span> HprofHeapGraph <span class="hljs-keyword">internal</span> <span class="hljs-keyword">constructor</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> header: HprofHeader,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reader: RandomAccessHprofReader,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> index: HprofInMemoryIndex<br>) : CloseableHeapGraph &#123;<br>  <br>  ...<br>  //缓存可以成为 GC Roots的对象<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> gcRoots: List&lt;GcRoot&gt;<br>    <span class="hljs-keyword">get</span>() = index.gcRoots()<br>  <br>  //记录的是所有对象<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> objects: Sequence&lt;HeapObject&gt;<br>  <br>  //对应TAG为 CLASS_DUMP<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> classes: Sequence&lt;HeapClass&gt;<br>  <br>  //对应TAG为 INSTANCE_DUMP<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> instances: Sequence&lt;HeapInstance&gt;<br>  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>内部主要包括了<code>gcRoots</code>、<code>objects</code>、<code>classes</code>和<code>instances</code>几种集合，可以快速定位dump堆中的对象。</p>
<h5 id="FindLeakInput"><a href="#FindLeakInput" class="headerlink" title="FindLeakInput"></a>FindLeakInput</h5><p>主要分析泄漏对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">///HeapAnalyzer.kt<br>  <span class="hljs-keyword">fun</span> analyze(<br>    heapDumpFile: File,<br>    graph: HeapGraph,<br>    leakingObjectFinder: LeakingObjectFinder,<br>    referenceMatchers: List&lt;ReferenceMatcher&gt; = emptyList(),<br>    computeRetainedHeapSize: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,<br>    objectInspectors: List&lt;ObjectInspector&gt; = emptyList(),<br>    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP<br>  ): HeapAnalysis &#123;<br><br>    return <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> helpers =<br>        FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)<br>      helpers.analyzeGraph(<br>          metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime<br>      )<br>    &#125; <span class="hljs-keyword">catch</span> (exception: Throwable) &#123;<br>      )<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>接下来执行到<code>analyzeGraph</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> FindLeakInput.analyzeGraph(<br>  metadataExtractor: MetadataExtractor,<br>  leakingObjectFinder: LeakingObjectFinder,<br>  heapDumpFile: File,<br>  analysisStartNanoTime: <span class="hljs-built_in">Long</span><br>): HeapAnalysisSuccess &#123;<br>  listener.onAnalysisProgress(EXTRACTING_METADATA)<br>  <span class="hljs-keyword">val</span> metadata = metadataExtractor.extractMetadata(graph)<br><br>  listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)<br>  <span class="hljs-keyword">val</span> leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)<br><br>  <span class="hljs-keyword">val</span> (applicationLeaks, libraryLeaks) = findLeaks(leakingObjectIds)<br>  <br>  return HeapAnalysisSuccess(<br>      heapDumpFile = heapDumpFile,<br>      createdAtTimeMillis = System.currentTimeMillis(),<br>      analysisDurationMillis = since(analysisStartNanoTime),<br>      metadata = metadata,<br>      applicationLeaks = applicationLeaks,<br>      libraryLeaks = libraryLeaks<br>  )    <br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> FindLeakInput.findLeaks(leakingObjectIds: Set&lt;<span class="hljs-built_in">Long</span>&gt;): Pair&lt;List&lt;ApplicationLeak&gt;, List&lt;LibraryLeak&gt;&gt; &#123;<br>  <span class="hljs-keyword">val</span> pathFinder = PathFinder(graph, listener, referenceMatchers)<br>  <span class="hljs-keyword">val</span> pathFindingResults =<br>    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)<br>  //找寻最短路径<br>  <span class="hljs-keyword">val</span> shortestPaths =<br>    deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)<br>  <span class="hljs-keyword">val</span> inspectedObjectsByPath = inspectObjects(shortestPaths)<br>  return buildLeakTraces(shortestPaths, inspectedObjectsByPath, retainedSizes)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要执行流程分为3步：</p>
<h6 id="findLeakingObjectIds"><a href="#findLeakingObjectIds" class="headerlink" title="findLeakingObjectIds"></a>findLeakingObjectIds</h6><blockquote>
<p>寻找泄漏的对象</p>
</blockquote>
<p>设置的<code>leakingObjectFinder</code>实际就是<code>KeyedWeakReferenceFinder</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//KeyedWeakReferenceFinder.kt<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> findLeakingObjectIds(graph: HeapGraph): Set&lt;<span class="hljs-built_in">Long</span>&gt; =<br>    findKeyedWeakReferences(graph).map &#123; it.referent.value &#125;<br>        .toSet()<br><br>  <span class="hljs-keyword">internal</span> <span class="hljs-keyword">fun</span> findKeyedWeakReferences(graph: HeapGraph): List&lt;KeyedWeakReferenceMirror&gt; &#123;<br>    return graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) &#123;<br>      <span class="hljs-keyword">val</span> keyedWeakReferenceClass = graph.findClassByName("leakcanary.KeyedWeakReference")<br><br>      <span class="hljs-keyword">val</span> keyedWeakReferenceClassId = keyedWeakReferenceClass?.objectId ?: 0<br>      <span class="hljs-keyword">val</span> legacyKeyedWeakReferenceClassId =<br>        graph.findClassByName("com.squareup.leakcanary.KeyedWeakReference")?.objectId ?: 0<br><br>      <span class="hljs-keyword">val</span> heapDumpUptimeMillis = heapDumpUptimeMillis(graph)<br><br>      <span class="hljs-keyword">val</span> addedToContext: List&lt;KeyedWeakReferenceMirror&gt; = graph.instances<br>          .filter &#123; instance -&gt;<br>            instance.instanceClassId == keyedWeakReferenceClassId || instance.instanceClassId == legacyKeyedWeakReferenceClassId<br>          &#125;<br>          .map &#123;<br>            KeyedWeakReferenceMirror.fromInstance(<br>                it, heapDumpUptimeMillis<br>            )<br>          &#125;<br>          .filter &#123; it.hasReferent &#125;<br>          .toList()<br>      graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext<br>      addedToContext<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>主要就是实现了 找寻<code>instance</code>实例中的被<code>KeyedWeakReference</code>所包装的实例，因为在最前面<code>watch</code>的过程中，需要监控的对象都是被<code>KeyedWeakReference</code>所包装的，既然能在<code>isntance</code>中找到就意味着这些对象是发生了内存泄漏的。</p>
<h6 id="findPathsFromGcRoots"><a href="#findPathsFromGcRoots" class="headerlink" title="findPathsFromGcRoots"></a>findPathsFromGcRoots</h6><blockquote>
<p>寻找泄漏对象到GC Roots对象的引用路径</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//PathFinder.kt <br><span class="hljs-keyword">fun</span> findPathsFromGcRoots(<br>    leakingObjectIds: Set&lt;<span class="hljs-built_in">Long</span>&gt;,<br>    computeRetainedHeapSize: <span class="hljs-built_in">Boolean</span><br>  ): PathFindingResults &#123;<br>...<br>    <span class="hljs-keyword">val</span> state = State(<br>        leakingObjectIds = leakingObjectIds.toLongScatterSet(),<br>        sizeOfObjectInstances = sizeOfObjectInstances,<br>        computeRetainedHeapSize = computeRetainedHeapSize,<br>        javaLangObjectId = javaLangObjectId,<br>        estimatedVisitedObjects = estimatedVisitedObjects<br>    )<br><br>    return state.findPathsFromGcRoots()<br>  &#125;<br><br>//找寻泄漏对象 到 GC Roots对象的路径<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> State.findPathsFromGcRoots(): PathFindingResults &#123;<br>    enqueueGcRoots()<br><br>    <span class="hljs-keyword">val</span> shortestPathsToLeakingObjects = mutableListOf&lt;ReferencePathNode&gt;()<br>    visitingQueue@ <span class="hljs-keyword">while</span> (queuesNotEmpty) &#123;<br>      <span class="hljs-keyword">val</span> node = poll()<br>      <span class="hljs-keyword">if</span> (node.objectId <span class="hljs-keyword">in</span> leakingObjectIds) &#123;<br>        shortestPathsToLeakingObjects.add(node)<br>        // Found all refs, stop searching (unless computing retained size)<br>        <span class="hljs-keyword">if</span> (shortestPathsToLeakingObjects.size == leakingObjectIds.size()) &#123;<br>          <span class="hljs-keyword">if</span> (computeRetainedHeapSize) &#123;<br>            listener.onAnalysisProgress(FINDING_DOMINATORS)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            break@visitingQueue<br>          &#125;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> heapObject = graph.findObjectById(node.objectId)) &#123;<br>        <span class="hljs-keyword">is</span> HeapClass -&gt; visitClassRecord(heapObject, node)<br>        <span class="hljs-keyword">is</span> HeapInstance -&gt; visitInstance(heapObject, node)<br>        <span class="hljs-keyword">is</span> HeapObjectArray -&gt; visitObjectArray(heapObject, node)<br>      &#125;<br>    &#125;<br>    return PathFindingResults(<br>        shortestPathsToLeakingObjects,<br>        <span class="hljs-keyword">if</span> (visitTracker <span class="hljs-keyword">is</span> Dominated) visitTracker.dominatorTree <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>    )<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>总体思路</p>
<blockquote>
<p>采用<strong>广度优先遍历</strong>从<code>GC Roots</code>开始遍历，直到<code>泄漏对象</code>为止。</p>
<p><code>广度优先遍历</code>：从根节点出发，沿着树宽度依此遍历树的每个节点。<strong>借助队列结构实现</strong></p>
<p>以<code>GC Roots对象</code>为树的根节点，然后从根节点开始遍历，对每个节点依据类型的不同采取对应的模式进行访问并得到对象，然后引用继续抽象成为<code>Node</code>加入队列以待后续遍历，直到遍历到<code>Node</code>为<code>leakObjectId</code>，期间经过的所有Node对象连在一起就是一次完整的引用路径。</p>
<p>最终得到的就是<code>泄漏对象 到 GC Roots对象</code>的引用路径。</p>
</blockquote>
<h6 id="deduplicateShortestPaths"><a href="#deduplicateShortestPaths" class="headerlink" title="deduplicateShortestPaths"></a>deduplicateShortestPaths</h6><blockquote>
<p>根据多条引用路径，进行裁剪得到最短的引用路径</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> deduplicateShortestPaths(<br>  inputPathResults: List&lt;ReferencePathNode&gt;<br>): List&lt;ShortestPath&gt; &#123;<br>  //根节点为0<br>  <span class="hljs-keyword">val</span> rootTrieNode = ParentNode(0)<br><br>  inputPathResults.forEach &#123; pathNode -&gt;<br>    // Go through the linked list of nodes and build the reverse list of instances from<br>    // root to leaking.<br>    <span class="hljs-keyword">val</span> path = mutableListOf&lt;<span class="hljs-built_in">Long</span>&gt;()<br>    <span class="hljs-keyword">var</span> leakNode: ReferencePathNode = pathNode<br>    <span class="hljs-keyword">while</span> (leakNode <span class="hljs-keyword">is</span> ChildNode) &#123;<br>      path.add(0, leakNode.objectId)<br>      leakNode = leakNode.parent<br>    &#125;<br>    path.add(0, leakNode.objectId)<br>    updateTrie(pathNode, path, 0, rootTrieNode)<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> updateTrie(<br>  pathNode: ReferencePathNode,<br>  path: List&lt;<span class="hljs-built_in">Long</span>&gt;,<br>  pathIndex: <span class="hljs-built_in">Int</span>,<br>  parentNode: ParentNode<br>) &#123;<br>  <span class="hljs-keyword">val</span> objectId = path[pathIndex]<br>  <span class="hljs-keyword">if</span> (pathIndex == path.lastIndex) &#123;<br>    parentNode.children[objectId] = LeafNode(objectId, pathNode)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">val</span> childNode = parentNode.children[objectId] ?: &#123;<br>      <span class="hljs-keyword">val</span> newChildNode = ParentNode(objectId)<br>      parentNode.children[objectId] = newChildNode<br>      newChildNode<br>    &#125;()<br>    <span class="hljs-keyword">if</span> (childNode <span class="hljs-keyword">is</span> ParentNode) &#123;<br>      updateTrie(pathNode, path, pathIndex + 1, childNode)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总体思路：</p>
<blockquote>
<p>一个对象被很多对象引用是很正常的行为，所以<code>泄漏对象</code>和<code>GC Roots对象</code>之间可能存在多条引用路径，此时就需要进行裁剪得到最短的引用路径方便分析。</p>
<p>将路径反转成为<code>GC Roots对象 到 泄漏对象</code>的的引用路径，然后通过<code>updateTrie()</code>转化成为无效Node为根节点的树，最后经过<code>深度优先遍历</code>得到从<code>根节点</code>到<code>叶子节点</code>的所有路径，即为最终的<code>最短引用路径</code>。</p>
<p><code>深度优先遍历</code>：从树的根节点开始，先遍历左子树再遍历右子树。<strong>借助栈结构实现</strong>。</p>
</blockquote>
<h6 id="buildLeakTraces"><a href="#buildLeakTraces" class="headerlink" title="buildLeakTraces"></a>buildLeakTraces</h6><blockquote>
<p>建立泄漏路径</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//HeapAnalzer.kt<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> buildLeakTraces(<br>    shortestPaths: List&lt;ShortestPath&gt;,<br>    inspectedObjectsByPath: List&lt;List&lt;InspectedObject&gt;&gt;,<br>    retainedSizes: Map&lt;<span class="hljs-built_in">Long</span>, Pair&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>&gt;&gt;?<br>  ): Pair&lt;List&lt;ApplicationLeak&gt;, List&lt;LibraryLeak&gt;&gt; &#123;<br>    ...<br>    shortestPaths.forEachIndexed &#123; pathIndex, shortestPath -&gt;<br>      <span class="hljs-keyword">val</span> inspectedObjects = inspectedObjectsByPath[pathIndex]<br>      //构建内存泄漏对象<br>      <span class="hljs-keyword">val</span> leakTraceObjects = buildLeakTraceObjects(inspectedObjects, retainedSizes)<br>      //构建引用路径<br>      <span class="hljs-keyword">val</span> referencePath = buildReferencePath(shortestPath.childPath, leakTraceObjects)<br><br>      <span class="hljs-keyword">val</span> leakTrace = LeakTrace(<br>          gcRootType = GcRootType.fromGcRoot(shortestPath.root.gcRoot),<br>          referencePath = referencePath,<br>          leakingObject = leakTraceObjects.last()<br>      )<br><br>      <span class="hljs-keyword">val</span> firstLibraryLeakNode = <span class="hljs-keyword">if</span> (shortestPath.root <span class="hljs-keyword">is</span> LibraryLeakNode) &#123;<br>        shortestPath.root<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        shortestPath.childPath.firstOrNull &#123; it <span class="hljs-keyword">is</span> LibraryLeakNode &#125; <span class="hljs-keyword">as</span> LibraryLeakNode?<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (firstLibraryLeakNode != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">val</span> matcher = firstLibraryLeakNode.matcher<br>        <span class="hljs-keyword">val</span> signature: String = matcher.pattern.toString()<br>            .createSHA1Hash()<br>        libraryLeaksMap.getOrPut(signature) &#123; matcher to mutableListOf() &#125;<br>            .second += leakTrace<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        //添加到 应用内存泄漏列表中<br>        applicationLeaksMap.getOrPut(leakTrace.signature) &#123; mutableListOf() &#125; += leakTrace<br>      &#125;<br>    &#125;    <br>    <br>  &#125;<br></code></pre></td></tr></table></figure>
<p>最终构建得到<code>ApplicationLeak</code>和<code>LibraryLeak</code>，组装得到<code>HeapAnalysis</code></p>
<ul>
<li><p><code>ApplicationLeak</code>：在开发工程中应用自身导致的内存泄漏</p>
</li>
<li><p><code>LibraryLeak</code>：<code>is a Leak caused by a known bug in third party code that you do not have control over.</code>已知的系统内存泄漏问题。</p>
<p><a href="https://github.com/square/leakcanary/pull/1785" target="_blank" rel="noopener">Explain Library Leaks in fundamentals</a></p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//HeapAnalyzerService.kt<br><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> onHandleIntentInForeground(intent: Intent?) &#123;<br>    <span class="hljs-keyword">if</span> (intent == <span class="hljs-literal">null</span> || !intent.hasExtra(HEAPDUMP_FILE_EXTRA)) &#123;<br>      SharkLog.d &#123; "HeapAnalyzerService received a <span class="hljs-literal">null</span> or empty intent, ignoring." &#125;<br>      return<br>    &#125;<br><br>    // Since we're running <span class="hljs-keyword">in</span> the main process we should be careful not to impact it.<br>    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)<br>    <span class="hljs-keyword">val</span> heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) <span class="hljs-keyword">as</span> File<br>    <span class="hljs-keyword">val</span> heapDumpDurationMillis = intent.getLongExtra(HEAPDUMP_DURATION_MILLIS, -1)<br>//获取 LeakCanary的配置<br>    <span class="hljs-keyword">val</span> config = LeakCanary.config<br>    <span class="hljs-keyword">val</span> heapAnalysis = <span class="hljs-keyword">if</span> (heapDumpFile.exists()) &#123;<br>      //解析 hprof文件<br>      analyzeHeap(heapDumpFile, config)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      missingFileFailure(heapDumpFile)<br>    &#125;<br>    <span class="hljs-keyword">val</span> fullHeapAnalysis = <span class="hljs-keyword">when</span> (heapAnalysis) &#123;<br>      <span class="hljs-keyword">is</span> HeapAnalysisSuccess -&gt; heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)<br>      <span class="hljs-keyword">is</span> HeapAnalysisFailure -&gt; heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)<br>    &#125;<br>    onAnalysisProgress(REPORTING_HEAP_ANALYSIS)<br>  //解析完成后 回调 onHeapAnalyzed<br>    config.onHeapAnalyzedListener.onHeapAnalyzed(fullHeapAnalysis)<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>解析完成后，回调到<code>onHeapAnalyzedListener</code>中的<code>onHeapAnalyzed()</code>.</p>
<p>其中<code>config</code>配置的<code>onHeapAnalyzedListener</code>为<code>DefaultOnHeapAnalyzedListener</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//DefaultOnHeapAnalyzedListener.kt<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> onHeapAnalyzed(heapAnalysis: HeapAnalysis) &#123;<br>    SharkLog.d &#123; "\u200B\n$&#123;LeakTraceWrapper.wrap(heapAnalysis.toString(), 120)&#125;" &#125;<br><br>    <span class="hljs-keyword">val</span> id = LeaksDbHelper(application).writableDatabase.use &#123; db -&gt;<br>      HeapAnalysisTable.insert(db, heapAnalysis)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> (contentTitle, screenToShow) = <span class="hljs-keyword">when</span> (heapAnalysis) &#123;<br>      <span class="hljs-keyword">is</span> HeapAnalysisFailure -&gt; application.getString(<br>          R.string.leak_canary_analysis_failed<br>      ) to HeapAnalysisFailureScreen(id)<br>      <span class="hljs-keyword">is</span> HeapAnalysisSuccess -&gt; &#123;<br>        <span class="hljs-keyword">val</span> retainedObjectCount = heapAnalysis.allLeaks.sumBy &#123; it.leakTraces.size &#125;<br>        <span class="hljs-keyword">val</span> leakTypeCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size<br>        application.getString(<br>            R.string.leak_canary_analysis_success_notification, retainedObjectCount, leakTypeCount<br>        ) to HeapDumpScreen(id)<br>      &#125;<br>    &#125;<br><br>    //显示通知 提示已经解析完毕<br>      showNotification(screenToShow, contentTitle)<br><br>  &#125;<br></code></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.LeakCanary整套流程从<code>注册监听Activity/Fragment对象生命周期</code>开始，当对应组件销毁时<code>添加对应组件的观察</code>。</p>
<ul>
<li>在<code>onActivityDestroyed()</code>添加对<code>Activity</code>的观察</li>
<li>在<code>onFragmentViewDestroyed()</code>添加对<code>Fragment中的View</code>的观察</li>
<li>在<code>onFragmentDestroyed()</code>添加对<code>Fragment</code>的观察</li>
<li>可以通过<code>AppWatcher.objectWatcher.watch(XX)</code>添加自定义对象的观察。</li>
</ul>
<p>2.在<code>泄漏检测</code>时，通过<code>WeakRefrence</code>包装<code>被观察的对象</code>，然后等待<strong>5s</strong>后，检查与<code>WeakReference</code>绑定的<code>ReferenceQueue</code>中是否包含<code>被观察对象</code>，若包含表示<code>被观察对象</code>已被回收；否则，判断对象可能泄漏。<em>5s并不一定是执行了GC，只是一个估值，一般都会触发GC。</em></p>
<p>3.在<code>准备DumpHeap</code>前，还会再去<code>手动执行一次GC</code>，等待<strong>100ms</strong>后如果还存在<code>泄漏对象</code>，就需要准备dump内存数据。此时有一个阈值，如果泄漏对象超过<strong>5个</strong>，才会去dump，避免频繁执行dump流程。</p>
<p>4.通过执行<code>Debug.dumpHprofData()</code>去生成<code>Hprof文件</code>，等待<code>Hprof文件</code>生成后，发送到<code>HeapAnalyzerService</code>去处理该文件。</p>
<p>5.<code>HeapAnalyzerService</code>收到<code>Hprof文件</code>后，通过<strong>Shark</strong>对文件进行解析，按照<code>Hprof文件格式</code>进行解析，解析得到<code>HprofHeapGraph</code>对象，内部包含<code>gcRoots</code>、<code>instances</code>、<code>classes</code>、<code>objects</code>等集合，可以快速定位泄漏对象。</p>
<p>6.得到<code>HprofHeapGraph</code>对象后，开始分析内存泄漏的最短路径。<em>内存泄漏的对象仍然与GC Roots对象保持可达的引用路径，导致GC无法释放。——一般用的都是<code>可达性分析</code></em>。</p>
<ul>
<li><code>寻找内存泄漏对象</code>：在<code>instances</code>集合中寻找<code>instanceClassId</code>为<code>KeyedWeakReferences</code>的对象，这些就是前面所观察的对象。</li>
<li><code>寻找所有内存泄漏对象与GC Roots对象的引用路径</code>：采用<code>广度优先遍历</code>，从<code>Gc Roots对象</code>开始遍历到<code>内存泄漏对象</code>的所有引用路径</li>
<li><code>裁剪所有路径得到 最短引用路径</code>：采用<code>深度优先遍历</code>，得到<code>内存泄漏对象</code>到<code>GC Roots对象</code>的最短引用路径</li>
<li><code>通知内存泄漏检测完毕</code>：将<code>最短引用路径</code>包装成<code>LeakTrace</code>，按照<strong>是否为应用自身导致的内存泄漏</strong>分为两个对象：<code>ApplicationLeak</code>和<code>LibraryLeak</code>。</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://square.github.io/leakcanary/getting_started/" target="_blank" rel="noopener">LeakCanary Wiki</a></p>
<p><a href="https://linjiang.tech/2019/12/25/leakcanary/" target="_blank" rel="noopener">LeakCanary解析</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/10/27/Android-硬件加速/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android硬件加速</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/12/Android-动画-属性动画/">
                        <span class="hidden-mobile">Android动画-属性动画</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
