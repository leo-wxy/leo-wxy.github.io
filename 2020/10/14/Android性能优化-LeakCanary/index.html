

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <meta name="description" content="LeakCanary主要用来进行内存泄漏检测，并且可以直观的展示泄漏的路径  如何使用1234dependencies &amp;#123;  // debugImplementation because LeakCanary should only run in debug builds.  debugImplementation &apos;com.squareup.leakcanary:leakcanary-">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android性能优化-LeakCanary">
<meta property="og:url" content="https://leo-wxy.github.io/2020/10/14/Android性能优化-LeakCanary/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="LeakCanary主要用来进行内存泄漏检测，并且可以直观的展示泄漏的路径  如何使用1234dependencies &amp;#123;  // debugImplementation because LeakCanary should only run in debug builds.  debugImplementation &apos;com.squareup.leakcanary:leakcanary-">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://leo-wxy.github.io/images/LeakCanary初始化.jpg">
<meta property="og:updated_time" content="2020-12-18T06:53:12.000Z">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Android性能优化-LeakCanary">
<meta name="twitter:description" content="LeakCanary主要用来进行内存泄漏检测，并且可以直观的展示泄漏的路径  如何使用1234dependencies &amp;#123;  // debugImplementation because LeakCanary should only run in debug builds.  debugImplementation &apos;com.squareup.leakcanary:leakcanary-">
<meta name="twitter:image" content="https://leo-wxy.github.io/images/LeakCanary初始化.jpg">
  
  <title>Android性能优化-LeakCanary - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.12","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android性能优化-LeakCanary">
              
                Android性能优化-LeakCanary
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-14 14:45" pubdate>
        2020年10月14日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      30k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      94 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android性能优化-LeakCanary</h1>
            
            <div class="markdown-body">
              <blockquote><p>LeakCanary主要用来<strong>进行内存泄漏检测</strong>，并且可以直观的展示泄漏的路径</p>
</blockquote>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  <span class="hljs-comment">// debugImplementation because LeakCanary should only run in debug builds.</span><br>  debugImplementation <span class="hljs-string">'com.squareup.leakcanary:leakcanary-android:2.5'</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置完成后，<code>LeakCanary</code>通过<code>ContentProvider</code>进行注册以及初始化。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//AppWatcherInstaller.kt</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppWatcherInstaller</span> : <span class="hljs-type">ContentProvider</span></span>() &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> application = context!!.applicationContext <span class="hljs-keyword">as</span> Application<br>    AppWatcher.manualInstall(application)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>涉及的部分Activity启动过程源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ActivityThread.java</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleBindApplication</span><span class="hljs-params">(AppBindData data)</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">//获取LoaderApk对象</span><br>  data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);<br>  <span class="hljs-comment">//创建进程对应的Android运行环境ContextImpl</span><br>  <span class="hljs-keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="hljs-keyword">this</span>, data.info);<br>  ...<br>  <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//准备创建Application对象</span><br>            Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);<br>            mInitialApplication = app;<br>            ...<br>             <span class="hljs-comment">//加载对应进程中的ContentProvider</span><br>            installContentProviders(app, data.providers);<br>            <span class="hljs-keyword">try</span> &#123;<br>                mInstrumentation.onCreate(data.instrumentationArgs);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                    <span class="hljs-string">"Exception thrown in onCreate() of "</span><br>                    + data.instrumentationName + <span class="hljs-string">": "</span> + e.toString(), e);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//调用Application的onCreate方法</span><br>                mInstrumentation.callApplicationOnCreate(app);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                        <span class="hljs-string">"Unable to create application "</span> + app.getClass().getName()<br>                        + <span class="hljs-string">": "</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            StrictMode.setThreadPolicy(savedPolicy);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>handleBindApplication()</code>进行<code>ContentProvider</code>的启动，此时<code>AppWatcherInstaller</code>会在此时启动。</p>
<p>向下调用到<code>AppWatcher.manualInstall(application)</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//AppWatcher.kt</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manualInstall</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>    InternalAppWatcher.install(application)<br>  &#125;<br><br><span class="hljs-comment">//InternalAppWatcher.kt</span><br><span class="hljs-comment">//开始了初始化流程</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>    <span class="hljs-comment">//初始化</span><br>  &#125;<br></code></pre></td></tr></table></figure>
<p>到此基本的<code>LeakCanary</code>初始化完毕</p>
<h3 id="主动添加内存泄漏监控"><a href="#主动添加内存泄漏监控" class="headerlink" title="主动添加内存泄漏监控"></a>主动添加内存泄漏监控</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">AppWatcher.objectWatcher.watch(watchObject,reason)<br></code></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h3><p>在初始化过程执行的<code>注册监听</code>过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//InternalAppWatcher.kt</span><br><span class="hljs-comment">//开始了初始化流程</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>    checkMainThread()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>::application.isInitialized) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    InternalAppWatcher.application = application<br>    <span class="hljs-keyword">if</span> (isDebuggableBuild) &#123;<br>      SharkLog.logger = DefaultCanaryLog()<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> configProvider = &#123; AppWatcher.config &#125;<br>    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)<br>    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)<br>    onAppWatcherInstalled(application)<br>  &#125;<br></code></pre></td></tr></table></figure>
<h4 id="监听Activity"><a href="#监听Activity" class="headerlink" title="监听Activity"></a>监听Activity</h4><p><code>ActivityDestroyWatcher.install</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityDestroyWatcher</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> objectWatcher: ObjectWatcher,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> configProvider: () -&gt; Config<br>) &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>        <span class="hljs-comment">//监听Activity onDestroy()生命周期</span><br>        <span class="hljs-keyword">if</span> (configProvider().watchActivities) &#123;<br>          objectWatcher.watch(<br>              activity, <span class="hljs-string">"<span class="hljs-subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback"</span><br>          )<br>        &#125;<br>      &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(<br>      application: <span class="hljs-type">Application</span>,<br>      objectWatcher: <span class="hljs-type">ObjectWatcher</span>,<br>      configProvider: () -&gt; <span class="hljs-type">Config</span><br>    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> activityDestroyWatcher =<br>        ActivityDestroyWatcher(objectWatcher, configProvider)<br>      <span class="hljs-comment">//往Application添加Activity生命周期回调监听</span><br>      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要是为了注册Activity的生命周期回调，监测到<code>onActivityDestroyed()</code>之后，将Activity加入到<code>objectWatcher</code>中</p>
<h4 id="监听Fragment"><a href="#监听Fragment" class="headerlink" title="监听Fragment"></a>监听Fragment</h4><p><code>FragmentDestroyWatcher.install</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> FragmentDestroyWatcher &#123;<br>  <br>  <span class="hljs-comment">//AndroidX fragment相关配置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ANDROIDX_FRAGMENT_CLASS_NAME = <span class="hljs-string">"androidx.fragment.app.Fragment"</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =<br>    <span class="hljs-string">"leakcanary.internal.AndroidXFragmentDestroyWatcher"</span><br>  <br>  <br>  <span class="hljs-comment">//supprt fragment相关配置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> ANDROID_SUPPORT_FRAGMENT_CLASS_NAME =<br>    StringBuilder(<span class="hljs-string">"android."</span>).append(<span class="hljs-string">"support.v4.app.Fragment"</span>)<br>        .toString()<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =<br>    <span class="hljs-string">"leakcanary.internal.AndroidSupportFragmentDestroyWatcher"</span><br><br>  <br>  ...<br>   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(<br>    application: <span class="hljs-type">Application</span>,<br>    objectWatcher: <span class="hljs-type">ObjectWatcher</span>,<br>    configProvider: () -&gt; <span class="hljs-type">AppWatcher</span>.<span class="hljs-type">Config</span><br>  )</span></span> &#123;<br>    <span class="hljs-keyword">val</span> fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; <span class="hljs-built_in">Unit</span>&gt;()<br><br>     <span class="hljs-comment">//Android 8.0及以上 直接构造 AndroidOFragmentDestroyWatcher</span><br>    <span class="hljs-keyword">if</span> (SDK_INT &gt;= O) &#123;<br>      fragmentDestroyWatchers.add(<br>          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)<br>      )<br>    &#125;<br><br>     <span class="hljs-comment">//androidx fragment对象 </span><br>    getWatcherIfAvailable(<br>        ANDROIDX_FRAGMENT_CLASS_NAME,<br>        ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<br>        objectWatcher,<br>        configProvider<br>    )?.let &#123;<br>      fragmentDestroyWatchers.add(it)<br>    &#125;<br><br>     <span class="hljs-comment">//fragment相关配置</span><br>    getWatcherIfAvailable(<br>        ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,<br>        ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<br>        objectWatcher,<br>        configProvider<br>    )?.let &#123;<br>      fragmentDestroyWatchers.add(it)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fragmentDestroyWatchers.size == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    application.registerActivityLifecycleCallbacks(<span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(<br>        activity: <span class="hljs-type">Activity</span>,<br>        savedInstanceState: <span class="hljs-type">Bundle</span>?<br>      )</span></span> &#123;<br>        <span class="hljs-comment">//在Activity创建时 添加Fragment的监听</span><br>        <span class="hljs-keyword">for</span> (watcher <span class="hljs-keyword">in</span> fragmentDestroyWatchers) &#123;<br>          <span class="hljs-comment">//调用到 对应的 invoke()</span><br>          watcher(activity)<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据上述源码，<code>FragmentDestroyWatcher</code>按照三种情况进行区分：</p>
<ul>
<li>Android O 及以上版本的fragment：<code>AndroidOFragmentDestroyWatcher</code></li>
<li>AndroidX 的fragment：<code>AndroidXFragmentDestroyWatcher</code></li>
<li>Android support 的 fragment：<code>AndroidSupportFragmentDestroyWatcher</code></li>
</ul>
<p>上述三种实现基本一致，只是对引用的<code>fragment</code>进行了区分，下面拿<code>AndroidSupportFragmentDestroyWatcher</code>进行分析</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//AndroidSupportFragmentDestroyWatcher.kt</span><br><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidSupportFragmentDestroyWatcher</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> objectWatcher: ObjectWatcher,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> configProvider: () -&gt; Config<br>) : (Activity) -&gt; <span class="hljs-built_in">Unit</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentLifecycleCallbacks = <span class="hljs-keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentViewDestroyed</span><span class="hljs-params">(<br>      fm: <span class="hljs-type">FragmentManager</span>,<br>      fragment: <span class="hljs-type">Fragment</span><br>    )</span></span> &#123;<br>      <span class="hljs-comment">//添加了对fragment引用的View的泄漏监听</span><br>      <span class="hljs-keyword">val</span> view = fragment.view<br>      <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span> &amp;&amp; configProvider().watchFragmentViews) &#123;<br>        objectWatcher.watch(<br>            view, <span class="hljs-string">"<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback "</span> +<br>            <span class="hljs-string">"(references to its views should be cleared to prevent leaks)"</span><br>        )<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentDestroyed</span><span class="hljs-params">(<br>      fm: <span class="hljs-type">FragmentManager</span>,<br>      fragment: <span class="hljs-type">Fragment</span><br>    )</span></span> &#123;<br>      <span class="hljs-keyword">if</span> (configProvider().watchFragments) &#123;<br>        <span class="hljs-comment">//添加对 fragment的泄漏监听</span><br>        objectWatcher.watch(<br>            fragment, <span class="hljs-string">"<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback"</span><br>        )<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">is</span> FragmentActivity) &#123;<br>      <span class="hljs-comment">//针对 fragmentManager 添加 fragmentlifecyclecallback监听</span><br>      <span class="hljs-keyword">val</span> supportFragmentManager = activity.supportFragmentManager<br>      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="hljs-literal">true</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要是在<code>FragmentManager</code>调用<code>registerFragmentLifecycleCallbacks()</code>添加生命周期监听。</p>
<ul>
<li>在<code>onFragmentViewDestroyed()</code>添加<code>View</code>的监听</li>
<li>在<code>onFragmentDestroyed()</code>添加<code>Fragment</code>的监听</li>
</ul>
<p>最后在<code>registerActivityLifecycleCallbacks()</code>的每个Activity的<code>onActivityCreated()</code>中执行<code>Fragment</code>的生命周期监听。</p>
<p>此时<code>objectWatcher</code>对象就已经监听到了如下实例：</p>
<ul>
<li>Activity</li>
<li>Fragment</li>
<li>Fragment中的View</li>
</ul>
<h4 id="InternalLeakCanary"><a href="#InternalLeakCanary" class="headerlink" title="InternalLeakCanary"></a>InternalLeakCanary</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//InternalappWatcher.kt</span><br>  <span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-keyword">val</span> internalLeakCanary = <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> leakCanaryListener = Class.forName(<span class="hljs-string">"leakcanary.internal.InternalLeakCanary"</span>)<br>      leakCanaryListener.getDeclaredField(<span class="hljs-string">"INSTANCE"</span>)<br>          .<span class="hljs-keyword">get</span>(<span class="hljs-literal">null</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>      NoLeakCanary<br>    &#125;<br>    <span class="hljs-meta">@kotlin</span>.Suppress(<span class="hljs-string">"UNCHECKED_CAST"</span>)<br>    onAppWatcherInstalled = internalLeakCanary <span class="hljs-keyword">as</span> (Application) -&gt; <span class="hljs-built_in">Unit</span><br>  &#125;<br></code></pre></td></tr></table></figure>
<p>最后执行的<code>onAppWatcherInstalled()</code>的实现类就是<code>InternalLeakCanary</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//InternalLeakCanary.kt</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>    _application = application<br><br>    checkRunningInDebuggableBuild()<br><br>    <span class="hljs-comment">//注册监听对象 可能泄漏的消息</span><br>    AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-keyword">val</span> heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application))<br><br>    <span class="hljs-keyword">val</span> gcTrigger = GcTrigger.Default<br><br>    <span class="hljs-keyword">val</span> configProvider = &#123; LeakCanary.config &#125;<br><br>    <span class="hljs-keyword">val</span> handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)<br>    handlerThread.start()<br>    <span class="hljs-keyword">val</span> backgroundHandler = Handler(handlerThread.looper)<br><br>    <span class="hljs-comment">//dump内存</span><br>    heapDumpTrigger = HeapDumpTrigger(<br>        application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,<br>        configProvider<br>    )<br>    application.registerVisibilityListener &#123; applicationVisible -&gt;<br>      <span class="hljs-keyword">this</span>.applicationVisible = applicationVisible<br>      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)<br>    &#125;<br>    registerResumedActivityListener(application)<br>    <span class="hljs-comment">//添加桌面的快捷入口</span><br>    addDynamicShortcut(application)<br><br>    <span class="hljs-comment">// We post so that the log happens after Application.onCreate()</span><br>    Handler().post &#123;<br>      SharkLog.d &#123;<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()) &#123;<br>          <span class="hljs-keyword">is</span> Yup -&gt; application.getString(R.string.leak_canary_heap_dump_enabled_text)<br>          <span class="hljs-keyword">is</span> Nope -&gt; application.getString(<br>              R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()<br>          )<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>InternalLeakCanary</code>主要负责接收<code>objectWatcher</code>通知的<code>可能存在的内存泄漏</code>消息并驱动<code>heapDumpTrigger</code>进行<code>Dump</code>过程。</p>
<p>得到最终产出的<code>Hprof文件</code>去进行分析的流程。</p>
<p><img src="/images/LeakCanary初始化.jpg" srcset="/img/loading.gif" lazyload alt="LeakCanary初始化"></p>
<h3 id="泄漏检测"><a href="#泄漏检测" class="headerlink" title="泄漏检测"></a>泄漏检测</h3><p>根据上节分析可知，所有需要监控的对象都会通过<code>objectWatcher.watch()</code>进行对象监听</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//监测引用队列间隔</span><br><span class="hljs-keyword">val</span> watchDurationMillis: <span class="hljs-built_in">Long</span> = TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>),<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkRetainedExecutor = Executor &#123;<br>    mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)<br>  &#125;<br><br><span class="hljs-keyword">val</span> objectWatcher = ObjectWatcher(<br>      clock = clock,<br>      checkRetainedExecutor = checkRetainedExecutor,<br>      isEnabled = &#123; <span class="hljs-literal">true</span> &#125;<br>  )<br></code></pre></td></tr></table></figure>
<p>实现类是<code>ObjectWatcher</code></p>
<h4 id="ObjectWatcher"><a href="#ObjectWatcher" class="headerlink" title="ObjectWatcher"></a>ObjectWatcher</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectWatcher</span> <span class="hljs-keyword">constructor</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clock: Clock,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkRetainedExecutor: Executor,<br>  <span class="hljs-comment">/**<br>   * Calls to [watch] will be ignored when [isEnabled] returns false<br>   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> isEnabled: () -&gt; <span class="hljs-built_in">Boolean</span> = &#123; <span class="hljs-literal">true</span> &#125;<br>) &#123;<br>  <span class="hljs-comment">//需要监听的弱引用对象实例</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()<br>  <span class="hljs-comment">//引用队列</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> queue = ReferenceQueue&lt;Any&gt;()<br>  <br>  ...<br>  <br>    <span class="hljs-meta">@Synchronized</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">watch</span><span class="hljs-params">(<br>    watchedObject: <span class="hljs-type">Any</span>,<br>    description: <span class="hljs-type">String</span><br>  )</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (!isEnabled()) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    removeWeaklyReachableObjects()<br>    <span class="hljs-keyword">val</span> key = UUID.randomUUID()<br>        .toString()<br>    <span class="hljs-keyword">val</span> watchUptimeMillis = clock.uptimeMillis()<br>      <span class="hljs-comment">//将需要监听的对象 构建一个弱引用实例</span><br>    <span class="hljs-keyword">val</span> reference =<br>      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)&#123;&#125;<br><br>    watchedObjects[key] = reference<br>      <span class="hljs-comment">//执行 checkExecutor任务</span><br>    checkRetainedExecutor.execute &#123;<br>      moveToRetained(key)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用<code>watch()</code>之后，将需要监听的对象添加弱引用(<code>WeakReference</code>)，再通过关联一个引用队列(<code>ReferenceQueue</code>)判断监听对象是否被回收。</p>
<blockquote>
<p>为什么选用弱引用？</p>
<p>除了强引用不会被回收外，还存在着<code>软引用</code>和<code>虚引用</code>。其中<code>软引用</code>必须在内存将满时才会被回收并加入到<code>ReferenceQueue</code>中，而<code>虚引用</code>在加入到<code>ReferenceQueue</code>时，内置的引用无法被清空。</p>
</blockquote>
<p>包装成弱引用对象后，执行<code>checkRetainedExecutor</code>的线程池，本质上执行的是<strong>等待5s后执行对象是否回收的判断。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetained</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br>  removeWeaklyReachableObjects()<br>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]<br>  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;<br>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeWeaklyReachableObjects</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span><br>  <span class="hljs-comment">// reachable. This is before finalization or garbage collection has actually happened.</span><br>  <span class="hljs-keyword">var</span> ref: KeyedWeakReference?<br>  <span class="hljs-keyword">do</span> &#123;<br>    ref = queue.poll() <span class="hljs-keyword">as</span> KeyedWeakReference?<br>    <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;<br>      watchedObjects.remove(ref.key)<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (ref != <span class="hljs-literal">null</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>watchedObjects</code>存放的就是<code>被观察的对象引用</code>，每次调用<code>watch()</code>都会发送一个延时5s的消息。</p>
<p>延时消息主要执行<code>moveToRetained()</code>，内部主要执行如下过程：</p>
<ol>
<li>遍历<code>queue(引用队列)</code>，将其中存在的对象从<code>watchedObjects</code>中移除，因为已经被回收</li>
<li>如果对象没有从<code>watchedObjects</code>中移除，就表示该对象发生了<code>内存泄漏</code></li>
</ol>
<h3 id="Dump出Hprof文件"><a href="#Dump出Hprof文件" class="headerlink" title="Dump出Hprof文件"></a>Dump出Hprof文件</h3><p>如果存在未被回收的对象，此时就会回调到<code>OnObjectRetainedListener.onObjectRetained()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> InternalLeakCanary : (Application) -&gt; <span class="hljs-built_in">Unit</span>, OnObjectRetainedListener &#123;<br>  ...<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>      <span class="hljs-comment">//添加回调监听注册</span><br>      AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="hljs-keyword">this</span>)<br>      ...<br>    &#125;<br>  <br>  <span class="hljs-comment">//实现的方法</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onObjectRetained</span><span class="hljs-params">()</span></span> = scheduleRetainedObjectCheck()  <br>  <br>  <br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//初始化完毕</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>::heapDumpTrigger.isInitialized) &#123;<br>      heapDumpTrigger.scheduleRetainedObjectCheck()<br>    &#125;<br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>切换到<code>HeapDumpTrigger</code>继续执行</p>
<h4 id="HeapDumpTrigger"><a href="#HeapDumpTrigger" class="headerlink" title="HeapDumpTrigger"></a>HeapDumpTrigger</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapDumpTrigger.kt </span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">(<br>    delayMillis: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>L<br>  )</span></span> &#123;<br>    <span class="hljs-keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt<br>    <span class="hljs-keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    checkScheduledAt = SystemClock.uptimeMillis() + delayMillis<br>    backgroundHandler.postDelayed(&#123;<br>      checkScheduledAt = <span class="hljs-number">0</span><br>      checkRetainedObjects()<br>    &#125;, delayMillis)<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkRetainedObjects</span><span class="hljs-params">()</span></span> &#123;<br>   ... <br>    <span class="hljs-comment">//获取未释放的对象数</span><br>    <span class="hljs-keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount<br><br>    <span class="hljs-keyword">if</span> (retainedReferenceCount &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">//手动执行一次GC</span><br>      gcTrigger.runGc()<br>      <span class="hljs-comment">//在获取一次 </span><br>      retainedReferenceCount = objectWatcher.retainedObjectCount<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否超过阈值，避免重复调用dump</span><br>    <span class="hljs-keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-comment">//dump内存生成 Hprof文件</span><br>        dumpHeap(retainedReferenceCount, retry = <span class="hljs-literal">true</span>)<br>    <br>  &#125;<br><br><span class="hljs-comment">//GcTrigger.kt</span><br>  <span class="hljs-keyword">object</span> Default : GcTrigger &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runGc</span><span class="hljs-params">()</span></span> &#123;<br>      Runtime.getRuntime()<br>          .gc()<br>      enqueueReferences()<br>      System.runFinalization()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueueReferences</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-comment">// Hack. We don't have a programmatic way to wait for the reference queue daemon to move</span><br>      <span class="hljs-comment">// references to the appropriate queues.</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">100</span>)<br>      &#125; <span class="hljs-keyword">catch</span> (e: InterruptedException) &#123;<br>        <span class="hljs-keyword">throw</span> AssertionError()<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>scheduleRetainedObjectCheck()</code>并不是直接去dump，而是先手动调用一次GC，然后再触发GC后等待<code>100ms</code>之后再去检测一次是否有对象未被回收。</p>
<p>其中判断过程还添加了<code>阈值(5)</code>，避免频繁触发<code>dumpHeap()</code>导致卡顿。</p>
<h4 id="dumpHeap"><a href="#dumpHeap" class="headerlink" title="dumpHeap()"></a>dumpHeap()</h4><p>主要负责dump 出 Hprof文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//InternalLeakCanary.kt</span><br>    <span class="hljs-keyword">val</span> heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application))<br><br><span class="hljs-comment">//HeapDumpTrigger.kt</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">(<br>    retainedReferenceCount: <span class="hljs-type">Int</span>,<br>    retry: <span class="hljs-type">Boolean</span><br>  )</span></span> &#123;<br>    saveResourceIdNamesToMemory()<br>    <span class="hljs-keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()<br>    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis<br>    <span class="hljs-comment">//开始执行dump过程</span><br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> heapDumpResult = heapDumper.dumpHeap()) &#123;<br>      <span class="hljs-keyword">is</span> NoHeapDump -&gt; &#123;<br>        ...<br>      &#125;<br>      <span class="hljs-keyword">is</span> HeapDump -&gt; &#123;<br>        lastDisplayedRetainedObjectCount = <span class="hljs-number">0</span><br>        lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()<br>        <span class="hljs-comment">//生成hprof文件</span><br>        objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)<br>        <span class="hljs-comment">//hprof文件生成完毕后，发送到HeapAnalyzeSerview</span><br>        HeapAnalyzerService.runAnalysis(<br>            context = application,<br>            heapDumpFile = heapDumpResult.file,<br>            heapDumpDurationMillis = heapDumpResult.durationMillis<br>        )<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>AndroidHeapDumper</code>去执行dump过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//AndroidHeapDumper.kt</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">()</span></span>: DumpHeapResult &#123;<br>    ...<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> durationMillis = measureDurationMillis &#123;<br>        <span class="hljs-comment">//执行dump过程</span><br>        Debug.dumpHprofData(heapDumpFile.absolutePath)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (heapDumpFile.length() == <span class="hljs-number">0L</span>) &#123;<br>        SharkLog.d &#123; <span class="hljs-string">"Dumped heap file is 0 byte length"</span> &#125;<br>        NoHeapDump<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        HeapDump(file = heapDumpFile, durationMillis = durationMillis)<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>      SharkLog.d(e) &#123; <span class="hljs-string">"Could not dump heap"</span> &#125;<br>      <span class="hljs-comment">// Abort heap dump</span><br>      NoHeapDump<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      cancelToast(toast)<br>      notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)<br>    &#125;<br>    <br>  &#125;<br></code></pre></td></tr></table></figure>
<p>主要是执行<code>Debug.dumpHprofData()</code>得到<code>Hprof文件</code>去进行内存分析。</p>
<h4 id="HeapAnalyzerService-runAnalysis"><a href="#HeapAnalyzerService-runAnalysis" class="headerlink" title="HeapAnalyzerService.runAnalysis()"></a>HeapAnalyzerService.runAnalysis()</h4><p>主要负责去分析Hprof文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapAnalyzerService.kt</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runAnalysis</span><span class="hljs-params">(<br>      context: <span class="hljs-type">Context</span>,<br>      heapDumpFile: <span class="hljs-type">File</span>,<br>      heapDumpDurationMillis: <span class="hljs-type">Long</span>? = <span class="hljs-literal">null</span><br>    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> intent = Intent(context, HeapAnalyzerService::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span><br>      <span class="hljs-comment">//携带文件地址 到 HeapAnalyzerService去进行分析</span><br>      intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)<br>      heapDumpDurationMillis?.let &#123;<br>        intent.putExtra(HEAPDUMP_DURATION_MILLIS, heapDumpDurationMillis)<br>      &#125;<br>      startForegroundService(context, intent)<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>接下来切换到<code>HeapAnalyzerService</code>开始进行Hprof文件解析流程。</p>
<h3 id="Hprof解析"><a href="#Hprof解析" class="headerlink" title="Hprof解析"></a>Hprof解析</h3><p>在<code>HeapAnalyzerService</code>收到传过来的Hprof文件地址后，就要开始解析</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapAnalyzerService  </span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">analyzeHeap</span><span class="hljs-params">(<br>    heapDumpFile: <span class="hljs-type">File</span>,<br>    config: <span class="hljs-type">Config</span><br>  )</span></span>: HeapAnalysis &#123;<br>    <span class="hljs-keyword">val</span> heapAnalyzer = HeapAnalyzer(<span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-keyword">val</span> proguardMappingReader = <span class="hljs-keyword">try</span> &#123;<br>      ProguardMappingReader(assets.<span class="hljs-keyword">open</span>(PROGUARD_MAPPING_FILE_NAME))<br>    &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>      <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> heapAnalyzer.analyze(<br>        heapDumpFile = heapDumpFile,<br>        leakingObjectFinder = config.leakingObjectFinder,<br>        referenceMatchers = config.referenceMatchers,<br>        computeRetainedHeapSize = config.computeRetainedHeapSize,<br>        objectInspectors = config.objectInspectors,<br>        metadataExtractor = config.metadataExtractor,<br>        proguardMapping = proguardMappingReader?.readProguardMapping()<br>    )<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>解析前需要了解一下<a href="/2020/12/14/Hprof文件解析/" title="Hprof结构">Hprof结构</a>，在此基础上进行Hprof解析的相关流程分析。</p>
<blockquote>
<p>简单说明一下Hprof的相关结构</p>
<p>主要分为两部分：</p>
<ul>
<li>Header：主要包含一些元信息，例如<code>文件协议的版本</code>、<code>开始</code>和<code>结束的时间戳</code>，以及<code>标识符大小</code></li>
<li>Record：主要结构为<code>TAG</code>、<code>TIME</code>、<code>LENGTH(BODY数据长度)</code>和<code>BODY</code><ul>
<li>TAG：表示<code>Record</code>类型，重要的有<code>HEAP_DUMP_SEGMENT</code>和<code>STRING</code>等</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="Shark-HeapAnalyzer"><a href="#Shark-HeapAnalyzer" class="headerlink" title="Shark.HeapAnalyzer"></a>Shark.HeapAnalyzer</h4><blockquote>
<p><code>Shark</code>是一款分析<code>Hprof文件</code>的工具，性能高且占用内存少，非常适合手机端的Hprof文件解析功能。</p>
<p>目的是<strong>提供快速解析Hprof文件和分析的能力。</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapAnalyzer.kt </span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">analyze</span><span class="hljs-params">(<br>    heapDumpFile: <span class="hljs-type">File</span>,<br>    leakingObjectFinder: <span class="hljs-type">LeakingObjectFinder</span>,<br>    referenceMatchers: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ReferenceMatcher</span>&gt; = emptyList()</span></span>,<br>    computeRetainedHeapSize: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,<br>    objectInspectors: List&lt;ObjectInspector&gt; = emptyList(),<br>    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,<br>    proguardMapping: ProguardMapping? = <span class="hljs-literal">null</span><br>  ): HeapAnalysis &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>      listener.onAnalysisProgress(PARSING_HEAP_DUMP)<br>      <span class="hljs-keyword">val</span> sourceProvider = ConstantMemoryMetricsDualSourceProvider(FileSourceProvider(heapDumpFile))<br>      sourceProvider.openHeapGraph(proguardMapping).use &#123; graph -&gt;<br>       <span class="hljs-comment">//                                                  </span><br>        <span class="hljs-keyword">val</span> helpers =<br>          FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)<br>        <span class="hljs-keyword">val</span> result = helpers.analyzeGraph(<br>            metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime<br>        )<br>        result.copy(metadata = result.metadata + (<span class="hljs-string">"Stats"</span> to stats))<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (exception: Throwable) &#123;<br><br>    &#125;  <br>    <br>  &#125;<br></code></pre></td></tr></table></figure>
<h5 id="openHeapGraph"><a href="#openHeapGraph" class="headerlink" title="openHeapGraph"></a>openHeapGraph</h5><p>主要用来按照格式解析Hprof文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HprofHeapGraph.kt</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> DualSourceProvider.<span class="hljs-title">openHeapGraph</span><span class="hljs-params">(<br>      proguardMapping: <span class="hljs-type">ProguardMapping</span>? = <span class="hljs-literal">null</span>,<br>      indexedGcRootTypes: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt; = HprofIndex.defaultIndexedGcRootTags()</span></span><br>    ): CloseableHeapGraph &#123;<br>      <span class="hljs-comment">//主要负责解析 Hprof head部分的数据</span><br>      <span class="hljs-keyword">val</span> header = openStreamingSource().use &#123; HprofHeader.parseHeaderOf(it) &#125;<br>      <span class="hljs-keyword">val</span> index = HprofIndex.indexRecordsOf(<span class="hljs-keyword">this</span>, header, proguardMapping, indexedGcRootTypes)<br>      <span class="hljs-keyword">return</span> index.openHeapGraph()<br>    &#125;<br><br><span class="hljs-comment">//HprofIndex.kt</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">indexRecordsOf</span><span class="hljs-params">(<br>      hprofSourceProvider: <span class="hljs-type">DualSourceProvider</span>,<br>      hprofHeader: <span class="hljs-type">HprofHeader</span>,<br>      proguardMapping: <span class="hljs-type">ProguardMapping</span>? = <span class="hljs-literal">null</span>,<br>      indexedGcRootTags: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt; = defaultIndexedGcRootTags()</span></span><br>    ): HprofIndex &#123;<br>      <span class="hljs-keyword">val</span> reader = StreamingHprofReader.readerFor(hprofSourceProvider, hprofHeader)<br>      <span class="hljs-keyword">val</span> index = HprofInMemoryIndex.indexHprof(<br>          reader = reader,<br>          hprofHeader = hprofHeader,<br>          proguardMapping = proguardMapping,<br>          indexedGcRootTags = indexedGcRootTags<br>      )<br>      <span class="hljs-keyword">return</span> HprofIndex(hprofSourceProvider, hprofHeader, index)<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>将Hprof中的<code>Record</code>解析成<code>HprofMemoryIndex</code>，将Record按照Tag进行分析和计数，并通过特定规则进行排序。</p>
<p>最终通过<code>openHeapGraph()</code>组合得到<code>HprofHeapGraph</code>对象，等价于<code>Hprof文件</code>转换成了<code>HprofHeapGraph</code>对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HprofHeapGraph.kt</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HprofHeapGraph</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">constructor</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> header: HprofHeader,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reader: RandomAccessHprofReader,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> index: HprofInMemoryIndex<br>) : CloseableHeapGraph &#123;<br>  <br>  ...<br>  <span class="hljs-comment">//缓存可以成为 GC Roots的对象</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> gcRoots: List&lt;GcRoot&gt;<br>    <span class="hljs-keyword">get</span>() = index.gcRoots()<br>  <br>  <span class="hljs-comment">//记录的是所有对象</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> objects: Sequence&lt;HeapObject&gt;<br>  <br>  <span class="hljs-comment">//对应TAG为 CLASS_DUMP</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> classes: Sequence&lt;HeapClass&gt;<br>  <br>  <span class="hljs-comment">//对应TAG为 INSTANCE_DUMP</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> instances: Sequence&lt;HeapInstance&gt;<br>  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>内部主要包括了<code>gcRoots</code>、<code>objects</code>、<code>classes</code>和<code>instances</code>几种集合，可以快速定位dump堆中的对象。</p>
<h5 id="FindLeakInput"><a href="#FindLeakInput" class="headerlink" title="FindLeakInput"></a>FindLeakInput</h5><p>主要分析泄漏对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">///HeapAnalyzer.kt</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">analyze</span><span class="hljs-params">(<br>    heapDumpFile: <span class="hljs-type">File</span>,<br>    graph: <span class="hljs-type">HeapGraph</span>,<br>    leakingObjectFinder: <span class="hljs-type">LeakingObjectFinder</span>,<br>    referenceMatchers: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ReferenceMatcher</span>&gt; = emptyList()</span></span>,<br>    computeRetainedHeapSize: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,<br>    objectInspectors: List&lt;ObjectInspector&gt; = emptyList(),<br>    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP<br>  ): HeapAnalysis &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> helpers =<br>        FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)<br>      helpers.analyzeGraph(<br>          metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime<br>      )<br>    &#125; <span class="hljs-keyword">catch</span> (exception: Throwable) &#123;<br>      )<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>接下来执行到<code>analyzeGraph</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">analyzeGraph</span><span class="hljs-params">(<br>  metadataExtractor: <span class="hljs-type">MetadataExtractor</span>,<br>  leakingObjectFinder: <span class="hljs-type">LeakingObjectFinder</span>,<br>  heapDumpFile: <span class="hljs-type">File</span>,<br>  analysisStartNanoTime: <span class="hljs-type">Long</span><br>)</span></span>: HeapAnalysisSuccess &#123;<br>  listener.onAnalysisProgress(EXTRACTING_METADATA)<br>  <span class="hljs-keyword">val</span> metadata = metadataExtractor.extractMetadata(graph)<br><br>  listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)<br>  <span class="hljs-keyword">val</span> leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)<br><br>  <span class="hljs-keyword">val</span> (applicationLeaks, libraryLeaks) = findLeaks(leakingObjectIds)<br>  <br>  <span class="hljs-keyword">return</span> HeapAnalysisSuccess(<br>      heapDumpFile = heapDumpFile,<br>      createdAtTimeMillis = System.currentTimeMillis(),<br>      analysisDurationMillis = since(analysisStartNanoTime),<br>      metadata = metadata,<br>      applicationLeaks = applicationLeaks,<br>      libraryLeaks = libraryLeaks<br>  )    <br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">findLeaks</span><span class="hljs-params">(leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;)</span></span>: Pair&lt;List&lt;ApplicationLeak&gt;, List&lt;LibraryLeak&gt;&gt; &#123;<br>  <span class="hljs-keyword">val</span> pathFinder = PathFinder(graph, listener, referenceMatchers)<br>  <span class="hljs-keyword">val</span> pathFindingResults =<br>    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)<br>  <span class="hljs-comment">//找寻最短路径</span><br>  <span class="hljs-keyword">val</span> shortestPaths =<br>    deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)<br>  <span class="hljs-keyword">val</span> inspectedObjectsByPath = inspectObjects(shortestPaths)<br>  <span class="hljs-keyword">return</span> buildLeakTraces(shortestPaths, inspectedObjectsByPath, retainedSizes)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要执行流程分为3步：</p>
<h6 id="findLeakingObjectIds"><a href="#findLeakingObjectIds" class="headerlink" title="findLeakingObjectIds"></a>findLeakingObjectIds</h6><blockquote>
<p>寻找泄漏的对象</p>
</blockquote>
<p>设置的<code>leakingObjectFinder</code>实际就是<code>KeyedWeakReferenceFinder</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//KeyedWeakReferenceFinder.kt</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findLeakingObjectIds</span><span class="hljs-params">(graph: <span class="hljs-type">HeapGraph</span>)</span></span>: Set&lt;<span class="hljs-built_in">Long</span>&gt; =<br>    findKeyedWeakReferences(graph).map &#123; it.referent.value &#125;<br>        .toSet()<br><br>  <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findKeyedWeakReferences</span><span class="hljs-params">(graph: <span class="hljs-type">HeapGraph</span>)</span></span>: List&lt;KeyedWeakReferenceMirror&gt; &#123;<br>    <span class="hljs-keyword">return</span> graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) &#123;<br>      <span class="hljs-keyword">val</span> keyedWeakReferenceClass = graph.findClassByName(<span class="hljs-string">"leakcanary.KeyedWeakReference"</span>)<br><br>      <span class="hljs-keyword">val</span> keyedWeakReferenceClassId = keyedWeakReferenceClass?.objectId ?: <span class="hljs-number">0</span><br>      <span class="hljs-keyword">val</span> legacyKeyedWeakReferenceClassId =<br>        graph.findClassByName(<span class="hljs-string">"com.squareup.leakcanary.KeyedWeakReference"</span>)?.objectId ?: <span class="hljs-number">0</span><br><br>      <span class="hljs-keyword">val</span> heapDumpUptimeMillis = heapDumpUptimeMillis(graph)<br><br>      <span class="hljs-keyword">val</span> addedToContext: List&lt;KeyedWeakReferenceMirror&gt; = graph.instances<br>          .filter &#123; instance -&gt;<br>            instance.instanceClassId == keyedWeakReferenceClassId || instance.instanceClassId == legacyKeyedWeakReferenceClassId<br>          &#125;<br>          .map &#123;<br>            KeyedWeakReferenceMirror.fromInstance(<br>                it, heapDumpUptimeMillis<br>            )<br>          &#125;<br>          .filter &#123; it.hasReferent &#125;<br>          .toList()<br>      graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext<br>      addedToContext<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>主要就是实现了 找寻<code>instance</code>实例中的被<code>KeyedWeakReference</code>所包装的实例，因为在最前面<code>watch</code>的过程中，需要监控的对象都是被<code>KeyedWeakReference</code>所包装的，既然能在<code>isntance</code>中找到就意味着这些对象是发生了内存泄漏的。</p>
<h6 id="findPathsFromGcRoots"><a href="#findPathsFromGcRoots" class="headerlink" title="findPathsFromGcRoots"></a>findPathsFromGcRoots</h6><blockquote>
<p>寻找泄漏对象到GC Roots对象的引用路径</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//PathFinder.kt </span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findPathsFromGcRoots</span><span class="hljs-params">(<br>    leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;,<br>    computeRetainedHeapSize: <span class="hljs-type">Boolean</span><br>  )</span></span>: PathFindingResults &#123;<br>...<br>    <span class="hljs-keyword">val</span> state = State(<br>        leakingObjectIds = leakingObjectIds.toLongScatterSet(),<br>        sizeOfObjectInstances = sizeOfObjectInstances,<br>        computeRetainedHeapSize = computeRetainedHeapSize,<br>        javaLangObjectId = javaLangObjectId,<br>        estimatedVisitedObjects = estimatedVisitedObjects<br>    )<br><br>    <span class="hljs-keyword">return</span> state.findPathsFromGcRoots()<br>  &#125;<br><br><span class="hljs-comment">//找寻泄漏对象 到 GC Roots对象的路径</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> State.<span class="hljs-title">findPathsFromGcRoots</span><span class="hljs-params">()</span></span>: PathFindingResults &#123;<br>    enqueueGcRoots()<br><br>    <span class="hljs-keyword">val</span> shortestPathsToLeakingObjects = mutableListOf&lt;ReferencePathNode&gt;()<br>    <span class="hljs-symbol">visitingQueue@</span> <span class="hljs-keyword">while</span> (queuesNotEmpty) &#123;<br>      <span class="hljs-keyword">val</span> node = poll()<br>      <span class="hljs-keyword">if</span> (node.objectId <span class="hljs-keyword">in</span> leakingObjectIds) &#123;<br>        shortestPathsToLeakingObjects.add(node)<br>        <span class="hljs-comment">// Found all refs, stop searching (unless computing retained size)</span><br>        <span class="hljs-keyword">if</span> (shortestPathsToLeakingObjects.size == leakingObjectIds.size()) &#123;<br>          <span class="hljs-keyword">if</span> (computeRetainedHeapSize) &#123;<br>            listener.onAnalysisProgress(FINDING_DOMINATORS)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><span class="hljs-symbol">@visitingQueue</span><br>          &#125;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> heapObject = graph.findObjectById(node.objectId)) &#123;<br>        <span class="hljs-keyword">is</span> HeapClass -&gt; visitClassRecord(heapObject, node)<br>        <span class="hljs-keyword">is</span> HeapInstance -&gt; visitInstance(heapObject, node)<br>        <span class="hljs-keyword">is</span> HeapObjectArray -&gt; visitObjectArray(heapObject, node)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> PathFindingResults(<br>        shortestPathsToLeakingObjects,<br>        <span class="hljs-keyword">if</span> (visitTracker <span class="hljs-keyword">is</span> Dominated) visitTracker.dominatorTree <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>    )<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>总体思路</p>
<blockquote>
<p>采用<strong>广度优先遍历</strong>从<code>GC Roots</code>开始遍历，直到<code>泄漏对象</code>为止。</p>
<p><code>广度优先遍历</code>：从根节点出发，沿着树宽度依此遍历树的每个节点。<strong>借助队列结构实现</strong></p>
<p>以<code>GC Roots对象</code>为树的根节点，然后从根节点开始遍历，对每个节点依据类型的不同采取对应的模式进行访问并得到对象，然后引用继续抽象成为<code>Node</code>加入队列以待后续遍历，直到遍历到<code>Node</code>为<code>leakObjectId</code>，期间经过的所有Node对象连在一起就是一次完整的引用路径。</p>
<p>最终得到的就是<code>泄漏对象 到 GC Roots对象</code>的引用路径。</p>
</blockquote>
<h6 id="deduplicateShortestPaths"><a href="#deduplicateShortestPaths" class="headerlink" title="deduplicateShortestPaths"></a>deduplicateShortestPaths</h6><blockquote>
<p>根据多条引用路径，进行裁剪得到最短的引用路径</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deduplicateShortestPaths</span><span class="hljs-params">(<br>  inputPathResults: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ReferencePathNode</span>&gt;<br>)</span></span>: List&lt;ShortestPath&gt; &#123;<br>  <span class="hljs-comment">//根节点为0</span><br>  <span class="hljs-keyword">val</span> rootTrieNode = ParentNode(<span class="hljs-number">0</span>)<br><br>  inputPathResults.forEach &#123; pathNode -&gt;<br>    <span class="hljs-comment">// Go through the linked list of nodes and build the reverse list of instances from</span><br>    <span class="hljs-comment">// root to leaking.</span><br>    <span class="hljs-keyword">val</span> path = mutableListOf&lt;<span class="hljs-built_in">Long</span>&gt;()<br>    <span class="hljs-keyword">var</span> leakNode: ReferencePathNode = pathNode<br>    <span class="hljs-keyword">while</span> (leakNode <span class="hljs-keyword">is</span> ChildNode) &#123;<br>      path.add(<span class="hljs-number">0</span>, leakNode.objectId)<br>      leakNode = leakNode.parent<br>    &#125;<br>    path.add(<span class="hljs-number">0</span>, leakNode.objectId)<br>    updateTrie(pathNode, path, <span class="hljs-number">0</span>, rootTrieNode)<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateTrie</span><span class="hljs-params">(<br>  pathNode: <span class="hljs-type">ReferencePathNode</span>,<br>  path: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Long</span>&gt;,<br>  pathIndex: <span class="hljs-type">Int</span>,<br>  parentNode: <span class="hljs-type">ParentNode</span><br>)</span></span> &#123;<br>  <span class="hljs-keyword">val</span> objectId = path[pathIndex]<br>  <span class="hljs-keyword">if</span> (pathIndex == path.lastIndex) &#123;<br>    parentNode.children[objectId] = LeafNode(objectId, pathNode)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">val</span> childNode = parentNode.children[objectId] ?: &#123;<br>      <span class="hljs-keyword">val</span> newChildNode = ParentNode(objectId)<br>      parentNode.children[objectId] = newChildNode<br>      newChildNode<br>    &#125;()<br>    <span class="hljs-keyword">if</span> (childNode <span class="hljs-keyword">is</span> ParentNode) &#123;<br>      updateTrie(pathNode, path, pathIndex + <span class="hljs-number">1</span>, childNode)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总体思路：</p>
<blockquote>
<p>一个对象被很多对象引用是很正常的行为，所以<code>泄漏对象</code>和<code>GC Roots对象</code>之间可能存在多条引用路径，此时就需要进行裁剪得到最短的引用路径方便分析。</p>
<p>将路径反转成为<code>GC Roots对象 到 泄漏对象</code>的的引用路径，然后通过<code>updateTrie()</code>转化成为无效Node为根节点的树，最后经过<code>深度优先遍历</code>得到从<code>根节点</code>到<code>叶子节点</code>的所有路径，即为最终的<code>最短引用路径</code>。</p>
<p><code>深度优先遍历</code>：从树的根节点开始，先遍历左子树再遍历右子树。<strong>借助栈结构实现</strong>。</p>
</blockquote>
<h6 id="buildLeakTraces"><a href="#buildLeakTraces" class="headerlink" title="buildLeakTraces"></a>buildLeakTraces</h6><blockquote>
<p>建立泄漏路径</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapAnalzer.kt</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">buildLeakTraces</span><span class="hljs-params">(<br>    shortestPaths: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ShortestPath</span>&gt;,<br>    inspectedObjectsByPath: <span class="hljs-type">List</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">InspectedObject</span>&gt;&gt;,<br>    retainedSizes: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">Long</span>, Pair&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>&gt;&gt;?<br>  )</span></span>: Pair&lt;List&lt;ApplicationLeak&gt;, List&lt;LibraryLeak&gt;&gt; &#123;<br>    ...<br>    shortestPaths.forEachIndexed &#123; pathIndex, shortestPath -&gt;<br>      <span class="hljs-keyword">val</span> inspectedObjects = inspectedObjectsByPath[pathIndex]<br>      <span class="hljs-comment">//构建内存泄漏对象</span><br>      <span class="hljs-keyword">val</span> leakTraceObjects = buildLeakTraceObjects(inspectedObjects, retainedSizes)<br>      <span class="hljs-comment">//构建引用路径</span><br>      <span class="hljs-keyword">val</span> referencePath = buildReferencePath(shortestPath.childPath, leakTraceObjects)<br><br>      <span class="hljs-keyword">val</span> leakTrace = LeakTrace(<br>          gcRootType = GcRootType.fromGcRoot(shortestPath.root.gcRoot),<br>          referencePath = referencePath,<br>          leakingObject = leakTraceObjects.last()<br>      )<br><br>      <span class="hljs-keyword">val</span> firstLibraryLeakNode = <span class="hljs-keyword">if</span> (shortestPath.root <span class="hljs-keyword">is</span> LibraryLeakNode) &#123;<br>        shortestPath.root<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        shortestPath.childPath.firstOrNull &#123; it <span class="hljs-keyword">is</span> LibraryLeakNode &#125; <span class="hljs-keyword">as</span> LibraryLeakNode?<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (firstLibraryLeakNode != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">val</span> matcher = firstLibraryLeakNode.matcher<br>        <span class="hljs-keyword">val</span> signature: String = matcher.pattern.toString()<br>            .createSHA1Hash()<br>        libraryLeaksMap.getOrPut(signature) &#123; matcher to mutableListOf() &#125;<br>            .second += leakTrace<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//添加到 应用内存泄漏列表中</span><br>        applicationLeaksMap.getOrPut(leakTrace.signature) &#123; mutableListOf() &#125; += leakTrace<br>      &#125;<br>    &#125;    <br>    <br>  &#125;<br></code></pre></td></tr></table></figure>
<p>最终构建得到<code>ApplicationLeak</code>和<code>LibraryLeak</code>，组装得到<code>HeapAnalysis</code></p>
<ul>
<li><p><code>ApplicationLeak</code>：在开发工程中应用自身导致的内存泄漏</p>
</li>
<li><p><code>LibraryLeak</code>：<code>is a Leak caused by a known bug in third party code that you do not have control over.</code>已知的系统内存泄漏问题。</p>
<p><a href="https://github.com/square/leakcanary/pull/1785" target="_blank" rel="noopener">Explain Library Leaks in fundamentals</a></p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapAnalyzerService.kt</span><br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHandleIntentInForeground</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (intent == <span class="hljs-literal">null</span> || !intent.hasExtra(HEAPDUMP_FILE_EXTRA)) &#123;<br>      SharkLog.d &#123; <span class="hljs-string">"HeapAnalyzerService received a null or empty intent, ignoring."</span> &#125;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// Since we're running in the main process we should be careful not to impact it.</span><br>    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)<br>    <span class="hljs-keyword">val</span> heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) <span class="hljs-keyword">as</span> File<br>    <span class="hljs-keyword">val</span> heapDumpDurationMillis = intent.getLongExtra(HEAPDUMP_DURATION_MILLIS, -<span class="hljs-number">1</span>)<br><span class="hljs-comment">//获取 LeakCanary的配置</span><br>    <span class="hljs-keyword">val</span> config = LeakCanary.config<br>    <span class="hljs-keyword">val</span> heapAnalysis = <span class="hljs-keyword">if</span> (heapDumpFile.exists()) &#123;<br>      <span class="hljs-comment">//解析 hprof文件</span><br>      analyzeHeap(heapDumpFile, config)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      missingFileFailure(heapDumpFile)<br>    &#125;<br>    <span class="hljs-keyword">val</span> fullHeapAnalysis = <span class="hljs-keyword">when</span> (heapAnalysis) &#123;<br>      <span class="hljs-keyword">is</span> HeapAnalysisSuccess -&gt; heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)<br>      <span class="hljs-keyword">is</span> HeapAnalysisFailure -&gt; heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)<br>    &#125;<br>    onAnalysisProgress(REPORTING_HEAP_ANALYSIS)<br>  <span class="hljs-comment">//解析完成后 回调 onHeapAnalyzed</span><br>    config.onHeapAnalyzedListener.onHeapAnalyzed(fullHeapAnalysis)<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>解析完成后，回调到<code>onHeapAnalyzedListener</code>中的<code>onHeapAnalyzed()</code>.</p>
<p>其中<code>config</code>配置的<code>onHeapAnalyzedListener</code>为<code>DefaultOnHeapAnalyzedListener</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//DefaultOnHeapAnalyzedListener.kt</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHeapAnalyzed</span><span class="hljs-params">(heapAnalysis: <span class="hljs-type">HeapAnalysis</span>)</span></span> &#123;<br>    SharkLog.d &#123; <span class="hljs-string">"\u200B\n<span class="hljs-subst">$&#123;LeakTraceWrapper.wrap(heapAnalysis.toString(), <span class="hljs-number">120</span>)&#125;</span>"</span> &#125;<br><br>    <span class="hljs-keyword">val</span> id = LeaksDbHelper(application).writableDatabase.use &#123; db -&gt;<br>      HeapAnalysisTable.insert(db, heapAnalysis)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> (contentTitle, screenToShow) = <span class="hljs-keyword">when</span> (heapAnalysis) &#123;<br>      <span class="hljs-keyword">is</span> HeapAnalysisFailure -&gt; application.getString(<br>          R.string.leak_canary_analysis_failed<br>      ) to HeapAnalysisFailureScreen(id)<br>      <span class="hljs-keyword">is</span> HeapAnalysisSuccess -&gt; &#123;<br>        <span class="hljs-keyword">val</span> retainedObjectCount = heapAnalysis.allLeaks.sumBy &#123; it.leakTraces.size &#125;<br>        <span class="hljs-keyword">val</span> leakTypeCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size<br>        application.getString(<br>            R.string.leak_canary_analysis_success_notification, retainedObjectCount, leakTypeCount<br>        ) to HeapDumpScreen(id)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//显示通知 提示已经解析完毕</span><br>      showNotification(screenToShow, contentTitle)<br><br>  &#125;<br></code></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.LeakCanary整套流程从<code>注册监听Activity/Fragment对象生命周期</code>开始，当对应组件销毁时<code>添加对应组件的观察</code>。</p>
<ul>
<li>在<code>onActivityDestroyed()</code>添加对<code>Activity</code>的观察</li>
<li>在<code>onFragmentViewDestroyed()</code>添加对<code>Fragment中的View</code>的观察</li>
<li>在<code>onFragmentDestroyed()</code>添加对<code>Fragment</code>的观察</li>
<li>可以通过<code>AppWatcher.objectWatcher.watch(XX)</code>添加自定义对象的观察。</li>
</ul>
<p>2.在<code>泄漏检测</code>时，通过<code>WeakRefrence</code>包装<code>被观察的对象</code>，然后等待<strong>5s</strong>后，检查与<code>WeakReference</code>绑定的<code>ReferenceQueue</code>中是否包含<code>被观察对象</code>，若包含表示<code>被观察对象</code>已被回收；否则，判断对象可能泄漏。<em>5s并不一定是执行了GC，只是一个估值，一般都会触发GC。</em></p>
<p>3.在<code>准备DumpHeap</code>前，还会再去<code>手动执行一次GC</code>，等待<strong>100ms</strong>后如果还存在<code>泄漏对象</code>，就需要准备dump内存数据。此时有一个阈值，如果泄漏对象超过<strong>5个</strong>，才会去dump，避免频繁执行dump流程。</p>
<p>4.通过执行<code>Debug.dumpHprofData()</code>去生成<code>Hprof文件</code>，等待<code>Hprof文件</code>生成后，发送到<code>HeapAnalyzerService</code>去处理该文件。</p>
<p>5.<code>HeapAnalyzerService</code>收到<code>Hprof文件</code>后，通过<strong>Shark</strong>对文件进行解析，按照<code>Hprof文件格式</code>进行解析，解析得到<code>HprofHeapGraph</code>对象，内部包含<code>gcRoots</code>、<code>instances</code>、<code>classes</code>、<code>objects</code>等集合，可以快速定位泄漏对象。</p>
<p>6.得到<code>HprofHeapGraph</code>对象后，开始分析内存泄漏的最短路径。<em>内存泄漏的对象仍然与GC Roots对象保持可达的引用路径，导致GC无法释放。——一般用的都是<code>可达性分析</code></em>。</p>
<ul>
<li><code>寻找内存泄漏对象</code>：在<code>instances</code>集合中寻找<code>instanceClassId</code>为<code>KeyedWeakReferences</code>的对象，这些就是前面所观察的对象。</li>
<li><code>寻找所有内存泄漏对象与GC Roots对象的引用路径</code>：采用<code>广度优先遍历</code>，从<code>Gc Roots对象</code>开始遍历到<code>内存泄漏对象</code>的所有引用路径</li>
<li><code>裁剪所有路径得到 最短引用路径</code>：采用<code>深度优先遍历</code>，得到<code>内存泄漏对象</code>到<code>GC Roots对象</code>的最短引用路径</li>
<li><code>通知内存泄漏检测完毕</code>：将<code>最短引用路径</code>包装成<code>LeakTrace</code>，按照<strong>是否为应用自身导致的内存泄漏</strong>分为两个对象：<code>ApplicationLeak</code>和<code>LibraryLeak</code>。</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://square.github.io/leakcanary/getting_started/" target="_blank" rel="noopener">LeakCanary Wiki</a></p>
<p><a href="https://linjiang.tech/2019/12/25/leakcanary/" target="_blank" rel="noopener">LeakCanary解析</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/10/27/Android-硬件加速/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android硬件加速</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/12/Android-动画-属性动画/">
                        <span class="hidden-mobile">Android动画-属性动画</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>
  




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
