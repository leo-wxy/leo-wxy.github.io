

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
    <meta name="description" content="LeakCanary主要用来进行内存泄漏检测，并且可以直观的展示泄漏的路径   如何使用1234dependencies &#123;  &#x2F;&#x2F; debugImplementation because LeakCanary should only run in debug builds.  debugImplementation &#x27;com.squareup.leakcanary:leakc">
<meta property="og:type" content="article">
<meta property="og:title" content="Android性能优化-LeakCanary">
<meta property="og:url" content="http://example.com/2020/10/14/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-LeakCanary/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="LeakCanary主要用来进行内存泄漏检测，并且可以直观的展示泄漏的路径   如何使用1234dependencies &#123;  &#x2F;&#x2F; debugImplementation because LeakCanary should only run in debug builds.  debugImplementation &#x27;com.squareup.leakcanary:leakc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/LeakCanary%E5%88%9D%E5%A7%8B%E5%8C%96.jpg">
<meta property="article:published_time" content="2020-10-14T06:45:26.000Z">
<meta property="article:modified_time" content="2020-12-18T06:53:12.000Z">
<meta property="article:author" content="Leo-Wxy">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/images/LeakCanary%E5%88%9D%E5%A7%8B%E5%8C%96.jpg">
  
  
  
  <title>Android性能优化-LeakCanary - Wxy的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":false};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Android性能优化-LeakCanary</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-10-14 14:45" pubdate>
          2020年10月14日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          4.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          15 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Android性能优化-LeakCanary</h1>
            
            
              <div class="markdown-body">
                
                <blockquote><p>LeakCanary主要用来<strong>进行内存泄漏检测</strong>，并且可以直观的展示泄漏的路径</p>
</blockquote>

<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  <span class="hljs-comment">// debugImplementation because LeakCanary should only run in debug builds.</span><br>  debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android:2.5&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置完成后，<code>LeakCanary</code>通过<code>ContentProvider</code>进行注册以及初始化。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//AppWatcherInstaller.kt</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppWatcherInstaller</span> : <span class="hljs-type">ContentProvider</span>() &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> application = context!!.applicationContext <span class="hljs-keyword">as</span> Application<br>    AppWatcher.manualInstall(application)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>涉及的部分Activity启动过程源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ActivityThread.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleBindApplication</span><span class="hljs-params">(AppBindData data)</span> &#123;<br>  ...<br>  <span class="hljs-comment">//获取LoaderApk对象</span><br>  data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);<br>  <span class="hljs-comment">//创建进程对应的Android运行环境ContextImpl</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(<span class="hljs-built_in">this</span>, data.info);<br>  ...<br>  <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//准备创建Application对象</span><br>            <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-literal">null</span>);<br>            mInitialApplication = app;<br>            ...<br>             <span class="hljs-comment">//加载对应进程中的ContentProvider</span><br>            installContentProviders(app, data.providers);<br>            <span class="hljs-keyword">try</span> &#123;<br>                mInstrumentation.onCreate(data.instrumentationArgs);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                    <span class="hljs-string">&quot;Exception thrown in onCreate() of &quot;</span><br>                    + data.instrumentationName + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//调用Application的onCreate方法</span><br>                mInstrumentation.callApplicationOnCreate(app);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                        <span class="hljs-string">&quot;Unable to create application &quot;</span> + app.getClass().getName()<br>                        + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            StrictMode.setThreadPolicy(savedPolicy);<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在<code>handleBindApplication()</code>进行<code>ContentProvider</code>的启动，此时<code>AppWatcherInstaller</code>会在此时启动。</p>
<p>向下调用到<code>AppWatcher.manualInstall(application)</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//AppWatcher.kt</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manualInstall</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>    InternalAppWatcher.install(application)<br>  &#125;<br><br><span class="hljs-comment">//InternalAppWatcher.kt</span><br><span class="hljs-comment">//开始了初始化流程</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>    <span class="hljs-comment">//初始化</span><br>  &#125;<br><br></code></pre></td></tr></table></figure>

<p>到此基本的<code>LeakCanary</code>初始化完毕</p>
<h3 id="主动添加内存泄漏监控"><a href="#主动添加内存泄漏监控" class="headerlink" title="主动添加内存泄漏监控"></a>主动添加内存泄漏监控</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">AppWatcher.objectWatcher.watch(watchObject,reason)<br></code></pre></td></tr></table></figure>



<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h3><p>在初始化过程执行的<code>注册监听</code>过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//InternalAppWatcher.kt</span><br><span class="hljs-comment">//开始了初始化流程</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>    checkMainThread()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>::application.isInitialized) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    InternalAppWatcher.application = application<br>    <span class="hljs-keyword">if</span> (isDebuggableBuild) &#123;<br>      SharkLog.logger = DefaultCanaryLog()<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> configProvider = &#123; AppWatcher.config &#125;<br>    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)<br>    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)<br>    onAppWatcherInstalled(application)<br>  &#125;<br></code></pre></td></tr></table></figure>

<h4 id="监听Activity"><a href="#监听Activity" class="headerlink" title="监听Activity"></a>监听Activity</h4><p><code>ActivityDestroyWatcher.install</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityDestroyWatcher</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> objectWatcher: ObjectWatcher,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> configProvider: () -&gt; Config<br>) &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>        <span class="hljs-comment">//监听Activity onDestroy()生命周期</span><br>        <span class="hljs-keyword">if</span> (configProvider().watchActivities) &#123;<br>          objectWatcher.watch(<br>              activity, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span><br>          )<br>        &#125;<br>      &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      application: <span class="hljs-type">Application</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      objectWatcher: <span class="hljs-type">ObjectWatcher</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      configProvider: () -&gt; <span class="hljs-type">Config</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> activityDestroyWatcher =<br>        ActivityDestroyWatcher(objectWatcher, configProvider)<br>      <span class="hljs-comment">//往Application添加Activity生命周期回调监听</span><br>      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要是为了注册Activity的生命周期回调，监测到<code>onActivityDestroyed()</code>之后，将Activity加入到<code>objectWatcher</code>中</p>
<h4 id="监听Fragment"><a href="#监听Fragment" class="headerlink" title="监听Fragment"></a>监听Fragment</h4><p><code>FragmentDestroyWatcher.install</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> FragmentDestroyWatcher &#123;<br>  <br>  <span class="hljs-comment">//AndroidX fragment相关配置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ANDROIDX_FRAGMENT_CLASS_NAME = <span class="hljs-string">&quot;androidx.fragment.app.Fragment&quot;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =<br>    <span class="hljs-string">&quot;leakcanary.internal.AndroidXFragmentDestroyWatcher&quot;</span><br>  <br>  <br>  <span class="hljs-comment">//supprt fragment相关配置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> ANDROID_SUPPORT_FRAGMENT_CLASS_NAME =<br>    StringBuilder(<span class="hljs-string">&quot;android.&quot;</span>).append(<span class="hljs-string">&quot;support.v4.app.Fragment&quot;</span>)<br>        .toString()<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =<br>    <span class="hljs-string">&quot;leakcanary.internal.AndroidSupportFragmentDestroyWatcher&quot;</span><br><br>  <br>  ...<br>   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    application: <span class="hljs-type">Application</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    objectWatcher: <span class="hljs-type">ObjectWatcher</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    configProvider: () -&gt; <span class="hljs-type">AppWatcher</span>.<span class="hljs-type">Config</span></span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span> &#123;<br>    <span class="hljs-keyword">val</span> fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; <span class="hljs-built_in">Unit</span>&gt;()<br><br>     <span class="hljs-comment">//Android 8.0及以上 直接构造 AndroidOFragmentDestroyWatcher</span><br>    <span class="hljs-keyword">if</span> (SDK_INT &gt;= O) &#123;<br>      fragmentDestroyWatchers.add(<br>          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)<br>      )<br>    &#125;<br><br>     <span class="hljs-comment">//androidx fragment对象 </span><br>    getWatcherIfAvailable(<br>        ANDROIDX_FRAGMENT_CLASS_NAME,<br>        ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<br>        objectWatcher,<br>        configProvider<br>    )?.let &#123;<br>      fragmentDestroyWatchers.add(it)<br>    &#125;<br><br>     <span class="hljs-comment">//fragment相关配置</span><br>    getWatcherIfAvailable(<br>        ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,<br>        ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<br>        objectWatcher,<br>        configProvider<br>    )?.let &#123;<br>      fragmentDestroyWatchers.add(it)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fragmentDestroyWatchers.size == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    application.registerActivityLifecycleCallbacks(<span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        activity: <span class="hljs-type">Activity</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">      )</span></span> &#123;<br>        <span class="hljs-comment">//在Activity创建时 添加Fragment的监听</span><br>        <span class="hljs-keyword">for</span> (watcher <span class="hljs-keyword">in</span> fragmentDestroyWatchers) &#123;<br>          <span class="hljs-comment">//调用到 对应的 invoke()</span><br>          watcher(activity)<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据上述源码，<code>FragmentDestroyWatcher</code>按照三种情况进行区分：</p>
<ul>
<li>Android O 及以上版本的fragment：<code>AndroidOFragmentDestroyWatcher</code></li>
<li>AndroidX 的fragment：<code>AndroidXFragmentDestroyWatcher</code></li>
<li>Android support 的 fragment：<code>AndroidSupportFragmentDestroyWatcher</code></li>
</ul>
<p>上述三种实现基本一致，只是对引用的<code>fragment</code>进行了区分，下面拿<code>AndroidSupportFragmentDestroyWatcher</code>进行分析</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//AndroidSupportFragmentDestroyWatcher.kt</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidSupportFragmentDestroyWatcher</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> objectWatcher: ObjectWatcher,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> configProvider: () -&gt; Config<br>) : (Activity) -&gt; <span class="hljs-built_in">Unit</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentLifecycleCallbacks = <span class="hljs-keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentViewDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      <span class="hljs-comment">//添加了对fragment引用的View的泄漏监听</span><br>      <span class="hljs-keyword">val</span> view = fragment.view<br>      <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span> &amp;&amp; configProvider().watchFragmentViews) &#123;<br>        objectWatcher.watch(<br>            view, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +<br>            <span class="hljs-string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span><br>        )<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      <span class="hljs-keyword">if</span> (configProvider().watchFragments) &#123;<br>        <span class="hljs-comment">//添加对 fragment的泄漏监听</span><br>        objectWatcher.watch(<br>            fragment, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span><br>        )<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">is</span> FragmentActivity) &#123;<br>      <span class="hljs-comment">//针对 fragmentManager 添加 fragmentlifecyclecallback监听</span><br>      <span class="hljs-keyword">val</span> supportFragmentManager = activity.supportFragmentManager<br>      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="hljs-literal">true</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要是在<code>FragmentManager</code>调用<code>registerFragmentLifecycleCallbacks()</code>添加生命周期监听。</p>
<ul>
<li>在<code>onFragmentViewDestroyed()</code>添加<code>View</code>的监听</li>
<li>在<code>onFragmentDestroyed()</code>添加<code>Fragment</code>的监听</li>
</ul>
<p>最后在<code>registerActivityLifecycleCallbacks()</code>的每个Activity的<code>onActivityCreated()</code>中执行<code>Fragment</code>的生命周期监听。</p>
<p>此时<code>objectWatcher</code>对象就已经监听到了如下实例：</p>
<ul>
<li>Activity</li>
<li>Fragment</li>
<li>Fragment中的View</li>
</ul>
<h4 id="InternalLeakCanary"><a href="#InternalLeakCanary" class="headerlink" title="InternalLeakCanary"></a>InternalLeakCanary</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//InternalappWatcher.kt</span><br>  <span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-keyword">val</span> internalLeakCanary = <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> leakCanaryListener = Class.forName(<span class="hljs-string">&quot;leakcanary.internal.InternalLeakCanary&quot;</span>)<br>      leakCanaryListener.getDeclaredField(<span class="hljs-string">&quot;INSTANCE&quot;</span>)<br>          .<span class="hljs-keyword">get</span>(<span class="hljs-literal">null</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>      NoLeakCanary<br>    &#125;<br>    <span class="hljs-meta">@kotlin</span>.Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)<br>    onAppWatcherInstalled = internalLeakCanary <span class="hljs-keyword">as</span> (Application) -&gt; <span class="hljs-built_in">Unit</span><br>  &#125;<br></code></pre></td></tr></table></figure>

<p>最后执行的<code>onAppWatcherInstalled()</code>的实现类就是<code>InternalLeakCanary</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//InternalLeakCanary.kt</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>    _application = application<br><br>    checkRunningInDebuggableBuild()<br><br>    <span class="hljs-comment">//注册监听对象 可能泄漏的消息</span><br>    AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-keyword">val</span> heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application))<br><br>    <span class="hljs-keyword">val</span> gcTrigger = GcTrigger.Default<br><br>    <span class="hljs-keyword">val</span> configProvider = &#123; LeakCanary.config &#125;<br><br>    <span class="hljs-keyword">val</span> handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)<br>    handlerThread.start()<br>    <span class="hljs-keyword">val</span> backgroundHandler = Handler(handlerThread.looper)<br><br>    <span class="hljs-comment">//dump内存</span><br>    heapDumpTrigger = HeapDumpTrigger(<br>        application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,<br>        configProvider<br>    )<br>    application.registerVisibilityListener &#123; applicationVisible -&gt;<br>      <span class="hljs-keyword">this</span>.applicationVisible = applicationVisible<br>      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)<br>    &#125;<br>    registerResumedActivityListener(application)<br>    <span class="hljs-comment">//添加桌面的快捷入口</span><br>    addDynamicShortcut(application)<br><br>    <span class="hljs-comment">// We post so that the log happens after Application.onCreate()</span><br>    Handler().post &#123;<br>      SharkLog.d &#123;<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()) &#123;<br>          <span class="hljs-keyword">is</span> Yup -&gt; application.getString(R.string.leak_canary_heap_dump_enabled_text)<br>          <span class="hljs-keyword">is</span> Nope -&gt; application.getString(<br>              R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()<br>          )<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p><code>InternalLeakCanary</code>主要负责接收<code>objectWatcher</code>通知的<code>可能存在的内存泄漏</code>消息并驱动<code>heapDumpTrigger</code>进行<code>Dump</code>过程。</p>
<p>得到最终产出的<code>Hprof文件</code>去进行分析的流程。</p>
<p><img src="/images/LeakCanary%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" srcset="/img/loading.gif" lazyload alt="LeakCanary初始化"></p>
<h3 id="泄漏检测"><a href="#泄漏检测" class="headerlink" title="泄漏检测"></a>泄漏检测</h3><p>根据上节分析可知，所有需要监控的对象都会通过<code>objectWatcher.watch()</code>进行对象监听</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//监测引用队列间隔</span><br><span class="hljs-keyword">val</span> watchDurationMillis: <span class="hljs-built_in">Long</span> = TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>),<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkRetainedExecutor = Executor &#123;<br>    mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)<br>  &#125;<br><br><span class="hljs-keyword">val</span> objectWatcher = ObjectWatcher(<br>      clock = clock,<br>      checkRetainedExecutor = checkRetainedExecutor,<br>      isEnabled = &#123; <span class="hljs-literal">true</span> &#125;<br>  )<br><br></code></pre></td></tr></table></figure>

<p>实现类是<code>ObjectWatcher</code></p>
<h4 id="ObjectWatcher"><a href="#ObjectWatcher" class="headerlink" title="ObjectWatcher"></a>ObjectWatcher</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectWatcher</span> <span class="hljs-keyword">constructor</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> clock: Clock,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> checkRetainedExecutor: Executor,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Calls to [watch] will be ignored when [isEnabled] returns false</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> isEnabled: () -&gt; <span class="hljs-built_in">Boolean</span> = &#123; <span class="hljs-literal">true</span> &#125;<br>) &#123;<br>  <span class="hljs-comment">//需要监听的弱引用对象实例</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()<br>  <span class="hljs-comment">//引用队列</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> queue = ReferenceQueue&lt;Any&gt;()<br>  <br>  ...<br>  <br>    <span class="hljs-meta">@Synchronized</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">watch</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    watchedObject: <span class="hljs-type">Any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    description: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (!isEnabled()) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    removeWeaklyReachableObjects()<br>    <span class="hljs-keyword">val</span> key = UUID.randomUUID()<br>        .toString()<br>    <span class="hljs-keyword">val</span> watchUptimeMillis = clock.uptimeMillis()<br>      <span class="hljs-comment">//将需要监听的对象 构建一个弱引用实例</span><br>    <span class="hljs-keyword">val</span> reference =<br>      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)&#123;&#125;<br><br>    watchedObjects[key] = reference<br>      <span class="hljs-comment">//执行 checkExecutor任务</span><br>    checkRetainedExecutor.execute &#123;<br>      moveToRetained(key)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用<code>watch()</code>之后，将需要监听的对象添加弱引用(<code>WeakReference</code>)，再通过关联一个引用队列(<code>ReferenceQueue</code>)判断监听对象是否被回收。</p>
<blockquote>
<p>为什么选用弱引用？</p>
<p>除了强引用不会被回收外，还存在着<code>软引用</code>和<code>虚引用</code>。其中<code>软引用</code>必须在内存将满时才会被回收并加入到<code>ReferenceQueue</code>中，而<code>虚引用</code>在加入到<code>ReferenceQueue</code>时，内置的引用无法被清空。</p>
</blockquote>
<p>包装成弱引用对象后，执行<code>checkRetainedExecutor</code>的线程池，本质上执行的是<strong>等待5s后执行对象是否回收的判断。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetained</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br>  removeWeaklyReachableObjects()<br>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]<br>  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;<br>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeWeaklyReachableObjects</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span><br>  <span class="hljs-comment">// reachable. This is before finalization or garbage collection has actually happened.</span><br>  <span class="hljs-keyword">var</span> ref: KeyedWeakReference?<br>  <span class="hljs-keyword">do</span> &#123;<br>    ref = queue.poll() <span class="hljs-keyword">as</span> KeyedWeakReference?<br>    <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;<br>      watchedObjects.remove(ref.key)<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (ref != <span class="hljs-literal">null</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>watchedObjects</code>存放的就是<code>被观察的对象引用</code>，每次调用<code>watch()</code>都会发送一个延时5s的消息。</p>
<p>延时消息主要执行<code>moveToRetained()</code>，内部主要执行如下过程：</p>
<ol>
<li>遍历<code>queue(引用队列)</code>，将其中存在的对象从<code>watchedObjects</code>中移除，因为已经被回收</li>
<li>如果对象没有从<code>watchedObjects</code>中移除，就表示该对象发生了<code>内存泄漏</code></li>
</ol>
<h3 id="Dump出Hprof文件"><a href="#Dump出Hprof文件" class="headerlink" title="Dump出Hprof文件"></a>Dump出Hprof文件</h3><p>如果存在未被回收的对象，此时就会回调到<code>OnObjectRetainedListener.onObjectRetained()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> InternalLeakCanary : (Application) -&gt; <span class="hljs-built_in">Unit</span>, OnObjectRetainedListener &#123;<br>  ...<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>      <span class="hljs-comment">//添加回调监听注册</span><br>      AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="hljs-keyword">this</span>)<br>      ...<br>    &#125;<br>  <br>  <span class="hljs-comment">//实现的方法</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onObjectRetained</span><span class="hljs-params">()</span></span> = scheduleRetainedObjectCheck()  <br>  <br>  <br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//初始化完毕</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>::heapDumpTrigger.isInitialized) &#123;<br>      heapDumpTrigger.scheduleRetainedObjectCheck()<br>    &#125;<br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>切换到<code>HeapDumpTrigger</code>继续执行</p>
<h4 id="HeapDumpTrigger"><a href="#HeapDumpTrigger" class="headerlink" title="HeapDumpTrigger"></a>HeapDumpTrigger</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapDumpTrigger.kt </span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    delayMillis: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>L</span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span> &#123;<br>    <span class="hljs-keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt<br>    <span class="hljs-keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    checkScheduledAt = SystemClock.uptimeMillis() + delayMillis<br>    backgroundHandler.postDelayed(&#123;<br>      checkScheduledAt = <span class="hljs-number">0</span><br>      checkRetainedObjects()<br>    &#125;, delayMillis)<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkRetainedObjects</span><span class="hljs-params">()</span></span> &#123;<br>   ... <br>    <span class="hljs-comment">//获取未释放的对象数</span><br>    <span class="hljs-keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount<br><br>    <span class="hljs-keyword">if</span> (retainedReferenceCount &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">//手动执行一次GC</span><br>      gcTrigger.runGc()<br>      <span class="hljs-comment">//在获取一次 </span><br>      retainedReferenceCount = objectWatcher.retainedObjectCount<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否超过阈值，避免重复调用dump</span><br>    <span class="hljs-keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-comment">//dump内存生成 Hprof文件</span><br>        dumpHeap(retainedReferenceCount, retry = <span class="hljs-literal">true</span>)<br>    <br>  &#125;<br><br><span class="hljs-comment">//GcTrigger.kt</span><br>  <span class="hljs-keyword">object</span> Default : GcTrigger &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runGc</span><span class="hljs-params">()</span></span> &#123;<br>      Runtime.getRuntime()<br>          .gc()<br>      enqueueReferences()<br>      System.runFinalization()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueueReferences</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-comment">// Hack. We don&#x27;t have a programmatic way to wait for the reference queue daemon to move</span><br>      <span class="hljs-comment">// references to the appropriate queues.</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">100</span>)<br>      &#125; <span class="hljs-keyword">catch</span> (e: InterruptedException) &#123;<br>        <span class="hljs-keyword">throw</span> AssertionError()<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p><code>scheduleRetainedObjectCheck()</code>并不是直接去dump，而是先手动调用一次GC，然后再触发GC后等待<code>100ms</code>之后再去检测一次是否有对象未被回收。</p>
<p>其中判断过程还添加了<code>阈值(5)</code>，避免频繁触发<code>dumpHeap()</code>导致卡顿。</p>
<h4 id="dumpHeap"><a href="#dumpHeap" class="headerlink" title="dumpHeap()"></a>dumpHeap()</h4><p>主要负责dump 出 Hprof文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//InternalLeakCanary.kt</span><br>    <span class="hljs-keyword">val</span> heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application))<br><br><span class="hljs-comment">//HeapDumpTrigger.kt</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    retainedReferenceCount: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    retry: <span class="hljs-type">Boolean</span></span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span> &#123;<br>    saveResourceIdNamesToMemory()<br>    <span class="hljs-keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()<br>    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis<br>    <span class="hljs-comment">//开始执行dump过程</span><br>    <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> heapDumpResult = heapDumper.dumpHeap()) &#123;<br>      <span class="hljs-keyword">is</span> NoHeapDump -&gt; &#123;<br>        ...<br>      &#125;<br>      <span class="hljs-keyword">is</span> HeapDump -&gt; &#123;<br>        lastDisplayedRetainedObjectCount = <span class="hljs-number">0</span><br>        lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()<br>        <span class="hljs-comment">//生成hprof文件</span><br>        objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)<br>        <span class="hljs-comment">//hprof文件生成完毕后，发送到HeapAnalyzeSerview</span><br>        HeapAnalyzerService.runAnalysis(<br>            context = application,<br>            heapDumpFile = heapDumpResult.file,<br>            heapDumpDurationMillis = heapDumpResult.durationMillis<br>        )<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>AndroidHeapDumper</code>去执行dump过程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//AndroidHeapDumper.kt</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">()</span></span>: DumpHeapResult &#123;<br>    ...<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> durationMillis = measureDurationMillis &#123;<br>        <span class="hljs-comment">//执行dump过程</span><br>        Debug.dumpHprofData(heapDumpFile.absolutePath)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (heapDumpFile.length() == <span class="hljs-number">0L</span>) &#123;<br>        SharkLog.d &#123; <span class="hljs-string">&quot;Dumped heap file is 0 byte length&quot;</span> &#125;<br>        NoHeapDump<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        HeapDump(file = heapDumpFile, durationMillis = durationMillis)<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>      SharkLog.d(e) &#123; <span class="hljs-string">&quot;Could not dump heap&quot;</span> &#125;<br>      <span class="hljs-comment">// Abort heap dump</span><br>      NoHeapDump<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      cancelToast(toast)<br>      notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)<br>    &#125;<br>    <br>  &#125;<br></code></pre></td></tr></table></figure>

<p>主要是执行<code>Debug.dumpHprofData()</code>得到<code>Hprof文件</code>去进行内存分析。</p>
<h4 id="HeapAnalyzerService-runAnalysis"><a href="#HeapAnalyzerService-runAnalysis" class="headerlink" title="HeapAnalyzerService.runAnalysis()"></a>HeapAnalyzerService.runAnalysis()</h4><p>主要负责去分析Hprof文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapAnalyzerService.kt</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runAnalysis</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      context: <span class="hljs-type">Context</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      heapDumpFile: <span class="hljs-type">File</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      heapDumpDurationMillis: <span class="hljs-type">Long</span>? = <span class="hljs-literal">null</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> intent = Intent(context, HeapAnalyzerService::<span class="hljs-keyword">class</span>.java)<br>      <span class="hljs-comment">//携带文件地址 到 HeapAnalyzerService去进行分析</span><br>      intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)<br>      heapDumpDurationMillis?.let &#123;<br>        intent.putExtra(HEAPDUMP_DURATION_MILLIS, heapDumpDurationMillis)<br>      &#125;<br>      startForegroundService(context, intent)<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>接下来切换到<code>HeapAnalyzerService</code>开始进行Hprof文件解析流程。</p>
<h3 id="Hprof解析"><a href="#Hprof解析" class="headerlink" title="Hprof解析"></a>Hprof解析</h3><p>在<code>HeapAnalyzerService</code>收到传过来的Hprof文件地址后，就要开始解析</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapAnalyzerService  </span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">analyzeHeap</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    heapDumpFile: <span class="hljs-type">File</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    config: <span class="hljs-type">Config</span></span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span>: HeapAnalysis &#123;<br>    <span class="hljs-keyword">val</span> heapAnalyzer = HeapAnalyzer(<span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-keyword">val</span> proguardMappingReader = <span class="hljs-keyword">try</span> &#123;<br>      ProguardMappingReader(assets.<span class="hljs-keyword">open</span>(PROGUARD_MAPPING_FILE_NAME))<br>    &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>      <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> heapAnalyzer.analyze(<br>        heapDumpFile = heapDumpFile,<br>        leakingObjectFinder = config.leakingObjectFinder,<br>        referenceMatchers = config.referenceMatchers,<br>        computeRetainedHeapSize = config.computeRetainedHeapSize,<br>        objectInspectors = config.objectInspectors,<br>        metadataExtractor = config.metadataExtractor,<br>        proguardMapping = proguardMappingReader?.readProguardMapping()<br>    )<br>  &#125;<br><br></code></pre></td></tr></table></figure>

<p>解析前需要了解一下<a href="/2020/12/14/Hprof%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/" title="Hprof文件解析">Hprof结构</a>，在此基础上进行Hprof解析的相关流程分析。</p>
<blockquote>
<p>简单说明一下Hprof的相关结构</p>
<p>主要分为两部分：</p>
<ul>
<li>Header：主要包含一些元信息，例如<code>文件协议的版本</code>、<code>开始</code>和<code>结束的时间戳</code>，以及<code>标识符大小</code></li>
<li>Record：主要结构为<code>TAG</code>、<code>TIME</code>、<code>LENGTH(BODY数据长度)</code>和<code>BODY</code><ul>
<li>TAG：表示<code>Record</code>类型，重要的有<code>HEAP_DUMP_SEGMENT</code>和<code>STRING</code>等</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="Shark-HeapAnalyzer"><a href="#Shark-HeapAnalyzer" class="headerlink" title="Shark.HeapAnalyzer"></a>Shark.HeapAnalyzer</h4><blockquote>
<p><code>Shark</code>是一款分析<code>Hprof文件</code>的工具，性能高且占用内存少，非常适合手机端的Hprof文件解析功能。</p>
<p>目的是<strong>提供快速解析Hprof文件和分析的能力。</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapAnalyzer.kt </span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">analyze</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    heapDumpFile: <span class="hljs-type">File</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    leakingObjectFinder: <span class="hljs-type">LeakingObjectFinder</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    referenceMatchers: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ReferenceMatcher</span>&gt; = emptyList()</span></span>,<br>    computeRetainedHeapSize: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,<br>    objectInspectors: List&lt;ObjectInspector&gt; = emptyList(),<br>    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,<br>    proguardMapping: ProguardMapping? = <span class="hljs-literal">null</span><br>  ): HeapAnalysis &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>      listener.onAnalysisProgress(PARSING_HEAP_DUMP)<br>      <span class="hljs-keyword">val</span> sourceProvider = ConstantMemoryMetricsDualSourceProvider(FileSourceProvider(heapDumpFile))<br>      sourceProvider.openHeapGraph(proguardMapping).use &#123; graph -&gt;<br>       <span class="hljs-comment">//                                                  </span><br>        <span class="hljs-keyword">val</span> helpers =<br>          FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)<br>        <span class="hljs-keyword">val</span> result = helpers.analyzeGraph(<br>            metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime<br>        )<br>        result.copy(metadata = result.metadata + (<span class="hljs-string">&quot;Stats&quot;</span> to stats))<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (exception: Throwable) &#123;<br><br>    &#125;  <br>    <br>  &#125;<br></code></pre></td></tr></table></figure>

<h5 id="openHeapGraph"><a href="#openHeapGraph" class="headerlink" title="openHeapGraph"></a>openHeapGraph</h5><p>主要用来按照格式解析Hprof文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HprofHeapGraph.kt</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> DualSourceProvider.<span class="hljs-title">openHeapGraph</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      proguardMapping: <span class="hljs-type">ProguardMapping</span>? = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      indexedGcRootTypes: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt; = HprofIndex.defaultIndexedGcRootTags()</span></span><br>    ): CloseableHeapGraph &#123;<br>      <span class="hljs-comment">//主要负责解析 Hprof head部分的数据</span><br>      <span class="hljs-keyword">val</span> header = openStreamingSource().use &#123; HprofHeader.parseHeaderOf(it) &#125;<br>      <span class="hljs-keyword">val</span> index = HprofIndex.indexRecordsOf(<span class="hljs-keyword">this</span>, header, proguardMapping, indexedGcRootTypes)<br>      <span class="hljs-keyword">return</span> index.openHeapGraph()<br>    &#125;<br><br><span class="hljs-comment">//HprofIndex.kt</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">indexRecordsOf</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      hprofSourceProvider: <span class="hljs-type">DualSourceProvider</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      hprofHeader: <span class="hljs-type">HprofHeader</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      proguardMapping: <span class="hljs-type">ProguardMapping</span>? = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      indexedGcRootTags: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">HprofRecordTag</span>&gt; = defaultIndexedGcRootTags()</span></span><br>    ): HprofIndex &#123;<br>      <span class="hljs-keyword">val</span> reader = StreamingHprofReader.readerFor(hprofSourceProvider, hprofHeader)<br>      <span class="hljs-keyword">val</span> index = HprofInMemoryIndex.indexHprof(<br>          reader = reader,<br>          hprofHeader = hprofHeader,<br>          proguardMapping = proguardMapping,<br>          indexedGcRootTags = indexedGcRootTags<br>      )<br>      <span class="hljs-keyword">return</span> HprofIndex(hprofSourceProvider, hprofHeader, index)<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>将Hprof中的<code>Record</code>解析成<code>HprofMemoryIndex</code>，将Record按照Tag进行分析和计数，并通过特定规则进行排序。</p>
<p>最终通过<code>openHeapGraph()</code>组合得到<code>HprofHeapGraph</code>对象，等价于<code>Hprof文件</code>转换成了<code>HprofHeapGraph</code>对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HprofHeapGraph.kt</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HprofHeapGraph</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">constructor</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> header: HprofHeader,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reader: RandomAccessHprofReader,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> index: HprofInMemoryIndex<br>) : CloseableHeapGraph &#123;<br>  <br>  ...<br>  <span class="hljs-comment">//缓存可以成为 GC Roots的对象</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> gcRoots: List&lt;GcRoot&gt;<br>    <span class="hljs-keyword">get</span>() = index.gcRoots()<br>  <br>  <span class="hljs-comment">//记录的是所有对象</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> objects: Sequence&lt;HeapObject&gt;<br>  <br>  <span class="hljs-comment">//对应TAG为 CLASS_DUMP</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> classes: Sequence&lt;HeapClass&gt;<br>  <br>  <span class="hljs-comment">//对应TAG为 INSTANCE_DUMP</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> instances: Sequence&lt;HeapInstance&gt;<br>  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>



<p>内部主要包括了<code>gcRoots</code>、<code>objects</code>、<code>classes</code>和<code>instances</code>几种集合，可以快速定位dump堆中的对象。</p>
<h5 id="FindLeakInput"><a href="#FindLeakInput" class="headerlink" title="FindLeakInput"></a>FindLeakInput</h5><p>主要分析泄漏对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">///HeapAnalyzer.kt</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">analyze</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    heapDumpFile: <span class="hljs-type">File</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    graph: <span class="hljs-type">HeapGraph</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    leakingObjectFinder: <span class="hljs-type">LeakingObjectFinder</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    referenceMatchers: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ReferenceMatcher</span>&gt; = emptyList()</span></span>,<br>    computeRetainedHeapSize: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>,<br>    objectInspectors: List&lt;ObjectInspector&gt; = emptyList(),<br>    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP<br>  ): HeapAnalysis &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> helpers =<br>        FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)<br>      helpers.analyzeGraph(<br>          metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime<br>      )<br>    &#125; <span class="hljs-keyword">catch</span> (exception: Throwable) &#123;<br>      )<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>接下来执行到<code>analyzeGraph</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">analyzeGraph</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  metadataExtractor: <span class="hljs-type">MetadataExtractor</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  leakingObjectFinder: <span class="hljs-type">LeakingObjectFinder</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  heapDumpFile: <span class="hljs-type">File</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  analysisStartNanoTime: <span class="hljs-type">Long</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: HeapAnalysisSuccess &#123;<br>  listener.onAnalysisProgress(EXTRACTING_METADATA)<br>  <span class="hljs-keyword">val</span> metadata = metadataExtractor.extractMetadata(graph)<br><br>  listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)<br>  <span class="hljs-keyword">val</span> leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)<br><br>  <span class="hljs-keyword">val</span> (applicationLeaks, libraryLeaks) = findLeaks(leakingObjectIds)<br>  <br>  <span class="hljs-keyword">return</span> HeapAnalysisSuccess(<br>      heapDumpFile = heapDumpFile,<br>      createdAtTimeMillis = System.currentTimeMillis(),<br>      analysisDurationMillis = since(analysisStartNanoTime),<br>      metadata = metadata,<br>      applicationLeaks = applicationLeaks,<br>      libraryLeaks = libraryLeaks<br>  )    <br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> FindLeakInput.<span class="hljs-title">findLeaks</span><span class="hljs-params">(leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;)</span></span>: Pair&lt;List&lt;ApplicationLeak&gt;, List&lt;LibraryLeak&gt;&gt; &#123;<br>  <span class="hljs-keyword">val</span> pathFinder = PathFinder(graph, listener, referenceMatchers)<br>  <span class="hljs-keyword">val</span> pathFindingResults =<br>    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)<br>  <span class="hljs-comment">//找寻最短路径</span><br>  <span class="hljs-keyword">val</span> shortestPaths =<br>    deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)<br>  <span class="hljs-keyword">val</span> inspectedObjectsByPath = inspectObjects(shortestPaths)<br>  <span class="hljs-keyword">return</span> buildLeakTraces(shortestPaths, inspectedObjectsByPath, retainedSizes)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要执行流程分为3步：</p>
<h6 id="findLeakingObjectIds"><a href="#findLeakingObjectIds" class="headerlink" title="findLeakingObjectIds"></a>findLeakingObjectIds</h6><blockquote>
<p>寻找泄漏的对象</p>
</blockquote>
<p>设置的<code>leakingObjectFinder</code>实际就是<code>KeyedWeakReferenceFinder</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//KeyedWeakReferenceFinder.kt</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findLeakingObjectIds</span><span class="hljs-params">(graph: <span class="hljs-type">HeapGraph</span>)</span></span>: Set&lt;<span class="hljs-built_in">Long</span>&gt; =<br>    findKeyedWeakReferences(graph).map &#123; it.referent.value &#125;<br>        .toSet()<br><br>  <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findKeyedWeakReferences</span><span class="hljs-params">(graph: <span class="hljs-type">HeapGraph</span>)</span></span>: List&lt;KeyedWeakReferenceMirror&gt; &#123;<br>    <span class="hljs-keyword">return</span> graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) &#123;<br>      <span class="hljs-keyword">val</span> keyedWeakReferenceClass = graph.findClassByName(<span class="hljs-string">&quot;leakcanary.KeyedWeakReference&quot;</span>)<br><br>      <span class="hljs-keyword">val</span> keyedWeakReferenceClassId = keyedWeakReferenceClass?.objectId ?: <span class="hljs-number">0</span><br>      <span class="hljs-keyword">val</span> legacyKeyedWeakReferenceClassId =<br>        graph.findClassByName(<span class="hljs-string">&quot;com.squareup.leakcanary.KeyedWeakReference&quot;</span>)?.objectId ?: <span class="hljs-number">0</span><br><br>      <span class="hljs-keyword">val</span> heapDumpUptimeMillis = heapDumpUptimeMillis(graph)<br><br>      <span class="hljs-keyword">val</span> addedToContext: List&lt;KeyedWeakReferenceMirror&gt; = graph.instances<br>          .filter &#123; instance -&gt;<br>            instance.instanceClassId == keyedWeakReferenceClassId || instance.instanceClassId == legacyKeyedWeakReferenceClassId<br>          &#125;<br>          .map &#123;<br>            KeyedWeakReferenceMirror.fromInstance(<br>                it, heapDumpUptimeMillis<br>            )<br>          &#125;<br>          .filter &#123; it.hasReferent &#125;<br>          .toList()<br>      graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext<br>      addedToContext<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>主要就是实现了 找寻<code>instance</code>实例中的被<code>KeyedWeakReference</code>所包装的实例，因为在最前面<code>watch</code>的过程中，需要监控的对象都是被<code>KeyedWeakReference</code>所包装的，既然能在<code>isntance</code>中找到就意味着这些对象是发生了内存泄漏的。</p>
<h6 id="findPathsFromGcRoots"><a href="#findPathsFromGcRoots" class="headerlink" title="findPathsFromGcRoots"></a>findPathsFromGcRoots</h6><blockquote>
<p>寻找泄漏对象到GC Roots对象的引用路径</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//PathFinder.kt </span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findPathsFromGcRoots</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    leakingObjectIds: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Long</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    computeRetainedHeapSize: <span class="hljs-type">Boolean</span></span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span>: PathFindingResults &#123;<br>...<br>    <span class="hljs-keyword">val</span> state = State(<br>        leakingObjectIds = leakingObjectIds.toLongScatterSet(),<br>        sizeOfObjectInstances = sizeOfObjectInstances,<br>        computeRetainedHeapSize = computeRetainedHeapSize,<br>        javaLangObjectId = javaLangObjectId,<br>        estimatedVisitedObjects = estimatedVisitedObjects<br>    )<br><br>    <span class="hljs-keyword">return</span> state.findPathsFromGcRoots()<br>  &#125;<br><br><span class="hljs-comment">//找寻泄漏对象 到 GC Roots对象的路径</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> State.<span class="hljs-title">findPathsFromGcRoots</span><span class="hljs-params">()</span></span>: PathFindingResults &#123;<br>    enqueueGcRoots()<br><br>    <span class="hljs-keyword">val</span> shortestPathsToLeakingObjects = mutableListOf&lt;ReferencePathNode&gt;()<br>    <span class="hljs-symbol">visitingQueue@</span> <span class="hljs-keyword">while</span> (queuesNotEmpty) &#123;<br>      <span class="hljs-keyword">val</span> node = poll()<br>      <span class="hljs-keyword">if</span> (node.objectId <span class="hljs-keyword">in</span> leakingObjectIds) &#123;<br>        shortestPathsToLeakingObjects.add(node)<br>        <span class="hljs-comment">// Found all refs, stop searching (unless computing retained size)</span><br>        <span class="hljs-keyword">if</span> (shortestPathsToLeakingObjects.size == leakingObjectIds.size()) &#123;<br>          <span class="hljs-keyword">if</span> (computeRetainedHeapSize) &#123;<br>            listener.onAnalysisProgress(FINDING_DOMINATORS)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><span class="hljs-symbol">@visitingQueue</span><br>          &#125;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> heapObject = graph.findObjectById(node.objectId)) &#123;<br>        <span class="hljs-keyword">is</span> HeapClass -&gt; visitClassRecord(heapObject, node)<br>        <span class="hljs-keyword">is</span> HeapInstance -&gt; visitInstance(heapObject, node)<br>        <span class="hljs-keyword">is</span> HeapObjectArray -&gt; visitObjectArray(heapObject, node)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> PathFindingResults(<br>        shortestPathsToLeakingObjects,<br>        <span class="hljs-keyword">if</span> (visitTracker <span class="hljs-keyword">is</span> Dominated) visitTracker.dominatorTree <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>    )<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>总体思路</p>
<blockquote>
<p>采用<strong>广度优先遍历</strong>从<code>GC Roots</code>开始遍历，直到<code>泄漏对象</code>为止。</p>
<p><code>广度优先遍历</code>：从根节点出发，沿着树宽度依此遍历树的每个节点。<strong>借助队列结构实现</strong></p>
<p>以<code>GC Roots对象</code>为树的根节点，然后从根节点开始遍历，对每个节点依据类型的不同采取对应的模式进行访问并得到对象，然后引用继续抽象成为<code>Node</code>加入队列以待后续遍历，直到遍历到<code>Node</code>为<code>leakObjectId</code>，期间经过的所有Node对象连在一起就是一次完整的引用路径。</p>
<p>最终得到的就是<code>泄漏对象 到 GC Roots对象</code>的引用路径。</p>
</blockquote>
<h6 id="deduplicateShortestPaths"><a href="#deduplicateShortestPaths" class="headerlink" title="deduplicateShortestPaths"></a>deduplicateShortestPaths</h6><blockquote>
<p>根据多条引用路径，进行裁剪得到最短的引用路径</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deduplicateShortestPaths</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  inputPathResults: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ReferencePathNode</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: List&lt;ShortestPath&gt; &#123;<br>  <span class="hljs-comment">//根节点为0</span><br>  <span class="hljs-keyword">val</span> rootTrieNode = ParentNode(<span class="hljs-number">0</span>)<br><br>  inputPathResults.forEach &#123; pathNode -&gt;<br>    <span class="hljs-comment">// Go through the linked list of nodes and build the reverse list of instances from</span><br>    <span class="hljs-comment">// root to leaking.</span><br>    <span class="hljs-keyword">val</span> path = mutableListOf&lt;<span class="hljs-built_in">Long</span>&gt;()<br>    <span class="hljs-keyword">var</span> leakNode: ReferencePathNode = pathNode<br>    <span class="hljs-keyword">while</span> (leakNode <span class="hljs-keyword">is</span> ChildNode) &#123;<br>      path.add(<span class="hljs-number">0</span>, leakNode.objectId)<br>      leakNode = leakNode.parent<br>    &#125;<br>    path.add(<span class="hljs-number">0</span>, leakNode.objectId)<br>    updateTrie(pathNode, path, <span class="hljs-number">0</span>, rootTrieNode)<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateTrie</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  pathNode: <span class="hljs-type">ReferencePathNode</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  path: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Long</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  pathIndex: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  parentNode: <span class="hljs-type">ParentNode</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-keyword">val</span> objectId = path[pathIndex]<br>  <span class="hljs-keyword">if</span> (pathIndex == path.lastIndex) &#123;<br>    parentNode.children[objectId] = LeafNode(objectId, pathNode)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">val</span> childNode = parentNode.children[objectId] ?: &#123;<br>      <span class="hljs-keyword">val</span> newChildNode = ParentNode(objectId)<br>      parentNode.children[objectId] = newChildNode<br>      newChildNode<br>    &#125;()<br>    <span class="hljs-keyword">if</span> (childNode <span class="hljs-keyword">is</span> ParentNode) &#123;<br>      updateTrie(pathNode, path, pathIndex + <span class="hljs-number">1</span>, childNode)<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>总体思路：</p>
<blockquote>
<p>一个对象被很多对象引用是很正常的行为，所以<code>泄漏对象</code>和<code>GC Roots对象</code>之间可能存在多条引用路径，此时就需要进行裁剪得到最短的引用路径方便分析。</p>
<p>将路径反转成为<code>GC Roots对象 到 泄漏对象</code>的的引用路径，然后通过<code>updateTrie()</code>转化成为无效Node为根节点的树，最后经过<code>深度优先遍历</code>得到从<code>根节点</code>到<code>叶子节点</code>的所有路径，即为最终的<code>最短引用路径</code>。</p>
<p><code>深度优先遍历</code>：从树的根节点开始，先遍历左子树再遍历右子树。<strong>借助栈结构实现</strong>。</p>
</blockquote>
<h6 id="buildLeakTraces"><a href="#buildLeakTraces" class="headerlink" title="buildLeakTraces"></a>buildLeakTraces</h6><blockquote>
<p>建立泄漏路径</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapAnalzer.kt</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">buildLeakTraces</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    shortestPaths: <span class="hljs-type">List</span>&lt;<span class="hljs-type">ShortestPath</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    inspectedObjectsByPath: <span class="hljs-type">List</span>&lt;<span class="hljs-type">List</span>&lt;<span class="hljs-type">InspectedObject</span>&gt;&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    retainedSizes: <span class="hljs-type">Map</span>&lt;<span class="hljs-type">Long</span>, Pair&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>&gt;&gt;?</span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span>: Pair&lt;List&lt;ApplicationLeak&gt;, List&lt;LibraryLeak&gt;&gt; &#123;<br>    ...<br>    shortestPaths.forEachIndexed &#123; pathIndex, shortestPath -&gt;<br>      <span class="hljs-keyword">val</span> inspectedObjects = inspectedObjectsByPath[pathIndex]<br>      <span class="hljs-comment">//构建内存泄漏对象</span><br>      <span class="hljs-keyword">val</span> leakTraceObjects = buildLeakTraceObjects(inspectedObjects, retainedSizes)<br>      <span class="hljs-comment">//构建引用路径</span><br>      <span class="hljs-keyword">val</span> referencePath = buildReferencePath(shortestPath.childPath, leakTraceObjects)<br><br>      <span class="hljs-keyword">val</span> leakTrace = LeakTrace(<br>          gcRootType = GcRootType.fromGcRoot(shortestPath.root.gcRoot),<br>          referencePath = referencePath,<br>          leakingObject = leakTraceObjects.last()<br>      )<br><br>      <span class="hljs-keyword">val</span> firstLibraryLeakNode = <span class="hljs-keyword">if</span> (shortestPath.root <span class="hljs-keyword">is</span> LibraryLeakNode) &#123;<br>        shortestPath.root<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        shortestPath.childPath.firstOrNull &#123; it <span class="hljs-keyword">is</span> LibraryLeakNode &#125; <span class="hljs-keyword">as</span> LibraryLeakNode?<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (firstLibraryLeakNode != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">val</span> matcher = firstLibraryLeakNode.matcher<br>        <span class="hljs-keyword">val</span> signature: String = matcher.pattern.toString()<br>            .createSHA1Hash()<br>        libraryLeaksMap.getOrPut(signature) &#123; matcher to mutableListOf() &#125;<br>            .second += leakTrace<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//添加到 应用内存泄漏列表中</span><br>        applicationLeaksMap.getOrPut(leakTrace.signature) &#123; mutableListOf() &#125; += leakTrace<br>      &#125;<br>    &#125;    <br>    <br>  &#125;<br><br></code></pre></td></tr></table></figure>

<p>最终构建得到<code>ApplicationLeak</code>和<code>LibraryLeak</code>，组装得到<code>HeapAnalysis</code></p>
<ul>
<li><p><code>ApplicationLeak</code>：在开发工程中应用自身导致的内存泄漏</p>
</li>
<li><p><code>LibraryLeak</code>：<code>is a Leak caused by a known bug in third party code that you do not have control over. </code>已知的系统内存泄漏问题。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/pull/1785">Explain Library Leaks in fundamentals</a></p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//HeapAnalyzerService.kt</span><br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHandleIntentInForeground</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (intent == <span class="hljs-literal">null</span> || !intent.hasExtra(HEAPDUMP_FILE_EXTRA)) &#123;<br>      SharkLog.d &#123; <span class="hljs-string">&quot;HeapAnalyzerService received a null or empty intent, ignoring.&quot;</span> &#125;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// Since we&#x27;re running in the main process we should be careful not to impact it.</span><br>    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)<br>    <span class="hljs-keyword">val</span> heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) <span class="hljs-keyword">as</span> File<br>    <span class="hljs-keyword">val</span> heapDumpDurationMillis = intent.getLongExtra(HEAPDUMP_DURATION_MILLIS, -<span class="hljs-number">1</span>)<br><span class="hljs-comment">//获取 LeakCanary的配置</span><br>    <span class="hljs-keyword">val</span> config = LeakCanary.config<br>    <span class="hljs-keyword">val</span> heapAnalysis = <span class="hljs-keyword">if</span> (heapDumpFile.exists()) &#123;<br>      <span class="hljs-comment">//解析 hprof文件</span><br>      analyzeHeap(heapDumpFile, config)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      missingFileFailure(heapDumpFile)<br>    &#125;<br>    <span class="hljs-keyword">val</span> fullHeapAnalysis = <span class="hljs-keyword">when</span> (heapAnalysis) &#123;<br>      <span class="hljs-keyword">is</span> HeapAnalysisSuccess -&gt; heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)<br>      <span class="hljs-keyword">is</span> HeapAnalysisFailure -&gt; heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)<br>    &#125;<br>    onAnalysisProgress(REPORTING_HEAP_ANALYSIS)<br>  <span class="hljs-comment">//解析完成后 回调 onHeapAnalyzed</span><br>    config.onHeapAnalyzedListener.onHeapAnalyzed(fullHeapAnalysis)<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>解析完成后，回调到<code>onHeapAnalyzedListener</code>中的<code>onHeapAnalyzed()</code>.</p>
<p>其中<code>config </code>配置的<code>onHeapAnalyzedListener</code>为<code>DefaultOnHeapAnalyzedListener</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//DefaultOnHeapAnalyzedListener.kt</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onHeapAnalyzed</span><span class="hljs-params">(heapAnalysis: <span class="hljs-type">HeapAnalysis</span>)</span></span> &#123;<br>    SharkLog.d &#123; <span class="hljs-string">&quot;\u200B\n<span class="hljs-subst">$&#123;LeakTraceWrapper.wrap(heapAnalysis.toString(), <span class="hljs-number">120</span>)&#125;</span>&quot;</span> &#125;<br><br>    <span class="hljs-keyword">val</span> id = LeaksDbHelper(application).writableDatabase.use &#123; db -&gt;<br>      HeapAnalysisTable.insert(db, heapAnalysis)<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> (contentTitle, screenToShow) = <span class="hljs-keyword">when</span> (heapAnalysis) &#123;<br>      <span class="hljs-keyword">is</span> HeapAnalysisFailure -&gt; application.getString(<br>          R.string.leak_canary_analysis_failed<br>      ) to HeapAnalysisFailureScreen(id)<br>      <span class="hljs-keyword">is</span> HeapAnalysisSuccess -&gt; &#123;<br>        <span class="hljs-keyword">val</span> retainedObjectCount = heapAnalysis.allLeaks.sumBy &#123; it.leakTraces.size &#125;<br>        <span class="hljs-keyword">val</span> leakTypeCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size<br>        application.getString(<br>            R.string.leak_canary_analysis_success_notification, retainedObjectCount, leakTypeCount<br>        ) to HeapDumpScreen(id)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//显示通知 提示已经解析完毕</span><br>      showNotification(screenToShow, contentTitle)<br><br>  &#125;<br></code></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.LeakCanary整套流程从<code>注册监听Activity/Fragment对象生命周期</code>开始，当对应组件销毁时<code>添加对应组件的观察</code>。</p>
<ul>
<li>在<code>onActivityDestroyed()</code>添加对<code>Activity</code>的观察</li>
<li>在<code>onFragmentViewDestroyed()</code>添加对<code>Fragment中的View</code>的观察</li>
<li>在<code>onFragmentDestroyed()</code>添加对<code>Fragment</code>的观察</li>
<li>可以通过<code>AppWatcher.objectWatcher.watch(XX)</code>添加自定义对象的观察。</li>
</ul>
<p>2.在<code>泄漏检测</code>时，通过<code>WeakRefrence</code>包装<code>被观察的对象</code>，然后等待<strong>5s</strong>后，检查与<code>WeakReference</code>绑定的<code>ReferenceQueue</code>中是否包含<code>被观察对象</code>，若包含表示<code>被观察对象</code>已被回收；否则，判断对象可能泄漏。<em>5s并不一定是执行了GC，只是一个估值，一般都会触发GC。</em></p>
<p>3.在<code>准备DumpHeap</code>前，还会再去<code>手动执行一次GC</code>，等待<strong>100ms</strong>后如果还存在<code>泄漏对象</code>，就需要准备dump内存数据。此时有一个阈值，如果泄漏对象超过<strong>5个</strong>，才会去dump，避免频繁执行dump流程。</p>
<p>4.通过执行<code>Debug.dumpHprofData()</code>去生成<code>Hprof文件</code>，等待<code>Hprof文件</code>生成后，发送到<code>HeapAnalyzerService</code>去处理该文件。</p>
<p>5.<code>HeapAnalyzerService</code>收到<code>Hprof文件</code>后，通过<strong>Shark</strong>对文件进行解析，按照<code>Hprof文件格式</code>进行解析，解析得到<code>HprofHeapGraph</code>对象，内部包含<code>gcRoots</code>、<code>instances</code>、<code>classes</code>、<code>objects</code>等集合，可以快速定位泄漏对象。</p>
<p>6.得到<code>HprofHeapGraph</code>对象后，开始分析内存泄漏的最短路径。<em>内存泄漏的对象仍然与GC Roots对象保持可达的引用路径，导致GC无法释放。——一般用的都是<code>可达性分析</code></em>。</p>
<ul>
<li><code>寻找内存泄漏对象</code>：在<code>instances</code>集合中寻找<code>instanceClassId</code>为<code>KeyedWeakReferences</code>的对象，这些就是前面所观察的对象。</li>
<li><code>寻找所有内存泄漏对象与GC Roots对象的引用路径</code>：采用<code>广度优先遍历</code>，从<code>Gc Roots对象</code>开始遍历到<code>内存泄漏对象</code>的所有引用路径</li>
<li><code>裁剪所有路径得到 最短引用路径</code>：采用<code>深度优先遍历</code>，得到<code>内存泄漏对象</code>到<code>GC Roots对象</code>的最短引用路径</li>
<li><code>通知内存泄漏检测完毕</code>：将<code>最短引用路径</code>包装成<code>LeakTrace</code>，按照<strong>是否为应用自身导致的内存泄漏</strong>分为两个对象：<code>ApplicationLeak</code>和<code>LibraryLeak</code>。</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://square.github.io/leakcanary/getting_started/">LeakCanary Wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://linjiang.tech/2019/12/25/leakcanary/">LeakCanary解析</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/" class="print-no-link">#Android</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Android性能优化-LeakCanary</div>
      <div>http://example.com/2020/10/14/Android性能优化-LeakCanary/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Leo-Wxy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年10月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/10/27/Android-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/" title="Android硬件加速">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android硬件加速</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/12/Android-%E5%8A%A8%E7%94%BB-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/" title="Android动画-属性动画">
                        <span class="hidden-mobile">Android动画-属性动画</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
