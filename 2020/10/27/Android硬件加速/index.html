

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <title>Android硬件加速 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.5","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android硬件加速">
              
                Android硬件加速
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-27 19:51" pubdate>
        2020年10月27日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      98
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android硬件加速</h1>
            
            <div class="markdown-body">
              <p><img src="/images/Android硬件加速.png" srcset="/img/loading.gif" alt="Android硬件加速xmind"></p>
<h2 id="软硬件绘制的分歧点"><a href="#软硬件绘制的分歧点" class="headerlink" title="软硬件绘制的分歧点"></a>软硬件绘制的分歧点</h2><p>绘制过程入口位于<code>ViewRootImpl.performDraw()</code>中</p>
<pre><code class="hljs java"><span class="hljs-comment">//viewRootImpl.java</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performDraw</span><span class="hljs-params">()</span> </span>&#123;
      ...
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//调用draw()执行实际的绘制工作</span>
            <span class="hljs-keyword">boolean</span> canUseAsync = draw(fullRedrawNeeded);
            <span class="hljs-keyword">if</span> (usingAsyncReport &amp;&amp; !canUseAsync) &#123;
                mAttachInfo.mThreadedRenderer.setFrameCompleteCallback(<span class="hljs-keyword">null</span>);
                usingAsyncReport = <span class="hljs-keyword">false</span>;
            &#125;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            mIsDrawing = <span class="hljs-keyword">false</span>;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        &#125;
    &#125;</code></pre>
<p><code>ViewRootImpl.draw()</code>实际执行的绘制工作</p>
<pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;
  ...
    <span class="hljs-keyword">final</span> Rect dirty = mDirty;<span class="hljs-comment">//需要重新绘制的区域</span>
  ...
    <span class="hljs-keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;
            <span class="hljs-comment">//是否支持硬件加速</span>
            <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;
              ...
                mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="hljs-keyword">this</span>, callback);<span class="hljs-comment">//硬件绘制</span>
            &#125; <span class="hljs-keyword">else</span> &#123;
              ...
                <span class="hljs-comment">//软件绘制</span>
                <span class="hljs-keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,
                        scalingRequired, dirty, surfaceInsets)) &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                &#125;
            &#125;
      ...
    &#125;
  ...
  
&#125;</code></pre>
<h2 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h2><p><img src="/images/Android绘制-软件绘制.png" srcset="/img/loading.gif" alt="Android绘制-软件绘制"></p>
<h3 id="ViewRootImpl软件绘制相关"><a href="#ViewRootImpl软件绘制相关" class="headerlink" title="ViewRootImpl软件绘制相关"></a>ViewRootImpl软件绘制相关</h3><blockquote>
<p>未开启<code>硬件加速</code>时，执行到<code>drawSoftware()</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">drawSoftware</span><span class="hljs-params">(Surface surface, AttachInfo attachInfo, <span class="hljs-keyword">int</span> xoff, <span class="hljs-keyword">int</span> yoff,
        <span class="hljs-keyword">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> </span>&#123;
    <span class="hljs-comment">// Draw with software renderer.</span>
    <span class="hljs-keyword">final</span> Canvas canvas;
  
   canvas = mSurface.lockCanvas(dirty);<span class="hljs-comment">//获取用于绘制的Canvas</span>
   ...
   mView.draw(canvas);<span class="hljs-comment">//将mView的内容绘制到Canvas</span>
   ...
   <span class="hljs-comment">//将Canvas的内容显示到屏幕上,向SurfaceFlinger服务Queue一个Graphic Buffer</span>
   surface.unlockCanvasAndPost(canvas);
&#125;</code></pre>
<p>此处的<code>mView</code>对应的就是<code>DecorView</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//DecorView.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
        <span class="hljs-keyword">super</span>.draw(canvas);

        <span class="hljs-keyword">if</span> (mMenuBackground != <span class="hljs-keyword">null</span>) &#123;
            mMenuBackground.draw(canvas);
        &#125;
    &#125;</code></pre>
<p>执行到<code>super.draw()</code>，<code>DecorView</code>继承自<code>FrameLayout</code>，等价于执行到<code>ViewGroup.draw()</code>。</p>
<pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
      ...
        <span class="hljs-keyword">if</span> (!dirtyOpaque) &#123;
          <span class="hljs-comment">//绘制背景</span>
            drawBackground(canvas);
        &#125;
        <span class="hljs-comment">//绘制自身</span>
        <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);
        <span class="hljs-comment">//绘制子View 只有ViewGroup会实现该方法</span>
        dispatchDraw(canvas);
        <span class="hljs-comment">//绘制前景</span>
        onDrawForeground(canvas);
      ...
    &#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-comment">//ViewGroup.java</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
      ...
        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties
                ? <span class="hljs-keyword">null</span> : buildOrderedChildList();<span class="hljs-comment">//绘制顺序按照Z值从大到小排列</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = preorderedList == <span class="hljs-keyword">null</span>
                &amp;&amp; isChildrenDrawingOrderEnabled();<span class="hljs-comment">//允许自定义绘制顺序</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;
            <span class="hljs-keyword">while</span> (transientIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;
                <span class="hljs-keyword">final</span> View transientChild = mTransientViews.get(transientIndex);
                <span class="hljs-keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||
                        transientChild.getAnimation() != <span class="hljs-keyword">null</span>) &#123;
                    more |= drawChild(canvas, transientChild, drawingTime);
                &#125;
                transientIndex++;
                <span class="hljs-keyword">if</span> (transientIndex &gt;= transientCount) &#123;
                    transientIndex = -<span class="hljs-number">1</span>;
                &#125;
            &#125;

            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<span class="hljs-comment">//根据自定义顺序获取当前绘制的View的绘制顺序</span>
            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;
                more |= drawChild(canvas, child, drawingTime);
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">//绘制子View</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">drawChild</span><span class="hljs-params">(Canvas canvas, View child, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;
        <span class="hljs-keyword">return</span> child.draw(canvas, <span class="hljs-keyword">this</span>, drawingTime);
    &#125;</code></pre>
<p><code>DecorView</code>是最顶层的View，自<code>drawSoftware()</code>开始绘制。</p>
<h3 id="View软件绘制相关"><a href="#View软件绘制相关" class="headerlink" title="View软件绘制相关"></a>View软件绘制相关</h3><p>上一节后面执行到了<code>child.draw()</code>，<code>child</code>为<code>View</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
        <span class="hljs-comment">//是否支持硬件绘制 显然当前情况不支持</span>
        <span class="hljs-keyword">boolean</span> drawingWithRenderNode = mAttachInfo != <span class="hljs-keyword">null</span>
                &amp;&amp; mAttachInfo.mHardwareAccelerated
                &amp;&amp; hardwareAcceleratedCanvas;
  
         ...
           <span class="hljs-comment">//后续绘制缓存会分析</span>
          <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123;
             <span class="hljs-keyword">if</span> (layerType != LAYER_TYPE_NONE) &#123;
                 <span class="hljs-comment">// If not drawing with RenderNode, treat HW layers as SW</span>
                 layerType = LAYER_TYPE_SOFTWARE;
                 buildDrawingCache(<span class="hljs-keyword">true</span>);
            &#125;
            cache = getDrawingCache(<span class="hljs-keyword">true</span>);
         &#125;
         <span class="hljs-comment">//缓存可用 且 非硬件绘制条件下</span>
         <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> drawingWithDrawingCache = cache != <span class="hljs-keyword">null</span> &amp;&amp; !drawingWithRenderNode;
         ...
         <span class="hljs-keyword">if</span> (!drawingWithDrawingCache) &#123;
            <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;
                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
                ((DisplayListCanvas) canvas).drawRenderNode(renderNode);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// ViewGroup 不需要绘制背景直接 绘制子View</span>
                <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;
                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    draw(canvas);
                &#125;
            &#125;
        &#125;
       ...
&#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
        <span class="hljs-keyword">if</span> ((changed &amp; DRAW_MASK) != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> ((mViewFlags &amp; WILL_NOT_DRAW) != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">if</span> (mBackground != <span class="hljs-keyword">null</span>
                        || mDefaultFocusHighlight != <span class="hljs-keyword">null</span>
                        || (mForegroundInfo != <span class="hljs-keyword">null</span> &amp;&amp; mForegroundInfo.mDrawable != <span class="hljs-keyword">null</span>)) &#123;
                    mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    mPrivateFlags |= PFLAG_SKIP_DRAW;
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;
            &#125;
            requestLayout();
            invalidate(<span class="hljs-keyword">true</span>);
        &#125;</code></pre>
<h3 id="软件绘制流程"><a href="#软件绘制流程" class="headerlink" title="软件绘制流程"></a>软件绘制流程</h3><p><img src="/images/软件绘制流程.jpg" srcset="/img/loading.gif" alt="软件绘制流程"></p>
<h3 id="Surface绘制流程"><a href="#Surface绘制流程" class="headerlink" title="Surface绘制流程"></a>Surface绘制流程</h3><p><img src="/images/软件绘制-Surface绘制过程.png" srcset="/img/loading.gif" alt="软件绘制-Surface绘制过程"></p>
<p>执行到<code>drawSoftware()</code>时，开始在<code>Surface</code>上进行绘制。</p>
<h4 id="申请GraphicBuffer"><a href="#申请GraphicBuffer" class="headerlink" title="申请GraphicBuffer"></a>申请<code>GraphicBuffer</code></h4><p>执行的是<code>mSurface.lockCanvas()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>
canvas = mSurface.lockCanvas()
  
<span class="hljs-comment">//Surface.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Canvas <span class="hljs-title">lockCanvas</span><span class="hljs-params">(Rect inOutDirty)</span>
            <span class="hljs-keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;
        <span class="hljs-keyword">synchronized</span> (mLock) &#123;
            checkNotReleasedLocked();
            <span class="hljs-keyword">if</span> (mLockedObject != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// Ideally, nativeLockCanvas() would throw in this situation and prevent the</span>
                <span class="hljs-comment">// double-lock, but that won't happen if mNativeObject was updated.  We can't</span>
                <span class="hljs-comment">// abandon the old mLockedObject because it might still be in use, so instead</span>
                <span class="hljs-comment">// we just refuse to re-lock the Surface.</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Surface was already locked"</span>);
            &#125;
            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
            <span class="hljs-keyword">return</span> mCanvas;
        &#125;
    &#125;</code></pre>
<p>执行到<code>nativeLockCanvas()</code>进入JNI代码层</p>
<pre><code class="hljs c++"><span class="hljs-comment">// core/jni/android_view_Surface.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeLockCanvas</span><span class="hljs-params">(JNIEnv* env, jclass clazz,
        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;
    <span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">surface</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;
  ...
    <span class="hljs-comment">//申请buffer</span>
    ANativeWindow_Buffer outBuffer;
    <span class="hljs-keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);
  ...
    <span class="hljs-comment">//构建Bitmap对象</span>
    SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,
                                         convertPixelFormat(outBuffer.format),
                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888
                                                 ? kOpaque_SkAlphaType : kPremul_SkAlphaType,
                                         GraphicsJNI::defaultColorSpace());

    SkBitmap bitmap;
    <span class="hljs-keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);
    bitmap.setInfo(info, bpr);
    <span class="hljs-keyword">if</span> (outBuffer.width &gt; <span class="hljs-number">0</span> &amp;&amp; outBuffer.height &gt; <span class="hljs-number">0</span>) &#123;
        bitmap.setPixels(outBuffer.bits);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// be safe with an empty bitmap.</span>
        bitmap.setPixels(<span class="hljs-literal">NULL</span>);
    &#125;
    <span class="hljs-comment">//canvas设置bitmap</span>
    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);
    nativeCanvas-&gt;setBitmap(bitmap);
    
    <span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">lockedSurface</span><span class="hljs-params">(surface)</span></span>;
    lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);
    <span class="hljs-keyword">return</span> (jlong) lockedSurface.get();
&#125;</code></pre>
<p>创建完<code>ANativeWindowBuffer</code>之后，需要与<code>surface</code>进行绑定</p>
<pre><code class="hljs c++"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Surface::lock</span><span class="hljs-params">(
        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span>
</span>&#123;
  ...
    ANativeWindowBuffer* out;
    <span class="hljs-keyword">int</span> fenceFd = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);  
  ...
     <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;
        <span class="hljs-function">sp&lt;GraphicBuffer&gt; <span class="hljs-title">backBuffer</span><span class="hljs-params">(GraphicBuffer::getSelf(out))</span></span>;
        <span class="hljs-function"><span class="hljs-keyword">const</span> Rect <span class="hljs-title">bounds</span><span class="hljs-params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;
       ...
     &#125;
  <span class="hljs-comment">//返回GraphicBuffer</span>
     <span class="hljs-keyword">return</span> err;
&#125;</code></pre>
<p>调用到<code>lock()</code>之后，将<code>ANativeWindowBuffer</code>转化为<code>GraphicBuffer</code>。再通过<code>dequeueBuffer</code>分配内存</p>
<pre><code class="hljs c++"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Surface::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">android_native_buffer_t</span>** buffer, <span class="hljs-keyword">int</span>* fenceFd)</span> </span>&#123;
  ...
    FrameEventHistoryDelta frameTimestamps;
    <span class="hljs-keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight,
                                                            reqFormat, reqUsage, &amp;mBufferAge,
                                                            enableFrameTimestamps ? &amp;frameTimestamps
                                                                                  : <span class="hljs-literal">nullptr</span>);    
  
  ...
    <span class="hljs-keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="hljs-literal">nullptr</span>) &#123;
        <span class="hljs-keyword">if</span> (mReportRemovedBuffers &amp;&amp; (gbuf != <span class="hljs-literal">nullptr</span>)) &#123;
            mRemovedBuffers.push_back(gbuf);
        &#125;
      <span class="hljs-comment">//</span>
        result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);
        <span class="hljs-keyword">if</span> (result != NO_ERROR) &#123;
            ALOGE(<span class="hljs-string">"dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d"</span>, result);
            mGraphicBufferProducer-&gt;cancelBuffer(buf, fence);
            <span class="hljs-keyword">return</span> result;
        &#125;
    &#125;
  <span class="hljs-comment">//获取buffer</span>
     *buffer = gbuf.get();
  ...
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,
                                            <span class="hljs-keyword">uint32_t</span> width, <span class="hljs-keyword">uint32_t</span> height, PixelFormat format,
                                            <span class="hljs-keyword">uint64_t</span> usage, <span class="hljs-keyword">uint64_t</span>* outBufferAge,
                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;
 ...
    <span class="hljs-keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;
      <span class="hljs-comment">//找到可用的slot，并指定状态为FREE slot:BufferSlot——用来存储GraphicBuffer</span>
            <span class="hljs-keyword">status_t</span> status = waitForFreeSlotThenRelock(FreeSlotCaller::Dequeue,
                    &amp;found);
            <span class="hljs-keyword">if</span> (status != NO_ERROR) &#123;
                <span class="hljs-keyword">return</span> status;
            &#125;
      ...
    &#125;
          *outSlot = found;
        ATRACE_BUFFER_INDEX(found);

        attachedByConsumer = mSlots[found].mNeedsReallocation;
        mSlots[found].mNeedsReallocation = <span class="hljs-literal">false</span>;
       <span class="hljs-comment">//转化可用slot的GraphicBuffer状态为DEQUEUED</span>
        mSlots[found].mBufferState.dequeue();
  ...
      <span class="hljs-keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;
        BQ_LOGV(<span class="hljs-string">"dequeueBuffer: allocating a new buffer for slot %d"</span>, *outSlot);
        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="hljs-keyword">new</span> GraphicBuffer(
                width, height, format, BQ_LAYER_COUNT, usage,
                &#123;mConsumerName.<span class="hljs-built_in">string</span>(), mConsumerName.size()&#125;);

        <span class="hljs-keyword">status_t</span> error = graphicBuffer-&gt;initCheck();

            <span class="hljs-keyword">if</span> (error == NO_ERROR &amp;&amp; !mCore-&gt;mIsAbandoned) &#123;
                graphicBuffer-&gt;setGenerationNumber(mCore-&gt;mGenerationNumber);
              <span class="hljs-comment">//对应outSlot申请GraphicBuffer</span>
                mSlots[*outSlot].mGraphicBuffer = graphicBuffer;
            &#125;
  ...
&#125;
  
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::waitForFreeSlotThenRelock</span><span class="hljs-params">(FreeSlotCaller caller,
        <span class="hljs-keyword">int</span>* found)</span> <span class="hljs-keyword">const</span> </span>&#123;
  ...
    <span class="hljs-comment">//当前是否 队列太多</span>
        <span class="hljs-keyword">bool</span> tooManyBuffers = mCore-&gt;mQueue.size()
                            &gt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(maxBufferCount);
        <span class="hljs-keyword">if</span> (tooManyBuffers) &#123;
            BQ_LOGV(<span class="hljs-string">"%s: queue size is %zu, waiting"</span>, callerString,
                    mCore-&gt;mQueue.size());
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// If in shared buffer mode and a shared buffer exists, always</span>
            <span class="hljs-comment">// return it.</span>
            <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot !=
                    BufferQueueCore::INVALID_BUFFER_SLOT) &#123;
                *found = mCore-&gt;mSharedBufferSlot;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">if</span> (caller == FreeSlotCaller::Dequeue) &#123;
                    <span class="hljs-comment">// If we're calling this from dequeue, prefer free buffers</span>
                  <span class="hljs-comment">//寻找处于 FREE 状态的GraphicBuffer</span>
                    <span class="hljs-keyword">int</span> slot = getFreeBufferLocked();
                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;
                        *found = slot;                      
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCore-&gt;mAllowAllocation) &#123;
                        *found = getFreeSlotLocked();
                    &#125;                                    
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// If we're calling this from attach, prefer free slots</span>
                    <span class="hljs-keyword">int</span> slot = getFreeSlotLocked();
                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;
                        *found = slot;
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        *found = getFreeBufferLocked();
                    &#125;
                &#125;
            &#125;
        &#125;    
  ...
        tryAgain = (*found == BufferQueueCore::INVALID_BUFFER_SLOT) ||
                   tooManyBuffers;
         <span class="hljs-keyword">if</span> (tryAgain) &#123;
           <span class="hljs-comment">//找不到可用的slot或者buffer太多，需要等待空闲</span>
         &#125;
&#125;</code></pre>
<p><code>BufferSlot</code>：用来存储<code>GraphicBuffer</code></p>
<p><code>waitForFreeSlotThenRelock()</code>返回可用的<code>slot</code>分为两种：</p>
<ul>
<li><code>getFreeBufferLocked()</code>：直接关联了<code>GraphicBuffer</code>，直接可用</li>
<li><code>getFreeSlotLocked()</code>：找到可用的<code>BufferSlot</code>，新建<code>GraphicBuffer</code>后，直接与其关联。</li>
</ul>
<p><code>lockCanvas()</code>最终通过<code>BufferQueueProducer.dequeueBuffer()</code>申请用来绘制的<code>GraphicBuffer</code></p>
<blockquote>
<p>尝试找到一个<code>BufferSlot</code>，并完成<code>GraphicBuffer</code>与<code>BufferSlot</code>的关联，途中切换<code>BufferSlot</code>状态<code>FREE-&gt;DEQUEUED</code>，最后返回对应的<code>BufferSlot</code>索引。</p>
</blockquote>
<h4 id="SurfaceFlinger消费GraphicBuffer"><a href="#SurfaceFlinger消费GraphicBuffer" class="headerlink" title="SurfaceFlinger消费GraphicBuffer"></a><code>SurfaceFlinger</code>消费<code>GraphicBuffer</code></h4><p>当<code>Cavans</code>绘制完毕后，调用<code>surface.unlockAndPostCanvas()</code>发送<code>GraphicBuffer</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//Surface.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlockAndPostCanvas</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
        <span class="hljs-keyword">synchronized</span> (mLock) &#123;
            checkNotReleasedLocked();

            <span class="hljs-keyword">if</span> (mHwuiContext != <span class="hljs-keyword">null</span>) &#123;
              <span class="hljs-comment">//硬件绘制流程</span>
                mHwuiContext.unlockAndPost(canvas);
            &#125; <span class="hljs-keyword">else</span> &#123;
              <span class="hljs-comment">//软件绘制流程</span>
                unlockSwCanvasAndPost(canvas);
            &#125;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlockSwCanvasAndPost</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
      ... 
        <span class="hljs-keyword">try</span> &#123;
            nativeUnlockCanvasAndPost(mLockedObject, canvas);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            nativeRelease(mLockedObject);
            mLockedObject = <span class="hljs-number">0</span>;
        &#125;
    &#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">// core/jni/android_view_Surface.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nativeUnlockCanvasAndPost</span><span class="hljs-params">(JNIEnv* env, jclass clazz,
        jlong nativeObject, jobject canvasObj)</span> </span>&#123;
  ...

    <span class="hljs-comment">// 绘制完成后，将Canvas从surface上脱离</span>
    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);
    nativeCanvas-&gt;setBitmap(SkBitmap());

    <span class="hljs-comment">// unlock surface</span>
    <span class="hljs-keyword">status_t</span> err = surface-&gt;unlockAndPost();
    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;
        doThrowIAE(env);
    &#125;
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Surface::unlockAndPost</span><span class="hljs-params">()</span>
</span>&#123;
  ...
    err = queueBuffer(mLockedBuffer.get(), fd);
    ALOGE_IF(err, <span class="hljs-string">"queueBuffer (handle=%p) failed (%s)"</span>,
            mLockedBuffer-&gt;handle, strerror(-err));

    mPostedBuffer = mLockedBuffer;
    mLockedBuffer = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> err;
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Surface::queueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">android_native_buffer_t</span>* buffer, <span class="hljs-keyword">int</span> fenceFd)</span> </span>&#123;
  ...
    <span class="hljs-comment">//根据Buffer获取slot</span>
    <span class="hljs-keyword">int</span> i = getSlotFromBufferLocked(buffer);
  ...
    <span class="hljs-comment">//GraphicBufferQueue 插入 GraphicBuffer</span>
    <span class="hljs-keyword">status_t</span> err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);
  ...
    <span class="hljs-comment">//插入Buffer后通知</span>
    mQueueBufferCondition.broadcast();
&#125; 

<span class="hljs-comment">//根据传入buffer获取slot</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Surface::getSlotFromBufferLocked</span><span class="hljs-params">(
        <span class="hljs-keyword">android_native_buffer_t</span>* buffer)</span> <span class="hljs-keyword">const</span> </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_BUFFER_SLOTS; i++) &#123;
        <span class="hljs-keyword">if</span> (mSlots[i].buffer != <span class="hljs-literal">NULL</span> &amp;&amp;
                mSlots[i].buffer-&gt;handle == buffer-&gt;handle) &#123;
            <span class="hljs-keyword">return</span> i;
        &#125;
    &#125;
    ALOGE(<span class="hljs-string">"getSlotFromBufferLocked: unknown buffer: %p"</span>, buffer-&gt;handle);
    <span class="hljs-keyword">return</span> BAD_VALUE;
&#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span>
status_t BufferQueueProducer::queueBuffer(<span class="hljs-keyword">int</span> slot,
        <span class="hljs-keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;
    BufferItem item;
  ...
    <span class="hljs-comment">//判断slot 以及 buffer状态是否正常</span>
        <span class="hljs-keyword">if</span> (slot &lt; <span class="hljs-number">0</span> || slot &gt;= BufferQueueDefs::NUM_BUFFER_SLOTS) &#123;
            BQ_LOGE(<span class="hljs-string">"queueBuffer: slot index %d out of range [0, %d)"</span>,
                    slot, BufferQueueDefs::NUM_BUFFER_SLOTS);
            <span class="hljs-keyword">return</span> BAD_VALUE;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mSlots[slot].mBufferState.isDequeued()) &#123;
            BQ_LOGE(<span class="hljs-string">"queueBuffer: slot %d is not owned by the producer "</span>
                    <span class="hljs-string">"(state = %s)"</span>, slot, mSlots[slot].mBufferState.string());
            <span class="hljs-keyword">return</span> BAD_VALUE;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mSlots[slot].mRequestBufferCalled) &#123;
            BQ_LOGE(<span class="hljs-string">"queueBuffer: slot %d was queued without requesting "</span>
                    <span class="hljs-string">"a buffer"</span>, slot);
            <span class="hljs-keyword">return</span> BAD_VALUE;
        &#125;
  ...
    <span class="hljs-comment">//构建BufferItem对象，等待传递</span>
        item.mAcquireCalled = mSlots[slot].mAcquireCalled;
        item.mGraphicBuffer = mSlots[slot].mGraphicBuffer;
        item.mCrop = crop;
        item.mTransform = transform &amp;
                ~static_cast&lt;uint32_t&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);
        item.mTransformToDisplayInverse =
                (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != <span class="hljs-number">0</span>;
        item.mScalingMode = static_cast&lt;uint32_t&gt;(scalingMode);
        item.mTimestamp = requestedPresentTimestamp;
        item.mIsAutoTimestamp = isAutoTimestamp;
        item.mDataSpace = dataSpace;
        item.mHdrMetadata = hdrMetadata;
        item.mFrameNumber = currentFrameNumber;
        item.mSlot = slot;
        item.mFence = acquireFence;
        item.mFenceTime = acquireFenceTime;
        item.mIsDroppable = mCore-&gt;mAsyncMode ||
                mCore-&gt;mDequeueBufferCannotBlock ||
                (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == slot);
        item.mSurfaceDamage = surfaceDamage;
        item.mQueuedBuffer = <span class="hljs-keyword">true</span>;
        item.mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mAutoRefresh;
        item.mApi = mCore-&gt;mConnectedApi;
  
    <span class="hljs-comment">//切换 BufferSlot状态到 QUEUED</span>
        mSlots[slot].mFence = acquireFence;
        mSlots[slot].mBufferState.queue();
    <span class="hljs-comment">//将item插入队列</span>
        <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;
            mCore-&gt;mQueue.push_back(item);
            frameAvailableListener = mCore-&gt;mConsumerListener;          
        &#125;<span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">const</span> BufferItem&amp; last = mCore-&gt;mQueue.itemAt(
                    mCore-&gt;mQueue.size() - <span class="hljs-number">1</span>);
            <span class="hljs-keyword">if</span> (last.mIsDroppable) &#123;
              ...
               mCore-&gt;mQueue.editItemAt(mCore-&gt;mQueue.size() - <span class="hljs-number">1</span>) = item;
               frameReplacedListener = mCore-&gt;mConsumerListener;
            &#125;<span class="hljs-keyword">else</span>&#123;
               mCore-&gt;mQueue.push_back(item);
               frameAvailableListener = mCore-&gt;mConsumerListener;              
            &#125;
        &#125;
  ...
    <span class="hljs-comment">//回调frameAvaliableListener 通知消费者有数据入队了</span>
        <span class="hljs-keyword">if</span> (frameAvailableListener != NULL) &#123;
            frameAvailableListener-&gt;onFrameAvailable(item);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (frameReplacedListener != NULL) &#123;
            frameReplacedListener-&gt;onFrameReplaced(item);
        &#125;    
&#125;</code></pre>
<p>//TODO 这里有个问题 如何和<code>BufferLayer</code>绑定</p>
<pre><code class="hljs c++"><span class="hljs-comment">//native/services/surfaceflinger/BufferLayer.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BufferQueueLayer::onFrameAvailable</span><span class="hljs-params">(<span class="hljs-keyword">const</span> BufferItem&amp; item)</span> </span>&#123;
  ...
   mFlinger-&gt;signalLayerUpdate();
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//SurfaceFlinger.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::signalLayerUpdate</span><span class="hljs-params">()</span> </span>&#123;
    mScheduler-&gt;resetIdleTimer();
    mPowerAdvisor.notifyDisplayUpdateImminent();
    mEventQueue-&gt;invalidate();
&#125;</code></pre>
<blockquote>
<p><code>unlockAndPost()</code>主要调用到<code>queueBuffer()</code>。</p>
<p>上节在<code>dequeueBuffer()</code>获取<code>slot</code>之后，就在对应的<code>slot</code>生成了<code>GraphicBuffer</code>。就可以继续Draw填充过程。</p>
<p>填充完成后，调用<code>queueBuffer()</code>根据<code>slot</code>获取对应的<code>GraphicBuffer</code>，封装成<code>BufferItem</code>对象，在回调<code>onFrameAvailable()</code>传入。通知<code>BufferQueueConsumer</code>有新数据传入。</p>
</blockquote>
<p><img src="/images/关系图.png" srcset="/img/loading.gif" alt="img"></p>
<h4 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h4><blockquote>
<p><strong>Android显示系统的核心</strong>。遵循<code>生产者-消费者</code>模型，只要往<code>BufferQueue</code>填充数据，就被认为是<code>生产者</code>。从<code>BufferQueue</code>获取数据，就被认为是<code>消费者</code>。</p>
<p><code>SurfaceFlinger</code>在合成并显示UI内容时，UI负责生产内容，<code>SurfaceFlinger</code>作为<code>消费者</code>消费内容。</p>
<p>在截屏时，<code>SurfaceFlinger</code>作为生产者，将当前的UI内容填充到另一个<code>BufferQueue</code>内，截屏作为<code>消费者</code>从<code>BufferQueue</code>获取数据</p>
</blockquote>
<p><img src="/images/v2-6a617ddb116d922b24f416582a5bf013_1440w.jpg" srcset="/img/loading.gif" alt="img"></p>
<p>如图所示执行步骤如下所示：</p>
<ol>
<li>初始化一个<code>BufferQueue</code></li>
<li><code>BufferQueueProducer</code>调用<code>dequeueBuffer</code>向<code>BufferQueue</code>申请一块空的<code>GRaphicBuffer</code></li>
<li>可以通过<code>requestBuffer</code>获取对应的<code>GraphicBuffer</code></li>
<li>向<code>GraphicBuffer</code>填充完数据后，调用<code>queueBuffer</code>向<code>BufferQueue</code>添加<code>GraphicBuffer</code></li>
<li>添加数据完成后，<code>BufferQueue</code>通过回调通知消费者，有新数据加入——<code>onFrameAvaliable()</code></li>
<li><code>BufferQueueConsumer</code>调用<code>acquireBuffer</code>从<code>BufferQueue</code>获取<code>GraphicBuffer</code></li>
<li>待<code>GraphicBuffer</code>使用完毕后，调用<code>releaseBuffer</code>将空的<code>GraphicBuffer</code>还给<code>BufferQueue</code>以便重复利用</li>
<li>空的数据返回后，<code>BufferQueue</code>通过回调通知生产者，有空闲数据。后续生产者可以继续获取空的<code>GraphicBuffer</code>进行使用——<code>onBufferReleased()</code></li>
<li>在<code>2~8</code>之间循环，形成一整套图形数据的生产-消费过程。</li>
</ol>
<h5 id="GraphicBuffer–BufferState"><a href="#GraphicBuffer–BufferState" class="headerlink" title="GraphicBuffer–BufferState"></a>GraphicBuffer–BufferState</h5><p>上面有提到，调用<code>dequeueBuffer()</code>需要获取空的<code>GraphicBuffer</code>，通过<code>getFreeBufferLocked()</code>寻找。</p>
<p>其中<code>GraphicBuffer</code>有以下几种状态(<code>BufferSlot.BufferState</code>)：</p>
<ul>
<li><code>FREE</code>：当前<code>GraphicBuffer</code>可用，且位于<code>BufferQueue</code>内</li>
<li><code>DEQUEUED</code>：当前<code>GraphicBuffer</code>被生产者获取了，该buffer当前属于生产者</li>
<li><code>QUEUED</code>：当前<code>GraphicBuffer</code>被生产者填充了数据，该buffer当前属于<code>BufferQueue</code></li>
<li><code>ACQUIRED</code>：当前<code>GraphicBuffer</code>被消费者获取了，该buffer当前属于消费者</li>
</ul>
<h2 id="硬件绘制"><a href="#硬件绘制" class="headerlink" title="硬件绘制"></a>硬件绘制</h2><blockquote>
<p>默认开启<code>硬件加速</code>，可以通过配置<code>android:hardwareAccelerated=&quot;false&quot;</code>关闭硬件加速</p>
<p><code>把View中绘制的计算工作交给GPU来处理，就是把drawXX()相关的方法进行转换。</code></p>
</blockquote>
<p><code>硬件绘制</code>主要包含两步：</p>
<ul>
<li><p><code>构建阶段</code></p>
<blockquote>
<p>遍历所有View，将需要绘制的操作缓存下来，构建<code>DisplayList</code>。交给<code>RenderThread</code>使用GPU进行硬件加速渲染。</p>
</blockquote>
</li>
<li><p><code>绘制阶段</code></p>
<blockquote>
<p>构建好的<code>DisplayList</code>交给<code>RenderThread</code>使用GPU进行硬件加速渲染，绘制的内容保存在<code>Graphic Buffer</code>并交由<code>SurfaceFlinger</code>显示。</p>
</blockquote>
</li>
</ul>
<h3 id="控制硬件加速"><a href="#控制硬件加速" class="headerlink" title="控制硬件加速"></a>控制硬件加速</h3><p><img src="/images/硬件绘制-控制硬件加速.png" srcset="/img/loading.gif" alt="硬件绘制-控制硬件加速"></p>
<blockquote>
<p>硬件绘制需要在<code>开启硬件加速</code>的条件下才可以执行</p>
</blockquote>
<p>可以在以下级别控制<code>硬件加速</code>：</p>
<ul>
<li><p><strong>应用</strong></p>
<p>在<code>AndroidManifest.xml</code>配置如下属性</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">...</span>&gt;</span></code></pre>
</li>
</ul>
<ul>
<li><p><strong>Activity</strong></p>
<p>在<code>AndroidManifest.xml</code>配置如下属性</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"true"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">...</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"false"</span> /&gt;</span> //控制某个Activity关闭硬件加速
  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span></code></pre>
</li>
</ul>
<ul>
<li><p><strong>窗口Window</strong></p>
<p>配置如下代码</p>
<pre><code class="hljs java">getWindow().setFlags(
    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);</code></pre>
</li>
</ul>
<ul>
<li><p><strong>视图View</strong></p>
<p>为单个视图停用硬件加速</p>
<pre><code class="hljs java">myView.setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="hljs-keyword">null</span>);</code></pre>
</li>
</ul>
<h3 id="DisplayList"><a href="#DisplayList" class="headerlink" title="DisplayList"></a>DisplayList</h3><p><img src="/images/硬件绘制-DisplayList.png" srcset="/img/loading.gif" alt="硬件绘制-DisplayList"></p>
<blockquote>
<p>本质上是一个<strong>缓冲区</strong>，里面<code>记录即将执行的绘制命令序列</code>。</p>
</blockquote>
<p><code>DisplayList</code>的存在有两个好处：</p>
<ol>
<li><p>在绘制下一帧时，若View没有发生变化，就不必执行相关绘制API，直接复用上次的<code>DisplayList</code>。</p>
</li>
<li><p>在绘制下一帧时，若View发生变化，但只是一些简单属性发生变化，就不需重建<code>DisplayList</code>，直接修改<code>DisplayList</code>相关属性即可。</p>
<p>针对以下属性，都不需重建<code>DisplayList</code></p>
<ul>
<li><code>alpha</code>：更改层的不透明度</li>
<li><code>x</code>、<code>y</code>、<code>translationX</code>、<code>translationY</code>：更改层的位置</li>
<li><code>scaleX</code>、<code>scaleY</code>：更改层的大小</li>
<li><code>rotation</code>、<code>rotationX</code>、<code>rotationY</code>：更改层在 3D 空间里的方向</li>
<li><code>pivotX</code>、<code>pivotY</code>：更改层的转换原点</li>
</ul>
</li>
</ol>
<p>以上在使用<code>DisplayList</code>的过程都不需要执行<code>onDraw()</code>。</p>
<p><img src="/images/DisplayList结构.png" srcset="/img/loading.gif" alt="img"></p>
<h3 id="RenderNode"><a href="#RenderNode" class="headerlink" title="RenderNode"></a>RenderNode</h3><blockquote>
<p>在Android 5.0后引入，是对<code>DisplayList</code>以及<code>View显示属性</code>的封装。</p>
</blockquote>
<p><strong>通常一个<code>RenderNode</code>对应一个<code>View</code>，包含了View自身及其子View的所有DisplayList。</strong></p>
<p>其中还有一个<code>RootRenderNode</code>，里面包含着<code>View层次结构中所有View的DisplayList信息</code>。</p>
<h3 id="ViewRootImpl硬件绘制相关"><a href="#ViewRootImpl硬件绘制相关" class="headerlink" title="ViewRootImpl硬件绘制相关"></a>ViewRootImpl硬件绘制相关</h3><blockquote>
<p>只有当前View支持<code>硬件加速</code>时，才可以进入<code>硬件绘制</code></p>
<p><code>if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled())</code></p>
</blockquote>
<p><img src="/images/硬件绘制-构建DisplayList.png" srcset="/img/loading.gif" alt="硬件绘制-构建DisplayList"></p>
<h4 id="ThreadedRenderer-draw"><a href="#ThreadedRenderer-draw" class="headerlink" title="ThreadedRenderer.draw()"></a>ThreadedRenderer.draw()</h4><blockquote>
<p><code>ThreadedRenderer</code>在UI线程创建，主要执行了两步：</p>
<ul>
<li>构建View的DrawOp树，就是<code>DisplayList</code>。<code>DrawOp 表示 Drawing Operations</code></li>
<li>与渲染线程(<code>RenderThread</code>)进行通信</li>
</ul>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//ThreadedRenderer.java</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks,
          FrameDrawingCallback frameDrawingCallback)</span> </span>&#123;
      attachInfo.mIgnoreDirtyState = <span class="hljs-keyword">true</span>;

      <span class="hljs-keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;
      choreographer.mFrameInfo.markDrawStart();
      <span class="hljs-comment">//构建View的DrawOp树</span>
      updateRootDisplayList(view, callbacks);

      ...
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] frameInfo = choreographer.mFrameInfo.mFrameInfo;
      <span class="hljs-keyword">if</span> (frameDrawingCallback != <span class="hljs-keyword">null</span>) &#123;
          nSetFrameCallback(mNativeProxy, frameDrawingCallback);
      &#125;
      <span class="hljs-comment">//通知RenderThread线程绘制</span>
      <span class="hljs-keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);
      ...
  &#125;</code></pre>
<h4 id="updateRootDisplayList"><a href="#updateRootDisplayList" class="headerlink" title="updateRootDisplayList()"></a>updateRootDisplayList()</h4><blockquote>
<p>构建<code>DrawOp</code>树，构建<code>RootDisplayList</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateRootDisplayList</span><span class="hljs-params">(View view, DrawCallbacks callbacks)</span> </span>&#123;
   <span class="hljs-comment">//更新View的displayList</span>
    updateViewTreeDisplayList(view);

    <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;
       <span class="hljs-comment">//获取DisplayCanvas</span>
        DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> saveCount = canvas.save();
            canvas.translate(mInsetLeft, mInsetTop);
            callbacks.onPreDraw(canvas);

            canvas.insertReorderBarrier();
           <span class="hljs-comment">//displayListCanvas缓存View对应的drawOp节点</span>
            canvas.drawRenderNode(view.updateDisplayListIfDirty());
            canvas.insertInorderBarrier();

            callbacks.onPostDraw(canvas);
            canvas.restoreToCount(saveCount);
            mRootNodeNeedsUpdate = <span class="hljs-keyword">false</span>;
        &#125; <span class="hljs-keyword">finally</span> &#123;
           <span class="hljs-comment">//RootRenderNode填充所有节点</span>
            mRootNode.end(canvas);
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewTreeDisplayList</span><span class="hljs-params">(View view)</span> </span>&#123;
    view.mPrivateFlags |= View.PFLAG_DRAWN;
    view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)<span class="hljs-comment">//invalidate()对应标记</span>
            == View.PFLAG_INVALIDATED;<span class="hljs-comment">//初始DecorView默认为 true</span>
    view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;
    view.updateDisplayListIfDirty();<span class="hljs-comment">//更新节点</span>
    view.mRecreateDisplayList = <span class="hljs-keyword">false</span>;
&#125;</code></pre>
<h4 id="DecorView-updateDisplayListIfDirty"><a href="#DecorView-updateDisplayListIfDirty" class="headerlink" title="DecorView.updateDisplayListIfDirty()"></a>DecorView.updateDisplayListIfDirty()</h4><blockquote>
<p><code>updateRootDisplayList()</code>中对应的View就是<code>DecorView</code>，是所有View的顶层。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
<span class="hljs-meta">@NonNull</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> RenderNode <span class="hljs-title">updateDisplayListIfDirty</span><span class="hljs-params">()</span> </span>&#123;
      ...
        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="hljs-number">0</span>
                || !renderNode.isValid()
                || (mRecreateDisplayList)) &#123;
          ...
          <span class="hljs-keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);
          <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;<span class="hljs-comment">//是否强制软件绘制</span>
                    buildDrawingCache(<span class="hljs-keyword">true</span>);
                    Bitmap cache = getDrawingCache(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//获取绘制缓存</span>
                    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//缓存有效，复用缓存</span>
                        canvas.drawBitmap(cache, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mLayerPaint);
                    &#125;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// Fast path for layouts with no backgrounds</span>
                    <span class="hljs-comment">//ViewGroup不需要绘制，直接调用dispatchDraw</span>
                    <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;
                        dispatchDraw(canvas);
                        drawAutofilledHighlight(canvas);
                         ...
                    &#125; <span class="hljs-keyword">else</span> &#123;
                      <span class="hljs-comment">//ViewGroup(需要绘制) / View 直接调用draw</span>
                        draw(canvas);
                    &#125;
                &#125;
            &#125; <span class="hljs-keyword">finally</span> &#123;
               <span class="hljs-comment">//缓存构建完成，放入渲染节点</span>
                renderNode.end(canvas);
                setDisplayListProperties(renderNode);
            &#125;
          
        &#125;
      
    &#125;</code></pre>
<p><code>DecorView</code>执行<code>updateDisplayListIfDirty()</code>，调用到<code>draw(Canvas)</code>，然后向下递归调用到<code>child.draw()</code></p>
<p><code>updateRootDisplayList()</code>主要执行以下几步：</p>
<ul>
<li>更新<code>DecorView</code>操作缓存(DisplayList)——<code>updateViewTreeDisplayList(decorView)</code></li>
<li>利用<code>DisplayCanvas</code>构建并缓存所有的<code>DrawOp(View的绘制操作)</code>——<code>mRootNode.start()</code></li>
<li>将<code>DisplayListCanvas</code>缓存的<code>DrawOp</code>填充到<code>RenderNode(View)</code>——<code>View.updateDisplayListIfDirty()</code></li>
<li>将<code>DecorView</code>的缓存<code>DrawOp</code>填充到<code>RootRenderNode</code>中——<code>mRootNode.end()</code></li>
</ul>
<p><img src="/images/硬件绘制-updateDisplayListIfDirty.png" srcset="/img/loading.gif" alt="硬件绘制-updateDisplayListIfDirty()"></p>
<h3 id="View硬件绘制相关"><a href="#View硬件绘制相关" class="headerlink" title="View硬件绘制相关"></a>View硬件绘制相关</h3><p>上一节中，通过<code>DecorView</code>递归调用<code>子View.updateDisplayListIfDirty()</code>不断填充<code>DisplayList</code>到对应View的<code>RenderNode</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">View</span><span class="hljs-params">(Context context)</span> </span>&#123;
  ...
     <span class="hljs-comment">//初始化渲染节点</span>
     mRenderNode = RenderNode.create(getClass().getName(), <span class="hljs-keyword">new</span> ViewAnimationHostBridge(<span class="hljs-keyword">this</span>));
  ...
&#125;

    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;
       <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();

        <span class="hljs-keyword">boolean</span> drawingWithRenderNode = mAttachInfo != <span class="hljs-keyword">null</span>
                &amp;&amp; mAttachInfo.mHardwareAccelerated
                &amp;&amp; hardwareAcceleratedCanvas;
        ...
        <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;
           <span class="hljs-comment">//继续执行到updateDisplayListIfDirty</span>
            renderNode = updateDisplayListIfDirty();
            <span class="hljs-keyword">if</span> (!renderNode.isValid()) &#123;
                renderNode = <span class="hljs-keyword">null</span>;
                drawingWithRenderNode = <span class="hljs-keyword">false</span>;
            &#125;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> RenderNode <span class="hljs-title">updateDisplayListIfDirty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">final</span> RenderNode renderNode = mRenderNode;
        <span class="hljs-keyword">if</span> (!canHaveDisplayList()) &#123;
            <span class="hljs-comment">// can't populate RenderNode, don't try</span>
            <span class="hljs-keyword">return</span> renderNode;
        &#125;

        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="hljs-number">0</span> <span class="hljs-comment">//绘制缓存无效</span>
                || !renderNode.isValid() <span class="hljs-comment">//渲染节点没有DisplayList</span>
                || (mRecreateDisplayList)) &#123; <span class="hljs-comment">//需要刷新DisplayList</span>
            <span class="hljs-comment">// Don't need to recreate the display list, just need to tell our</span>
            <span class="hljs-comment">// children to restore/recreate theirs</span>
            <span class="hljs-keyword">if</span> (renderNode.isValid() <span class="hljs-comment">//只要draw过一次后，一直返回true</span>
                    &amp;&amp; !mRecreateDisplayList) &#123;<span class="hljs-comment">//调用一些只需要displayList属性修改的方法</span>
                <span class="hljs-comment">//不需要重建 DisplayList</span>
                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
                dispatchGetDisplayList();

                <span class="hljs-keyword">return</span> renderNode; <span class="hljs-comment">// no work needed</span>
            &#125;

            <span class="hljs-comment">// If we got here, we're recreating it. Mark it as such to ensure that</span>
            <span class="hljs-comment">// we copy in child display lists into ours in drawChild()</span>
            mRecreateDisplayList = <span class="hljs-keyword">true</span>;

            <span class="hljs-keyword">int</span> width = mRight - mLeft;
            <span class="hljs-keyword">int</span> height = mBottom - mTop;
            <span class="hljs-keyword">int</span> layerType = getLayerType();
           <span class="hljs-comment">//获取DisplayListCanvas</span>
            <span class="hljs-keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);

            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;<span class="hljs-comment">//软件绘制，绘制缓存存在直接复用</span>
                    buildDrawingCache(<span class="hljs-keyword">true</span>);
                    Bitmap cache = getDrawingCache(<span class="hljs-keyword">true</span>);
                    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;
                        canvas.drawBitmap(cache, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mLayerPaint);
                    &#125;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    computeScroll();

                    canvas.translate(-mScrollX, -mScrollY);
                    <span class="hljs-comment">//添加 缓存有效标记</span>
                    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;

                    <span class="hljs-comment">//ViewGroup不需要绘制，直接调用dispatchDraw</span>
                    <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;
                        dispatchDraw(canvas);
                        drawAutofilledHighlight(canvas);
                         ...
                    &#125; <span class="hljs-keyword">else</span> &#123;
                      <span class="hljs-comment">//ViewGroup(需要绘制) / View 直接调用draw</span>
                        draw(canvas);
                    &#125;
                &#125;
            &#125; <span class="hljs-keyword">finally</span> &#123;
               <span class="hljs-comment">//RenderNode 收集DisplayList</span>
                renderNode.end(canvas);
                setDisplayListProperties(renderNode);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
        &#125;
        <span class="hljs-keyword">return</span> renderNode;
    &#125;

    <span class="hljs-comment">//是否会有DisplayList = 是否开启硬件加速</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canHaveDisplayList</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> !(mAttachInfo == <span class="hljs-keyword">null</span> || mAttachInfo.mThreadedRenderer == <span class="hljs-keyword">null</span>);
    &#125;

    <span class="hljs-comment">//只有flag标记为 PFLAG_INVALIDATED ，调用需要 重建DisplayList</span>
    mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="hljs-number">0</span>;</code></pre>
<p>根据上述源码可判断<code>View需要重新构建DisplayList(执行draw())</code>有以下条件：</p>
<ol>
<li><p><code>(mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0</code>当前View绘制缓存无效</p>
<p><strong>mPrivateFlags没有<code>PFLAG_DRAWING_CACHE_VALID</code>标记</strong></p>
</li>
<li><p><code>renderNode.isValid()==false</code> View对应的<code>DisplayList</code>尚未构建或者被销毁</p>
<p><strong>只要View绘制过一次，就会一直返回true。除非<code>detached</code></strong></p>
</li>
<li><p><code>mRecreateDisplayList==true</code> View需要重新构建<code>DisplayList</code></p>
<p><strong>mPrivateFlags持有<code>PFLAG_INVALIDATED</code>标记</strong></p>
</li>
</ol>
<p>能满足以上条件的就是调用<code>View.invalidate()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">()</span> </span>&#123;
        invalidate(<span class="hljs-keyword">true</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> invalidateCache)</span> </span>&#123;
        invalidateInternal(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="hljs-keyword">true</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidateInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">boolean</span> invalidateCache,
            <span class="hljs-keyword">boolean</span> fullInvalidate)</span> </span>&#123;
      ...
            <span class="hljs-keyword">if</span> (invalidateCache) &#123;
                mPrivateFlags |= PFLAG_INVALIDATED; <span class="hljs-comment">//添加PFLAG_INVALIDATED标志</span>
                mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;<span class="hljs-comment">//移除PFLAG_DRAWING_CACHE_VALID标志</span>
            &#125;
      
    &#125;</code></pre>
<h4 id="dispatchGetDisplayList"><a href="#dispatchGetDisplayList" class="headerlink" title="dispatchGetDisplayList()"></a>dispatchGetDisplayList()</h4><p>只会在不重建<code>DisplayList</code>情况下调用</p>
<pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
<span class="hljs-comment">// 只会在ViewGroup下实现，更新子View的DisplayList</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchGetDisplayList</span><span class="hljs-params">()</span> </span>&#123;&#125;


<span class="hljs-comment">//ViewGroup.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchGetDisplayList</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mChildrenCount;
        <span class="hljs-keyword">final</span> View[] children = mChildren;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;
            <span class="hljs-keyword">final</span> View child = children[i];
           <span class="hljs-comment">//View可见 || 设置动画</span>
            <span class="hljs-keyword">if</span> (((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>)) &#123;
                recreateChildDisplayList(child);<span class="hljs-comment">//调用子</span>
            &#125;
        &#125;
        ...
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recreateChildDisplayList</span><span class="hljs-params">(View child)</span> </span>&#123;
        child.mRecreateDisplayList = (child.mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="hljs-number">0</span>;<span class="hljs-comment">//没有PFLAG_INVALIDATED 返回true</span>
        child.mPrivateFlags &amp;= ~PFLAG_INVALIDATED; <span class="hljs-comment">//移除 PFLAG_INVALIDATED标志</span>
        child.updateDisplayListIfDirty();
        child.mRecreateDisplayList = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//执行完后 重置状态</span>
    &#125;</code></pre>
<h3 id="RenderThread渲染UI"><a href="#RenderThread渲染UI" class="headerlink" title="RenderThread渲染UI"></a>RenderThread渲染UI</h3><p>构建完<code>RootRenderNode</code>的<code>DisplayList——DrawOp树</code>之后，就需要准备渲染。<em>利用GPU将DisplayList绘制到屏幕上</em>。</p>
<p><img src="/images/CPU GPU通信模型" srcset="/img/loading.gif" alt="img"></p>
<p>根据图示渲染过程主要分为5阶段：</p>
<ol>
<li>UI线程创建OpenGL渲染需要的命令及数据——<code>构建DrawOp树</code></li>
<li>CPU将数据共享给GPU，使用<code>匿名共享内存</code></li>
<li>通知GPU渲染</li>
<li>swapBuffers，并通知<code>SurfaceFlinger</code>开始合成图层</li>
<li>SurfaceFlinger开始合成图层</li>
</ol>
<h3 id="硬件绘制流程"><a href="#硬件绘制流程" class="headerlink" title="硬件绘制流程"></a>硬件绘制流程</h3><p><img src="/images/硬件绘制流程.jpg" srcset="/img/loading.gif" alt="硬件绘制流程"></p>
<p>如上图所示：</p>
<blockquote>
<p>硬件绘制的流程，主要包含两个步骤：<strong>录制 、 回放</strong>。</p>
<p><code>录制</code>：需要View的<code>draw()</code>参与，需要记录View的绘制步骤，并编译为<strong>绘制指令</strong>(<code>drawOp</code>)</p>
<p><code>回放</code>：还原绘制内容，只需要还原<strong>绘制指令</strong>，而且这个绘制指令是可以修改的，修改的过程是不需要重新触发<code>draw()</code>。</p>
</blockquote>
<h2 id="软件绘制VS硬件绘制"><a href="#软件绘制VS硬件绘制" class="headerlink" title="软件绘制VS硬件绘制"></a>软件绘制VS硬件绘制</h2><table>
<thead>
<tr>
<th>渲染场景</th>
<th>软件绘制</th>
<th>硬件绘制</th>
<th>效果分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面初始化</td>
<td>绘制所有View</td>
<td>创建所有<code>DisplayList</code></td>
<td>GPU负责复杂的计算任务</td>
</tr>
<tr>
<td>调用背景透明TextView.setText()</td>
<td>重绘脏区所有View</td>
<td>TextView及每一级父View重建<code>DisplayList</code></td>
<td>重叠的兄弟节点不需要进行重绘，GPU会自行处理</td>
</tr>
<tr>
<td>TextView逐帧播放动画</td>
<td>每帧动画都要重绘脏区View</td>
<td>第一帧需要重建<code>DisplayList</code><br>后续只要更新对应的<code>DisplayList</code>即可</td>
<td>刷新每帧性能提升</td>
</tr>
<tr>
<td>修改TextView透明度</td>
<td>重绘脏区所有View</td>
<td>直接调用<code>RenderNode.setAlpha()</code>即可</td>
<td>只触发<code>DecorView.updateDisplayListIfDirty</code>，不再往下遍历</td>
</tr>
</tbody>
</table>
<h2 id="绘制缓存"><a href="#绘制缓存" class="headerlink" title="绘制缓存"></a>绘制缓存</h2><p><img src="/images/Android绘制-绘制缓存.png" srcset="/img/loading.gif" alt="绘制缓存"></p>
<blockquote>
<p>绘图缓存是指一个<code>Bitmap(软件绘制)</code>和<code>(硬件绘制)</code>，保存的是控件及其子控件的一个快照。</p>
<p>可以通过<code>View.setLayerType()</code>设置使用何种类型的缓存。</p>
<p><code>LAYER_TYPE_NONE</code>：视图正常渲染，不受屏幕外缓冲区支持。<strong>默认值</strong></p>
<p><code>LAYER_TYPE_SOFTWARE</code>：标识这个View有一个<code>Software Layer</code>，在一定条件下，会变成<code>bitmap</code>对象。</p>
<p><code>LAYER_TYPE_HARDWARE</code>：标识这个VIew有一个<code>Hardware Layer</code>，通过GPU来实现。依赖<code>硬件加速</code>实现，如果未开启<code>硬件加速</code>，按照<code>Software Layer</code>实现。</p>
</blockquote>
<h3 id="软件绘制缓存"><a href="#软件绘制缓存" class="headerlink" title="软件绘制缓存"></a>软件绘制缓存</h3><pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;
     ...
        Bitmap cache = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">int</span> layerType = getLayerType(); <span class="hljs-comment">// layerType默认为LAYER_TYPE_NONE</span>
        <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123;<span class="hljs-comment">//软件绘制条件</span>
             <span class="hljs-keyword">if</span> (layerType != LAYER_TYPE_NONE) &#123;<span class="hljs-comment">//必须设置 `LAYER_TYPE_SOFTWARE` 或 LAYER_TYPE_HARDWARE 缓存生效</span>
                 <span class="hljs-comment">// If not drawing with RenderNode, treat HW layers as SW</span>
                 layerType = LAYER_TYPE_SOFTWARE;<span class="hljs-comment">//设置 软件layer</span>
                 buildDrawingCache(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//构建缓存</span>
            &#125;
            cache = getDrawingCache(<span class="hljs-keyword">true</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildDrawingCache</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoScale)</span> </span>&#123;
       buildDrawingCacheImpl(autoScale);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildDrawingCacheImpl</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoScale)</span> </span>&#123;
     ...
       quality = Bitmap.Config.ARGB_8888;<span class="hljs-comment">//默认缓存bitmap图像类型</span>
       bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(),
                        width, height, quality);
       bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
       <span class="hljs-keyword">if</span> (autoScale) &#123;
          mDrawingCache = bitmap;
       &#125; <span class="hljs-keyword">else</span> &#123;
          mUnscaledDrawingCache = bitmap;
       &#125;
      ...
    &#125;</code></pre>
<p>要启用<code>软件绘制缓存</code>，必须调用<code>View.setLayerType()</code>设置<code>LAYER_TYPE_HARDDWARE、LAYER_TYPE_SOFTWARE</code>。通过<code>buildDrawingCache()</code>生成<code>绘制缓存</code>，对应会生成两个缓存对象：</p>
<ul>
<li><code>mDrawingCache</code>：根据兼容模式进行放大或缩小</li>
<li><code>mUnscaledDrawingCache</code>：反映了控件的真实尺寸，多用作控件截图。</li>
</ul>
<p>后续通过<code>getDrawingCache()</code>获取缓存内容。</p>
<pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;
 <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> drawingWithDrawingCache = cache != <span class="hljs-keyword">null</span> &amp;&amp; !drawingWithRenderNode; <span class="hljs-comment">//是否使用缓存</span>
 ...
 <span class="hljs-keyword">if</span>(!drawingWithDrawingCache) &#123;<span class="hljs-comment">//未使用缓存</span>
    <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;<span class="hljs-comment">//硬件绘制</span>
        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
        ((DisplayListCanvas) canvas).drawRenderNode(renderNode);
    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//软件绘制</span>
        <span class="hljs-comment">// 需要回调到`onDraw()`</span>
        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;
            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
            dispatchDraw(canvas);
        &#125; <span class="hljs-keyword">else</span> &#123;
            draw(canvas);
        &#125;
    &#125;
 &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cache!=<span class="hljs-keyword">null</span>)&#123;
   canvas.drawBitmap(cache...)<span class="hljs-comment">//将缓存绘制于画布上</span>
 &#125;
&#125;</code></pre>
<h3 id="硬件绘制缓存"><a href="#硬件绘制缓存" class="headerlink" title="硬件绘制缓存"></a>硬件绘制缓存</h3><p><code>DisplayList</code>可以理解为缓存，开启<code>硬件加速</code>时，只要每次回放<code>DisplayList</code>即可。</p>
<h3 id="绘制缓存的开启原则"><a href="#绘制缓存的开启原则" class="headerlink" title="绘制缓存的开启原则"></a>绘制缓存的开启原则</h3><ul>
<li>不要为<code>十分轻量级的控件</code>启用绘制缓存。可能缓存绘制的开销 &gt; 控件重绘开销</li>
<li>为<code>很少发生内容改变的控件</code>启用绘制缓存。避免<code>invalidate()</code>时产生额外的缓存绘制操作</li>
<li>当父控件需要频繁改变子控件的位置或变换时对<code>子控件</code>启用绘制缓存，避免频繁重绘子控件。通过<code>ViewGroup.setChildrenDrawingWithCache()</code>启用子控件绘制缓存。</li>
</ul>
<h2 id="属性动画更新相关"><a href="#属性动画更新相关" class="headerlink" title="属性动画更新相关"></a>属性动画更新相关</h2><p><img src="/images/Android绘制-属性动画更新相关.png" srcset="/img/loading.gif" alt="Android绘制-属性动画更新相关"></p>
<p>在<a href="/2020/10/12/Android动画-属性动画/" title="Android动画-属性动画">Android动画-属性动画</a>中讲到最后通过反射调用<code>View.setXX()</code>去执行动画。</p>
<pre><code class="hljs java"><span class="hljs-comment">//view.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScaleX</span><span class="hljs-params">(<span class="hljs-keyword">float</span> scaleX)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (scaleX != getScaleX()) &#123;
            scaleX = sanitizeFloatPropertyValue(scaleX, <span class="hljs-string">"scaleX"</span>);
            invalidateViewProperty(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);
            mRenderNode.setScaleX(scaleX);<span class="hljs-comment">//更新对应View的displayList</span>
            invalidateViewProperty(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);

            invalidateParentIfNeededAndWasQuickRejected();
            notifySubtreeAccessibilityStateChangedIfNeeded();
        &#125;
    &#125;</code></pre>
<p>关键在于<code>invalidateViewProperty()</code>调用界面刷新</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidateViewProperty</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> invalidateParent, <span class="hljs-keyword">boolean</span> forceRedraw)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!isHardwareAccelerated()
            || !mRenderNode.isValid()
            || (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//软件绘制</span>
        <span class="hljs-keyword">if</span> (invalidateParent) &#123;
            invalidateParentCaches();
        &#125;
        <span class="hljs-keyword">if</span> (forceRedraw) &#123;
            mPrivateFlags |= PFLAG_DRAWN; <span class="hljs-comment">// force another invalidation with the new orientation</span>
        &#125;
        invalidate(<span class="hljs-keyword">false</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        damageInParent();<span class="hljs-comment">//硬件绘制</span>
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">damageInParent</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo != <span class="hljs-keyword">null</span>) &#123;
        mParent.onDescendantInvalidated(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">//一层层向上层调用</span>
    &#125;
&#125;</code></pre>
<p><code>mParent</code>一般指向<code>ViewGroup</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//ViewGroup.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDescendantInvalidated</span><span class="hljs-params">(@NonNull View child, @NonNull View target)</span> </span>&#123;
      ...
        <span class="hljs-keyword">if</span> ((target.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// We lazily use PFLAG_DIRTY, since computing opaque isn't worth the potential</span>
            <span class="hljs-comment">// optimization in provides in a DisplayList world.</span>
            mPrivateFlags = (mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DIRTY;

            <span class="hljs-comment">// simplified invalidateChildInParent behavior: clear cache validity to be safe...</span>
            <span class="hljs-comment">//标记缓存无效</span>
            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;
        &#125;
      ...
        <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span>) &#123;
          <span class="hljs-comment">//继续向顶层View请求</span>
            mParent.onDescendantInvalidated(<span class="hljs-keyword">this</span>, target);
        &#125;
    &#125;</code></pre>
<p>在<code>onDescendantInvalidated()</code>主要移除了<code>PFLAG_DRAWING_CACHE_VALID</code>标志</p>
<p>最顶层的View是<code>DecorView</code>，而<code>ViewRootImpl</code>就是<code>DecorView的parent</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDescendantInvalidated</span><span class="hljs-params">(@NonNull View child, @NonNull View descendant)</span> </span>&#123;
        <span class="hljs-keyword">if</span> ((descendant.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != <span class="hljs-number">0</span>) &#123;
            mIsAnimating = <span class="hljs-keyword">true</span>;
        &#125;
        invalidate();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">()</span> </span>&#123;
        mDirty.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mWidth, mHeight);
        <span class="hljs-keyword">if</span> (!mWillDrawSoon) &#123;
            scheduleTraversals();<span class="hljs-comment">//开始执行绘制流程</span>
        &#125;
    &#125;</code></pre>
<p>总结：属性动画最后反射调用<code>View.setXX()</code>更新View属性时，调用到<code>invalidateViewProperty()</code>，主要实现的功能就是<code>移除PFLAG_DRAWING_CACHE_VALID</code>标志。在执行绘制过程中，在回到<code>View.updateDisplayListIfDirty()</code>时</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RenderNode <span class="hljs-title">updateDisplayListIfDirty</span><span class="hljs-params">()</span> </span>&#123;
  ...
     <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="hljs-number">0</span> <span class="hljs-comment">//满足该条件</span>
               || !renderNode.isValid()
               || (mRecreateDisplayList)) &#123;
           <span class="hljs-comment">// Don't need to recreate the display list, just need to tell our</span>
           <span class="hljs-comment">// children to restore/recreate theirs</span>
           <span class="hljs-keyword">if</span> (renderNode.isValid()
                   &amp;&amp; !mRecreateDisplayList) &#123;<span class="hljs-comment">//未设置 PFLAG_INVALIDATED标志</span>
               mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
               mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
               dispatchGetDisplayList();<span class="hljs-comment">//只要刷新DisplayList</span>

               <span class="hljs-keyword">return</span> renderNode; <span class="hljs-comment">// no work needed</span>
           &#125;
       ...
&#125;</code></pre>
<p><strong>在开启硬件加速的条件下，属性动画更新过程中不会回调<code>onDraw()</code></strong></p>
<h2 id="关键节点"><a href="#关键节点" class="headerlink" title="关键节点"></a>关键节点</h2><h3 id="DisplayList初始化"><a href="#DisplayList初始化" class="headerlink" title="DisplayList初始化"></a><code>DisplayList</code>初始化</h3><p><code>DisplayListCanvas.start()</code> -&gt; <code>DisplayListCanvas.obtain()</code>-&gt;<code>nCreateDisplayListCanvas</code></p>
<pre><code class="hljs c++"><span class="hljs-comment">//android_view_DisplayListCanvas.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="hljs-params">(jlong renderNodePtr,
        jint width, jint height)</span> </span>&#123;
    RenderNode* renderNode = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));
&#125;

<span class="hljs-comment">//Canvas.cpp</span>
<span class="hljs-function">Canvas* <span class="hljs-title">Canvas::create_recording_canvas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, uirenderer::RenderNode* renderNode)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (uirenderer::Properties::isSkiaEnabled()) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uirenderer::RecordingCanvas(width, height);
&#125;

<span class="hljs-comment">//Properrties.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Properties::isSkiaEnabled</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">auto</span> renderType = getRenderPipelineType();<span class="hljs-comment">//分为三种类型 SkiaGL SkiaVulkan OpenGL(默认)</span>
    <span class="hljs-keyword">return</span> RenderPipelineType::SkiaGL == renderType || RenderPipelineType::SkiaVulkan == renderType;
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//RecordingCanvas.cpp</span>
RecordingCanvas::RecordingCanvas(<span class="hljs-keyword">size_t</span> width, <span class="hljs-keyword">size_t</span> height)
        : mState(*<span class="hljs-keyword">this</span>), mResourceCache(ResourceCache::getInstance()) &#123;
    resetRecording(width, height);
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RecordingCanvas::resetRecording</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, RenderNode* node)</span> </span>&#123;
    LOG_ALWAYS_FATAL_IF(mDisplayList, <span class="hljs-string">"prepareDirty called a second time during a recording!"</span>);
    mDisplayList = <span class="hljs-keyword">new</span> DisplayList();<span class="hljs-comment">//初始化DisplayList</span>

    mState.initializeRecordingSaveStack(width, height);

    mDeferredBarrierType = DeferredBarrierType::InOrder;
&#125;</code></pre>
<h3 id="插入DrawOp到DisplayList"><a href="#插入DrawOp到DisplayList" class="headerlink" title="插入DrawOp到DisplayList"></a>插入DrawOp到DisplayList</h3><p><code>DisplayListCanvas</code>内部也包含了各种<code>drawXX()</code>，例如<code>drawLines()、drawText()</code>等。在调用这些方法后，会把对应的绘制操作转换为<code>drawOp</code></p>
<pre><code class="hljs c++"><span class="hljs-comment">//DisplayListCanvas.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisplayListCanvas</span> <span class="hljs-title">extends</span> <span class="hljs-title">RecordingCanvas</span> &#123;</span>
 ...
   <span class="hljs-comment">//所有绘制方法由RecordCanvas实现</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(CanvasProperty&lt;Float&gt; cx, CanvasProperty&lt;Float&gt; cy,
            CanvasProperty&lt;Float&gt; radius, CanvasProperty&lt;Paint&gt; paint)</span> </span>&#123;
        nDrawCircle(mNativeCanvasWrapper, cx.getNativeContainer(), cy.getNativeContainer(),
                radius.getNativeContainer(), paint.getNativeContainer());
    &#125;
&#125;

<span class="hljs-comment">//RecordingCanvas.java</span>
    @<span class="hljs-function">Override
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-keyword">float</span> startX, <span class="hljs-keyword">float</span> startY, <span class="hljs-keyword">float</span> stopX, <span class="hljs-keyword">float</span> stopY,
            @NonNull Paint paint)</span> </span>&#123;
        nDrawLine(mNativeCanvasWrapper, startX, startY, stopX, stopY, paint.getNativeInstance());
    &#125;</code></pre>
<p><code>drawCircle()和drawRoundRect()</code>由<code>DisplayListCanvas</code>实现。其他的绘制方法交由<code>RecordingCanvas</code>实现。</p>
<pre><code class="hljs c++"><span class="hljs-comment">//android_view_DisplayListCanvas.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">android_view_DisplayListCanvas_drawCircleProps</span><span class="hljs-params">(jlong canvasPtr,
        jlong xPropPtr, jlong yPropPtr, jlong radiusPropPtr, jlong paintPropPtr)</span> </span>&#123;
    Canvas* canvas = <span class="hljs-keyword">reinterpret_cast</span>&lt;Canvas*&gt;(canvasPtr);
    CanvasPropertyPrimitive* xProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(xPropPtr);
    CanvasPropertyPrimitive* yProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(yPropPtr);
    CanvasPropertyPrimitive* radiusProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(radiusPropPtr);
    CanvasPropertyPaint* paintProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPaint*&gt;(paintPropPtr);
    canvas-&gt;drawCircle(xProp, yProp, radiusProp, paintProp);
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//RecordingCanvas.h</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-keyword">float</span> startX, <span class="hljs-keyword">float</span> startY, <span class="hljs-keyword">float</span> stopX, <span class="hljs-keyword">float</span> stopY,
                          <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span> <span class="hljs-keyword">override</span> </span>&#123;
        <span class="hljs-keyword">float</span> points[<span class="hljs-number">4</span>] = &#123;startX, startY, stopX, stopY&#125;;
        drawLines(points, <span class="hljs-number">4</span>, paint);
    &#125;

<span class="hljs-comment">//RecordingCanvas.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RecordingCanvas::drawLines</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>* points, <span class="hljs-keyword">int</span> floatCount, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (CC_UNLIKELY(floatCount &lt; <span class="hljs-number">4</span> || paint.nothingToDraw())) <span class="hljs-keyword">return</span>;
    floatCount &amp;= ~<span class="hljs-number">0x3</span>;  <span class="hljs-comment">// round down to nearest four</span>
 
    addOp(alloc().create_trivial&lt;LinesOp&gt;(
            calcBoundsOfPoints(points, floatCount), *mState.currentSnapshot()-&gt;transform,
            getRecordedClip(), refPaint(&amp;paint), refBuffer&lt;<span class="hljs-keyword">float</span>&gt;(points, floatCount), floatCount));
&#125;</code></pre>
<p>通过<code>addOp()</code>将<code>DrawLine</code>的绘制操作缓存到<code>displayList</code>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><a href="/2018/12/14/View的工作原理/" title="View的绘制过程">View的绘制过程</a>
<p><a href="https://developer.android.com/guide/topics/graphics/hardware-accel?hl=zh-cn" target="_blank" rel="noopener">Android官方文档-硬件加速</a></p>
<p><a href="https://blog.csdn.net/Luoshengyang/article/details/45943255" target="_blank" rel="noopener">DisplayList构建过程分析</a></p>
<p><a href="https://tech.meituan.com/2017/01/19/hardware-accelerate.html" target="_blank" rel="noopener">Android硬件加速原理与实现简介</a></p>
<p><a href="https://www.jianshu.com/p/dd800800145b" target="_blank" rel="noopener">RenderThread与OpenGL GPU渲染</a></p>
<p><a href="https://www.androidperformance.com/2019/07/27/Android-Hardware-Layer/" target="_blank" rel="noopener">Android 中的 Hardware Layer 详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/62813895" target="_blank" rel="noopener">深入浅出Android BufferQueue</a></p>
<!-- https://www.jianshu.com/p/abfaea892611 ， https://blog.csdn.net/jinzhuojun/article/details/54234354 https://www.jianshu.com/p/40f660e17a73 -->

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/10/31/Android匿名共享内存-Ashmem/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android匿名共享内存-Ashmem</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/21/Android事件分发/">
                        <span class="hidden-mobile">Android事件分发</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>







  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
