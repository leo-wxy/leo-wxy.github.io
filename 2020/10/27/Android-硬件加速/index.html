

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <title>Android硬件加速 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android硬件加速">
              
                Android硬件加速
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-27 19:51" pubdate>
        2020年10月27日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      122
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android硬件加速</h1>
            
            <div class="markdown-body">
              <p><img src="/images/Android硬件加速.png" srcset="/img/loading.gif" alt="Android硬件加速xmind"></p>
<h2 id="软硬件绘制的分歧点"><a href="#软硬件绘制的分歧点" class="headerlink" title="软硬件绘制的分歧点"></a>软硬件绘制的分歧点</h2><p>绘制过程入口位于<code>ViewRootImpl.performDraw()</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//viewRootImpl.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performDraw</span><span class="hljs-params">()</span> </span>&#123;<br>      ...<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//调用draw()执行实际的绘制工作</span><br>            <span class="hljs-keyword">boolean</span> canUseAsync = draw(fullRedrawNeeded);<br>            <span class="hljs-keyword">if</span> (usingAsyncReport &amp;&amp; !canUseAsync) &#123;<br>                mAttachInfo.mThreadedRenderer.setFrameCompleteCallback(<span class="hljs-keyword">null</span>);<br>                usingAsyncReport = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mIsDrawing = <span class="hljs-keyword">false</span>;<br>            Trace.traceEnd(Trace.TRACE_TAG_VIEW);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>ViewRootImpl.draw()</code>实际执行的绘制工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;<br>  ...<br>    <span class="hljs-keyword">final</span> Rect dirty = mDirty;<span class="hljs-comment">//需要重新绘制的区域</span><br>  ...<br>    <span class="hljs-keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;<br>            <span class="hljs-comment">//是否支持硬件加速</span><br>            <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;<br>              ...<br>                mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="hljs-keyword">this</span>, callback);<span class="hljs-comment">//硬件绘制</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              ...<br>                <span class="hljs-comment">//软件绘制</span><br>                <span class="hljs-keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,<br>                        scalingRequired, dirty, surfaceInsets)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>      ...<br>    &#125;<br>  ...<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h2><p><img src="/images/Android绘制-软件绘制.png" srcset="/img/loading.gif" alt="Android绘制-软件绘制"></p>
<h3 id="ViewRootImpl软件绘制相关"><a href="#ViewRootImpl软件绘制相关" class="headerlink" title="ViewRootImpl软件绘制相关"></a>ViewRootImpl软件绘制相关</h3><blockquote>
<p>未开启<code>硬件加速</code>时，执行到<code>drawSoftware()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">drawSoftware</span><span class="hljs-params">(Surface surface, AttachInfo attachInfo, <span class="hljs-keyword">int</span> xoff, <span class="hljs-keyword">int</span> yoff,<br>        <span class="hljs-keyword">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> </span>&#123;<br>    <span class="hljs-comment">// Draw with software renderer.</span><br>    <span class="hljs-keyword">final</span> Canvas canvas;<br>  <br>   canvas = mSurface.lockCanvas(dirty);<span class="hljs-comment">//获取用于绘制的Canvas</span><br>   ...<br>   mView.draw(canvas);<span class="hljs-comment">//将mView的内容绘制到Canvas</span><br>   ...<br>   <span class="hljs-comment">//将Canvas的内容显示到屏幕上,向SurfaceFlinger服务Queue一个Graphic Buffer</span><br>   surface.unlockCanvasAndPost(canvas);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此处的<code>mView</code>对应的就是<code>DecorView</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DecorView.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.draw(canvas);<br><br>        <span class="hljs-keyword">if</span> (mMenuBackground != <span class="hljs-keyword">null</span>) &#123;<br>            mMenuBackground.draw(canvas);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>执行到<code>super.draw()</code>，<code>DecorView</code>继承自<code>FrameLayout</code>，等价于执行到<code>ViewGroup.draw()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>      ...<br>        <span class="hljs-keyword">if</span> (!dirtyOpaque) &#123;<br>          <span class="hljs-comment">//绘制背景</span><br>            drawBackground(canvas);<br>        &#125;<br>        <span class="hljs-comment">//绘制自身</span><br>        <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);<br>        <span class="hljs-comment">//绘制子View 只有ViewGroup会实现该方法</span><br>        dispatchDraw(canvas);<br>        <span class="hljs-comment">//绘制前景</span><br>        onDrawForeground(canvas);<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewGroup.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>      ...<br>        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties<br>                ? <span class="hljs-keyword">null</span> : buildOrderedChildList();<span class="hljs-comment">//绘制顺序按照Z值从大到小排列</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = preorderedList == <span class="hljs-keyword">null</span><br>                &amp;&amp; isChildrenDrawingOrderEnabled();<span class="hljs-comment">//允许自定义绘制顺序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;<br>            <span class="hljs-keyword">while</span> (transientIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;<br>                <span class="hljs-keyword">final</span> View transientChild = mTransientViews.get(transientIndex);<br>                <span class="hljs-keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||<br>                        transientChild.getAnimation() != <span class="hljs-keyword">null</span>) &#123;<br>                    more |= drawChild(canvas, transientChild, drawingTime);<br>                &#125;<br>                transientIndex++;<br>                <span class="hljs-keyword">if</span> (transientIndex &gt;= transientCount) &#123;<br>                    transientIndex = -<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<span class="hljs-comment">//根据自定义顺序获取当前绘制的View的绘制顺序</span><br>            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);<br>            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;<br>                more |= drawChild(canvas, child, drawingTime);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//绘制子View</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">drawChild</span><span class="hljs-params">(Canvas canvas, View child, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> child.draw(canvas, <span class="hljs-keyword">this</span>, drawingTime);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>DecorView</code>是最顶层的View，自<code>drawSoftware()</code>开始绘制。</p>
<h3 id="View软件绘制相关"><a href="#View软件绘制相关" class="headerlink" title="View软件绘制相关"></a>View软件绘制相关</h3><p>上一节后面执行到了<code>child.draw()</code>，<code>child</code>为<code>View</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();<br>        <span class="hljs-comment">//是否支持硬件绘制 显然当前情况不支持</span><br>        <span class="hljs-keyword">boolean</span> drawingWithRenderNode = mAttachInfo != <span class="hljs-keyword">null</span><br>                &amp;&amp; mAttachInfo.mHardwareAccelerated<br>                &amp;&amp; hardwareAcceleratedCanvas;<br>  <br>         ...<br>           <span class="hljs-comment">//后续绘制缓存会分析</span><br>          <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123;<br>             <span class="hljs-keyword">if</span> (layerType != LAYER_TYPE_NONE) &#123;<br>                 <span class="hljs-comment">// If not drawing with RenderNode, treat HW layers as SW</span><br>                 layerType = LAYER_TYPE_SOFTWARE;<br>                 buildDrawingCache(<span class="hljs-keyword">true</span>);<br>            &#125;<br>            cache = getDrawingCache(<span class="hljs-keyword">true</span>);<br>         &#125;<br>         <span class="hljs-comment">//缓存可用 且 非硬件绘制条件下</span><br>         <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> drawingWithDrawingCache = cache != <span class="hljs-keyword">null</span> &amp;&amp; !drawingWithRenderNode;<br>         ...<br>         <span class="hljs-keyword">if</span> (!drawingWithDrawingCache) &#123;<br>            <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;<br>                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>                ((DisplayListCanvas) canvas).drawRenderNode(renderNode);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// ViewGroup 不需要绘制背景直接 绘制子View</span><br>                <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;<br>                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>                    dispatchDraw(canvas);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    draw(canvas);<br>                &#125;<br>            &#125;<br>        &#125;<br>       ...<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><br>        <span class="hljs-keyword">if</span> ((changed &amp; DRAW_MASK) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((mViewFlags &amp; WILL_NOT_DRAW) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (mBackground != <span class="hljs-keyword">null</span><br>                        || mDefaultFocusHighlight != <span class="hljs-keyword">null</span><br>                        || (mForegroundInfo != <span class="hljs-keyword">null</span> &amp;&amp; mForegroundInfo.mDrawable != <span class="hljs-keyword">null</span>)) &#123;<br>                    mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mPrivateFlags |= PFLAG_SKIP_DRAW;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;<br>            &#125;<br>            requestLayout();<br>            invalidate(<span class="hljs-keyword">true</span>);<br>        &#125;<br></code></pre></td></tr></table></figure>
<h3 id="软件绘制流程"><a href="#软件绘制流程" class="headerlink" title="软件绘制流程"></a>软件绘制流程</h3><p><img src="/images/软件绘制流程.jpg" srcset="/img/loading.gif" alt="软件绘制流程"></p>
<h3 id="Surface绘制流程"><a href="#Surface绘制流程" class="headerlink" title="Surface绘制流程"></a>Surface绘制流程</h3><p><img src="/images/软件绘制-Surface绘制过程.png" srcset="/img/loading.gif" alt="软件绘制-Surface绘制过程"></p>
<p>执行到<code>drawSoftware()</code>时，开始在<code>Surface</code>上进行绘制。</p>
<h4 id="申请GraphicBuffer"><a href="#申请GraphicBuffer" class="headerlink" title="申请GraphicBuffer"></a>申请<code>GraphicBuffer</code></h4><p>执行的是<code>mSurface.lockCanvas()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>canvas = mSurface.lockCanvas()<br>  <br><span class="hljs-comment">//Surface.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Canvas <span class="hljs-title">lockCanvas</span><span class="hljs-params">(Rect inOutDirty)</span><br>            <span class="hljs-keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            checkNotReleasedLocked();<br>            <span class="hljs-keyword">if</span> (mLockedObject != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// Ideally, nativeLockCanvas() would throw in this situation and prevent the</span><br>                <span class="hljs-comment">// double-lock, but that won't happen if mNativeObject was updated.  We can't</span><br>                <span class="hljs-comment">// abandon the old mLockedObject because it might still be in use, so instead</span><br>                <span class="hljs-comment">// we just refuse to re-lock the Surface.</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Surface was already locked"</span>);<br>            &#125;<br>            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);<br>            <span class="hljs-keyword">return</span> mCanvas;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>执行到<code>nativeLockCanvas()</code>进入JNI代码层</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// core/jni/android_view_Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeLockCanvas</span><span class="hljs-params">(JNIEnv* env, jclass clazz,<br>        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;<br>    <span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">surface</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;<br>  ...<br>    <span class="hljs-comment">//申请buffer</span><br>    ANativeWindow_Buffer outBuffer;<br>    <span class="hljs-keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);<br>  ...<br>    <span class="hljs-comment">//构建Bitmap对象</span><br>    SkImageInfo info = SkImageInfo::Make(outBuffer.<span class="hljs-built_in">width</span>, outBuffer.<span class="hljs-built_in">height</span>,<br>                                         convertPixelFormat(outBuffer.format),<br>                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888<br>                                                 ? kOpaque_SkAlphaType : kPremul_SkAlphaType,<br>                                         GraphicsJNI::defaultColorSpace());<br><br>    SkBitmap bitmap;<br>    <span class="hljs-keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);<br>    bitmap.setInfo(info, bpr);<br>    <span class="hljs-keyword">if</span> (outBuffer.<span class="hljs-built_in">width</span> &gt; <span class="hljs-number">0</span> &amp;&amp; outBuffer.<span class="hljs-built_in">height</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        bitmap.setPixels(outBuffer.bits);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// be safe with an empty bitmap.</span><br>        bitmap.setPixels(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-comment">//canvas设置bitmap</span><br>    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);<br>    nativeCanvas-&gt;setBitmap(bitmap);<br>    <br>    <span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">lockedSurface</span><span class="hljs-params">(surface)</span></span>;<br>    lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);<br>    <span class="hljs-keyword">return</span> (jlong) lockedSurface.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建完<code>ANativeWindowBuffer</code>之后，需要与<code>surface</code>进行绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Surface::lock</span><span class="hljs-params">(<br>        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br></span>&#123;<br>  ...<br>    ANativeWindowBuffer* out;<br>    <span class="hljs-keyword">int</span> fenceFd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);  <br>  ...<br>     <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>        <span class="hljs-function">sp&lt;GraphicBuffer&gt; <span class="hljs-title">backBuffer</span><span class="hljs-params">(GraphicBuffer::getSelf(out))</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">const</span> Rect <span class="hljs-title">bounds</span><span class="hljs-params">(backBuffer-&gt;<span class="hljs-built_in">width</span>, backBuffer-&gt;<span class="hljs-built_in">height</span>)</span></span>;<br>       ...<br>     &#125;<br>  <span class="hljs-comment">//返回GraphicBuffer</span><br>     <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用到<code>lock()</code>之后，将<code>ANativeWindowBuffer</code>转化为<code>GraphicBuffer</code>。再通过<code>dequeueBuffer</code>分配内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Surface::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">android_native_buffer_t</span>** <span class="hljs-built_in">buffer</span>, <span class="hljs-keyword">int</span>* fenceFd)</span> </span>&#123;<br>  ...<br>    FrameEventHistoryDelta frameTimestamps;<br>    <span class="hljs-keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight,<br>                                                            reqFormat, reqUsage, &amp;mBufferAge,<br>                                                            enableFrameTimestamps ? &amp;frameTimestamps<br>                                                                                  : <span class="hljs-literal">nullptr</span>);    <br>  <br>  ...<br>    <span class="hljs-keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mReportRemovedBuffers &amp;&amp; (gbuf != <span class="hljs-literal">nullptr</span>)) &#123;<br>            mRemovedBuffers.push_back(gbuf);<br>        &#125;<br>      <span class="hljs-comment">//</span><br>        result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);<br>        <span class="hljs-keyword">if</span> (result != NO_ERROR) &#123;<br>            ALOGE(<span class="hljs-string">"dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d"</span>, result);<br>            mGraphicBufferProducer-&gt;cancelBuffer(buf, fence);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">//获取buffer</span><br>     *<span class="hljs-built_in">buffer</span> = gbuf.<span class="hljs-built_in">get</span>();<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,<br>                                            <span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">width</span>, <span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">height</span>, PixelFormat format,<br>                                            <span class="hljs-keyword">uint64_t</span> usage, <span class="hljs-keyword">uint64_t</span>* outBufferAge,<br>                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;<br> ...<br>    <span class="hljs-keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;<br>      <span class="hljs-comment">//找到可用的slot，并指定状态为FREE slot:BufferSlot——用来存储GraphicBuffer</span><br>            <span class="hljs-keyword">status_t</span> status = waitForFreeSlotThenRelock(FreeSlotCaller::Dequeue,<br>                    &amp;found);<br>            <span class="hljs-keyword">if</span> (status != NO_ERROR) &#123;<br>                <span class="hljs-keyword">return</span> status;<br>            &#125;<br>      ...<br>    &#125;<br>          *outSlot = found;<br>        ATRACE_BUFFER_INDEX(found);<br><br>        attachedByConsumer = mSlots[found].mNeedsReallocation;<br>        mSlots[found].mNeedsReallocation = <span class="hljs-literal">false</span>;<br>       <span class="hljs-comment">//转化可用slot的GraphicBuffer状态为DEQUEUED</span><br>        mSlots[found].mBufferState.dequeue();<br>  ...<br>      <span class="hljs-keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;<br>        BQ_LOGV(<span class="hljs-string">"dequeueBuffer: allocating a new buffer for slot %d"</span>, *outSlot);<br>        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="hljs-keyword">new</span> GraphicBuffer(<br>                <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>, format, BQ_LAYER_COUNT, usage,<br>                &#123;mConsumerName.<span class="hljs-built_in">string</span>(), mConsumerName.<span class="hljs-built_in">size</span>()&#125;);<br><br>        <span class="hljs-keyword">status_t</span> error = graphicBuffer-&gt;initCheck();<br><br>            <span class="hljs-keyword">if</span> (error == NO_ERROR &amp;&amp; !mCore-&gt;mIsAbandoned) &#123;<br>                graphicBuffer-&gt;setGenerationNumber(mCore-&gt;mGenerationNumber);<br>              <span class="hljs-comment">//对应outSlot申请GraphicBuffer</span><br>                mSlots[*outSlot].mGraphicBuffer = graphicBuffer;<br>            &#125;<br>  ...<br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::waitForFreeSlotThenRelock</span><span class="hljs-params">(FreeSlotCaller caller,<br>        <span class="hljs-keyword">int</span>* found)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//当前是否 队列太多</span><br>        <span class="hljs-keyword">bool</span> tooManyBuffers = mCore-&gt;mQueue.<span class="hljs-built_in">size</span>()<br>                            &gt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(maxBufferCount);<br>        <span class="hljs-keyword">if</span> (tooManyBuffers) &#123;<br>            BQ_LOGV(<span class="hljs-string">"%s: queue size is %zu, waiting"</span>, callerString,<br>                    mCore-&gt;mQueue.<span class="hljs-built_in">size</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// If in shared buffer mode and a shared buffer exists, always</span><br>            <span class="hljs-comment">// return it.</span><br>            <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot !=<br>                    BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                *found = mCore-&gt;mSharedBufferSlot;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (caller == FreeSlotCaller::Dequeue) &#123;<br>                    <span class="hljs-comment">// If we're calling this from dequeue, prefer free buffers</span><br>                  <span class="hljs-comment">//寻找处于 FREE 状态的GraphicBuffer</span><br>                    <span class="hljs-keyword">int</span> slot = getFreeBufferLocked();<br>                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                        *found = slot;                      <br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCore-&gt;mAllowAllocation) &#123;<br>                        *found = getFreeSlotLocked();<br>                    &#125;                                    <br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// If we're calling this from attach, prefer free slots</span><br>                    <span class="hljs-keyword">int</span> slot = getFreeSlotLocked();<br>                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                        *found = slot;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        *found = getFreeBufferLocked();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;    <br>  ...<br>        tryAgain = (*found == BufferQueueCore::INVALID_BUFFER_SLOT) ||<br>                   tooManyBuffers;<br>         <span class="hljs-keyword">if</span> (tryAgain) &#123;<br>           <span class="hljs-comment">//找不到可用的slot或者buffer太多，需要等待空闲</span><br>         &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>BufferSlot</code>：用来存储<code>GraphicBuffer</code></p>
<p><code>waitForFreeSlotThenRelock()</code>返回可用的<code>slot</code>分为两种：</p>
<ul>
<li><code>getFreeBufferLocked()</code>：直接关联了<code>GraphicBuffer</code>，直接可用</li>
<li><code>getFreeSlotLocked()</code>：找到可用的<code>BufferSlot</code>，新建<code>GraphicBuffer</code>后，直接与其关联。</li>
</ul>
<p><code>lockCanvas()</code>最终通过<code>BufferQueueProducer.dequeueBuffer()</code>申请用来绘制的<code>GraphicBuffer</code></p>
<blockquote>
<p>尝试找到一个<code>BufferSlot</code>，并完成<code>GraphicBuffer</code>与<code>BufferSlot</code>的关联，途中切换<code>BufferSlot</code>状态<code>FREE-&gt;DEQUEUED</code>，最后返回对应的<code>BufferSlot</code>索引。</p>
</blockquote>
<h4 id="SurfaceFlinger消费GraphicBuffer"><a href="#SurfaceFlinger消费GraphicBuffer" class="headerlink" title="SurfaceFlinger消费GraphicBuffer"></a><code>SurfaceFlinger</code>消费<code>GraphicBuffer</code></h4><p>当<code>Cavans</code>绘制完毕后，调用<code>surface.unlockAndPostCanvas()</code>发送<code>GraphicBuffer</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Surface.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlockAndPostCanvas</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            checkNotReleasedLocked();<br><br>            <span class="hljs-keyword">if</span> (mHwuiContext != <span class="hljs-keyword">null</span>) &#123;<br>              <span class="hljs-comment">//硬件绘制流程</span><br>                mHwuiContext.unlockAndPost(canvas);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//软件绘制流程</span><br>                unlockSwCanvasAndPost(canvas);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlockSwCanvasAndPost</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>      ... <br>        <span class="hljs-keyword">try</span> &#123;<br>            nativeUnlockCanvasAndPost(mLockedObject, canvas);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            nativeRelease(mLockedObject);<br>            mLockedObject = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// core/jni/android_view_Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nativeUnlockCanvasAndPost</span><span class="hljs-params">(JNIEnv* env, jclass clazz,<br>        jlong nativeObject, jobject canvasObj)</span> </span>&#123;<br>  ...<br><br>    <span class="hljs-comment">// 绘制完成后，将Canvas从surface上脱离</span><br>    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);<br>    nativeCanvas-&gt;setBitmap(SkBitmap());<br><br>    <span class="hljs-comment">// unlock surface</span><br>    <span class="hljs-keyword">status_t</span> err = surface-&gt;unlockAndPost();<br>    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br>        doThrowIAE(env);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Surface::unlockAndPost</span><span class="hljs-params">()</span><br></span>&#123;<br>  ...<br>    err = queueBuffer(mLockedBuffer.<span class="hljs-built_in">get</span>(), fd);<br>    ALOGE_IF(err, <span class="hljs-string">"queueBuffer (handle=%p) failed (%s)"</span>,<br>            mLockedBuffer-&gt;handle, strerror(-err));<br><br>    mPostedBuffer = mLockedBuffer;<br>    mLockedBuffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Surface::queueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">android_native_buffer_t</span>* <span class="hljs-built_in">buffer</span>, <span class="hljs-keyword">int</span> fenceFd)</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//根据Buffer获取slot</span><br>    <span class="hljs-keyword">int</span> i = getSlotFromBufferLocked(<span class="hljs-built_in">buffer</span>);<br>  ...<br>    <span class="hljs-comment">//GraphicBufferQueue 插入 GraphicBuffer</span><br>    <span class="hljs-keyword">status_t</span> err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);<br>  ...<br>    <span class="hljs-comment">//插入Buffer后通知</span><br>    mQueueBufferCondition.broadcast();<br>&#125; <br><br><span class="hljs-comment">//根据传入buffer获取slot</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Surface::getSlotFromBufferLocked</span><span class="hljs-params">(<br>        <span class="hljs-keyword">android_native_buffer_t</span>* <span class="hljs-built_in">buffer</span>)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  <span class="hljs-comment">//NUM_BUFFER_SLOTS 64</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_BUFFER_SLOTS; i++) &#123;<br>        <span class="hljs-keyword">if</span> (mSlots[i].<span class="hljs-built_in">buffer</span> != <span class="hljs-literal">NULL</span> &amp;&amp;<br>                mSlots[i].<span class="hljs-built_in">buffer</span>-&gt;handle == <span class="hljs-built_in">buffer</span>-&gt;handle) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    ALOGE(<span class="hljs-string">"getSlotFromBufferLocked: unknown buffer: %p"</span>, <span class="hljs-built_in">buffer</span>-&gt;handle);<br>    <span class="hljs-keyword">return</span> BAD_VALUE;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span><br>status_t BufferQueueProducer::queueBuffer(<span class="hljs-keyword">int</span> slot,<br>        <span class="hljs-keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;<br>    BufferItem item;<br>  ...<br>    <span class="hljs-comment">//判断slot 以及 buffer状态是否正常</span><br>        <span class="hljs-keyword">if</span> (slot &lt; <span class="hljs-number">0</span> || slot &gt;= BufferQueueDefs::NUM_BUFFER_SLOTS) &#123;<br>            BQ_LOGE(<span class="hljs-string">"queueBuffer: slot index %d out of range [0, %d)"</span>,<br>                    slot, BufferQueueDefs::NUM_BUFFER_SLOTS);<br>            <span class="hljs-keyword">return</span> BAD_VALUE;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mSlots[slot].mBufferState.isDequeued()) &#123;<br>            BQ_LOGE(<span class="hljs-string">"queueBuffer: slot %d is not owned by the producer "</span><br>                    <span class="hljs-string">"(state = %s)"</span>, slot, mSlots[slot].mBufferState.string());<br>            <span class="hljs-keyword">return</span> BAD_VALUE;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mSlots[slot].mRequestBufferCalled) &#123;<br>            BQ_LOGE(<span class="hljs-string">"queueBuffer: slot %d was queued without requesting "</span><br>                    <span class="hljs-string">"a buffer"</span>, slot);<br>            <span class="hljs-keyword">return</span> BAD_VALUE;<br>        &#125;<br>  ...<br>    <span class="hljs-comment">//构建BufferItem对象，等待传递</span><br>        item.mAcquireCalled = mSlots[slot].mAcquireCalled;<br>        item.mGraphicBuffer = mSlots[slot].mGraphicBuffer;<br>        item.mCrop = crop;<br>        item.mTransform = transform &amp;<br>                ~static_cast&lt;uint32_t&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);<br>        item.mTransformToDisplayInverse =<br>                (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != <span class="hljs-number">0</span>;<br>        item.mScalingMode = static_cast&lt;uint32_t&gt;(scalingMode);<br>        item.mTimestamp = requestedPresentTimestamp;<br>        item.mIsAutoTimestamp = isAutoTimestamp;<br>        item.mDataSpace = dataSpace;<br>        item.mHdrMetadata = hdrMetadata;<br>        item.mFrameNumber = currentFrameNumber;<br>        item.mSlot = slot;<br>        item.mFence = acquireFence;<br>        item.mFenceTime = acquireFenceTime;<br>        item.mIsDroppable = mCore-&gt;mAsyncMode ||<br>                mCore-&gt;mDequeueBufferCannotBlock ||<br>                (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == slot);<br>        item.mSurfaceDamage = surfaceDamage;<br>        item.mQueuedBuffer = <span class="hljs-keyword">true</span>;<br>        item.mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mAutoRefresh;<br>        item.mApi = mCore-&gt;mConnectedApi;<br>  <br>    <span class="hljs-comment">//切换 BufferSlot状态到 QUEUED</span><br>        mSlots[slot].mFence = acquireFence;<br>        mSlots[slot].mBufferState.queue();<br>    <span class="hljs-comment">//将item插入队列</span><br>        <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;<br>            mCore-&gt;mQueue.push_back(item);<br>            frameAvailableListener = mCore-&gt;mConsumerListener;          <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">const</span> BufferItem&amp; last = mCore-&gt;mQueue.itemAt(<br>                    mCore-&gt;mQueue.size() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (last.mIsDroppable) &#123;<br>              ...<br>               mCore-&gt;mQueue.editItemAt(mCore-&gt;mQueue.size() - <span class="hljs-number">1</span>) = item;<br>               frameReplacedListener = mCore-&gt;mConsumerListener;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>               mCore-&gt;mQueue.push_back(item);<br>               frameAvailableListener = mCore-&gt;mConsumerListener;              <br>            &#125;<br>        &#125;<br>  ...<br>    <span class="hljs-comment">//回调frameAvaliableListener 通知消费者有数据入队了</span><br>        <span class="hljs-keyword">if</span> (frameAvailableListener != NULL) &#123;<br>            frameAvailableListener-&gt;onFrameAvailable(item);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (frameReplacedListener != NULL) &#123;<br>            frameReplacedListener-&gt;onFrameReplaced(item);<br>        &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>//TODO 这里有个问题 如何和<code>BufferLayer</code>绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BufferQueueLayer::onFrameAvailable</span><span class="hljs-params">(<span class="hljs-keyword">const</span> BufferItem&amp; item)</span> </span>&#123;<br>  ...<br>   mFlinger-&gt;signalLayerUpdate();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::signalLayerUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>    mScheduler-&gt;resetIdleTimer();<br>    mPowerAdvisor.notifyDisplayUpdateImminent();<br>    mEventQueue-&gt;invalidate();<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>unlockAndPost()</code>主要调用到<code>queueBuffer()</code>。</p>
<p>上节在<code>dequeueBuffer()</code>获取<code>slot</code>之后，就在对应的<code>slot</code>生成了<code>GraphicBuffer</code>。就可以继续Draw填充过程。</p>
<p>填充完成后，调用<code>queueBuffer()</code>根据<code>slot</code>获取对应的<code>GraphicBuffer</code>，封装成<code>BufferItem</code>对象，在回调<code>onFrameAvailable()</code>传入。通知<code>BufferQueueConsumer</code>有新数据传入。</p>
</blockquote>
<p><img src="/images/关系图.png" srcset="/img/loading.gif" alt="img"></p>
<h4 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h4><blockquote>
<p><strong>Android显示系统的核心</strong>。遵循<code>生产者-消费者</code>模型，只要往<code>BufferQueue</code>填充数据，就被认为是<code>生产者</code>。从<code>BufferQueue</code>获取数据，就被认为是<code>消费者</code>。</p>
<p><code>SurfaceFlinger</code>在合成并显示UI内容时，UI负责生产内容，<code>SurfaceFlinger</code>作为<code>消费者</code>消费内容。</p>
<p>在截屏时，<code>SurfaceFlinger</code>作为生产者，将当前的UI内容填充到另一个<code>BufferQueue</code>内，截屏作为<code>消费者</code>从<code>BufferQueue</code>获取数据</p>
</blockquote>
<p><img src="/images/v2-6a617ddb116d922b24f416582a5bf013_1440w.jpg" srcset="/img/loading.gif" alt="img"></p>
<p>如图所示执行步骤如下所示：</p>
<ol>
<li>初始化一个<code>BufferQueue</code></li>
<li><code>BufferQueueProducer</code>调用<code>dequeueBuffer</code>向<code>BufferQueue</code>申请一块空的<code>GRaphicBuffer</code></li>
<li>可以通过<code>requestBuffer</code>获取对应的<code>GraphicBuffer</code></li>
<li>向<code>GraphicBuffer</code>填充完数据后，调用<code>queueBuffer</code>向<code>BufferQueue</code>添加<code>GraphicBuffer</code></li>
<li>添加数据完成后，<code>BufferQueue</code>通过回调通知消费者，有新数据加入——<code>onFrameAvaliable()</code></li>
<li><code>BufferQueueConsumer</code>调用<code>acquireBuffer</code>从<code>BufferQueue</code>获取<code>GraphicBuffer</code></li>
<li>待<code>GraphicBuffer</code>使用完毕后，调用<code>releaseBuffer</code>将空的<code>GraphicBuffer</code>还给<code>BufferQueue</code>以便重复利用</li>
<li>空的数据返回后，<code>BufferQueue</code>通过回调通知生产者，有空闲数据。后续生产者可以继续获取空的<code>GraphicBuffer</code>进行使用——<code>onBufferReleased()</code></li>
<li>在<code>2~8</code>之间循环，形成一整套图形数据的生产-消费过程。</li>
</ol>
<h5 id="GraphicBuffer–BufferState"><a href="#GraphicBuffer–BufferState" class="headerlink" title="GraphicBuffer–BufferState"></a>GraphicBuffer–BufferState</h5><p>上面有提到，调用<code>dequeueBuffer()</code>需要获取空的<code>GraphicBuffer</code>，通过<code>getFreeBufferLocked()</code>寻找。</p>
<p>其中<code>GraphicBuffer</code>有以下几种状态(<code>BufferSlot.BufferState</code>)：</p>
<ul>
<li><code>FREE</code>：当前<code>GraphicBuffer</code>可用，且位于<code>BufferQueue</code>内</li>
<li><code>DEQUEUED</code>：当前<code>GraphicBuffer</code>被生产者获取了，该buffer当前属于生产者</li>
<li><code>QUEUED</code>：当前<code>GraphicBuffer</code>被生产者填充了数据，该buffer当前属于<code>BufferQueue</code></li>
<li><code>ACQUIRED</code>：当前<code>GraphicBuffer</code>被消费者获取了，该buffer当前属于消费者</li>
</ul>
<h2 id="硬件绘制"><a href="#硬件绘制" class="headerlink" title="硬件绘制"></a>硬件绘制</h2><blockquote>
<p>默认开启<code>硬件加速</code>，可以通过配置<code>android:hardwareAccelerated=&quot;false&quot;</code>关闭硬件加速</p>
<p><code>把View中绘制的计算工作交给GPU来处理，就是把drawXX()相关的方法进行转换。</code></p>
</blockquote>
<p><code>硬件绘制</code>主要包含两步：</p>
<ul>
<li><p><code>构建阶段</code></p>
<blockquote>
<p>遍历所有View，将需要绘制的操作缓存下来，构建<code>DisplayList</code>。交给<code>RenderThread</code>使用GPU进行硬件加速渲染。</p>
</blockquote>
</li>
<li><p><code>绘制阶段</code></p>
<blockquote>
<p>构建好的<code>DisplayList</code>交给<code>RenderThread</code>使用GPU进行硬件加速渲染，绘制的内容保存在<code>Graphic Buffer</code>并交由<code>SurfaceFlinger</code>显示。</p>
</blockquote>
</li>
</ul>
<h3 id="控制硬件加速"><a href="#控制硬件加速" class="headerlink" title="控制硬件加速"></a>控制硬件加速</h3><p><img src="/images/硬件绘制-控制硬件加速.png" srcset="/img/loading.gif" alt="硬件绘制-控制硬件加速"></p>
<blockquote>
<p>硬件绘制需要在<code>开启硬件加速</code>的条件下才可以执行</p>
</blockquote>
<p>可以在以下级别控制<code>硬件加速</code>：</p>
<ul>
<li><p><strong>应用</strong></p>
<p>在<code>AndroidManifest.xml</code>配置如下属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">...</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>Activity</strong></p>
<p>在<code>AndroidManifest.xml</code>配置如下属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"true"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">...</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"false"</span> /&gt;</span> //控制某个Activity关闭硬件加速<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>窗口Window</strong></p>
<p>配置如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">getWindow().setFlags(<br>    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,<br>    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>视图View</strong></p>
<p>为单个视图停用硬件加速</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myView.setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="DisplayList"><a href="#DisplayList" class="headerlink" title="DisplayList"></a>DisplayList</h3><p><img src="/images/硬件绘制-DisplayList.png" srcset="/img/loading.gif" alt="硬件绘制-DisplayList"></p>
<blockquote>
<p>本质上是一个<strong>缓冲区</strong>，里面<code>记录即将执行的绘制命令序列</code>。</p>
</blockquote>
<p><code>DisplayList</code>的存在有两个好处：</p>
<ol>
<li><p>在绘制下一帧时，若View没有发生变化，就不必执行相关绘制API，直接复用上次的<code>DisplayList</code>。</p>
</li>
<li><p>在绘制下一帧时，若View发生变化，但只是一些简单属性发生变化，就不需重建<code>DisplayList</code>，直接修改<code>DisplayList</code>相关属性即可。</p>
<p>针对以下属性，都不需重建<code>DisplayList</code></p>
<ul>
<li><code>alpha</code>：更改层的不透明度</li>
<li><code>x</code>、<code>y</code>、<code>translationX</code>、<code>translationY</code>：更改层的位置</li>
<li><code>scaleX</code>、<code>scaleY</code>：更改层的大小</li>
<li><code>rotation</code>、<code>rotationX</code>、<code>rotationY</code>：更改层在 3D 空间里的方向</li>
<li><code>pivotX</code>、<code>pivotY</code>：更改层的转换原点</li>
</ul>
</li>
</ol>
<p>以上在使用<code>DisplayList</code>的过程都不需要执行<code>onDraw()</code>。</p>
<p><img src="/images/DisplayList结构.png" srcset="/img/loading.gif" alt="img"></p>
<h3 id="RenderNode"><a href="#RenderNode" class="headerlink" title="RenderNode"></a>RenderNode</h3><blockquote>
<p>在Android 5.0后引入，是对<code>DisplayList</code>以及<code>View显示属性</code>的封装。</p>
</blockquote>
<p><strong>通常一个<code>RenderNode</code>对应一个<code>View</code>，包含了View自身及其子View的所有DisplayList。</strong></p>
<p>其中还有一个<code>RootRenderNode</code>，里面包含着<code>View层次结构中所有View的DisplayList信息</code>。</p>
<h3 id="ViewRootImpl硬件绘制相关"><a href="#ViewRootImpl硬件绘制相关" class="headerlink" title="ViewRootImpl硬件绘制相关"></a>ViewRootImpl硬件绘制相关</h3><blockquote>
<p>只有当前View支持<code>硬件加速</code>时，才可以进入<code>硬件绘制</code></p>
<p><code>if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled())</code></p>
</blockquote>
<p><img src="/images/硬件绘制-构建DisplayList.png" srcset="/img/loading.gif" alt="硬件绘制-构建DisplayList"></p>
<h4 id="ThreadedRenderer-draw"><a href="#ThreadedRenderer-draw" class="headerlink" title="ThreadedRenderer.draw()"></a>ThreadedRenderer.draw()</h4><blockquote>
<p><code>ThreadedRenderer</code>在UI线程创建，主要执行了两步：</p>
<ul>
<li>构建View的DrawOp树，就是<code>DisplayList</code>。<code>DrawOp 表示 Drawing Operations</code></li>
<li>与渲染线程(<code>RenderThread</code>)进行通信</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ThreadedRenderer.java</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks,<br>          FrameDrawingCallback frameDrawingCallback)</span> </span>&#123;<br>      attachInfo.mIgnoreDirtyState = <span class="hljs-keyword">true</span>;<br><br>      <span class="hljs-keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;<br>      choreographer.mFrameInfo.markDrawStart();<br>      <span class="hljs-comment">//构建View的DrawOp树</span><br>      updateRootDisplayList(view, callbacks);<br><br>      ...<br>      <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] frameInfo = choreographer.mFrameInfo.mFrameInfo;<br>      <span class="hljs-keyword">if</span> (frameDrawingCallback != <span class="hljs-keyword">null</span>) &#123;<br>          nSetFrameCallback(mNativeProxy, frameDrawingCallback);<br>      &#125;<br>      <span class="hljs-comment">//通知RenderThread线程绘制</span><br>      <span class="hljs-keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);<br>      ...<br>  &#125;<br></code></pre></td></tr></table></figure>
<h4 id="updateRootDisplayList"><a href="#updateRootDisplayList" class="headerlink" title="updateRootDisplayList()"></a>updateRootDisplayList()</h4><blockquote>
<p>构建<code>DrawOp</code>树，构建<code>RootDisplayList</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateRootDisplayList</span><span class="hljs-params">(View view, DrawCallbacks callbacks)</span> </span>&#123;<br>   <span class="hljs-comment">//更新View的displayList</span><br>    updateViewTreeDisplayList(view);<br><br>    <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;<br>       <span class="hljs-comment">//获取DisplayCanvas</span><br>        DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> saveCount = canvas.save();<br>            canvas.translate(mInsetLeft, mInsetTop);<br>            callbacks.onPreDraw(canvas);<br><br>            canvas.insertReorderBarrier();<br>           <span class="hljs-comment">//displayListCanvas缓存View对应的drawOp节点</span><br>            canvas.drawRenderNode(view.updateDisplayListIfDirty());<br>            canvas.insertInorderBarrier();<br><br>            callbacks.onPostDraw(canvas);<br>            canvas.restoreToCount(saveCount);<br>            mRootNodeNeedsUpdate = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-comment">//RootRenderNode填充所有节点</span><br>            mRootNode.end(canvas);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewTreeDisplayList</span><span class="hljs-params">(View view)</span> </span>&#123;<br>    view.mPrivateFlags |= View.PFLAG_DRAWN;<br>    view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)<span class="hljs-comment">//invalidate()对应标记</span><br>            == View.PFLAG_INVALIDATED;<span class="hljs-comment">//初始DecorView默认为 true</span><br>    view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;<br>    view.updateDisplayListIfDirty();<span class="hljs-comment">//更新节点</span><br>    view.mRecreateDisplayList = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="DecorView-updateDisplayListIfDirty"><a href="#DecorView-updateDisplayListIfDirty" class="headerlink" title="DecorView.updateDisplayListIfDirty()"></a>DecorView.updateDisplayListIfDirty()</h4><blockquote>
<p><code>updateRootDisplayList()</code>中对应的View就是<code>DecorView</code>，是所有View的顶层。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><br><span class="hljs-meta">@NonNull</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RenderNode <span class="hljs-title">updateDisplayListIfDirty</span><span class="hljs-params">()</span> </span>&#123;<br>      ...<br>        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="hljs-number">0</span><br>                || !renderNode.isValid()<br>                || (mRecreateDisplayList)) &#123;<br>          ...<br>          <span class="hljs-keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);<br>          <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;<span class="hljs-comment">//是否强制软件绘制</span><br>                    buildDrawingCache(<span class="hljs-keyword">true</span>);<br>                    Bitmap cache = getDrawingCache(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//获取绘制缓存</span><br>                    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//缓存有效，复用缓存</span><br>                        canvas.drawBitmap(cache, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mLayerPaint);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Fast path for layouts with no backgrounds</span><br>                    <span class="hljs-comment">//ViewGroup不需要绘制，直接调用dispatchDraw</span><br>                    <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;<br>                        dispatchDraw(canvas);<br>                        drawAutofilledHighlight(canvas);<br>                         ...<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                      <span class="hljs-comment">//ViewGroup(需要绘制) / View 直接调用draw</span><br>                        draw(canvas);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               <span class="hljs-comment">//缓存构建完成，放入渲染节点</span><br>                renderNode.end(canvas);<br>                setDisplayListProperties(renderNode);<br>            &#125;<br>          <br>        &#125;<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>DecorView</code>执行<code>updateDisplayListIfDirty()</code>，调用到<code>draw(Canvas)</code>，然后向下递归调用到<code>child.draw()</code></p>
<p><code>updateRootDisplayList()</code>主要执行以下几步：</p>
<ul>
<li>更新<code>DecorView</code>操作缓存(DisplayList)——<code>updateViewTreeDisplayList(decorView)</code></li>
<li>利用<code>DisplayCanvas</code>构建并缓存所有的<code>DrawOp(View的绘制操作)</code>——<code>mRootNode.start()</code></li>
<li>将<code>DisplayListCanvas</code>缓存的<code>DrawOp</code>填充到<code>RenderNode(View)</code>——<code>View.updateDisplayListIfDirty()</code></li>
<li>将<code>DecorView</code>的缓存<code>DrawOp</code>填充到<code>RootRenderNode</code>中——<code>mRootNode.end()</code></li>
</ul>
<p><img src="/images/硬件绘制-updateDisplayListIfDirty.png" srcset="/img/loading.gif" alt="硬件绘制-updateDisplayListIfDirty()"></p>
<h3 id="View硬件绘制相关"><a href="#View硬件绘制相关" class="headerlink" title="View硬件绘制相关"></a>View硬件绘制相关</h3><p>上一节中，通过<code>DecorView</code>递归调用<code>子View.updateDisplayListIfDirty()</code>不断填充<code>DisplayList</code>到对应View的<code>RenderNode</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">View</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>  ...<br>     <span class="hljs-comment">//初始化渲染节点</span><br>     mRenderNode = RenderNode.create(getClass().getName(), <span class="hljs-keyword">new</span> ViewAnimationHostBridge(<span class="hljs-keyword">this</span>));<br>  ...<br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();<br><br>        <span class="hljs-keyword">boolean</span> drawingWithRenderNode = mAttachInfo != <span class="hljs-keyword">null</span><br>                &amp;&amp; mAttachInfo.mHardwareAccelerated<br>                &amp;&amp; hardwareAcceleratedCanvas;<br>        ...<br>        <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;<br>           <span class="hljs-comment">//继续执行到updateDisplayListIfDirty</span><br>            renderNode = updateDisplayListIfDirty();<br>            <span class="hljs-keyword">if</span> (!renderNode.isValid()) &#123;<br>                renderNode = <span class="hljs-keyword">null</span>;<br>                drawingWithRenderNode = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RenderNode <span class="hljs-title">updateDisplayListIfDirty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> RenderNode renderNode = mRenderNode;<br>        <span class="hljs-keyword">if</span> (!canHaveDisplayList()) &#123;<br>            <span class="hljs-comment">// can't populate RenderNode, don't try</span><br>            <span class="hljs-keyword">return</span> renderNode;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="hljs-number">0</span> <span class="hljs-comment">//绘制缓存无效</span><br>                || !renderNode.isValid() <span class="hljs-comment">//渲染节点没有DisplayList</span><br>                || (mRecreateDisplayList)) &#123; <span class="hljs-comment">//需要刷新DisplayList</span><br>            <span class="hljs-comment">// Don't need to recreate the display list, just need to tell our</span><br>            <span class="hljs-comment">// children to restore/recreate theirs</span><br>            <span class="hljs-keyword">if</span> (renderNode.isValid() <span class="hljs-comment">//只要draw过一次后，一直返回true</span><br>                    &amp;&amp; !mRecreateDisplayList) &#123;<span class="hljs-comment">//调用一些只需要displayList属性修改的方法</span><br>                <span class="hljs-comment">//不需要重建 DisplayList</span><br>                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;<br>                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>                dispatchGetDisplayList();<br><br>                <span class="hljs-keyword">return</span> renderNode; <span class="hljs-comment">// no work needed</span><br>            &#125;<br><br>            <span class="hljs-comment">// If we got here, we're recreating it. Mark it as such to ensure that</span><br>            <span class="hljs-comment">// we copy in child display lists into ours in drawChild()</span><br>            mRecreateDisplayList = <span class="hljs-keyword">true</span>;<br><br>            <span class="hljs-keyword">int</span> width = mRight - mLeft;<br>            <span class="hljs-keyword">int</span> height = mBottom - mTop;<br>            <span class="hljs-keyword">int</span> layerType = getLayerType();<br>           <span class="hljs-comment">//获取DisplayListCanvas</span><br>            <span class="hljs-keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;<span class="hljs-comment">//软件绘制，绘制缓存存在直接复用</span><br>                    buildDrawingCache(<span class="hljs-keyword">true</span>);<br>                    Bitmap cache = getDrawingCache(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;<br>                        canvas.drawBitmap(cache, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mLayerPaint);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    computeScroll();<br><br>                    canvas.translate(-mScrollX, -mScrollY);<br>                    <span class="hljs-comment">//添加 缓存有效标记</span><br>                    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;<br>                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br><br>                    <span class="hljs-comment">//ViewGroup不需要绘制，直接调用dispatchDraw</span><br>                    <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;<br>                        dispatchDraw(canvas);<br>                        drawAutofilledHighlight(canvas);<br>                         ...<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                      <span class="hljs-comment">//ViewGroup(需要绘制) / View 直接调用draw</span><br>                        draw(canvas);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               <span class="hljs-comment">//RenderNode 收集DisplayList</span><br>                renderNode.end(canvas);<br>                setDisplayListProperties(renderNode);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;<br>            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>        &#125;<br>        <span class="hljs-keyword">return</span> renderNode;<br>    &#125;<br><br>    <span class="hljs-comment">//是否会有DisplayList = 是否开启硬件加速</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canHaveDisplayList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !(mAttachInfo == <span class="hljs-keyword">null</span> || mAttachInfo.mThreadedRenderer == <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//只有flag标记为 PFLAG_INVALIDATED ，调用需要 重建DisplayList</span><br>    mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<p>根据上述源码可判断<code>View需要重新构建DisplayList(执行draw())</code>有以下条件：</p>
<ol>
<li><p><code>(mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0</code>当前View绘制缓存无效</p>
<p><strong>mPrivateFlags没有<code>PFLAG_DRAWING_CACHE_VALID</code>标记</strong></p>
</li>
<li><p><code>renderNode.isValid()==false</code> View对应的<code>DisplayList</code>尚未构建或者被销毁</p>
<p><strong>只要View绘制过一次，就会一直返回true。除非<code>detached</code></strong></p>
</li>
<li><p><code>mRecreateDisplayList==true</code> View需要重新构建<code>DisplayList</code></p>
<p><strong>mPrivateFlags持有<code>PFLAG_INVALIDATED</code>标记</strong></p>
</li>
</ol>
<p>能满足以上条件的就是调用<code>View.invalidate()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">()</span> </span>&#123;<br>        invalidate(<span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> invalidateCache)</span> </span>&#123;<br>        invalidateInternal(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidateInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">boolean</span> invalidateCache,<br>            <span class="hljs-keyword">boolean</span> fullInvalidate)</span> </span>&#123;<br>      ...<br>            <span class="hljs-keyword">if</span> (invalidateCache) &#123;<br>                mPrivateFlags |= PFLAG_INVALIDATED; <span class="hljs-comment">//添加PFLAG_INVALIDATED标志</span><br>                mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;<span class="hljs-comment">//移除PFLAG_DRAWING_CACHE_VALID标志</span><br>            &#125;<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="dispatchGetDisplayList"><a href="#dispatchGetDisplayList" class="headerlink" title="dispatchGetDisplayList()"></a>dispatchGetDisplayList()</h4><p>只会在不重建<code>DisplayList</code>情况下调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><br><span class="hljs-comment">// 只会在ViewGroup下实现，更新子View的DisplayList</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchGetDisplayList</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><br><span class="hljs-comment">//ViewGroup.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchGetDisplayList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mChildrenCount;<br>        <span class="hljs-keyword">final</span> View[] children = mChildren;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-keyword">final</span> View child = children[i];<br>           <span class="hljs-comment">//View可见 || 设置动画</span><br>            <span class="hljs-keyword">if</span> (((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>)) &#123;<br>                recreateChildDisplayList(child);<span class="hljs-comment">//调用子</span><br>            &#125;<br>        &#125;<br>        ...<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recreateChildDisplayList</span><span class="hljs-params">(View child)</span> </span>&#123;<br>        child.mRecreateDisplayList = (child.mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="hljs-number">0</span>;<span class="hljs-comment">//没有PFLAG_INVALIDATED 返回true</span><br>        child.mPrivateFlags &amp;= ~PFLAG_INVALIDATED; <span class="hljs-comment">//移除 PFLAG_INVALIDATED标志</span><br>        child.updateDisplayListIfDirty();<br>        child.mRecreateDisplayList = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//执行完后 重置状态</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="RenderThread渲染UI"><a href="#RenderThread渲染UI" class="headerlink" title="RenderThread渲染UI"></a>RenderThread渲染UI</h3><p>构建完<code>RootRenderNode</code>的<code>DisplayList——DrawOp树</code>之后，就需要准备渲染。<em>利用GPU将DisplayList绘制到屏幕上</em>。</p>
<h4 id="ThreadedRenderer-nSyncAndFrame"><a href="#ThreadedRenderer-nSyncAndFrame" class="headerlink" title="ThreadedRenderer#nSyncAndFrame"></a>ThreadedRenderer#nSyncAndFrame</h4><p>构建DisplayList完毕后，向下执行到<code>nSyncAndDrawFrame()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ThreadedRenderer.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks,<br>            FrameDrawingCallback frameDrawingCallback)</span> </span>&#123;<br>      ...<br>        <span class="hljs-comment">//构建DisplayList</span><br>        updateRootDisplayList(view, callbacks);<br>      ...<br>      <span class="hljs-comment">//开始绘制DisplayList</span><br>        <span class="hljs-keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nSyncAndDrawFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nativeProxy, <span class="hljs-keyword">long</span>[] frameInfo, <span class="hljs-keyword">int</span> size)</span></span>;<br></code></pre></td></tr></table></figure>
<p><code>nSyncAndDrawFrame()</code>切换到<code>Native</code>层执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//core/jni/android_view_ThreadedRenderer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="hljs-params">(JNIEnv* env, jobject clazz,<br>        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize)</span> </span>&#123;<br>    LOG_ALWAYS_FATAL_IF(frameInfoSize != UI_THREAD_FRAME_INFO_SIZE,<br>            <span class="hljs-string">"Mismatched size expectations, given %d expected %d"</span>,<br>            frameInfoSize, UI_THREAD_FRAME_INFO_SIZE);<br>    RenderProxy* proxy = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);<br>    env-&gt;GetLongArrayRegion(frameInfo, <span class="hljs-number">0</span>, frameInfoSize, proxy-&gt;frameInfo());<br>    <span class="hljs-keyword">return</span> proxy-&gt;syncAndDrawFrame();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>RenderProxy</code>继续执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//libs/hwui/renderthread/RenderProxy.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RenderProxy::syncAndDrawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mDrawFrameTask.drawFrame();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="DrawFrameTask-drawFrame"><a href="#DrawFrameTask-drawFrame" class="headerlink" title="DrawFrameTask#drawFrame()"></a>DrawFrameTask#drawFrame()</h4><p>调用了<code>DrawFrameTask#drawFrame()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//libs/hwui/renderthread/DrawFrameTask.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DrawFrameTask::drawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    LOG_ALWAYS_FATAL_IF(!mContext, <span class="hljs-string">"Cannot drawFrame with no CanvasContext!"</span>);<br><br>    mSyncResult = SyncResult::OK;<br>    mSyncQueued = systemTime(CLOCK_MONOTONIC);<br>    postAndWait();<br><br>    <span class="hljs-keyword">return</span> mSyncResult;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawFrameTask::postAndWait</span><span class="hljs-params">()</span> </span>&#123;<br>    AutoMutex _lock(mLock);<br>    mRenderThread-&gt;<span class="hljs-built_in">queue</span>().post([<span class="hljs-keyword">this</span>]() &#123; run(); &#125;);<br>    mSignal.wait(mLock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawFrameTask::run</span><span class="hljs-params">()</span> </span>&#123;<br>    ATRACE_NAME(<span class="hljs-string">"DrawFrame"</span>);<br><br>    <span class="hljs-keyword">bool</span> canUnblockUiThread;<br>    <span class="hljs-keyword">bool</span> canDrawThisFrame;<br>    &#123;<br>        <span class="hljs-function">TreeInfo <span class="hljs-title">info</span><span class="hljs-params">(TreeInfo::MODE_FULL, *mContext)</span></span>;<br>      <span class="hljs-comment">//同步帧状态</span><br>        canUnblockUiThread = syncFrameState(info);<br>        canDrawThisFrame = info.out.canDrawThisFrame;<br><br>        <span class="hljs-keyword">if</span> (mFrameCompleteCallback) &#123;<br>            mContext-&gt;addFrameCompleteListener(<span class="hljs-built_in">std</span>::move(mFrameCompleteCallback));<br>            mFrameCompleteCallback = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Grab a copy of everything we need</span><br>    CanvasContext* context = mContext;<br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int64_t</span>)&gt; callback = <span class="hljs-built_in">std</span>::move(mFrameCallback);<br>    mFrameCallback = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// From this point on anything in "this" is *UNSAFE TO ACCESS*</span><br>    <span class="hljs-keyword">if</span> (canUnblockUiThread) &#123;<br>        unblockUiThread();<br>    &#125;<br><br>    <span class="hljs-comment">// Even if we aren't drawing this vsync pulse the next frame number will still be accurate</span><br>    <span class="hljs-keyword">if</span> (CC_UNLIKELY(callback)) &#123;<br>        context-&gt;enqueueFrameWork([callback, frameNr = context-&gt;getFrameNumber()]() &#123;<br>            callback(frameNr);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;<br>      <span class="hljs-comment">//执行绘制流程</span><br>        context-&gt;draw();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// wait on fences so tasks don't overlap next frame</span><br>        context-&gt;waitOnFences();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!canUnblockUiThread) &#123;<br>        unblockUiThread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要执行过程为两步：</p>
<ul>
<li>调用<code>syncFrameState()</code>同步Frame信息</li>
<li>调用<code>CanvasContext.draw()</code>开始绘制</li>
</ul>
<h5 id="syncFrameState"><a href="#syncFrameState" class="headerlink" title="syncFrameState"></a>syncFrameState</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DrawFrameTask::syncFrameState</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;<br>    ATRACE_CALL();<br>    <span class="hljs-keyword">int64_t</span> vsync = mFrameInfo[<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(FrameInfoIndex::Vsync)];<br>    mRenderThread-&gt;timeLord().vsyncReceived(vsync);<br>    <span class="hljs-keyword">bool</span> canDraw = mContext-&gt;makeCurrent();<br>    mContext-&gt;unpinImages();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mLayers.size(); i++) &#123;<br>        mLayers[i]-&gt;apply();<br>    &#125;<br>    mLayers.clear();<br>    mContext-&gt;setContentDrawBounds(mContentDrawBounds);<br>  <br>    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="CanvasContext初始化"><a href="#CanvasContext初始化" class="headerlink" title="CanvasContext初始化"></a>CanvasContext初始化</h4><blockquote>
<p>CanvasContext是 渲染的上下文，可以选择不同的渲染模式。</p>
<p>目前分为三种:</p>
<ul>
<li>OpenGL</li>
<li>SkiaGL</li>
<li>SkiaVulkan</li>
</ul>
</blockquote>
<p>先分析<code>CanvasContext#create()</code>判断使用哪种渲染模式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">CanvasContext* <span class="hljs-title">CanvasContext::create</span><span class="hljs-params">(RenderThread&amp; thread, <span class="hljs-keyword">bool</span> translucent,<br>                                     RenderNode* rootRenderNode, IContextFactory* contextFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> renderType = Properties::getRenderPipelineType();<br><br>    <span class="hljs-keyword">switch</span> (renderType) &#123;<br>        <span class="hljs-keyword">case</span> RenderPipelineType::OpenGL:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,<br>                                     <span class="hljs-built_in">std</span>::make_unique&lt;OpenGLPipeline&gt;(thread));<br>        <span class="hljs-keyword">case</span> RenderPipelineType::SkiaGL:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,<br>                                     <span class="hljs-built_in">std</span>::make_unique&lt;skiapipeline::SkiaOpenGLPipeline&gt;(thread));<br>        <span class="hljs-keyword">case</span> RenderPipelineType::SkiaVulkan:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,<br>                                     <span class="hljs-built_in">std</span>::make_unique&lt;skiapipeline::SkiaVulkanPipeline&gt;(thread));<br>        <span class="hljs-keyword">default</span>:<br>            LOG_ALWAYS_FATAL(<span class="hljs-string">"canvas context type %d not supported"</span>, (<span class="hljs-keyword">int32_t</span>)renderType);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>就拿第一个<code>OpenGLPipeline</code>进行分析，其他的和他流程一致，不过绘制方式不同</p>
<h5 id="OpenGLPipeline"><a href="#OpenGLPipeline" class="headerlink" title="OpenGLPipeline"></a>OpenGLPipeline</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//libs/hwui/renderthread/OpenGLPipeline.cpp</span><br>OpenGLPipeline::OpenGLPipeline(RenderThread&amp; thread)<br>        : mEglManager(thread.eglManager()), mRenderThread(thread) &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>创建了<code>OpenGLPipeline</code>之后，对应的也创建了<code>EglManager</code>对象。</p>
<h5 id="EglManager"><a href="#EglManager" class="headerlink" title="EglManager"></a>EglManager</h5><blockquote>
<p>主要封装了 opengl相关的操作</p>
</blockquote>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EglManager::initialize</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (hasEglContext()) <span class="hljs-keyword">return</span>;<br><br>    ATRACE_NAME(<span class="hljs-string">"Creating EGLContext"</span>);<br><br>  <span class="hljs-comment">//获取EglDisplay对象</span><br>    mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);<br>    LOG_ALWAYS_FATAL_IF(mEglDisplay == EGL_NO_DISPLAY, <span class="hljs-string">"Failed to get EGL_DEFAULT_DISPLAY! err=%s"</span>,<br>                        eglErrorString());<br><br>    EGLint major, minor;<br>    initExtensions();<br><br>    <span class="hljs-comment">// Now that extensions are loaded, pick a swap behavior</span><br>    <span class="hljs-keyword">if</span> (Properties::enablePartialUpdates) &#123;<br>        <span class="hljs-comment">// An Adreno driver bug is causing rendering problems for SkiaGL with</span><br>        <span class="hljs-comment">// buffer age swap behavior (b/31957043).  To temporarily workaround,</span><br>        <span class="hljs-comment">// we will use preserved swap behavior.</span><br>        <span class="hljs-keyword">if</span> (Properties::useBufferAge &amp;&amp; EglExtensions.bufferAge) &#123;<br>            mSwapBehavior = SwapBehavior::BufferAge;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mSwapBehavior = SwapBehavior::Preserved;<br>        &#125;<br>    &#125;<br><br>    loadConfigs();<br>   <span class="hljs-comment">//创建egl上下文你</span><br>    createContext();<br>   <span class="hljs-comment">//创建离屏渲染Buffer</span><br>    createPBufferSurface();<br>    makeCurrent(mPBufferSurface);<br>    DeviceInfo::initialize();<br>    mRenderThread.renderState().onGLContextCreated();<br></code></pre></td></tr></table></figure>
<p>目前只是创建了<code>PBufferSurface</code>，在没有<code>WindowSurface</code>的时候是无法渲染显示在屏幕上的。</p>
<blockquote>
<p><code>PBufferSurface</code>：在显存中开辟一块空间，存放渲染后的数据。</p>
<p><code>WindowSurface</code>：在屏幕上的一块显示区域的封装，渲染后就显示在屏幕上</p>
</blockquote>
<h6 id="设置WindowSurface"><a href="#设置WindowSurface" class="headerlink" title="设置WindowSurface"></a>设置<code>WindowSurface</code></h6><blockquote>
<p>主要是在<code>ViewRootImpl#performTraversals()</code>进行设置的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;<br>      <br>      ...<br>                        <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span>) &#123;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                              <span class="hljs-comment">//初始化ThreadedRenderer 并赋值surface 用于绘制显示</span><br>                                hwInitialized = mAttachInfo.mThreadedRenderer.initialize(<br>                                        mSurface);<br>                                <span class="hljs-keyword">if</span> (hwInitialized &amp;&amp; (host.mPrivateFlags<br>                                        &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == <span class="hljs-number">0</span>) &#123;<br>                                    <span class="hljs-comment">// Don't pre-allocate if transparent regions</span><br>                                    <span class="hljs-comment">// are requested as they may not be needed</span><br>                                    mSurface.allocateBuffers();<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (OutOfResourcesException e) &#123;<br>                                handleOutOfResourcesException(e);<br>                                <span class="hljs-keyword">return</span>;<br>                            &#125;<br>                        &#125;      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>ThreadedRenderer#initalize</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Surface surface)</span> <span class="hljs-keyword">throws</span> OutOfResourcesException </span>&#123;<br>    <span class="hljs-keyword">boolean</span> status = !mInitialized;<br>    mInitialized = <span class="hljs-keyword">true</span>;<br>    updateEnabledState(surface);<br>  <br>    nInitialize(mNativeProxy, surface);<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>切换到Native层继续执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">android_view_ThreadedRenderer_initialize</span><span class="hljs-params">(JNIEnv* env, jobject clazz,<br>        jlong proxyPtr, jobject jsurface)</span> </span>&#123;<br>    RenderProxy* proxy = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);<br>    sp&lt;Surface&gt; surface = android_view_Surface_getSurface(env, jsurface);<br>    proxy-&gt;initialize(surface);<br>&#125;<br><br><span class="hljs-comment">//RenderProxy.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderProxy::initialize</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;Surface&gt;&amp; surface)</span> </span>&#123;<br>    mRenderThread.<span class="hljs-built_in">queue</span>().post(<br>            [ <span class="hljs-keyword">this</span>, surf = surface ]() <span class="hljs-keyword">mutable</span> &#123; mContext-&gt;setSurface(<span class="hljs-built_in">std</span>::move(surf)); &#125;);<br>&#125;<br><br><span class="hljs-comment">//CanvasContext.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CanvasContext::setSurface</span><span class="hljs-params">(sp&lt;Surface&gt;&amp;&amp; surface)</span> </span>&#123;<br>    ATRACE_CALL();<br><br>    mNativeSurface = <span class="hljs-built_in">std</span>::move(surface);<br><br>    ColorMode colorMode = mWideColorGamut ? ColorMode::WideColorGamut : ColorMode::Srgb;<br>    <span class="hljs-keyword">bool</span> hasSurface = mRenderPipeline-&gt;setSurface(mNativeSurface.get(), mSwapBehavior, colorMode);<br><br>    mFrameNumber = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (hasSurface) &#123;<br>        mHaveNewSurface = <span class="hljs-literal">true</span>;<br>        mSwapHistory.clear();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mRenderThread.removeFrameCallback(<span class="hljs-keyword">this</span>);<br>        mGenerationID++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此处的<code>mRenderPipeline</code>为上节的<code>OpenGLPipeline</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//libs/hwui/renderthread/OpenGLPipeline.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">OpenGLPipeline::setSurface</span><span class="hljs-params">(Surface* surface, SwapBehavior swapBehavior, ColorMode colorMode)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mEglSurface != EGL_NO_SURFACE) &#123;<br>        mEglManager.destroySurface(mEglSurface);<br>        mEglSurface = EGL_NO_SURFACE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (surface) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> wideColorGamut = colorMode == ColorMode::WideColorGamut;<br>        mEglSurface = mEglManager.createSurface(surface, wideColorGamut);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行到<code>createSurface()</code>创建<code>WindowSurface</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">EGLSurface <span class="hljs-title">EglManager::createSurface</span><span class="hljs-params">(EGLNativeWindowType window, <span class="hljs-keyword">bool</span> wideColorGamut)</span> </span>&#123;<br>  ...<br>    EGLSurface surface = eglCreateWindowSurface(<br>            mEglDisplay, wideColorGamut ? mEglConfigWideGamut : mEglConfig, window, attribs);<br>    <span class="hljs-keyword">return</span> surface;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到此创建<code>WindowSurface</code>完毕。</p>
<h4 id="CanvasContext-draw"><a href="#CanvasContext-draw" class="headerlink" title="CanvasContext#draw"></a>CanvasContext#draw</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CanvasContext::draw</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//开始绘制</span><br>    <span class="hljs-keyword">bool</span> drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,<br>                                      mContentDrawBounds, mOpaque, mWideColorGamut, mLightInfo,<br>                                      mRenderNodes, &amp;(profiler()));<br>  <br>  <span class="hljs-comment">//交换缓冲区</span><br>    <span class="hljs-keyword">bool</span> didSwap =<br>            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="OpenGLPipeline-draw"><a href="#OpenGLPipeline-draw" class="headerlink" title="OpenGLPipeline#draw"></a>OpenGLPipeline#draw</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">OpenGLPipeline::draw</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Frame&amp; frame, <span class="hljs-keyword">const</span> SkRect&amp; screenDirty, <span class="hljs-keyword">const</span> SkRect&amp; dirty,<br>                          <span class="hljs-keyword">const</span> FrameBuilder::LightGeometry&amp; lightGeometry,<br>                          LayerUpdateQueue* layerUpdateQueue, <span class="hljs-keyword">const</span> Rect&amp; contentDrawBounds,<br>                          <span class="hljs-keyword">bool</span> opaque, <span class="hljs-keyword">bool</span> wideColorGamut,<br>                          <span class="hljs-keyword">const</span> BakedOpRenderer::LightInfo&amp; lightInfo,<br>                          <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;sp&lt;RenderNode&gt;&gt;&amp; renderNodes,<br>                          FrameInfoVisualizer* profiler)</span> </span>&#123;<br>    mEglManager.damageFrame(frame, dirty);<br><br>    <span class="hljs-keyword">bool</span> drew = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">auto</span>&amp; caches = Caches::getInstance();<br>    <span class="hljs-function">FrameBuilder <span class="hljs-title">frameBuilder</span><span class="hljs-params">(dirty, frame.width(), frame.height(), lightGeometry, caches)</span></span>;<br><br>    frameBuilder.deferLayers(*layerUpdateQueue);<br>    layerUpdateQueue-&gt;clear();<br><br>    frameBuilder.deferRenderNodeScene(renderNodes, contentDrawBounds);<br><br>    <span class="hljs-function">BakedOpRenderer <span class="hljs-title">renderer</span><span class="hljs-params">(caches, mRenderThread.renderState(), opaque, wideColorGamut,<br>                             lightInfo)</span></span>;<br>    frameBuilder.replayBakedOps&lt;BakedOpDispatcher&gt;(renderer);<br>    <span class="hljs-function">ProfileRenderer <span class="hljs-title">profileRenderer</span><span class="hljs-params">(renderer)</span></span>;<br>    profiler-&gt;draw(profileRenderer);<br>  <span class="hljs-comment">//调用GPU进行渲染</span><br>    drew = renderer.didDraw();<br><br>    <span class="hljs-comment">// post frame cleanup</span><br>    caches.clearGarbage();<br>    caches.pathCache.trim();<br>    caches.tessellationCache.trim();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="OpenGLPipeline-swapBuffers"><a href="#OpenGLPipeline-swapBuffers" class="headerlink" title="OpenGLPipeline#swapBuffers"></a>OpenGLPipeline#swapBuffers</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">OpenGLPipeline::swapBuffers</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Frame&amp; frame, <span class="hljs-keyword">bool</span> drew, <span class="hljs-keyword">const</span> SkRect&amp; screenDirty,<br>                                 FrameInfo* currentFrameInfo, <span class="hljs-keyword">bool</span>* requireSwap)</span> </span>&#123;<br>    GL_CHECKPOINT(LOW);<br><br>    <span class="hljs-comment">// Even if we decided to cancel the frame, from the perspective of jank</span><br>    <span class="hljs-comment">// metrics the frame was swapped at this point</span><br>    currentFrameInfo-&gt;markSwapBuffers();<br><br>    *requireSwap = drew || mEglManager.damageRequiresSwap();<br><br>    <span class="hljs-keyword">if</span> (*requireSwap &amp;&amp; (CC_UNLIKELY(!mEglManager.swapBuffers(frame, screenDirty)))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> *requireSwap;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/CPU GPU通信模型" srcset="/img/loading.gif" alt="img"></p>
<p>根据图示渲染过程主要分为5阶段：</p>
<ol>
<li>UI线程创建OpenGL渲染需要的命令及数据——<code>构建DrawOp树</code></li>
<li>CPU将数据共享给GPU，使用<code>匿名共享内存</code></li>
<li>通知GPU渲染</li>
<li>swapBuffers，并通知<code>SurfaceFlinger</code>开始合成图层</li>
<li>SurfaceFlinger开始合成图层</li>
</ol>
<h3 id="硬件绘制流程"><a href="#硬件绘制流程" class="headerlink" title="硬件绘制流程"></a>硬件绘制流程</h3><p><img src="/images/硬件绘制流程.jpg" srcset="/img/loading.gif" alt="硬件绘制流程"></p>
<p>如上图所示：</p>
<blockquote>
<p>硬件绘制的流程，主要包含两个步骤：<strong>录制 、 回放</strong>。</p>
<p><code>录制</code>：需要View的<code>draw()</code>参与，需要记录View的绘制步骤，并编译为<strong>绘制指令</strong>(<code>drawOp</code>)</p>
<p><code>回放</code>：还原绘制内容，只需要还原<strong>绘制指令</strong>，而且这个绘制指令是可以修改的，修改的过程是不需要重新触发<code>draw()</code>。</p>
</blockquote>
<h3 id="硬件渲染过程"><a href="#硬件渲染过程" class="headerlink" title="硬件渲染过程"></a>硬件渲染过程</h3><p><img src="/images/RenderThread渲染过程.jpg" srcset="/img/loading.gif" alt="RenderThread渲染过程"></p>
<h2 id="软件绘制VS硬件绘制"><a href="#软件绘制VS硬件绘制" class="headerlink" title="软件绘制VS硬件绘制"></a>软件绘制VS硬件绘制</h2><table>
<thead>
<tr>
<th>渲染场景</th>
<th>软件绘制</th>
<th>硬件绘制</th>
<th>效果分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面初始化</td>
<td>绘制所有View</td>
<td>创建所有<code>DisplayList</code></td>
<td>GPU负责复杂的计算任务</td>
</tr>
<tr>
<td>调用背景透明TextView.setText()</td>
<td>重绘脏区所有View</td>
<td>TextView及每一级父View重建<code>DisplayList</code></td>
<td>重叠的兄弟节点不需要进行重绘，GPU会自行处理</td>
</tr>
<tr>
<td>TextView逐帧播放动画</td>
<td>每帧动画都要重绘脏区View</td>
<td>第一帧需要重建<code>DisplayList</code><br>后续只要更新对应的<code>DisplayList</code>即可</td>
<td>刷新每帧性能提升</td>
</tr>
<tr>
<td>修改TextView透明度</td>
<td>重绘脏区所有View</td>
<td>直接调用<code>RenderNode.setAlpha()</code>即可</td>
<td>只触发<code>DecorView.updateDisplayListIfDirty</code>，不再往下遍历</td>
</tr>
</tbody>
</table>
<h2 id="绘制缓存"><a href="#绘制缓存" class="headerlink" title="绘制缓存"></a>绘制缓存</h2><p><img src="/images/Android绘制-绘制缓存.png" srcset="/img/loading.gif" alt="绘制缓存"></p>
<blockquote>
<p>绘图缓存是指一个<code>Bitmap(软件绘制)</code>和<code>(硬件绘制)</code>，保存的是控件及其子控件的一个快照。</p>
<p>可以通过<code>View.setLayerType()</code>设置使用何种类型的缓存。</p>
<p><code>LAYER_TYPE_NONE</code>：视图正常渲染，不受屏幕外缓冲区支持。<strong>默认值</strong></p>
<p><code>LAYER_TYPE_SOFTWARE</code>：标识这个View有一个<code>Software Layer</code>，在一定条件下，会变成<code>bitmap</code>对象。</p>
<p><code>LAYER_TYPE_HARDWARE</code>：标识这个VIew有一个<code>Hardware Layer</code>，通过GPU来实现。依赖<code>硬件加速</code>实现，如果未开启<code>硬件加速</code>，按照<code>Software Layer</code>实现。</p>
</blockquote>
<h3 id="软件绘制缓存"><a href="#软件绘制缓存" class="headerlink" title="软件绘制缓存"></a>软件绘制缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;<br>     ...<br>        Bitmap cache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> layerType = getLayerType(); <span class="hljs-comment">// layerType默认为LAYER_TYPE_NONE</span><br>        <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123;<span class="hljs-comment">//软件绘制条件</span><br>             <span class="hljs-keyword">if</span> (layerType != LAYER_TYPE_NONE) &#123;<span class="hljs-comment">//必须设置 `LAYER_TYPE_SOFTWARE` 或 LAYER_TYPE_HARDWARE 缓存生效</span><br>                 <span class="hljs-comment">// If not drawing with RenderNode, treat HW layers as SW</span><br>                 layerType = LAYER_TYPE_SOFTWARE;<span class="hljs-comment">//设置 软件layer</span><br>                 buildDrawingCache(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//构建缓存</span><br>            &#125;<br>            cache = getDrawingCache(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildDrawingCache</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoScale)</span> </span>&#123;<br>       buildDrawingCacheImpl(autoScale);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildDrawingCacheImpl</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoScale)</span> </span>&#123;<br>     ...<br>       quality = Bitmap.Config.ARGB_8888;<span class="hljs-comment">//默认缓存bitmap图像类型</span><br>       bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(),<br>                        width, height, quality);<br>       bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);<br>       <span class="hljs-keyword">if</span> (autoScale) &#123;<br>          mDrawingCache = bitmap;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>          mUnscaledDrawingCache = bitmap;<br>       &#125;<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>要启用<code>软件绘制缓存</code>，必须调用<code>View.setLayerType()</code>设置<code>LAYER_TYPE_HARDDWARE、LAYER_TYPE_SOFTWARE</code>。通过<code>buildDrawingCache()</code>生成<code>绘制缓存</code>，对应会生成两个缓存对象：</p>
<ul>
<li><code>mDrawingCache</code>：根据兼容模式进行放大或缩小</li>
<li><code>mUnscaledDrawingCache</code>：反映了控件的真实尺寸，多用作控件截图。</li>
</ul>
<p>后续通过<code>getDrawingCache()</code>获取缓存内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;<br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> drawingWithDrawingCache = cache != <span class="hljs-keyword">null</span> &amp;&amp; !drawingWithRenderNode; <span class="hljs-comment">//是否使用缓存</span><br> ...<br> <span class="hljs-keyword">if</span>(!drawingWithDrawingCache) &#123;<span class="hljs-comment">//未使用缓存</span><br>    <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;<span class="hljs-comment">//硬件绘制</span><br>        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>        ((DisplayListCanvas) canvas).drawRenderNode(renderNode);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//软件绘制</span><br>        <span class="hljs-comment">// 需要回调到`onDraw()`</span><br>        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;<br>            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>            dispatchDraw(canvas);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            draw(canvas);<br>        &#125;<br>    &#125;<br> &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cache!=<span class="hljs-keyword">null</span>)&#123;<br>   canvas.drawBitmap(cache...)<span class="hljs-comment">//将缓存绘制于画布上</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="硬件绘制缓存"><a href="#硬件绘制缓存" class="headerlink" title="硬件绘制缓存"></a>硬件绘制缓存</h3><p><code>DisplayList</code>可以理解为缓存，开启<code>硬件加速</code>时，只要每次回放<code>DisplayList</code>即可。</p>
<h3 id="绘制缓存的开启原则"><a href="#绘制缓存的开启原则" class="headerlink" title="绘制缓存的开启原则"></a>绘制缓存的开启原则</h3><ul>
<li>不要为<code>十分轻量级的控件</code>启用绘制缓存。可能缓存绘制的开销 &gt; 控件重绘开销</li>
<li>为<code>很少发生内容改变的控件</code>启用绘制缓存。避免<code>invalidate()</code>时产生额外的缓存绘制操作</li>
<li>当父控件需要频繁改变子控件的位置或变换时对<code>子控件</code>启用绘制缓存，避免频繁重绘子控件。通过<code>ViewGroup.setChildrenDrawingWithCache()</code>启用子控件绘制缓存。</li>
</ul>
<h2 id="属性动画更新相关"><a href="#属性动画更新相关" class="headerlink" title="属性动画更新相关"></a>属性动画更新相关</h2><p><img src="/images/Android绘制-属性动画更新相关.png" srcset="/img/loading.gif" alt="Android绘制-属性动画更新相关"></p>
<p>在中讲到最后通过反射调用<code>View.setXX()</code>去执行动画。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//view.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScaleX</span><span class="hljs-params">(<span class="hljs-keyword">float</span> scaleX)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (scaleX != getScaleX()) &#123;<br>            scaleX = sanitizeFloatPropertyValue(scaleX, <span class="hljs-string">"scaleX"</span>);<br>            invalidateViewProperty(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>            mRenderNode.setScaleX(scaleX);<span class="hljs-comment">//更新对应View的displayList</span><br>            invalidateViewProperty(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br><br>            invalidateParentIfNeededAndWasQuickRejected();<br>            notifySubtreeAccessibilityStateChangedIfNeeded();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>关键在于<code>invalidateViewProperty()</code>调用界面刷新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidateViewProperty</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> invalidateParent, <span class="hljs-keyword">boolean</span> forceRedraw)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isHardwareAccelerated()<br>            || !mRenderNode.isValid()<br>            || (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//软件绘制</span><br>        <span class="hljs-keyword">if</span> (invalidateParent) &#123;<br>            invalidateParentCaches();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (forceRedraw) &#123;<br>            mPrivateFlags |= PFLAG_DRAWN; <span class="hljs-comment">// force another invalidation with the new orientation</span><br>        &#125;<br>        invalidate(<span class="hljs-keyword">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        damageInParent();<span class="hljs-comment">//硬件绘制</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">damageInParent</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo != <span class="hljs-keyword">null</span>) &#123;<br>        mParent.onDescendantInvalidated(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">//一层层向上层调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>mParent</code>一般指向<code>ViewGroup</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewGroup.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDescendantInvalidated</span><span class="hljs-params">(@NonNull View child, @NonNull View target)</span> </span>&#123;<br>      ...<br>        <span class="hljs-keyword">if</span> ((target.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// We lazily use PFLAG_DIRTY, since computing opaque isn't worth the potential</span><br>            <span class="hljs-comment">// optimization in provides in a DisplayList world.</span><br>            mPrivateFlags = (mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DIRTY;<br><br>            <span class="hljs-comment">// simplified invalidateChildInParent behavior: clear cache validity to be safe...</span><br>            <span class="hljs-comment">//标记缓存无效</span><br>            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;<br>        &#125;<br>      ...<br>        <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-comment">//继续向顶层View请求</span><br>            mParent.onDescendantInvalidated(<span class="hljs-keyword">this</span>, target);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>onDescendantInvalidated()</code>主要移除了<code>PFLAG_DRAWING_CACHE_VALID</code>标志</p>
<p>最顶层的View是<code>DecorView</code>，而<code>ViewRootImpl</code>就是<code>DecorView的parent</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDescendantInvalidated</span><span class="hljs-params">(@NonNull View child, @NonNull View descendant)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((descendant.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != <span class="hljs-number">0</span>) &#123;<br>            mIsAnimating = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        invalidate();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">()</span> </span>&#123;<br>        mDirty.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mWidth, mHeight);<br>        <span class="hljs-keyword">if</span> (!mWillDrawSoon) &#123;<br>            scheduleTraversals();<span class="hljs-comment">//开始执行绘制流程</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>总结：属性动画最后反射调用<code>View.setXX()</code>更新View属性时，调用到<code>invalidateViewProperty()</code>，主要实现的功能就是<code>移除PFLAG_DRAWING_CACHE_VALID</code>标志。在执行绘制过程中，在回到<code>View.updateDisplayListIfDirty()</code>时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RenderNode <span class="hljs-title">updateDisplayListIfDirty</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>     <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="hljs-number">0</span> <span class="hljs-comment">//满足该条件</span><br>               || !renderNode.isValid()<br>               || (mRecreateDisplayList)) &#123;<br>           <span class="hljs-comment">// Don't need to recreate the display list, just need to tell our</span><br>           <span class="hljs-comment">// children to restore/recreate theirs</span><br>           <span class="hljs-keyword">if</span> (renderNode.isValid()<br>                   &amp;&amp; !mRecreateDisplayList) &#123;<span class="hljs-comment">//未设置 PFLAG_INVALIDATED标志</span><br>               mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;<br>               mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>               dispatchGetDisplayList();<span class="hljs-comment">//只要刷新DisplayList</span><br><br>               <span class="hljs-keyword">return</span> renderNode; <span class="hljs-comment">// no work needed</span><br>           &#125;<br>       ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>在开启硬件加速的条件下，属性动画更新过程中不会回调<code>onDraw()</code></strong></p>
<h2 id="关键节点"><a href="#关键节点" class="headerlink" title="关键节点"></a>关键节点</h2><h3 id="DisplayList初始化"><a href="#DisplayList初始化" class="headerlink" title="DisplayList初始化"></a><code>DisplayList</code>初始化</h3><p><code>DisplayListCanvas.start()</code> -&gt; <code>DisplayListCanvas.obtain()</code>-&gt;<code>nCreateDisplayListCanvas</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//android_view_DisplayListCanvas.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="hljs-params">(jlong renderNodePtr,<br>        jint <span class="hljs-built_in">width</span>, jint <span class="hljs-built_in">height</span>)</span> </span>&#123;<br>    RenderNode* renderNode = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(Canvas::create_recording_canvas(<span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>, renderNode));<br>&#125;<br><br><span class="hljs-comment">//Canvas.cpp</span><br><span class="hljs-function">Canvas* <span class="hljs-title">Canvas::create_recording_canvas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-keyword">int</span> <span class="hljs-built_in">height</span>, uirenderer::RenderNode* renderNode)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (uirenderer::Properties::isSkiaEnabled()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uirenderer::RecordingCanvas(<span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>);<br>&#125;<br><br><span class="hljs-comment">//Properrties.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Properties::isSkiaEnabled</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> renderType = getRenderPipelineType();<span class="hljs-comment">//分为三种类型 SkiaGL SkiaVulkan OpenGL(默认)</span><br>    <span class="hljs-keyword">return</span> RenderPipelineType::SkiaGL == renderType || RenderPipelineType::SkiaVulkan == renderType;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//RecordingCanvas.cpp</span><br>RecordingCanvas::RecordingCanvas(<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">width</span>, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">height</span>)<br>        : mState(*<span class="hljs-keyword">this</span>), mResourceCache(ResourceCache::getInstance()) &#123;<br>    resetRecording(<span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RecordingCanvas::resetRecording</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-keyword">int</span> <span class="hljs-built_in">height</span>, RenderNode* node)</span> </span>&#123;<br>    LOG_ALWAYS_FATAL_IF(mDisplayList, <span class="hljs-string">"prepareDirty called a second time during a recording!"</span>);<br>    mDisplayList = <span class="hljs-keyword">new</span> DisplayList();<span class="hljs-comment">//初始化DisplayList</span><br><br>    mState.initializeRecordingSaveStack(<span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>);<br><br>    mDeferredBarrierType = DeferredBarrierType::InOrder;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="插入DrawOp到DisplayList"><a href="#插入DrawOp到DisplayList" class="headerlink" title="插入DrawOp到DisplayList"></a>插入DrawOp到DisplayList</h3><p><code>DisplayListCanvas</code>内部也包含了各种<code>drawXX()</code>，例如<code>drawLines()、drawText()</code>等。在调用这些方法后，会把对应的绘制操作转换为<code>drawOp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//DisplayListCanvas.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisplayListCanvas</span> <span class="hljs-title">extends</span> <span class="hljs-title">RecordingCanvas</span> &#123;</span><br> ...<br>   <span class="hljs-comment">//所有绘制方法由RecordCanvas实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(CanvasProperty&lt;Float&gt; cx, CanvasProperty&lt;Float&gt; cy,<br>            CanvasProperty&lt;Float&gt; radius, CanvasProperty&lt;Paint&gt; paint)</span> </span>&#123;<br>        nDrawCircle(mNativeCanvasWrapper, cx.getNativeContainer(), cy.getNativeContainer(),<br>                radius.getNativeContainer(), paint.getNativeContainer());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//RecordingCanvas.java</span><br>    @<span class="hljs-function">Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-keyword">float</span> startX, <span class="hljs-keyword">float</span> startY, <span class="hljs-keyword">float</span> stopX, <span class="hljs-keyword">float</span> stopY,<br>            @NonNull Paint paint)</span> </span>&#123;<br>        nDrawLine(mNativeCanvasWrapper, startX, startY, stopX, stopY, paint.getNativeInstance());<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>drawCircle()和drawRoundRect()</code>由<code>DisplayListCanvas</code>实现。其他的绘制方法交由<code>RecordingCanvas</code>实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//android_view_DisplayListCanvas.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">android_view_DisplayListCanvas_drawCircleProps</span><span class="hljs-params">(jlong canvasPtr,<br>        jlong xPropPtr, jlong yPropPtr, jlong radiusPropPtr, jlong paintPropPtr)</span> </span>&#123;<br>    Canvas* canvas = <span class="hljs-keyword">reinterpret_cast</span>&lt;Canvas*&gt;(canvasPtr);<br>    CanvasPropertyPrimitive* xProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(xPropPtr);<br>    CanvasPropertyPrimitive* yProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(yPropPtr);<br>    CanvasPropertyPrimitive* radiusProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(radiusPropPtr);<br>    CanvasPropertyPaint* paintProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPaint*&gt;(paintPropPtr);<br>    canvas-&gt;drawCircle(xProp, yProp, radiusProp, paintProp);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//RecordingCanvas.h</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-keyword">float</span> startX, <span class="hljs-keyword">float</span> startY, <span class="hljs-keyword">float</span> stopX, <span class="hljs-keyword">float</span> stopY,<br>                          <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">float</span> points[<span class="hljs-number">4</span>] = &#123;startX, startY, stopX, stopY&#125;;<br>        drawLines(points, <span class="hljs-number">4</span>, paint);<br>    &#125;<br><br><span class="hljs-comment">//RecordingCanvas.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RecordingCanvas::drawLines</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>* points, <span class="hljs-keyword">int</span> floatCount, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (CC_UNLIKELY(floatCount &lt; <span class="hljs-number">4</span> || paint.nothingToDraw())) <span class="hljs-keyword">return</span>;<br>    floatCount &amp;= ~<span class="hljs-number">0x3</span>;  <span class="hljs-comment">// round down to nearest four</span><br> <br>    addOp(alloc().create_trivial&lt;LinesOp&gt;(<br>            calcBoundsOfPoints(points, floatCount), *mState.currentSnapshot()-&gt;transform,<br>            getRecordedClip(), refPaint(&amp;paint), refBuffer&lt;<span class="hljs-keyword">float</span>&gt;(points, floatCount), floatCount));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>addOp()</code>将<code>DrawLine</code>的绘制操作缓存到<code>displayList</code>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><a href="/2018/12/14/View的工作原理/" title="View的绘制过程">View的绘制过程</a>
<p><a href="https://developer.android.com/guide/topics/graphics/hardware-accel?hl=zh-cn" target="_blank" rel="noopener">Android官方文档-硬件加速</a></p>
<p><a href="https://blog.csdn.net/Luoshengyang/article/details/45943255" target="_blank" rel="noopener">DisplayList构建过程分析</a></p>
<p><a href="https://tech.meituan.com/2017/01/19/hardware-accelerate.html" target="_blank" rel="noopener">Android硬件加速原理与实现简介</a></p>
<p><a href="https://www.jianshu.com/p/dd800800145b" target="_blank" rel="noopener">RenderThread与OpenGL GPU渲染</a></p>
<p><a href="https://www.androidperformance.com/2019/07/27/Android-Hardware-Layer/" target="_blank" rel="noopener">Android 中的 Hardware Layer 详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/62813895" target="_blank" rel="noopener">深入浅出Android BufferQueue</a></p>
<p><a href="https://www.jianshu.com/p/f808813880b0" target="_blank" rel="noopener">BufferQueue</a></p>
<!-- https://www.jianshu.com/p/abfaea892611 ， https://blog.csdn.net/jinzhuojun/article/details/54234354 https://www.jianshu.com/p/40f660e17a73 -->

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/10/31/Android-匿名共享内存-Ashmem/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android匿名共享内存-Ashmem</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/14/Android性能优化-LeakCanary/">
                        <span class="hidden-mobile">Android性能优化-LeakCanary</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
