

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
  <title>Android硬件加速 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.10","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android硬件加速">
              
                Android硬件加速
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-27 19:51" pubdate>
        2020年10月27日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      122
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android硬件加速</h1>
            
            <div class="markdown-body">
              <p><img src="/images/Android硬件加速.png" srcset="/img/loading.gif" lazyload="" alt="Android硬件加速xmind"></p>
<h2 id="软硬件绘制的分歧点"><a href="#软硬件绘制的分歧点" class="headerlink" title="软硬件绘制的分歧点"></a>软硬件绘制的分歧点</h2><p>绘制过程入口位于<code>ViewRootImpl.performDraw()</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">//viewRootImpl.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performDraw() &#123;<br>      ...<br>        <span class="hljs-keyword">try</span> &#123;<br>            //调用draw()执行实际的绘制工作<br>            <span class="hljs-keyword">boolean</span> canUseAsync = draw(fullRedrawNeeded);<br>            <span class="hljs-keyword">if</span> (usingAsyncReport &amp;&amp; !canUseAsync) &#123;<br>                mAttachInfo.mThreadedRenderer.setFrameCompleteCallback(<span class="hljs-keyword">null</span>);<br>                usingAsyncReport = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mIsDrawing = <span class="hljs-keyword">false</span>;<br>            Trace.traceEnd(Trace.TRACE_TAG_VIEW);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>ViewRootImpl.draw()</code>实际执行的绘制工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> draw(<span class="hljs-keyword">boolean</span> fullRedrawNeeded) &#123;<br>  ...<br>    <span class="hljs-keyword">final</span> Rect dirty = mDirty;//需要重新绘制的区域<br>  ...<br>    <span class="hljs-keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;<br>            //是否支持硬件加速<br>            <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;<br>              ...<br>                mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="hljs-keyword">this</span>, callback);//硬件绘制<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              ...<br>                //软件绘制<br>                <span class="hljs-keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,<br>                        scalingRequired, dirty, surfaceInsets)) &#123;<br>                    return <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>      ...<br>    &#125;<br>  ...<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h2><p><img src="/images/Android绘制-软件绘制.png" srcset="/img/loading.gif" lazyload="" alt="Android绘制-软件绘制"></p>
<h3 id="ViewRootImpl软件绘制相关"><a href="#ViewRootImpl软件绘制相关" class="headerlink" title="ViewRootImpl软件绘制相关"></a>ViewRootImpl软件绘制相关</h3><blockquote>
<p>未开启<code>硬件加速</code>时，执行到<code>drawSoftware()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> drawSoftware(Surface surface, AttachInfo attachInfo, <span class="hljs-keyword">int</span> xoff, <span class="hljs-keyword">int</span> yoff,<br>        <span class="hljs-keyword">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets) &#123;<br>    // Draw with software renderer.<br>    <span class="hljs-keyword">final</span> Canvas canvas;<br>  <br>   canvas = mSurface.lockCanvas(dirty);//获取用于绘制的Canvas<br>   ...<br>   mView.draw(canvas);//将mView的内容绘制到Canvas<br>   ...<br>   //将Canvas的内容显示到屏幕上,向SurfaceFlinger服务Queue一个Graphic Buffer<br>   surface.unlockCanvasAndPost(canvas);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此处的<code>mView</code>对应的就是<code>DecorView</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">//DecorView.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> draw(Canvas canvas) &#123;<br>        <span class="hljs-keyword">super</span>.draw(canvas);<br><br>        <span class="hljs-keyword">if</span> (mMenuBackground != <span class="hljs-keyword">null</span>) &#123;<br>            mMenuBackground.draw(canvas);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>执行到<code>super.draw()</code>，<code>DecorView</code>继承自<code>FrameLayout</code>，等价于执行到<code>ViewGroup.draw()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> draw(Canvas canvas) &#123;<br>      ...<br>        <span class="hljs-keyword">if</span> (!dirtyOpaque) &#123;<br>          //绘制背景<br>            drawBackground(canvas);<br>        &#125;<br>        //绘制自身<br>        <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);<br>        //绘制子View 只有ViewGroup会实现该方法<br>        dispatchDraw(canvas);<br>        //绘制前景<br>        onDrawForeground(canvas);<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewGroup.java<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> dispatchDraw(Canvas canvas) &#123;<br>      ...<br>        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties<br>                ? <span class="hljs-keyword">null</span> : buildOrderedChildList();//绘制顺序按照Z值从大到小排列<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = preorderedList == <span class="hljs-keyword">null</span><br>                &amp;&amp; isChildrenDrawingOrderEnabled();//允许自定义绘制顺序<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; childrenCount; i++) &#123;<br>            <span class="hljs-keyword">while</span> (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;<br>                <span class="hljs-keyword">final</span> View transientChild = mTransientViews.get(transientIndex);<br>                <span class="hljs-keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||<br>                        transientChild.getAnimation() != <span class="hljs-keyword">null</span>) &#123;<br>                    more |= drawChild(canvas, transientChild, drawingTime);<br>                &#125;<br>                transientIndex++;<br>                <span class="hljs-keyword">if</span> (transientIndex &gt;= transientCount) &#123;<br>                    transientIndex = -1;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);//根据自定义顺序获取当前绘制的View的绘制顺序<br>            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);<br>            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;<br>                more |= drawChild(canvas, child, drawingTime);<br>            &#125;<br>        &#125;<br>    &#125;<br>    //绘制子View<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> drawChild(Canvas canvas, View child, <span class="hljs-keyword">long</span> drawingTime) &#123;<br>        return child.draw(canvas, <span class="hljs-keyword">this</span>, drawingTime);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>DecorView</code>是最顶层的View，自<code>drawSoftware()</code>开始绘制。</p>
<h3 id="View软件绘制相关"><a href="#View软件绘制相关" class="headerlink" title="View软件绘制相关"></a>View软件绘制相关</h3><p>上一节后面执行到了<code>child.draw()</code>，<code>child</code>为<code>View</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br><span class="hljs-keyword">boolean</span> draw(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();<br>        //是否支持硬件绘制 显然当前情况不支持<br>        <span class="hljs-keyword">boolean</span> drawingWithRenderNode = mAttachInfo != <span class="hljs-keyword">null</span><br>                &amp;&amp; mAttachInfo.mHardwareAccelerated<br>                &amp;&amp; hardwareAcceleratedCanvas;<br>  <br>         ...<br>           //后续绘制缓存会分析<br>          <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123;<br>             <span class="hljs-keyword">if</span> (layerType != LAYER_TYPE_NONE) &#123;<br>                 // If not drawing with RenderNode, treat HW layers as SW<br>                 layerType = LAYER_TYPE_SOFTWARE;<br>                 buildDrawingCache(<span class="hljs-keyword">true</span>);<br>            &#125;<br>            cache = getDrawingCache(<span class="hljs-keyword">true</span>);<br>         &#125;<br>         //缓存可用 且 非硬件绘制条件下<br>         <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> drawingWithDrawingCache = cache != <span class="hljs-keyword">null</span> &amp;&amp; !drawingWithRenderNode;<br>         ...<br>         <span class="hljs-keyword">if</span> (!drawingWithDrawingCache) &#123;<br>            <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;<br>                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>                ((DisplayListCanvas) canvas).drawRenderNode(renderNode);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                // ViewGroup 不需要绘制背景直接 绘制子View<br>                <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;<br>                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>                    dispatchDraw(canvas);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    draw(canvas);<br>                &#125;<br>            &#125;<br>        &#125;<br>       ...<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>        <span class="hljs-keyword">if</span> ((changed &amp; DRAW_MASK) != 0) &#123;<br>            <span class="hljs-keyword">if</span> ((mViewFlags &amp; WILL_NOT_DRAW) != 0) &#123;<br>                <span class="hljs-keyword">if</span> (mBackground != <span class="hljs-keyword">null</span><br>                        || mDefaultFocusHighlight != <span class="hljs-keyword">null</span><br>                        || (mForegroundInfo != <span class="hljs-keyword">null</span> &amp;&amp; mForegroundInfo.mDrawable != <span class="hljs-keyword">null</span>)) &#123;<br>                    mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mPrivateFlags |= PFLAG_SKIP_DRAW;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;<br>            &#125;<br>            requestLayout();<br>            invalidate(<span class="hljs-keyword">true</span>);<br>        &#125;<br></code></pre></td></tr></table></figure>
<h3 id="软件绘制流程"><a href="#软件绘制流程" class="headerlink" title="软件绘制流程"></a>软件绘制流程</h3><p><img src="/images/软件绘制流程.jpg" srcset="/img/loading.gif" lazyload="" alt="软件绘制流程"></p>
<h3 id="Surface绘制流程"><a href="#Surface绘制流程" class="headerlink" title="Surface绘制流程"></a>Surface绘制流程</h3><p><img src="/images/软件绘制-Surface绘制过程.png" srcset="/img/loading.gif" lazyload="" alt="软件绘制-Surface绘制过程"></p>
<p>执行到<code>drawSoftware()</code>时，开始在<code>Surface</code>上进行绘制。</p>
<h4 id="申请GraphicBuffer"><a href="#申请GraphicBuffer" class="headerlink" title="申请GraphicBuffer"></a>申请<code>GraphicBuffer</code></h4><p>执行的是<code>mSurface.lockCanvas()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>canvas = mSurface.lockCanvas()<br>  <br>//Surface.java<br>    <span class="hljs-keyword">public</span> Canvas lockCanvas(Rect inOutDirty)<br>            <span class="hljs-keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException &#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            checkNotReleasedLocked();<br>            <span class="hljs-keyword">if</span> (mLockedObject != 0) &#123;<br>                // Ideally, nativeLockCanvas() would throw in <span class="hljs-keyword">this</span> situation and prevent the<br>                // <span class="hljs-keyword">double</span>-lock, but that won't happen <span class="hljs-keyword">if</span> mNativeObject was updated.  We can't<br>                // abandon the old mLockedObject because it might still be in use, so instead<br>                // we just refuse to re-lock the Surface.<br>                throw new IllegalArgumentException("Surface was already locked");<br>            &#125;<br>            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);<br>            return mCanvas;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>执行到<code>nativeLockCanvas()</code>进入JNI代码层</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">// core/jni/android_view_Surface.cpp<br><span class="hljs-keyword">static</span> jlong nativeLockCanvas(JNIEnv* env, jclass clazz,<br>        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) &#123;<br>    sp&lt;Surface&gt; surface(<span class="hljs-keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));<br>  ...<br>    //申请buffer<br>    ANativeWindow_Buffer outBuffer;<br>    status_t err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);<br>  ...<br>    //构建Bitmap对象<br>    SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,<br>                                         convertPixelFormat(outBuffer.format),<br>                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888<br>                                                 ? kOpaque_SkAlphaType : kPremul_SkAlphaType,<br>                                         GraphicsJNI::defaultColorSpace());<br><br>    SkBitmap bitmap;<br>    ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);<br>    bitmap.setInfo(info, bpr);<br>    <span class="hljs-keyword">if</span> (outBuffer.width &gt; 0 &amp;&amp; outBuffer.height &gt; 0) &#123;<br>        bitmap.setPixels(outBuffer.bits);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // be safe with an empty bitmap.<br>        bitmap.setPixels(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    //canvas设置bitmap<br>    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);<br>    nativeCanvas-&gt;setBitmap(bitmap);<br>    <br>    sp&lt;Surface&gt; lockedSurface(surface);<br>    lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);<br>    <span class="hljs-keyword">return</span> (jlong) lockedSurface.get();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建完<code>ANativeWindowBuffer</code>之后，需要与<code>surface</code>进行绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">//native/libs/gui/Surface.cpp<br>status_t Surface::lock(<br>        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)<br>&#123;<br>  ...<br>    ANativeWindowBuffer* out;<br>    <span class="hljs-keyword">int</span> fenceFd = -1;<br>    status_t err = dequeueBuffer(&amp;out, &amp;fenceFd);  <br>  ...<br>     <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>        sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));<br>        <span class="hljs-keyword">const</span> Rect bounds(backBuffer-&gt;width, backBuffer-&gt;height);<br>       ...<br>     &#125;<br>  //返回GraphicBuffer<br>     <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用到<code>lock()</code>之后，将<code>ANativeWindowBuffer</code>转化为<code>GraphicBuffer</code>。再通过<code>dequeueBuffer</code>分配内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++">//native/libs/gui/Surface.cpp<br><span class="hljs-keyword">int</span> Surface::dequeueBuffer(android_native_buffer_t** buffer, <span class="hljs-keyword">int</span>* fenceFd) &#123;<br>  ...<br>    FrameEventHistoryDelta frameTimestamps;<br>    status_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight,<br>                                                            reqFormat, reqUsage, &amp;mBufferAge,<br>                                                            enableFrameTimestamps ? &amp;frameTimestamps<br>                                                                                  : <span class="hljs-literal">nullptr</span>);    <br>  <br>  ...<br>    <span class="hljs-keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mReportRemovedBuffers &amp;&amp; (gbuf != <span class="hljs-literal">nullptr</span>)) &#123;<br>            mRemovedBuffers.push_back(gbuf);<br>        &#125;<br>      //<br>        result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);<br>        <span class="hljs-keyword">if</span> (result != NO_ERROR) &#123;<br>            ALOGE("dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d", result);<br>            mGraphicBufferProducer-&gt;cancelBuffer(buf, fence);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>  //获取buffer<br>     *buffer = gbuf.get();<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++">//native/libs/gui/BufferQueueProducer.cpp<br>status_t BufferQueueProducer::dequeueBuffer(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,<br>                                            uint32_t width, uint32_t height, PixelFormat format,<br>                                            uint64_t usage, uint64_t* outBufferAge,<br>                                            FrameEventHistoryDelta* outTimestamps) &#123;<br> ...<br>    <span class="hljs-keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;<br>      //找到可用的slot，并指定状态为FREE slot:BufferSlot——用来存储GraphicBuffer<br>            status_t status = waitForFreeSlotThenRelock(FreeSlotCaller::Dequeue,<br>                    &amp;found);<br>            <span class="hljs-keyword">if</span> (status != NO_ERROR) &#123;<br>                <span class="hljs-keyword">return</span> status;<br>            &#125;<br>      ...<br>    &#125;<br>          *outSlot = found;<br>        ATRACE_BUFFER_INDEX(found);<br><br>        attachedByConsumer = mSlots[found].mNeedsReallocation;<br>        mSlots[found].mNeedsReallocation = <span class="hljs-literal">false</span>;<br>       //转化可用slot的GraphicBuffer状态为DEQUEUED<br>        mSlots[found].mBufferState.dequeue();<br>  ...<br>      <span class="hljs-keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;<br>        BQ_LOGV("dequeueBuffer: allocating a <span class="hljs-keyword">new</span> buffer <span class="hljs-keyword">for</span> slot %d", *outSlot);<br>        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="hljs-keyword">new</span> GraphicBuffer(<br>                width, height, format, BQ_LAYER_COUNT, usage,<br>                &#123;mConsumerName.<span class="hljs-built_in">string</span>(), mConsumerName.size()&#125;);<br><br>        status_t error = graphicBuffer-&gt;initCheck();<br><br>            <span class="hljs-keyword">if</span> (error == NO_ERROR &amp;&amp; !mCore-&gt;mIsAbandoned) &#123;<br>                graphicBuffer-&gt;setGenerationNumber(mCore-&gt;mGenerationNumber);<br>              //对应outSlot申请GraphicBuffer<br>                mSlots[*outSlot].mGraphicBuffer = graphicBuffer;<br>            &#125;<br>  ...<br>&#125;<br>  <br>status_t BufferQueueProducer::waitForFreeSlotThenRelock(FreeSlotCaller caller,<br>        <span class="hljs-keyword">int</span>* found) <span class="hljs-keyword">const</span> &#123;<br>  ...<br>    //当前是否 队列太多<br>        <span class="hljs-keyword">bool</span> tooManyBuffers = mCore-&gt;mQueue.size()<br>                            &gt; <span class="hljs-keyword">static_cast</span>&lt;size_t&gt;(maxBufferCount);<br>        <span class="hljs-keyword">if</span> (tooManyBuffers) &#123;<br>            BQ_LOGV("%s: <span class="hljs-built_in">queue</span> size is %zu, waiting", callerString,<br>                    mCore-&gt;mQueue.size());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            // If in shared buffer mode <span class="hljs-keyword">and</span> a shared buffer exists, always<br>            // <span class="hljs-keyword">return</span> it.<br>            <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot !=<br>                    BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                *found = mCore-&gt;mSharedBufferSlot;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (caller == FreeSlotCaller::Dequeue) &#123;<br>                    // If we're calling <span class="hljs-keyword">this</span> from dequeue, prefer <span class="hljs-built_in">free</span> buffers<br>                  //寻找处于 FREE 状态的GraphicBuffer<br>                    <span class="hljs-keyword">int</span> slot = getFreeBufferLocked();<br>                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                        *found = slot;                      <br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCore-&gt;mAllowAllocation) &#123;<br>                        *found = getFreeSlotLocked();<br>                    &#125;                                    <br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    // If we're calling <span class="hljs-keyword">this</span> from attach, prefer <span class="hljs-built_in">free</span> slots<br>                    <span class="hljs-keyword">int</span> slot = getFreeSlotLocked();<br>                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                        *found = slot;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        *found = getFreeBufferLocked();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;    <br>  ...<br>        tryAgain = (*found == BufferQueueCore::INVALID_BUFFER_SLOT) ||<br>                   tooManyBuffers;<br>         <span class="hljs-keyword">if</span> (tryAgain) &#123;<br>           //找不到可用的slot或者buffer太多，需要等待空闲<br>         &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>BufferSlot</code>：用来存储<code>GraphicBuffer</code></p>
<p><code>waitForFreeSlotThenRelock()</code>返回可用的<code>slot</code>分为两种：</p>
<ul>
<li><code>getFreeBufferLocked()</code>：直接关联了<code>GraphicBuffer</code>，直接可用</li>
<li><code>getFreeSlotLocked()</code>：找到可用的<code>BufferSlot</code>，新建<code>GraphicBuffer</code>后，直接与其关联。</li>
</ul>
<p><code>lockCanvas()</code>最终通过<code>BufferQueueProducer.dequeueBuffer()</code>申请用来绘制的<code>GraphicBuffer</code></p>
<blockquote>
<p>尝试找到一个<code>BufferSlot</code>，并完成<code>GraphicBuffer</code>与<code>BufferSlot</code>的关联，途中切换<code>BufferSlot</code>状态<code>FREE-&gt;DEQUEUED</code>，最后返回对应的<code>BufferSlot</code>索引。</p>
</blockquote>
<h4 id="SurfaceFlinger消费GraphicBuffer"><a href="#SurfaceFlinger消费GraphicBuffer" class="headerlink" title="SurfaceFlinger消费GraphicBuffer"></a><code>SurfaceFlinger</code>消费<code>GraphicBuffer</code></h4><p>当<code>Cavans</code>绘制完毕后，调用<code>surface.unlockAndPostCanvas()</code>发送<code>GraphicBuffer</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">//Surface.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> unlockAndPostCanvas(Canvas canvas) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            checkNotReleasedLocked();<br><br>            <span class="hljs-keyword">if</span> (mHwuiContext != <span class="hljs-keyword">null</span>) &#123;<br>              //硬件绘制流程<br>                mHwuiContext.unlockAndPost(canvas);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              //软件绘制流程<br>                unlockSwCanvasAndPost(canvas);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> unlockSwCanvasAndPost(Canvas canvas) &#123;<br>      ... <br>        <span class="hljs-keyword">try</span> &#123;<br>            nativeUnlockCanvasAndPost(mLockedObject, canvas);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            nativeRelease(mLockedObject);<br>            mLockedObject = 0;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">// core/jni/android_view_Surface.cpp<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz,<br>        jlong nativeObject, jobject canvasObj) &#123;<br>  ...<br><br>    // 绘制完成后，将Canvas从surface上脱离<br>    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);<br>    nativeCanvas-&gt;setBitmap(SkBitmap());<br><br>    // unlock surface<br>    status_t err = surface-&gt;unlockAndPost();<br>    <span class="hljs-keyword">if</span> (err &lt; 0) &#123;<br>        doThrowIAE(env);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">//native/libs/gui/Surface.cpp<br>status_t Surface::unlockAndPost()<br>&#123;<br>  ...<br>    err = queueBuffer(mLockedBuffer.get(), fd);<br>    ALOGE_IF(err, "queueBuffer (handle=%p) failed (%s)",<br>            mLockedBuffer-&gt;handle, strerror(-err));<br><br>    mPostedBuffer = mLockedBuffer;<br>    mLockedBuffer = 0;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++">//native/libs/gui/Surface.cpp<br><span class="hljs-keyword">int</span> Surface::queueBuffer(android_native_buffer_t* buffer, <span class="hljs-keyword">int</span> fenceFd) &#123;<br>  ...<br>    //根据Buffer获取slot<br>    <span class="hljs-keyword">int</span> i = getSlotFromBufferLocked(buffer);<br>  ...<br>    //GraphicBufferQueue 插入 GraphicBuffer<br>    status_t err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);<br>  ...<br>    //插入Buffer后通知<br>    mQueueBufferCondition.broadcast();<br>&#125; <br><br>//根据传入buffer获取slot<br><span class="hljs-keyword">int</span> Surface::getSlotFromBufferLocked(<br>        android_native_buffer_t* buffer) <span class="hljs-keyword">const</span> &#123;<br>  //NUM_BUFFER_SLOTS 64<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; NUM_BUFFER_SLOTS; i++) &#123;<br>        <span class="hljs-keyword">if</span> (mSlots[i].buffer != <span class="hljs-literal">NULL</span> &amp;&amp;<br>                mSlots[i].buffer-&gt;handle == buffer-&gt;handle) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    ALOGE("getSlotFromBufferLocked: unknown buffer: %p", buffer-&gt;handle);<br>    <span class="hljs-keyword">return</span> BAD_VALUE;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java">//<span class="hljs-keyword">native</span>/libs/gui/BufferQueueProducer.cpp<br>status_t BufferQueueProducer::queueBuffer(<span class="hljs-keyword">int</span> slot,<br>        <span class="hljs-keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;<br>    BufferItem item;<br>  ...<br>    //判断slot 以及 buffer状态是否正常<br>        <span class="hljs-keyword">if</span> (slot &lt; 0 || slot &gt;= BufferQueueDefs::NUM_BUFFER_SLOTS) &#123;<br>            BQ_LOGE("queueBuffer: slot index %d out of range [0, %d)",<br>                    slot, BufferQueueDefs::NUM_BUFFER_SLOTS);<br>            return BAD_VALUE;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mSlots[slot].mBufferState.isDequeued()) &#123;<br>            BQ_LOGE("queueBuffer: slot %d is not owned by the producer "<br>                    "(state = %s)", slot, mSlots[slot].mBufferState.string());<br>            return BAD_VALUE;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mSlots[slot].mRequestBufferCalled) &#123;<br>            BQ_LOGE("queueBuffer: slot %d was queued without requesting "<br>                    "a buffer", slot);<br>            return BAD_VALUE;<br>        &#125;<br>  ...<br>    //构建BufferItem对象，等待传递<br>        item.mAcquireCalled = mSlots[slot].mAcquireCalled;<br>        item.mGraphicBuffer = mSlots[slot].mGraphicBuffer;<br>        item.mCrop = crop;<br>        item.mTransform = transform &amp;<br>                ~static_cast&lt;uint32_t&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);<br>        item.mTransformToDisplayInverse =<br>                (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != 0;<br>        item.mScalingMode = static_cast&lt;uint32_t&gt;(scalingMode);<br>        item.mTimestamp = requestedPresentTimestamp;<br>        item.mIsAutoTimestamp = isAutoTimestamp;<br>        item.mDataSpace = dataSpace;<br>        item.mHdrMetadata = hdrMetadata;<br>        item.mFrameNumber = currentFrameNumber;<br>        item.mSlot = slot;<br>        item.mFence = acquireFence;<br>        item.mFenceTime = acquireFenceTime;<br>        item.mIsDroppable = mCore-&gt;mAsyncMode ||<br>                mCore-&gt;mDequeueBufferCannotBlock ||<br>                (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == slot);<br>        item.mSurfaceDamage = surfaceDamage;<br>        item.mQueuedBuffer = <span class="hljs-keyword">true</span>;<br>        item.mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mAutoRefresh;<br>        item.mApi = mCore-&gt;mConnectedApi;<br>  <br>    //切换 BufferSlot状态到 QUEUED<br>        mSlots[slot].mFence = acquireFence;<br>        mSlots[slot].mBufferState.queue();<br>    //将item插入队列<br>        <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;<br>            mCore-&gt;mQueue.push_back(item);<br>            frameAvailableListener = mCore-&gt;mConsumerListener;          <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">const</span> BufferItem&amp; last = mCore-&gt;mQueue.itemAt(<br>                    mCore-&gt;mQueue.size() - 1);<br>            <span class="hljs-keyword">if</span> (last.mIsDroppable) &#123;<br>              ...<br>               mCore-&gt;mQueue.editItemAt(mCore-&gt;mQueue.size() - 1) = item;<br>               frameReplacedListener = mCore-&gt;mConsumerListener;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>               mCore-&gt;mQueue.push_back(item);<br>               frameAvailableListener = mCore-&gt;mConsumerListener;              <br>            &#125;<br>        &#125;<br>  ...<br>    //回调frameAvaliableListener 通知消费者有数据入队了<br>        <span class="hljs-keyword">if</span> (frameAvailableListener != NULL) &#123;<br>            frameAvailableListener-&gt;onFrameAvailable(item);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (frameReplacedListener != NULL) &#123;<br>            frameReplacedListener-&gt;onFrameReplaced(item);<br>        &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>//TODO 这里有个问题 如何和<code>BufferLayer</code>绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">//native/services/surfaceflinger/BufferLayer.cpp<br><span class="hljs-keyword">void</span> BufferQueueLayer::onFrameAvailable(<span class="hljs-keyword">const</span> BufferItem&amp; item) &#123;<br>  ...<br>   mFlinger-&gt;signalLayerUpdate();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">//SurfaceFlinger.cpp<br><span class="hljs-keyword">void</span> SurfaceFlinger::signalLayerUpdate() &#123;<br>    mScheduler-&gt;resetIdleTimer();<br>    mPowerAdvisor.notifyDisplayUpdateImminent();<br>    mEventQueue-&gt;invalidate();<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>unlockAndPost()</code>主要调用到<code>queueBuffer()</code>。</p>
<p>上节在<code>dequeueBuffer()</code>获取<code>slot</code>之后，就在对应的<code>slot</code>生成了<code>GraphicBuffer</code>。就可以继续Draw填充过程。</p>
<p>填充完成后，调用<code>queueBuffer()</code>根据<code>slot</code>获取对应的<code>GraphicBuffer</code>，封装成<code>BufferItem</code>对象，在回调<code>onFrameAvailable()</code>传入。通知<code>BufferQueueConsumer</code>有新数据传入。</p>
</blockquote>
<p><img src="/images/关系图.png" srcset="/img/loading.gif" lazyload="" alt="img"></p>
<h4 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h4><blockquote>
<p><strong>Android显示系统的核心</strong>。遵循<code>生产者-消费者</code>模型，只要往<code>BufferQueue</code>填充数据，就被认为是<code>生产者</code>。从<code>BufferQueue</code>获取数据，就被认为是<code>消费者</code>。</p>
<p><code>SurfaceFlinger</code>在合成并显示UI内容时，UI负责生产内容，<code>SurfaceFlinger</code>作为<code>消费者</code>消费内容。</p>
<p>在截屏时，<code>SurfaceFlinger</code>作为生产者，将当前的UI内容填充到另一个<code>BufferQueue</code>内，截屏作为<code>消费者</code>从<code>BufferQueue</code>获取数据</p>
</blockquote>
<p><img src="/images/v2-6a617ddb116d922b24f416582a5bf013_1440w.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p>
<p>如图所示执行步骤如下所示：</p>
<ol>
<li>初始化一个<code>BufferQueue</code></li>
<li><code>BufferQueueProducer</code>调用<code>dequeueBuffer</code>向<code>BufferQueue</code>申请一块空的<code>GRaphicBuffer</code></li>
<li>可以通过<code>requestBuffer</code>获取对应的<code>GraphicBuffer</code></li>
<li>向<code>GraphicBuffer</code>填充完数据后，调用<code>queueBuffer</code>向<code>BufferQueue</code>添加<code>GraphicBuffer</code></li>
<li>添加数据完成后，<code>BufferQueue</code>通过回调通知消费者，有新数据加入——<code>onFrameAvaliable()</code></li>
<li><code>BufferQueueConsumer</code>调用<code>acquireBuffer</code>从<code>BufferQueue</code>获取<code>GraphicBuffer</code></li>
<li>待<code>GraphicBuffer</code>使用完毕后，调用<code>releaseBuffer</code>将空的<code>GraphicBuffer</code>还给<code>BufferQueue</code>以便重复利用</li>
<li>空的数据返回后，<code>BufferQueue</code>通过回调通知生产者，有空闲数据。后续生产者可以继续获取空的<code>GraphicBuffer</code>进行使用——<code>onBufferReleased()</code></li>
<li>在<code>2~8</code>之间循环，形成一整套图形数据的生产-消费过程。</li>
</ol>
<h5 id="GraphicBuffer–BufferState"><a href="#GraphicBuffer–BufferState" class="headerlink" title="GraphicBuffer–BufferState"></a>GraphicBuffer–BufferState</h5><p>上面有提到，调用<code>dequeueBuffer()</code>需要获取空的<code>GraphicBuffer</code>，通过<code>getFreeBufferLocked()</code>寻找。</p>
<p>其中<code>GraphicBuffer</code>有以下几种状态(<code>BufferSlot.BufferState</code>)：</p>
<ul>
<li><code>FREE</code>：当前<code>GraphicBuffer</code>可用，且位于<code>BufferQueue</code>内</li>
<li><code>DEQUEUED</code>：当前<code>GraphicBuffer</code>被生产者获取了，该buffer当前属于生产者</li>
<li><code>QUEUED</code>：当前<code>GraphicBuffer</code>被生产者填充了数据，该buffer当前属于<code>BufferQueue</code></li>
<li><code>ACQUIRED</code>：当前<code>GraphicBuffer</code>被消费者获取了，该buffer当前属于消费者</li>
</ul>
<h2 id="硬件绘制"><a href="#硬件绘制" class="headerlink" title="硬件绘制"></a>硬件绘制</h2><blockquote>
<p>默认开启<code>硬件加速</code>，可以通过配置<code>android:hardwareAccelerated=&quot;false&quot;</code>关闭硬件加速</p>
<p><code>把View中绘制的计算工作交给GPU来处理，就是把drawXX()相关的方法进行转换。</code></p>
</blockquote>
<p><code>硬件绘制</code>主要包含两步：</p>
<ul>
<li><p><code>构建阶段</code></p>
<blockquote>
<p>遍历所有View，将需要绘制的操作缓存下来，构建<code>DisplayList</code>。交给<code>RenderThread</code>使用GPU进行硬件加速渲染。</p>
</blockquote>
</li>
<li><p><code>绘制阶段</code></p>
<blockquote>
<p>构建好的<code>DisplayList</code>交给<code>RenderThread</code>使用GPU进行硬件加速渲染，绘制的内容保存在<code>Graphic Buffer</code>并交由<code>SurfaceFlinger</code>显示。</p>
</blockquote>
</li>
</ul>
<h3 id="控制硬件加速"><a href="#控制硬件加速" class="headerlink" title="控制硬件加速"></a>控制硬件加速</h3><p><img src="/images/硬件绘制-控制硬件加速.png" srcset="/img/loading.gif" lazyload="" alt="硬件绘制-控制硬件加速"></p>
<blockquote>
<p>硬件绘制需要在<code>开启硬件加速</code>的条件下才可以执行</p>
</blockquote>
<p>可以在以下级别控制<code>硬件加速</code>：</p>
<ul>
<li><p><strong>应用</strong></p>
<p>在<code>AndroidManifest.xml</code>配置如下属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;application android:hardwareAccelerated="true" ...&gt;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>Activity</strong></p>
<p>在<code>AndroidManifest.xml</code>配置如下属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;application android:hardwareAccelerated="true"&gt;<br>      &lt;activity ... /&gt;<br>      &lt;activity android:hardwareAccelerated="false" /&gt; //控制某个Activity关闭硬件加速<br>  &lt;/application&gt;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>窗口Window</strong></p>
<p>配置如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">getWindow().setFlags(<br>    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,<br>    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>视图View</strong></p>
<p>为单个视图停用硬件加速</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myView.setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="DisplayList"><a href="#DisplayList" class="headerlink" title="DisplayList"></a>DisplayList</h3><p><img src="/images/硬件绘制-DisplayList.png" srcset="/img/loading.gif" lazyload="" alt="硬件绘制-DisplayList"></p>
<blockquote>
<p>本质上是一个<strong>缓冲区</strong>，里面<code>记录即将执行的绘制命令序列</code>。</p>
</blockquote>
<p><code>DisplayList</code>的存在有两个好处：</p>
<ol>
<li><p>在绘制下一帧时，若View没有发生变化，就不必执行相关绘制API，直接复用上次的<code>DisplayList</code>。</p>
</li>
<li><p>在绘制下一帧时，若View发生变化，但只是一些简单属性发生变化，就不需重建<code>DisplayList</code>，直接修改<code>DisplayList</code>相关属性即可。</p>
<p>针对以下属性，都不需重建<code>DisplayList</code></p>
<ul>
<li><code>alpha</code>：更改层的不透明度</li>
<li><code>x</code>、<code>y</code>、<code>translationX</code>、<code>translationY</code>：更改层的位置</li>
<li><code>scaleX</code>、<code>scaleY</code>：更改层的大小</li>
<li><code>rotation</code>、<code>rotationX</code>、<code>rotationY</code>：更改层在 3D 空间里的方向</li>
<li><code>pivotX</code>、<code>pivotY</code>：更改层的转换原点</li>
</ul>
</li>
</ol>
<p>以上在使用<code>DisplayList</code>的过程都不需要执行<code>onDraw()</code>。</p>
<p><img src="/images/DisplayList结构.png" srcset="/img/loading.gif" lazyload="" alt="img"></p>
<h3 id="RenderNode"><a href="#RenderNode" class="headerlink" title="RenderNode"></a>RenderNode</h3><blockquote>
<p>在Android 5.0后引入，是对<code>DisplayList</code>以及<code>View显示属性</code>的封装。</p>
</blockquote>
<p><strong>通常一个<code>RenderNode</code>对应一个<code>View</code>，包含了View自身及其子View的所有DisplayList。</strong></p>
<p>其中还有一个<code>RootRenderNode</code>，里面包含着<code>View层次结构中所有View的DisplayList信息</code>。</p>
<h3 id="ViewRootImpl硬件绘制相关"><a href="#ViewRootImpl硬件绘制相关" class="headerlink" title="ViewRootImpl硬件绘制相关"></a>ViewRootImpl硬件绘制相关</h3><blockquote>
<p>只有当前View支持<code>硬件加速</code>时，才可以进入<code>硬件绘制</code></p>
<p><code>if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled())</code></p>
</blockquote>
<p><img src="/images/硬件绘制-构建DisplayList.png" srcset="/img/loading.gif" lazyload="" alt="硬件绘制-构建DisplayList"></p>
<h4 id="ThreadedRenderer-draw"><a href="#ThreadedRenderer-draw" class="headerlink" title="ThreadedRenderer.draw()"></a>ThreadedRenderer.draw()</h4><blockquote>
<p><code>ThreadedRenderer</code>在UI线程创建，主要执行了两步：</p>
<ul>
<li>构建View的DrawOp树，就是<code>DisplayList</code>。<code>DrawOp 表示 Drawing Operations</code></li>
<li>与渲染线程(<code>RenderThread</code>)进行通信</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">//ThreadedRenderer.java<br>  <span class="hljs-keyword">void</span> draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks,<br>          FrameDrawingCallback frameDrawingCallback) &#123;<br>      attachInfo.mIgnoreDirtyState = <span class="hljs-keyword">true</span>;<br><br>      <span class="hljs-keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;<br>      choreographer.mFrameInfo.markDrawStart();<br>      //构建View的DrawOp树<br>      updateRootDisplayList(view, callbacks);<br><br>      ...<br>      <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] frameInfo = choreographer.mFrameInfo.mFrameInfo;<br>      <span class="hljs-keyword">if</span> (frameDrawingCallback != <span class="hljs-keyword">null</span>) &#123;<br>          nSetFrameCallback(mNativeProxy, frameDrawingCallback);<br>      &#125;<br>      //通知RenderThread线程绘制<br>      <span class="hljs-keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);<br>      ...<br>  &#125;<br></code></pre></td></tr></table></figure>
<h4 id="updateRootDisplayList"><a href="#updateRootDisplayList" class="headerlink" title="updateRootDisplayList()"></a>updateRootDisplayList()</h4><blockquote>
<p>构建<code>DrawOp</code>树，构建<code>RootDisplayList</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> updateRootDisplayList(View view, DrawCallbacks callbacks) &#123;<br>   //更新View的displayList<br>    updateViewTreeDisplayList(view);<br><br>    <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;<br>       //获取DisplayCanvas<br>        DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> saveCount = canvas.save();<br>            canvas.translate(mInsetLeft, mInsetTop);<br>            callbacks.onPreDraw(canvas);<br><br>            canvas.insertReorderBarrier();<br>           //displayListCanvas缓存View对应的drawOp节点<br>            canvas.drawRenderNode(view.updateDisplayListIfDirty());<br>            canvas.insertInorderBarrier();<br><br>            callbacks.onPostDraw(canvas);<br>            canvas.restoreToCount(saveCount);<br>            mRootNodeNeedsUpdate = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>           //RootRenderNode填充所有节点<br>            mRootNode.end(canvas);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> updateViewTreeDisplayList(View view) &#123;<br>    view.mPrivateFlags |= View.PFLAG_DRAWN;<br>    view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)//invalidate()对应标记<br>            == View.PFLAG_INVALIDATED;//初始DecorView默认为 <span class="hljs-keyword">true</span><br>    view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;<br>    view.updateDisplayListIfDirty();//更新节点<br>    view.mRecreateDisplayList = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="DecorView-updateDisplayListIfDirty"><a href="#DecorView-updateDisplayListIfDirty" class="headerlink" title="DecorView.updateDisplayListIfDirty()"></a>DecorView.updateDisplayListIfDirty()</h4><blockquote>
<p><code>updateRootDisplayList()</code>中对应的View就是<code>DecorView</code>，是所有View的顶层。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>@NonNull<br>    <span class="hljs-keyword">public</span> RenderNode updateDisplayListIfDirty() &#123;<br>      ...<br>        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0<br>                || !renderNode.isValid()<br>                || (mRecreateDisplayList)) &#123;<br>          ...<br>          <span class="hljs-keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);<br>          <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;//是否强制软件绘制<br>                    buildDrawingCache(<span class="hljs-keyword">true</span>);<br>                    Bitmap cache = getDrawingCache(<span class="hljs-keyword">true</span>);//获取绘制缓存<br>                    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;//缓存有效，复用缓存<br>                        canvas.drawBitmap(cache, 0, 0, mLayerPaint);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    // Fast path <span class="hljs-keyword">for</span> layouts with no backgrounds<br>                    //ViewGroup不需要绘制，直接调用dispatchDraw<br>                    <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;<br>                        dispatchDraw(canvas);<br>                        drawAutofilledHighlight(canvas);<br>                         ...<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                      //ViewGroup(需要绘制) / View 直接调用draw<br>                        draw(canvas);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               //缓存构建完成，放入渲染节点<br>                renderNode.end(canvas);<br>                setDisplayListProperties(renderNode);<br>            &#125;<br>          <br>        &#125;<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>DecorView</code>执行<code>updateDisplayListIfDirty()</code>，调用到<code>draw(Canvas)</code>，然后向下递归调用到<code>child.draw()</code></p>
<p><code>updateRootDisplayList()</code>主要执行以下几步：</p>
<ul>
<li>更新<code>DecorView</code>操作缓存(DisplayList)——<code>updateViewTreeDisplayList(decorView)</code></li>
<li>利用<code>DisplayCanvas</code>构建并缓存所有的<code>DrawOp(View的绘制操作)</code>——<code>mRootNode.start()</code></li>
<li>将<code>DisplayListCanvas</code>缓存的<code>DrawOp</code>填充到<code>RenderNode(View)</code>——<code>View.updateDisplayListIfDirty()</code></li>
<li>将<code>DecorView</code>的缓存<code>DrawOp</code>填充到<code>RootRenderNode</code>中——<code>mRootNode.end()</code></li>
</ul>
<p><img src="/images/硬件绘制-updateDisplayListIfDirty.png" srcset="/img/loading.gif" lazyload="" alt="硬件绘制-updateDisplayListIfDirty()"></p>
<h3 id="View硬件绘制相关"><a href="#View硬件绘制相关" class="headerlink" title="View硬件绘制相关"></a>View硬件绘制相关</h3><p>上一节中，通过<code>DecorView</code>递归调用<code>子View.updateDisplayListIfDirty()</code>不断填充<code>DisplayList</code>到对应View的<code>RenderNode</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br><span class="hljs-keyword">public</span> View(Context context) &#123;<br>  ...<br>     //初始化渲染节点<br>     mRenderNode = RenderNode.create(getClass().getName(), new ViewAnimationHostBridge(<span class="hljs-keyword">this</span>));<br>  ...<br>&#125;<br><br>    <span class="hljs-keyword">boolean</span> draw(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime) &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();<br><br>        <span class="hljs-keyword">boolean</span> drawingWithRenderNode = mAttachInfo != <span class="hljs-keyword">null</span><br>                &amp;&amp; mAttachInfo.mHardwareAccelerated<br>                &amp;&amp; hardwareAcceleratedCanvas;<br>        ...<br>        <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;<br>           //继续执行到updateDisplayListIfDirty<br>            renderNode = updateDisplayListIfDirty();<br>            <span class="hljs-keyword">if</span> (!renderNode.isValid()) &#123;<br>                renderNode = <span class="hljs-keyword">null</span>;<br>                drawingWithRenderNode = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> RenderNode updateDisplayListIfDirty() &#123;<br>        <span class="hljs-keyword">final</span> RenderNode renderNode = mRenderNode;<br>        <span class="hljs-keyword">if</span> (!canHaveDisplayList()) &#123;<br>            // can't populate RenderNode, don't <span class="hljs-keyword">try</span><br>            return renderNode;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0 //绘制缓存无效<br>                || !renderNode.isValid() //渲染节点没有DisplayList<br>                || (mRecreateDisplayList)) &#123; //需要刷新DisplayList<br>            // Don't need to recreate the display list, just need to tell our<br>            // children to restore/recreate theirs<br>            <span class="hljs-keyword">if</span> (renderNode.isValid() //只要draw过一次后，一直返回<span class="hljs-keyword">true</span><br>                    &amp;&amp; !mRecreateDisplayList) &#123;//调用一些只需要displayList属性修改的方法<br>                //不需要重建 DisplayList<br>                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;<br>                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>                dispatchGetDisplayList();<br><br>                return renderNode; // no work needed<br>            &#125;<br><br>            // If we got here, we're recreating it. Mark it as such to ensure that<br>            // we copy in child display lists into ours in drawChild()<br>            mRecreateDisplayList = <span class="hljs-keyword">true</span>;<br><br>            <span class="hljs-keyword">int</span> width = mRight - mLeft;<br>            <span class="hljs-keyword">int</span> height = mBottom - mTop;<br>            <span class="hljs-keyword">int</span> layerType = getLayerType();<br>           //获取DisplayListCanvas<br>            <span class="hljs-keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;//软件绘制，绘制缓存存在直接复用<br>                    buildDrawingCache(<span class="hljs-keyword">true</span>);<br>                    Bitmap cache = getDrawingCache(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;<br>                        canvas.drawBitmap(cache, 0, 0, mLayerPaint);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    computeScroll();<br><br>                    canvas.translate(-mScrollX, -mScrollY);<br>                    //添加 缓存有效标记<br>                    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;<br>                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br><br>                    //ViewGroup不需要绘制，直接调用dispatchDraw<br>                    <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;<br>                        dispatchDraw(canvas);<br>                        drawAutofilledHighlight(canvas);<br>                         ...<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                      //ViewGroup(需要绘制) / View 直接调用draw<br>                        draw(canvas);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               //RenderNode 收集DisplayList<br>                renderNode.end(canvas);<br>                setDisplayListProperties(renderNode);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;<br>            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>        &#125;<br>        return renderNode;<br>    &#125;<br><br>    //是否会有DisplayList = 是否开启硬件加速<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> canHaveDisplayList() &#123;<br>        return !(mAttachInfo == <span class="hljs-keyword">null</span> || mAttachInfo.mThreadedRenderer == <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    //只有flag标记为 PFLAG_INVALIDATED ，调用需要 重建DisplayList<br>    mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != 0;<br></code></pre></td></tr></table></figure>
<p>根据上述源码可判断<code>View需要重新构建DisplayList(执行draw())</code>有以下条件：</p>
<ol>
<li><p><code>(mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0</code>当前View绘制缓存无效</p>
<p><strong>mPrivateFlags没有<code>PFLAG_DRAWING_CACHE_VALID</code>标记</strong></p>
</li>
<li><p><code>renderNode.isValid()==false</code> View对应的<code>DisplayList</code>尚未构建或者被销毁</p>
<p><strong>只要View绘制过一次，就会一直返回true。除非<code>detached</code></strong></p>
</li>
<li><p><code>mRecreateDisplayList==true</code> View需要重新构建<code>DisplayList</code></p>
<p><strong>mPrivateFlags持有<code>PFLAG_INVALIDATED</code>标记</strong></p>
</li>
</ol>
<p>能满足以上条件的就是调用<code>View.invalidate()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> invalidate() &#123;<br>        invalidate(<span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> invalidate(<span class="hljs-keyword">boolean</span> invalidateCache) &#123;<br>        invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> invalidateInternal(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">boolean</span> invalidateCache,<br>            <span class="hljs-keyword">boolean</span> fullInvalidate) &#123;<br>      ...<br>            <span class="hljs-keyword">if</span> (invalidateCache) &#123;<br>                mPrivateFlags |= PFLAG_INVALIDATED; //添加PFLAG_INVALIDATED标志<br>                mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;//移除PFLAG_DRAWING_CACHE_VALID标志<br>            &#125;<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="dispatchGetDisplayList"><a href="#dispatchGetDisplayList" class="headerlink" title="dispatchGetDisplayList()"></a>dispatchGetDisplayList()</h4><p>只会在不重建<code>DisplayList</code>情况下调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>// 只会在ViewGroup下实现，更新子View的DisplayList<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> dispatchGetDisplayList() &#123;&#125;<br><br><br>//ViewGroup.java<br>    @Override<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> dispatchGetDisplayList() &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mChildrenCount;<br>        <span class="hljs-keyword">final</span> View[] children = mChildren;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; count; i++) &#123;<br>            <span class="hljs-keyword">final</span> View child = children[i];<br>           //View可见 || 设置动画<br>            <span class="hljs-keyword">if</span> (((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>)) &#123;<br>                recreateChildDisplayList(child);//调用子<br>            &#125;<br>        &#125;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> recreateChildDisplayList(View child) &#123;<br>        child.mRecreateDisplayList = (child.mPrivateFlags &amp; PFLAG_INVALIDATED) != 0;//没有PFLAG_INVALIDATED 返回<span class="hljs-keyword">true</span><br>        child.mPrivateFlags &amp;= ~PFLAG_INVALIDATED; //移除 PFLAG_INVALIDATED标志<br>        child.updateDisplayListIfDirty();<br>        child.mRecreateDisplayList = <span class="hljs-keyword">false</span>; //执行完后 重置状态<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="RenderThread渲染UI"><a href="#RenderThread渲染UI" class="headerlink" title="RenderThread渲染UI"></a>RenderThread渲染UI</h3><p>构建完<code>RootRenderNode</code>的<code>DisplayList——DrawOp树</code>之后，就需要准备渲染。<em>利用GPU将DisplayList绘制到屏幕上</em>。</p>
<h4 id="ThreadedRenderer-nSyncAndFrame"><a href="#ThreadedRenderer-nSyncAndFrame" class="headerlink" title="ThreadedRenderer#nSyncAndFrame"></a>ThreadedRenderer#nSyncAndFrame</h4><p>构建DisplayList完毕后，向下执行到<code>nSyncAndDrawFrame()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">//ThreadedRenderer.java<br>    <span class="hljs-keyword">void</span> draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks,<br>            FrameDrawingCallback frameDrawingCallback) &#123;<br>      ...<br>        //构建DisplayList<br>        updateRootDisplayList(view, callbacks);<br>      ...<br>      //开始绘制DisplayList<br>        <span class="hljs-keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> nSyncAndDrawFrame(<span class="hljs-keyword">long</span> nativeProxy, <span class="hljs-keyword">long</span>[] frameInfo, <span class="hljs-keyword">int</span> size);<br></code></pre></td></tr></table></figure>
<p><code>nSyncAndDrawFrame()</code>切换到<code>Native</code>层执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//core/jni/android_view_ThreadedRenderer.cpp<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> android_view_ThreadedRenderer_syncAndDrawFrame(JNIEnv* env, jobject clazz,<br>        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize) &#123;<br>    LOG_ALWAYS_FATAL_IF(frameInfoSize != UI_THREAD_FRAME_INFO_SIZE,<br>            "Mismatched size expectations, given %d expected %d",<br>            frameInfoSize, UI_THREAD_FRAME_INFO_SIZE);<br>    RenderProxy* proxy = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);<br>    env-&gt;GetLongArrayRegion(frameInfo, 0, frameInfoSize, proxy-&gt;frameInfo());<br>    <span class="hljs-keyword">return</span> proxy-&gt;syncAndDrawFrame();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>RenderProxy</code>继续执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//libs/hwui/renderthread/RenderProxy.cpp<br><span class="hljs-keyword">int</span> RenderProxy::syncAndDrawFrame() &#123;<br>    <span class="hljs-keyword">return</span> mDrawFrameTask.drawFrame();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="DrawFrameTask-drawFrame"><a href="#DrawFrameTask-drawFrame" class="headerlink" title="DrawFrameTask#drawFrame()"></a>DrawFrameTask#drawFrame()</h4><p>调用了<code>DrawFrameTask#drawFrame()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//libs/hwui/renderthread/DrawFrameTask.cpp<br><span class="hljs-keyword">int</span> DrawFrameTask::drawFrame() &#123;<br>    LOG_ALWAYS_FATAL_IF(!mContext, "Cannot drawFrame with no CanvasContext!");<br><br>    mSyncResult = SyncResult::OK;<br>    mSyncQueued = systemTime(CLOCK_MONOTONIC);<br>    postAndWait();<br><br>    <span class="hljs-keyword">return</span> mSyncResult;<br>&#125;<br><br><span class="hljs-keyword">void</span> DrawFrameTask::postAndWait() &#123;<br>    AutoMutex _lock(mLock);<br>    mRenderThread-&gt;<span class="hljs-built_in">queue</span>().post([<span class="hljs-keyword">this</span>]() &#123; run(); &#125;);<br>    mSignal.wait(mLock);<br>&#125;<br><br><span class="hljs-keyword">void</span> DrawFrameTask::run() &#123;<br>    ATRACE_NAME("DrawFrame");<br><br>    <span class="hljs-keyword">bool</span> canUnblockUiThread;<br>    <span class="hljs-keyword">bool</span> canDrawThisFrame;<br>    &#123;<br>        TreeInfo info(TreeInfo::MODE_FULL, *mContext);<br>      //同步帧状态<br>        canUnblockUiThread = syncFrameState(info);<br>        canDrawThisFrame = info.out.canDrawThisFrame;<br><br>        <span class="hljs-keyword">if</span> (mFrameCompleteCallback) &#123;<br>            mContext-&gt;addFrameCompleteListener(<span class="hljs-built_in">std</span>::move(mFrameCompleteCallback));<br>            mFrameCompleteCallback = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    // Grab a copy of everything we need<br>    CanvasContext* context = mContext;<br>    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(int64_t)&gt; callback = <span class="hljs-built_in">std</span>::move(mFrameCallback);<br>    mFrameCallback = <span class="hljs-literal">nullptr</span>;<br><br>    // From <span class="hljs-keyword">this</span> point on anything in "<span class="hljs-keyword">this</span>" is *UNSAFE TO ACCESS*<br>    <span class="hljs-keyword">if</span> (canUnblockUiThread) &#123;<br>        unblockUiThread();<br>    &#125;<br><br>    // Even <span class="hljs-keyword">if</span> we aren't drawing <span class="hljs-keyword">this</span> vsync pulse the next frame number will still be accurate<br>    <span class="hljs-keyword">if</span> (CC_UNLIKELY(callback)) &#123;<br>        context-&gt;enqueueFrameWork([callback, frameNr = context-&gt;getFrameNumber()]() &#123;<br>            callback(frameNr);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;<br>      //执行绘制流程<br>        context-&gt;draw();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // wait on fences so tasks don't overlap next frame<br>        context-&gt;waitOnFences();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!canUnblockUiThread) &#123;<br>        unblockUiThread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要执行过程为两步：</p>
<ul>
<li>调用<code>syncFrameState()</code>同步Frame信息</li>
<li>调用<code>CanvasContext.draw()</code>开始绘制</li>
</ul>
<h5 id="syncFrameState"><a href="#syncFrameState" class="headerlink" title="syncFrameState"></a>syncFrameState</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> DrawFrameTask::syncFrameState(TreeInfo&amp; info) &#123;<br>    ATRACE_CALL();<br>    int64_t vsync = mFrameInfo[<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(FrameInfoIndex::Vsync)];<br>    mRenderThread-&gt;timeLord().vsyncReceived(vsync);<br>    <span class="hljs-keyword">bool</span> canDraw = mContext-&gt;makeCurrent();<br>    mContext-&gt;unpinImages();<br><br>    <span class="hljs-keyword">for</span> (size_t i = 0; i &lt; mLayers.size(); i++) &#123;<br>        mLayers[i]-&gt;apply();<br>    &#125;<br>    mLayers.clear();<br>    mContext-&gt;setContentDrawBounds(mContentDrawBounds);<br>  <br>    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="CanvasContext初始化"><a href="#CanvasContext初始化" class="headerlink" title="CanvasContext初始化"></a>CanvasContext初始化</h4><blockquote>
<p>CanvasContext是 渲染的上下文，可以选择不同的渲染模式。</p>
<p>目前分为三种:</p>
<ul>
<li>OpenGL</li>
<li>SkiaGL</li>
<li>SkiaVulkan</li>
</ul>
</blockquote>
<p>先分析<code>CanvasContext#create()</code>判断使用哪种渲染模式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CanvasContext* CanvasContext::create(RenderThread&amp; thread, <span class="hljs-keyword">bool</span> translucent,<br>                                     RenderNode* rootRenderNode, IContextFactory* contextFactory) &#123;<br>    <span class="hljs-keyword">auto</span> renderType = Properties::getRenderPipelineType();<br><br>    <span class="hljs-keyword">switch</span> (renderType) &#123;<br>        <span class="hljs-keyword">case</span> RenderPipelineType::OpenGL:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,<br>                                     <span class="hljs-built_in">std</span>::make_unique&lt;OpenGLPipeline&gt;(thread));<br>        <span class="hljs-keyword">case</span> RenderPipelineType::SkiaGL:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,<br>                                     <span class="hljs-built_in">std</span>::make_unique&lt;skiapipeline::SkiaOpenGLPipeline&gt;(thread));<br>        <span class="hljs-keyword">case</span> RenderPipelineType::SkiaVulkan:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,<br>                                     <span class="hljs-built_in">std</span>::make_unique&lt;skiapipeline::SkiaVulkanPipeline&gt;(thread));<br>        <span class="hljs-keyword">default</span>:<br>            LOG_ALWAYS_FATAL("canvas context type %d <span class="hljs-keyword">not</span> supported", (int32_t)renderType);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>就拿第一个<code>OpenGLPipeline</code>进行分析，其他的和他流程一致，不过绘制方式不同</p>
<h5 id="OpenGLPipeline"><a href="#OpenGLPipeline" class="headerlink" title="OpenGLPipeline"></a>OpenGLPipeline</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//libs/hwui/renderthread/OpenGLPipeline.cpp<br>OpenGLPipeline::OpenGLPipeline(RenderThread&amp; thread)<br>        : mEglManager(thread.eglManager()), mRenderThread(thread) &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>创建了<code>OpenGLPipeline</code>之后，对应的也创建了<code>EglManager</code>对象。</p>
<h5 id="EglManager"><a href="#EglManager" class="headerlink" title="EglManager"></a>EglManager</h5><blockquote>
<p>主要封装了 opengl相关的操作</p>
</blockquote>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> EglManager::initialize() &#123;<br>    <span class="hljs-keyword">if</span> (hasEglContext()) <span class="hljs-keyword">return</span>;<br><br>    ATRACE_NAME("Creating EGLContext");<br><br>  //获取EglDisplay对象<br>    mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);<br>    LOG_ALWAYS_FATAL_IF(mEglDisplay == EGL_NO_DISPLAY, "Failed to get EGL_DEFAULT_DISPLAY! err=%s",<br>                        eglErrorString());<br><br>    EGLint major, minor;<br>    initExtensions();<br><br>    // Now that extensions are loaded, pick a swap behavior<br>    <span class="hljs-keyword">if</span> (Properties::enablePartialUpdates) &#123;<br>        // An Adreno driver bug is causing rendering problems <span class="hljs-keyword">for</span> SkiaGL with<br>        // buffer age swap behavior (b/31957043).  To temporarily workaround,<br>        // we will use preserved swap behavior.<br>        <span class="hljs-keyword">if</span> (Properties::useBufferAge &amp;&amp; EglExtensions.bufferAge) &#123;<br>            mSwapBehavior = SwapBehavior::BufferAge;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mSwapBehavior = SwapBehavior::Preserved;<br>        &#125;<br>    &#125;<br><br>    loadConfigs();<br>   //创建egl上下文你<br>    createContext();<br>   //创建离屏渲染Buffer<br>    createPBufferSurface();<br>    makeCurrent(mPBufferSurface);<br>    DeviceInfo::initialize();<br>    mRenderThread.renderState().onGLContextCreated();<br></code></pre></td></tr></table></figure>
<p>目前只是创建了<code>PBufferSurface</code>，在没有<code>WindowSurface</code>的时候是无法渲染显示在屏幕上的。</p>
<blockquote>
<p><code>PBufferSurface</code>：在显存中开辟一块空间，存放渲染后的数据。</p>
<p><code>WindowSurface</code>：在屏幕上的一块显示区域的封装，渲染后就显示在屏幕上</p>
</blockquote>
<h6 id="设置WindowSurface"><a href="#设置WindowSurface" class="headerlink" title="设置WindowSurface"></a>设置<code>WindowSurface</code></h6><blockquote>
<p>主要是在<code>ViewRootImpl#performTraversals()</code>进行设置的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performTraversals() &#123;<br>      <br>      ...<br>                        <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span>) &#123;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                              //初始化ThreadedRenderer 并赋值surface 用于绘制显示<br>                                hwInitialized = mAttachInfo.mThreadedRenderer.initialize(<br>                                        mSurface);<br>                                <span class="hljs-keyword">if</span> (hwInitialized &amp;&amp; (host.mPrivateFlags<br>                                        &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) &#123;<br>                                    // Don't pre-allocate <span class="hljs-keyword">if</span> transparent regions<br>                                    // are requested as they may not be needed<br>                                    mSurface.allocateBuffers();<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (OutOfResourcesException e) &#123;<br>                                handleOutOfResourcesException(e);<br>                                return;<br>                            &#125;<br>                        &#125;      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>ThreadedRenderer#initalize</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> initialize(Surface surface) <span class="hljs-keyword">throws</span> OutOfResourcesException &#123;<br>    <span class="hljs-keyword">boolean</span> status = !mInitialized;<br>    mInitialized = <span class="hljs-keyword">true</span>;<br>    updateEnabledState(surface);<br>  <br>    nInitialize(mNativeProxy, surface);<br>    return status;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>切换到Native层继续执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> android_view_ThreadedRenderer_initialize(JNIEnv* env, jobject clazz,<br>        jlong proxyPtr, jobject jsurface) &#123;<br>    RenderProxy* proxy = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);<br>    sp&lt;Surface&gt; surface = android_view_Surface_getSurface(env, jsurface);<br>    proxy-&gt;initialize(surface);<br>&#125;<br><br>//RenderProxy.cpp<br><span class="hljs-keyword">void</span> RenderProxy::initialize(<span class="hljs-keyword">const</span> sp&lt;Surface&gt;&amp; surface) &#123;<br>    mRenderThread.<span class="hljs-built_in">queue</span>().post(<br>            [ <span class="hljs-keyword">this</span>, surf = surface ]() <span class="hljs-keyword">mutable</span> &#123; mContext-&gt;setSurface(<span class="hljs-built_in">std</span>::move(surf)); &#125;);<br>&#125;<br><br>//CanvasContext.cpp<br><span class="hljs-keyword">void</span> CanvasContext::setSurface(sp&lt;Surface&gt;&amp;&amp; surface) &#123;<br>    ATRACE_CALL();<br><br>    mNativeSurface = <span class="hljs-built_in">std</span>::move(surface);<br><br>    ColorMode colorMode = mWideColorGamut ? ColorMode::WideColorGamut : ColorMode::Srgb;<br>    <span class="hljs-keyword">bool</span> hasSurface = mRenderPipeline-&gt;setSurface(mNativeSurface.get(), mSwapBehavior, colorMode);<br><br>    mFrameNumber = -1;<br><br>    <span class="hljs-keyword">if</span> (hasSurface) &#123;<br>        mHaveNewSurface = <span class="hljs-literal">true</span>;<br>        mSwapHistory.clear();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mRenderThread.removeFrameCallback(<span class="hljs-keyword">this</span>);<br>        mGenerationID++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此处的<code>mRenderPipeline</code>为上节的<code>OpenGLPipeline</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//libs/hwui/renderthread/OpenGLPipeline.cpp<br><span class="hljs-keyword">bool</span> OpenGLPipeline::setSurface(Surface* surface, SwapBehavior swapBehavior, ColorMode colorMode) &#123;<br>    <span class="hljs-keyword">if</span> (mEglSurface != EGL_NO_SURFACE) &#123;<br>        mEglManager.destroySurface(mEglSurface);<br>        mEglSurface = EGL_NO_SURFACE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (surface) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> wideColorGamut = colorMode == ColorMode::WideColorGamut;<br>        mEglSurface = mEglManager.createSurface(surface, wideColorGamut);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行到<code>createSurface()</code>创建<code>WindowSurface</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">EGLSurface EglManager::createSurface(EGLNativeWindowType window, <span class="hljs-keyword">bool</span> wideColorGamut) &#123;<br>  ...<br>    EGLSurface surface = eglCreateWindowSurface(<br>            mEglDisplay, wideColorGamut ? mEglConfigWideGamut : mEglConfig, window, attribs);<br>    <span class="hljs-keyword">return</span> surface;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到此创建<code>WindowSurface</code>完毕。</p>
<h4 id="CanvasContext-draw"><a href="#CanvasContext-draw" class="headerlink" title="CanvasContext#draw"></a>CanvasContext#draw</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> CanvasContext::draw() &#123;<br>  ...<br>    //开始绘制<br>    <span class="hljs-keyword">bool</span> drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,<br>                                      mContentDrawBounds, mOpaque, mWideColorGamut, mLightInfo,<br>                                      mRenderNodes, &amp;(profiler()));<br>  <br>  //交换缓冲区<br>    <span class="hljs-keyword">bool</span> didSwap =<br>            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="OpenGLPipeline-draw"><a href="#OpenGLPipeline-draw" class="headerlink" title="OpenGLPipeline#draw"></a>OpenGLPipeline#draw</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> OpenGLPipeline::draw(<span class="hljs-keyword">const</span> Frame&amp; frame, <span class="hljs-keyword">const</span> SkRect&amp; screenDirty, <span class="hljs-keyword">const</span> SkRect&amp; dirty,<br>                          <span class="hljs-keyword">const</span> FrameBuilder::LightGeometry&amp; lightGeometry,<br>                          LayerUpdateQueue* layerUpdateQueue, <span class="hljs-keyword">const</span> Rect&amp; contentDrawBounds,<br>                          <span class="hljs-keyword">bool</span> opaque, <span class="hljs-keyword">bool</span> wideColorGamut,<br>                          <span class="hljs-keyword">const</span> BakedOpRenderer::LightInfo&amp; lightInfo,<br>                          <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;sp&lt;RenderNode&gt;&gt;&amp; renderNodes,<br>                          FrameInfoVisualizer* profiler) &#123;<br>    mEglManager.damageFrame(frame, dirty);<br><br>    <span class="hljs-keyword">bool</span> drew = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">auto</span>&amp; caches = Caches::getInstance();<br>    FrameBuilder frameBuilder(dirty, frame.width(), frame.height(), lightGeometry, caches);<br><br>    frameBuilder.deferLayers(*layerUpdateQueue);<br>    layerUpdateQueue-&gt;clear();<br><br>    frameBuilder.deferRenderNodeScene(renderNodes, contentDrawBounds);<br><br>    BakedOpRenderer renderer(caches, mRenderThread.renderState(), opaque, wideColorGamut,<br>                             lightInfo);<br>    frameBuilder.replayBakedOps&lt;BakedOpDispatcher&gt;(renderer);<br>    ProfileRenderer profileRenderer(renderer);<br>    profiler-&gt;draw(profileRenderer);<br>  //调用GPU进行渲染<br>    drew = renderer.didDraw();<br><br>    // post frame cleanup<br>    caches.clearGarbage();<br>    caches.pathCache.trim();<br>    caches.tessellationCache.trim();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="OpenGLPipeline-swapBuffers"><a href="#OpenGLPipeline-swapBuffers" class="headerlink" title="OpenGLPipeline#swapBuffers"></a>OpenGLPipeline#swapBuffers</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> OpenGLPipeline::swapBuffers(<span class="hljs-keyword">const</span> Frame&amp; frame, <span class="hljs-keyword">bool</span> drew, <span class="hljs-keyword">const</span> SkRect&amp; screenDirty,<br>                                 FrameInfo* currentFrameInfo, <span class="hljs-keyword">bool</span>* requireSwap) &#123;<br>    GL_CHECKPOINT(LOW);<br><br>    // Even <span class="hljs-keyword">if</span> we decided to cancel the frame, from the perspective of jank<br>    // metrics the frame was swapped at <span class="hljs-keyword">this</span> point<br>    currentFrameInfo-&gt;markSwapBuffers();<br><br>    *requireSwap = drew || mEglManager.damageRequiresSwap();<br><br>    <span class="hljs-keyword">if</span> (*requireSwap &amp;&amp; (CC_UNLIKELY(!mEglManager.swapBuffers(frame, screenDirty)))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> *requireSwap;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/CPU GPU通信模型" srcset="/img/loading.gif" lazyload="" alt="img"></p>
<p>根据图示渲染过程主要分为5阶段：</p>
<ol>
<li>UI线程创建OpenGL渲染需要的命令及数据——<code>构建DrawOp树</code></li>
<li>CPU将数据共享给GPU，使用<code>匿名共享内存</code></li>
<li>通知GPU渲染</li>
<li>swapBuffers，并通知<code>SurfaceFlinger</code>开始合成图层</li>
<li>SurfaceFlinger开始合成图层</li>
</ol>
<h3 id="硬件绘制流程"><a href="#硬件绘制流程" class="headerlink" title="硬件绘制流程"></a>硬件绘制流程</h3><p><img src="/images/硬件绘制流程.jpg" srcset="/img/loading.gif" lazyload="" alt="硬件绘制流程"></p>
<p>如上图所示：</p>
<blockquote>
<p>硬件绘制的流程，主要包含两个步骤：<strong>录制 、 回放</strong>。</p>
<p><code>录制</code>：需要View的<code>draw()</code>参与，需要记录View的绘制步骤，并编译为<strong>绘制指令</strong>(<code>drawOp</code>)</p>
<p><code>回放</code>：还原绘制内容，只需要还原<strong>绘制指令</strong>，而且这个绘制指令是可以修改的，修改的过程是不需要重新触发<code>draw()</code>。</p>
</blockquote>
<h3 id="硬件渲染过程"><a href="#硬件渲染过程" class="headerlink" title="硬件渲染过程"></a>硬件渲染过程</h3><p><img src="/images/RenderThread渲染过程.jpg" srcset="/img/loading.gif" lazyload="" alt="RenderThread渲染过程"></p>
<h2 id="软件绘制VS硬件绘制"><a href="#软件绘制VS硬件绘制" class="headerlink" title="软件绘制VS硬件绘制"></a>软件绘制VS硬件绘制</h2><table>
<thead>
<tr>
<th>渲染场景</th>
<th>软件绘制</th>
<th>硬件绘制</th>
<th>效果分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面初始化</td>
<td>绘制所有View</td>
<td>创建所有<code>DisplayList</code></td>
<td>GPU负责复杂的计算任务</td>
</tr>
<tr>
<td>调用背景透明TextView.setText()</td>
<td>重绘脏区所有View</td>
<td>TextView及每一级父View重建<code>DisplayList</code></td>
<td>重叠的兄弟节点不需要进行重绘，GPU会自行处理</td>
</tr>
<tr>
<td>TextView逐帧播放动画</td>
<td>每帧动画都要重绘脏区View</td>
<td>第一帧需要重建<code>DisplayList</code><br>后续只要更新对应的<code>DisplayList</code>即可</td>
<td>刷新每帧性能提升</td>
</tr>
<tr>
<td>修改TextView透明度</td>
<td>重绘脏区所有View</td>
<td>直接调用<code>RenderNode.setAlpha()</code>即可</td>
<td>只触发<code>DecorView.updateDisplayListIfDirty</code>，不再往下遍历</td>
</tr>
</tbody>
</table>
<h2 id="绘制缓存"><a href="#绘制缓存" class="headerlink" title="绘制缓存"></a>绘制缓存</h2><p><img src="/images/Android绘制-绘制缓存.png" srcset="/img/loading.gif" lazyload="" alt="绘制缓存"></p>
<blockquote>
<p>绘图缓存是指一个<code>Bitmap(软件绘制)</code>和<code>(硬件绘制)</code>，保存的是控件及其子控件的一个快照。</p>
<p>可以通过<code>View.setLayerType()</code>设置使用何种类型的缓存。</p>
<p><code>LAYER_TYPE_NONE</code>：视图正常渲染，不受屏幕外缓冲区支持。<strong>默认值</strong></p>
<p><code>LAYER_TYPE_SOFTWARE</code>：标识这个View有一个<code>Software Layer</code>，在一定条件下，会变成<code>bitmap</code>对象。</p>
<p><code>LAYER_TYPE_HARDWARE</code>：标识这个VIew有一个<code>Hardware Layer</code>，通过GPU来实现。依赖<code>硬件加速</code>实现，如果未开启<code>硬件加速</code>，按照<code>Software Layer</code>实现。</p>
</blockquote>
<h3 id="软件绘制缓存"><a href="#软件绘制缓存" class="headerlink" title="软件绘制缓存"></a>软件绘制缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>    <span class="hljs-keyword">boolean</span> draw(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime) &#123;<br>     ...<br>        Bitmap cache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> layerType = getLayerType(); // layerType默认为LAYER_TYPE_NONE<br>        <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123;//软件绘制条件<br>             <span class="hljs-keyword">if</span> (layerType != LAYER_TYPE_NONE) &#123;//必须设置 `LAYER_TYPE_SOFTWARE` 或 LAYER_TYPE_HARDWARE 缓存生效<br>                 // If not drawing with RenderNode, treat HW layers as SW<br>                 layerType = LAYER_TYPE_SOFTWARE;//设置 软件layer<br>                 buildDrawingCache(<span class="hljs-keyword">true</span>);//构建缓存<br>            &#125;<br>            cache = getDrawingCache(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> buildDrawingCache(<span class="hljs-keyword">boolean</span> autoScale) &#123;<br>       buildDrawingCacheImpl(autoScale);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> buildDrawingCacheImpl(<span class="hljs-keyword">boolean</span> autoScale) &#123;<br>     ...<br>       quality = Bitmap.Config.ARGB_8888;//默认缓存bitmap图像类型<br>       bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(),<br>                        width, height, quality);<br>       bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);<br>       <span class="hljs-keyword">if</span> (autoScale) &#123;<br>          mDrawingCache = bitmap;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>          mUnscaledDrawingCache = bitmap;<br>       &#125;<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>要启用<code>软件绘制缓存</code>，必须调用<code>View.setLayerType()</code>设置<code>LAYER_TYPE_HARDDWARE、LAYER_TYPE_SOFTWARE</code>。通过<code>buildDrawingCache()</code>生成<code>绘制缓存</code>，对应会生成两个缓存对象：</p>
<ul>
<li><code>mDrawingCache</code>：根据兼容模式进行放大或缩小</li>
<li><code>mUnscaledDrawingCache</code>：反映了控件的真实尺寸，多用作控件截图。</li>
</ul>
<p>后续通过<code>getDrawingCache()</code>获取缓存内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br><span class="hljs-keyword">boolean</span> draw(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime) &#123;<br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> drawingWithDrawingCache = cache != <span class="hljs-keyword">null</span> &amp;&amp; !drawingWithRenderNode; //是否使用缓存<br> ...<br> <span class="hljs-keyword">if</span>(!drawingWithDrawingCache) &#123;//未使用缓存<br>    <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;//硬件绘制<br>        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>        ((DisplayListCanvas) canvas).drawRenderNode(renderNode);<br>    &#125; <span class="hljs-keyword">else</span> &#123;//软件绘制<br>        // 需要回调到`onDraw()`<br>        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;<br>            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>            dispatchDraw(canvas);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            draw(canvas);<br>        &#125;<br>    &#125;<br> &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cache!=<span class="hljs-keyword">null</span>)&#123;<br>   canvas.drawBitmap(cache...)//将缓存绘制于画布上<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="硬件绘制缓存"><a href="#硬件绘制缓存" class="headerlink" title="硬件绘制缓存"></a>硬件绘制缓存</h3><p><code>DisplayList</code>可以理解为缓存，开启<code>硬件加速</code>时，只要每次回放<code>DisplayList</code>即可。</p>
<h3 id="绘制缓存的开启原则"><a href="#绘制缓存的开启原则" class="headerlink" title="绘制缓存的开启原则"></a>绘制缓存的开启原则</h3><ul>
<li>不要为<code>十分轻量级的控件</code>启用绘制缓存。可能缓存绘制的开销 &gt; 控件重绘开销</li>
<li>为<code>很少发生内容改变的控件</code>启用绘制缓存。避免<code>invalidate()</code>时产生额外的缓存绘制操作</li>
<li>当父控件需要频繁改变子控件的位置或变换时对<code>子控件</code>启用绘制缓存，避免频繁重绘子控件。通过<code>ViewGroup.setChildrenDrawingWithCache()</code>启用子控件绘制缓存。</li>
</ul>
<h2 id="属性动画更新相关"><a href="#属性动画更新相关" class="headerlink" title="属性动画更新相关"></a>属性动画更新相关</h2><p><img src="/images/Android绘制-属性动画更新相关.png" srcset="/img/loading.gif" lazyload="" alt="Android绘制-属性动画更新相关"></p>
<p>在中讲到最后通过反射调用<code>View.setXX()</code>去执行动画。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">//view.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setScaleX(<span class="hljs-keyword">float</span> scaleX) &#123;<br>        <span class="hljs-keyword">if</span> (scaleX != getScaleX()) &#123;<br>            scaleX = sanitizeFloatPropertyValue(scaleX, "scaleX");<br>            invalidateViewProperty(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>            mRenderNode.setScaleX(scaleX);//更新对应View的displayList<br>            invalidateViewProperty(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br><br>            invalidateParentIfNeededAndWasQuickRejected();<br>            notifySubtreeAccessibilityStateChangedIfNeeded();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>关键在于<code>invalidateViewProperty()</code>调用界面刷新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> invalidateViewProperty(<span class="hljs-keyword">boolean</span> invalidateParent, <span class="hljs-keyword">boolean</span> forceRedraw) &#123;<br>    <span class="hljs-keyword">if</span> (!isHardwareAccelerated()<br>            || !mRenderNode.isValid()<br>            || (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != 0) &#123;//软件绘制<br>        <span class="hljs-keyword">if</span> (invalidateParent) &#123;<br>            invalidateParentCaches();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (forceRedraw) &#123;<br>            mPrivateFlags |= PFLAG_DRAWN; // force another invalidation with the new orientation<br>        &#125;<br>        invalidate(<span class="hljs-keyword">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        damageInParent();//硬件绘制<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> damageInParent() &#123;<br>    <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo != <span class="hljs-keyword">null</span>) &#123;<br>        mParent.onDescendantInvalidated(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);//一层层向上层调用<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>mParent</code>一般指向<code>ViewGroup</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewGroup.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onDescendantInvalidated(@NonNull View child, @NonNull View target) &#123;<br>      ...<br>        <span class="hljs-keyword">if</span> ((target.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) != 0) &#123;<br>            // We lazily use PFLAG_DIRTY, since computing opaque isn't worth the potential<br>            // optimization in provides in a DisplayList world.<br>            mPrivateFlags = (mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DIRTY;<br><br>            // simplified invalidateChildInParent behavior: clear cache validity to be safe...<br>            //标记缓存无效<br>            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;<br>        &#125;<br>      ...<br>        <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span>) &#123;<br>          //继续向顶层View请求<br>            mParent.onDescendantInvalidated(<span class="hljs-keyword">this</span>, target);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>onDescendantInvalidated()</code>主要移除了<code>PFLAG_DRAWING_CACHE_VALID</code>标志</p>
<p>最顶层的View是<code>DecorView</code>，而<code>ViewRootImpl</code>就是<code>DecorView的parent</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onDescendantInvalidated(@NonNull View child, @NonNull View descendant) &#123;<br>        <span class="hljs-keyword">if</span> ((descendant.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != 0) &#123;<br>            mIsAnimating = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        invalidate();<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> invalidate() &#123;<br>        mDirty.set(0, 0, mWidth, mHeight);<br>        <span class="hljs-keyword">if</span> (!mWillDrawSoon) &#123;<br>            scheduleTraversals();//开始执行绘制流程<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>总结：属性动画最后反射调用<code>View.setXX()</code>更新View属性时，调用到<code>invalidateViewProperty()</code>，主要实现的功能就是<code>移除PFLAG_DRAWING_CACHE_VALID</code>标志。在执行绘制过程中，在回到<code>View.updateDisplayListIfDirty()</code>时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RenderNode updateDisplayListIfDirty() &#123;<br>  ...<br>     <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0 //满足该条件<br>               || !renderNode.isValid()<br>               || (mRecreateDisplayList)) &#123;<br>           // Don't need to recreate the display list, just need to tell our<br>           // children to restore/recreate theirs<br>           <span class="hljs-keyword">if</span> (renderNode.isValid()<br>                   &amp;&amp; !mRecreateDisplayList) &#123;//未设置 PFLAG_INVALIDATED标志<br>               mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;<br>               mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;<br>               dispatchGetDisplayList();//只要刷新DisplayList<br><br>               return renderNode; // no work needed<br>           &#125;<br>       ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>在开启硬件加速的条件下，属性动画更新过程中不会回调<code>onDraw()</code></strong></p>
<h2 id="关键节点"><a href="#关键节点" class="headerlink" title="关键节点"></a>关键节点</h2><h3 id="DisplayList初始化"><a href="#DisplayList初始化" class="headerlink" title="DisplayList初始化"></a><code>DisplayList</code>初始化</h3><p><code>DisplayListCanvas.start()</code> -&gt; <code>DisplayListCanvas.obtain()</code>-&gt;<code>nCreateDisplayListCanvas</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">//android_view_DisplayListCanvas.cpp<br><span class="hljs-keyword">static</span> jlong android_view_DisplayListCanvas_createDisplayListCanvas(jlong renderNodePtr,<br>        jint width, jint height) &#123;<br>    RenderNode* renderNode = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));<br>&#125;<br><br>//Canvas.cpp<br>Canvas* Canvas::create_recording_canvas(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, uirenderer::RenderNode* renderNode) &#123;<br>    <span class="hljs-keyword">if</span> (uirenderer::Properties::isSkiaEnabled()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uirenderer::RecordingCanvas(width, height);<br>&#125;<br><br>//Properrties.cpp<br><span class="hljs-keyword">bool</span> Properties::isSkiaEnabled() &#123;<br>    <span class="hljs-keyword">auto</span> renderType = getRenderPipelineType();//分为三种类型 SkiaGL SkiaVulkan OpenGL(默认)<br>    <span class="hljs-keyword">return</span> RenderPipelineType::SkiaGL == renderType || RenderPipelineType::SkiaVulkan == renderType;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">//RecordingCanvas.cpp<br>RecordingCanvas::RecordingCanvas(size_t width, size_t height)<br>        : mState(*<span class="hljs-keyword">this</span>), mResourceCache(ResourceCache::getInstance()) &#123;<br>    resetRecording(width, height);<br>&#125;<br><br><span class="hljs-keyword">void</span> RecordingCanvas::resetRecording(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, RenderNode* node) &#123;<br>    LOG_ALWAYS_FATAL_IF(mDisplayList, "prepareDirty called a second time during a recording!");<br>    mDisplayList = <span class="hljs-keyword">new</span> DisplayList();//初始化DisplayList<br><br>    mState.initializeRecordingSaveStack(width, height);<br><br>    mDeferredBarrierType = DeferredBarrierType::InOrder;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="插入DrawOp到DisplayList"><a href="#插入DrawOp到DisplayList" class="headerlink" title="插入DrawOp到DisplayList"></a>插入DrawOp到DisplayList</h3><p><code>DisplayListCanvas</code>内部也包含了各种<code>drawXX()</code>，例如<code>drawLines()、drawText()</code>等。在调用这些方法后，会把对应的绘制操作转换为<code>drawOp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">//DisplayListCanvas.java<br><span class="hljs-keyword">public</span> final class DisplayListCanvas extends RecordingCanvas &#123;<br> ...<br>   //所有绘制方法由RecordCanvas实现<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> drawCircle(CanvasProperty&lt;Float&gt; cx, CanvasProperty&lt;Float&gt; cy,<br>            CanvasProperty&lt;Float&gt; radius, CanvasProperty&lt;Paint&gt; paint) &#123;<br>        nDrawCircle(mNativeCanvasWrapper, cx.getNativeContainer(), cy.getNativeContainer(),<br>                radius.getNativeContainer(), paint.getNativeContainer());<br>    &#125;<br>&#125;<br><br>//RecordingCanvas.java<br>    @Override<br>    <span class="hljs-keyword">public</span> final <span class="hljs-keyword">void</span> drawLine(<span class="hljs-keyword">float</span> startX, <span class="hljs-keyword">float</span> startY, <span class="hljs-keyword">float</span> stopX, <span class="hljs-keyword">float</span> stopY,<br>            @NonNull Paint paint) &#123;<br>        nDrawLine(mNativeCanvasWrapper, startX, startY, stopX, stopY, paint.getNativeInstance());<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>drawCircle()和drawRoundRect()</code>由<code>DisplayListCanvas</code>实现。其他的绘制方法交由<code>RecordingCanvas</code>实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">//android_view_DisplayListCanvas.cpp<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> android_view_DisplayListCanvas_drawCircleProps(jlong canvasPtr,<br>        jlong xPropPtr, jlong yPropPtr, jlong radiusPropPtr, jlong paintPropPtr) &#123;<br>    Canvas* canvas = <span class="hljs-keyword">reinterpret_cast</span>&lt;Canvas*&gt;(canvasPtr);<br>    CanvasPropertyPrimitive* xProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(xPropPtr);<br>    CanvasPropertyPrimitive* yProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(yPropPtr);<br>    CanvasPropertyPrimitive* radiusProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(radiusPropPtr);<br>    CanvasPropertyPaint* paintProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPaint*&gt;(paintPropPtr);<br>    canvas-&gt;drawCircle(xProp, yProp, radiusProp, paintProp);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">//RecordingCanvas.h<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> drawLine(<span class="hljs-keyword">float</span> startX, <span class="hljs-keyword">float</span> startY, <span class="hljs-keyword">float</span> stopX, <span class="hljs-keyword">float</span> stopY,<br>                          <span class="hljs-keyword">const</span> SkPaint&amp; paint) override &#123;<br>        <span class="hljs-keyword">float</span> points[4] = &#123;startX, startY, stopX, stopY&#125;;<br>        drawLines(points, 4, paint);<br>    &#125;<br><br>//RecordingCanvas.cpp<br><span class="hljs-keyword">void</span> RecordingCanvas::drawLines(<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>* points, <span class="hljs-keyword">int</span> floatCount, <span class="hljs-keyword">const</span> SkPaint&amp; paint) &#123;<br>    <span class="hljs-keyword">if</span> (CC_UNLIKELY(floatCount &lt; 4 || paint.nothingToDraw())) <span class="hljs-keyword">return</span>;<br>    floatCount &amp;= ~0x3;  // round down to nearest four<br> <br>    addOp(alloc().create_trivial&lt;LinesOp&gt;(<br>            calcBoundsOfPoints(points, floatCount), *mState.currentSnapshot()-&gt;transform,<br>            getRecordedClip(), refPaint(&amp;paint), refBuffer&lt;<span class="hljs-keyword">float</span>&gt;(points, floatCount), floatCount));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>addOp()</code>将<code>DrawLine</code>的绘制操作缓存到<code>displayList</code>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><a href="/2018/12/14/View的工作原理/" title="View的绘制过程">View的绘制过程</a>
<p><a href="https://developer.android.com/guide/topics/graphics/hardware-accel?hl=zh-cn" target="_blank" rel="noopener">Android官方文档-硬件加速</a></p>
<p><a href="https://blog.csdn.net/Luoshengyang/article/details/45943255" target="_blank" rel="noopener">DisplayList构建过程分析</a></p>
<p><a href="https://tech.meituan.com/2017/01/19/hardware-accelerate.html" target="_blank" rel="noopener">Android硬件加速原理与实现简介</a></p>
<p><a href="https://www.jianshu.com/p/dd800800145b" target="_blank" rel="noopener">RenderThread与OpenGL GPU渲染</a></p>
<p><a href="https://www.androidperformance.com/2019/07/27/Android-Hardware-Layer/" target="_blank" rel="noopener">Android 中的 Hardware Layer 详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/62813895" target="_blank" rel="noopener">深入浅出Android BufferQueue</a></p>
<p><a href="https://www.jianshu.com/p/f808813880b0" target="_blank" rel="noopener">BufferQueue</a></p>
<!-- https://www.jianshu.com/p/abfaea892611 ， https://blog.csdn.net/jinzhuojun/article/details/54234354 https://www.jianshu.com/p/40f660e17a73 -->

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/10/31/Android-匿名共享内存-Ashmem/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android匿名共享内存-Ashmem</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/14/Android性能优化-LeakCanary/">
                        <span class="hidden-mobile">Android性能优化-LeakCanary</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
