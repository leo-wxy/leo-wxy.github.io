

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
    <meta name="description" content="基于Android 6.0源码进行分析  SurfaceFlinger是Android系统中最重要的图像消费者，Activity绘制的界面图像，都会传递到SurfaceFlinger中。 主要作用：接收图像缓冲区数据，然后交给HWComposer或OpenGL合成，合成完毕后再返回。  SurfaceFlinger初始化init通过执行surfaceflinger.rc文件，然后就执行到了ma">
<meta property="og:type" content="article">
<meta property="og:title" content="Android-SurfaceFlinger解析">
<meta property="og:url" content="http://example.com/2020/12/21/Android-SurfaceFlinger%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="基于Android 6.0源码进行分析  SurfaceFlinger是Android系统中最重要的图像消费者，Activity绘制的界面图像，都会传递到SurfaceFlinger中。 主要作用：接收图像缓冲区数据，然后交给HWComposer或OpenGL合成，合成完毕后再返回。  SurfaceFlinger初始化init通过执行surfaceflinger.rc文件，然后就执行到了ma">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/SurfaceFlinger%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg">
<meta property="og:image" content="http://example.com/images/Sf%E5%88%9D%E5%A7%8B%E5%8C%96.png">
<meta property="og:image" content="http://example.com/images/SF%E6%8E%A5%E6%94%B6Vsync%E4%BF%A1%E5%8F%B7.jpg">
<meta property="og:image" content="http://example.com/images/SF%E5%A4%84%E7%90%86Vsync%E4%BF%A1%E5%8F%B7.jpg">
<meta property="og:image" content="http://example.com/images/BufferQueue%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg">
<meta property="og:image" content="http://example.com/images/SF-Surface%E5%92%8CLayer%E5%88%9B%E5%BB%BA%E5%87%86%E5%A4%87.jpg">
<meta property="og:image" content="http://example.com/images/SF-Buffer%E3%80%81Layer%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg">
<meta property="og:image" content="http://example.com/images/SF-BufferQueueCore.jpg">
<meta property="og:image" content="http://example.com/images/SF-BufferQueue-dequeueBuffer.jpg">
<meta property="og:image" content="http://example.com/images/BufferSlot%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98%E8%BF%87%E7%A8%8B.jpg">
<meta property="article:published_time" content="2020-12-21T07:06:52.000Z">
<meta property="article:modified_time" content="2021-01-29T08:10:40.000Z">
<meta property="article:author" content="Leo-Wxy">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/images/SurfaceFlinger%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg">
  
  
  
  <title>Android-SurfaceFlinger解析 - Wxy的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":false};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Android-SurfaceFlinger解析</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-12-21 15:06" pubdate>
          2020年12月21日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          38 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Android-SurfaceFlinger解析</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p> 基于<code>Android 6.0</code>源码进行分析</p>
</blockquote>
<p><code>SurfaceFlinger</code>是Android系统中最重要的<strong>图像消费者</strong>，Activity绘制的界面图像，都会传递到<code>SurfaceFlinger</code>中。</p>
<p>主要作用：<strong>接收图像缓冲区数据，然后交给HWComposer或OpenGL合成，合成完毕后再返回。</strong></p>
<p><img src="/images/SurfaceFlinger%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt="SurfaceFlinger执行流程"></p>
<h2 id="SurfaceFlinger初始化"><a href="#SurfaceFlinger初始化" class="headerlink" title="SurfaceFlinger初始化"></a>SurfaceFlinger初始化</h2><p><code>init</code>通过执行<code>surfaceflinger.rc</code>文件，然后就执行到了<code>main_surfaceflinger.cpp</code>开始初始化流程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>**)</span> </span>&#123;<br>    <span class="hljs-built_in">signal</span>(SIGPIPE, SIG_IGN);<br><br>    hardware::<span class="hljs-built_in">configureRpcThreadpool</span>(<span class="hljs-number">1</span> <span class="hljs-comment">/* maxThreads */</span>,<br>            <span class="hljs-literal">false</span> <span class="hljs-comment">/* callerWillJoin */</span>);<br><br>    <span class="hljs-built_in">startGraphicsAllocatorService</span>();<br><br>   <span class="hljs-comment">//设置支持最多 4个 binder线程执行</span><br>    ProcessState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">setThreadPoolMaxThreadCount</span>(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// start the thread pool</span><br>    <span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ps</span><span class="hljs-params">(ProcessState::self())</span></span>;<br>    ps-&gt;<span class="hljs-built_in">startThreadPool</span>();<br><br>    <span class="hljs-comment">//构建 Surfaceflinger实例</span><br>    sp&lt;SurfaceFlinger&gt; flinger = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SurfaceFlinger</span>();<br><br>    <span class="hljs-comment">// 执行初始化流程</span><br>    flinger-&gt;<span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-comment">// 通过ServiceManager注册 SurfaceFlinger服务</span><br>    <span class="hljs-function">sp&lt;IServiceManager&gt; <span class="hljs-title">sm</span><span class="hljs-params">(defaultServiceManager())</span></span>;<br>    sm-&gt;<span class="hljs-built_in">addService</span>(<span class="hljs-built_in">String16</span>(SurfaceFlinger::<span class="hljs-built_in">getServiceName</span>()), flinger, <span class="hljs-literal">false</span>,<br>                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);<br><br>    <span class="hljs-built_in">startDisplayService</span>(); <span class="hljs-comment">// dependency on SF getting registered above</span><br><br>    <span class="hljs-comment">// 开始运行</span><br>    flinger-&gt;<span class="hljs-built_in">run</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="new-SurfaceFlinger"><a href="#new-SurfaceFlinger" class="headerlink" title="new SurfaceFlinger"></a>new SurfaceFlinger</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::onFirstRef</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    mEventQueue-&gt;<span class="hljs-built_in">init</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>mEventQueue</code>执行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MessageQueue::init</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span> </span>&#123;<br>    mFlinger = flinger;<br>    mLooper = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Looper</span>(<span class="hljs-literal">true</span>);<br>    mHandler = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Handler</span>(*<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始化<code>Handler</code></p>
<h3 id="SurfaceFlinger-init"><a href="#SurfaceFlinger-init" class="headerlink" title="SurfaceFlinger#init"></a>SurfaceFlinger#init</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGI</span>(  <span class="hljs-string">&quot;SurfaceFlinger&#x27;s main thread ready to run. &quot;</span><br>            <span class="hljs-string">&quot;Initializing graphics H/W...&quot;</span>);<br><br>    <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;Phase offest NS: %&quot;</span> PRId64 <span class="hljs-string">&quot;&quot;</span>, vsyncPhaseOffsetNs);<br><br>    Mutex::Autolock _l(mStateLock);<br><br>    <span class="hljs-comment">// start the EventThread</span><br>    mEventThreadSource =<br>            std::<span class="hljs-built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs,<br>                                             <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;app&quot;</span>);<br>    mEventThread = std::<span class="hljs-built_in">make_unique</span>&lt;impl::EventThread&gt;(mEventThreadSource.<span class="hljs-built_in">get</span>(),<br>                                                       [<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-built_in">resyncWithRateLimit</span>(); &#125;,<br>                                                       impl::EventThread::<span class="hljs-built_in">InterceptVSyncsCallback</span>(),<br>                                                       <span class="hljs-string">&quot;appEventThread&quot;</span>);<br>    mSfEventThreadSource =<br>            std::<span class="hljs-built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync,<br>                                             SurfaceFlinger::sfVsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;sf&quot;</span>);<br><br>    mSFEventThread =<br>            std::<span class="hljs-built_in">make_unique</span>&lt;impl::EventThread&gt;(mSfEventThreadSource.<span class="hljs-built_in">get</span>(),<br>                                                [<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-built_in">resyncWithRateLimit</span>(); &#125;,<br>                                                [<span class="hljs-keyword">this</span>](<span class="hljs-type">nsecs_t</span> timestamp) &#123;<br>                                                    mInterceptor-&gt;<span class="hljs-built_in">saveVSyncEvent</span>(timestamp);<br>                                                &#125;,<br>                                                <span class="hljs-string">&quot;sfEventThread&quot;</span>);<br>    mEventQueue-&gt;<span class="hljs-built_in">setEventThread</span>(mSFEventThread.<span class="hljs-built_in">get</span>());<br>    mVsyncModulator.<span class="hljs-built_in">setEventThread</span>(mSFEventThread.<span class="hljs-built_in">get</span>());<br><br>    <span class="hljs-comment">// Get a RenderEngine for the given display / config (can&#x27;t fail)</span><br>    <span class="hljs-built_in">getBE</span>().mRenderEngine =<br>            RE::impl::RenderEngine::<span class="hljs-built_in">create</span>(HAL_PIXEL_FORMAT_RGBA_8888,<br>                                           hasWideColorDisplay<br>                                                   ? RE::RenderEngine::WIDE_COLOR_SUPPORT<br>                                                   : <span class="hljs-number">0</span>);<br>  <br>    <span class="hljs-built_in">getBE</span>().mHwc.<span class="hljs-built_in">reset</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-built_in">HWComposer</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Hwc2::impl::Composer&gt;(<span class="hljs-built_in">getBE</span>().mHwcServiceName)));<br>    <span class="hljs-built_in">getBE</span>().mHwc-&gt;<span class="hljs-built_in">registerCallback</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">getBE</span>().mComposerSequenceId);<br>    <span class="hljs-comment">// Process any initial hotplug and resulting display changes.</span><br>    <span class="hljs-built_in">processDisplayHotplugEventsLocked</span>();<br>    <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(!<span class="hljs-built_in">getBE</span>().mHwc-&gt;<span class="hljs-built_in">isConnected</span>(HWC_DISPLAY_PRIMARY),<br>            <span class="hljs-string">&quot;Registered composer callback but didn&#x27;t create the default primary display&quot;</span>);<br><br>    <span class="hljs-comment">// make the default display GLContext current so that we can create textures</span><br>    <span class="hljs-comment">// when creating Layers (which may happens before we render something)</span><br>    <span class="hljs-built_in">getDefaultDisplayDeviceLocked</span>()-&gt;<span class="hljs-built_in">makeCurrent</span>();<br><br>    mEventControlThread = std::<span class="hljs-built_in">make_unique</span>&lt;impl::EventControlThread&gt;(<br>            [<span class="hljs-keyword">this</span>](<span class="hljs-type">bool</span> enabled) &#123; <span class="hljs-built_in">setVsyncEnabled</span>(HWC_DISPLAY_PRIMARY, enabled); &#125;);<br><br>    <span class="hljs-comment">// initialize our drawing state</span><br>    mDrawingState = mCurrentState;<br><br>    <span class="hljs-comment">// set initial conditions (e.g. unblank default device)</span><br>    <span class="hljs-built_in">initializeDisplays</span>();<br><br>    <span class="hljs-built_in">getBE</span>().mRenderEngine-&gt;<span class="hljs-built_in">primeCache</span>();<br><br>    <span class="hljs-comment">// Inform native graphics APIs whether the present timestamp is supported:</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getHwComposer</span>().<span class="hljs-built_in">hasCapability</span>(<br>            HWC2::Capability::PresentFenceIsNotReliable)) &#123;<br>        mStartPropertySetThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StartPropertySetThread</span>(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mStartPropertySetThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StartPropertySetThread</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mStartPropertySetThread-&gt;<span class="hljs-built_in">Start</span>() != NO_ERROR) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Run StartPropertySetThread failed!&quot;</span>);<br>    &#125;<br><br>    mLegacySrgbSaturationMatrix = <span class="hljs-built_in">getBE</span>().mHwc-&gt;<span class="hljs-built_in">getDataspaceSaturationMatrix</span>(HWC_DISPLAY_PRIMARY,<br>            Dataspace::SRGB_LINEAR);<br><br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Done initializing&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="创建HWComposer"><a href="#创建HWComposer" class="headerlink" title="创建HWComposer"></a>创建HWComposer</h4><blockquote>
<p><code>HWComposer</code>代表着硬件显示设备。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span><br>HWComposer::<span class="hljs-built_in">HWComposer</span>(<br>        <span class="hljs-type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,<br>        EventHandler&amp; handler)<br>    : <span class="hljs-built_in">mFlinger</span>(flinger),<br>      <span class="hljs-built_in">mFbDev</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">mHwc</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">mNumDisplays</span>(<span class="hljs-number">1</span>),<br>      <span class="hljs-built_in">mCBContext</span>(<span class="hljs-keyword">new</span> cb_context),<br>      <span class="hljs-built_in">mEventHandler</span>(handler),<br>      <span class="hljs-built_in">mDebugForceFakeVSync</span>(<span class="hljs-literal">false</span>)<br>&#123;<br>    ...     <br>    <span class="hljs-type">bool</span> needVSyncThread = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// Note: some devices may insist that the FB HAL be opened before HWC.</span><br>    <span class="hljs-type">int</span> fberr = <span class="hljs-built_in">loadFbHalModule</span>();<br>    <span class="hljs-built_in">loadHwcModule</span>();<span class="hljs-comment">//加载HWComposer模块</span><br><br>    <span class="hljs-comment">// these display IDs are always reserved</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;<br>        mAllocatedDisplayIDs.<span class="hljs-built_in">markBit</span>(i);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mHwc) &#123;<br>        <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;Using %s version %u.%u&quot;</span>, HWC_HARDWARE_COMPOSER,<br>              (<span class="hljs-built_in">hwcApiVersion</span>(mHwc) &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>,<br>              (<span class="hljs-built_in">hwcApiVersion</span>(mHwc) &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>);<br>        <span class="hljs-keyword">if</span> (mHwc-&gt;registerProcs) &#123;<br>            mCBContext-&gt;hwc = <span class="hljs-keyword">this</span>;<br>            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;<br>          <span class="hljs-comment">//vsync信号回调方法</span><br>            mCBContext-&gt;procs.vsync = &amp;hook_vsync;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hwcHasApiVersion</span>(mHwc, HWC_DEVICE_API_VERSION_1_1))<br>                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;<br>            <span class="hljs-keyword">else</span><br>                mCBContext-&gt;procs.hotplug = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(mCBContext-&gt;procs.zero));<br>          <span class="hljs-comment">//注册回调函数</span><br>            mHwc-&gt;<span class="hljs-built_in">registerProcs</span>(mHwc, &amp;mCBContext-&gt;procs);<br>        &#125;<br><br>        <span class="hljs-comment">// don&#x27;t need a vsync thread if we have a hardware composer</span><br>        needVSyncThread = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// always turn vsync off when we start</span><br>        <span class="hljs-built_in">eventControl</span>(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// the number of displays we actually have depends on the</span><br>        <span class="hljs-comment">// hw composer version</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hwcHasApiVersion</span>(mHwc, HWC_DEVICE_API_VERSION_1_3)) &#123;<br>            <span class="hljs-comment">// 1.3 adds support for virtual displays</span><br>            mNumDisplays = MAX_HWC_DISPLAYS;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hwcHasApiVersion</span>(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;<br>            <span class="hljs-comment">// 1.1 adds support for multiple displays</span><br>            mNumDisplays = NUM_BUILTIN_DISPLAYS;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mNumDisplays = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (needVSyncThread) &#123;<br>        <span class="hljs-comment">// 不支持硬件Vsync的设备，则使用`VsyncThread`模拟发出Vsync信号</span><br>        mVSyncThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">VSyncThread</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Vsync信号</code>本身由显示驱动发出，如果不支持硬件<code>Vsync</code>，则使用<code>VsyncThread</code>模拟发出信号。</p>
<h4 id="初始化显示设备"><a href="#初始化显示设备" class="headerlink" title="初始化显示设备"></a>初始化显示设备</h4><h4 id="运行EventThread线程"><a href="#运行EventThread线程" class="headerlink" title="运行EventThread线程"></a>运行EventThread线程</h4><blockquote>
<p><code>EventThread</code>主要用来接收<code>Vsync信号</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>        <span class="hljs-comment">// start the EventThread</span><br>    sp&lt;VSyncSource&gt; vsyncSrc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DispSyncSource</span>(&amp;mPrimaryDispSync,<br>            vsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;app&quot;</span>);<br>  <span class="hljs-comment">//创建App的Vsync信号接收线程</span><br>    mEventThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EventThread</span>(vsyncSrc);<br>    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DispSyncSource</span>(&amp;mPrimaryDispSync,<br>            sfVsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;sf&quot;</span>);<br>   <span class="hljs-comment">//创建Sf的Vsync信号接收线程</span><br>    mSFEventThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EventThread</span>(sfVsyncSrc);<br>    mEventQueue.<span class="hljs-built_in">setEventThread</span>(mSFEventThread);<br>...<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="DispSyncSource"><a href="#DispSyncSource" class="headerlink" title="DispSyncSource"></a>DispSyncSource</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">DispSyncSource</span>(DispSync* dispSync, <span class="hljs-type">nsecs_t</span> phaseOffset, <span class="hljs-type">bool</span> traceVsync,<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* label) :<br>        <span class="hljs-built_in">mValue</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">mTraceVsync</span>(traceVsync),<br>        <span class="hljs-built_in">mVsyncOnLabel</span>(String8::format(<span class="hljs-string">&quot;VsyncOn-%s&quot;</span>, label)),<br>        <span class="hljs-built_in">mVsyncEventLabel</span>(String8::format(<span class="hljs-string">&quot;VSYNC-%s&quot;</span>, label)),<br>        <span class="hljs-built_in">mDispSync</span>(dispSync),<br>        <span class="hljs-built_in">mCallbackMutex</span>(),<br>        <span class="hljs-built_in">mCallback</span>(),<br>        <span class="hljs-built_in">mVsyncMutex</span>(),<br>        <span class="hljs-built_in">mPhaseOffset</span>(phaseOffset),<br>        <span class="hljs-built_in">mEnabled</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br></code></pre></td></tr></table></figure>

<h5 id="EventThread"><a href="#EventThread" class="headerlink" title="EventThread"></a>EventThread</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">EventThread::<span class="hljs-built_in">EventThread</span>(<span class="hljs-type">const</span> sp&lt;VSyncSource&gt;&amp; src)<br>    : <span class="hljs-built_in">mVSyncSource</span>(src),<br>      <span class="hljs-built_in">mUseSoftwareVSync</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">mVsyncEnabled</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">mDebugVsyncEnabled</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">mVsyncHintSent</span>(<span class="hljs-literal">false</span>) &#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i=<span class="hljs-number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;<br>        mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<br>        mVSyncEvent[i].header.id = <span class="hljs-number">0</span>;<br>        mVSyncEvent[i].header.timestamp = <span class="hljs-number">0</span>;<br>        mVSyncEvent[i].vsync.count =  <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigevent</span> se;<br>    se.sigev_notify = SIGEV_THREAD;<br>    se.sigev_value.sival_ptr = <span class="hljs-keyword">this</span>;<br>    se.sigev_notify_function = vsyncOffCallback;<br>    se.sigev_notify_attributes = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">timer_create</span>(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventThread::onFirstRef</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//运行EventThread线程</span><br>    <span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;EventThread&quot;</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EventThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    DisplayEventReceiver::Event event;<br>    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;<br>  <span class="hljs-comment">//等待事件发生</span><br>    signalConnections = <span class="hljs-built_in">waitForEvent</span>(&amp;event);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> count = signalConnections.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;<br>        <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;Connection&gt;&amp; <span class="hljs-title">conn</span><span class="hljs-params">(signalConnections[i])</span></span>;<br>        <span class="hljs-comment">// 分发事件给所有的监听者</span><br>        <span class="hljs-type">status_t</span> err = conn-&gt;<span class="hljs-built_in">postEvent</span>(event);<br>        <span class="hljs-keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;<br>          <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">removeDisplayEventConnection</span>(signalConnections[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::<span class="hljs-built_in">waitForEvent</span>(<br>        DisplayEventReceiver::Event* event)<br>&#123;<br>    Mutex::Autolock _l(mLock);<br>    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// Here we figure out if we need to enable or disable vsyncs</span><br>        <span class="hljs-keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;<br>            <span class="hljs-built_in">disableVSyncLocked</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;<br>            <span class="hljs-built_in">enableVSyncLocked</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// note: !timestamp implies signalConnections.isEmpty(), because we</span><br>        <span class="hljs-comment">// don&#x27;t populate signalConnections if there&#x27;s no vsync pending</span><br>        <span class="hljs-keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;<br>            <span class="hljs-comment">// wait for something to happen</span><br>            <span class="hljs-keyword">if</span> (waitForVSync) &#123;<br>                <span class="hljs-type">bool</span> softwareSync = mUseSoftwareVSync;<br>                <span class="hljs-type">nsecs_t</span> timeout = softwareSync ? <span class="hljs-built_in">ms2ns</span>(<span class="hljs-number">16</span>) : <span class="hljs-built_in">ms2ns</span>(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">if</span> (mCondition.<span class="hljs-built_in">waitRelative</span>(mLock, timeout) == TIMED_OUT) &#123;<br>                    <span class="hljs-keyword">if</span> (!softwareSync) &#123;<br>                        <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Timed out waiting for hw vsync; faking it&quot;</span>);<br>                    &#125;<br>                    mVSyncEvent[<span class="hljs-number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<br>                    mVSyncEvent[<span class="hljs-number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;<br>                    mVSyncEvent[<span class="hljs-number">0</span>].header.timestamp = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);<br>                    mVSyncEvent[<span class="hljs-number">0</span>].vsync.count++;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mCondition.<span class="hljs-built_in">wait</span>(mLock);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (signalConnections.<span class="hljs-built_in">isEmpty</span>());<br><br>    <span class="hljs-keyword">return</span> signalConnections;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建<code>EventThread</code>线程完毕后，执行<code>threadLoop</code>，通过<code>waitForEvent()</code>等待事件通知。</p>
<p>等待通过<code>mCondition.wait()</code>实现</p>
<h5 id="MessaqeQueue-setEventThread"><a href="#MessaqeQueue-setEventThread" class="headerlink" title="MessaqeQueue#setEventThread"></a>MessaqeQueue#setEventThread</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MessageQueue::setEventThread</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span></span><br><span class="hljs-function"></span>&#123;<br>    mEventThread = eventThread;<br>    mEvents = eventThread-&gt;<span class="hljs-built_in">createEventConnection</span>();<br>    mEventTube = mEvents-&gt;<span class="hljs-built_in">getDataChannel</span>();<br>    mLooper-&gt;<span class="hljs-built_in">addFd</span>(mEventTube-&gt;<span class="hljs-built_in">getFd</span>(), <span class="hljs-number">0</span>, Looper::EVENT_INPUT,<br>            MessageQueue::cb_eventReceiver, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要执行了以下几步：</p>
<h6 id="EventThread-createEventConnection"><a href="#EventThread-createEventConnection" class="headerlink" title="EventThread#createEventConnection"></a>EventThread#createEventConnection</h6><blockquote>
<p>新建<code>BitTube</code>对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/EventThread.cpp</span><br><span class="hljs-function">sp&lt;EventThread::Connection&gt; <span class="hljs-title">EventThread::createEventConnection</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Connection</span>(<span class="hljs-built_in">const_cast</span>&lt;EventThread*&gt;(<span class="hljs-keyword">this</span>));<br>&#125;<br><br>EventThread::Connection::<span class="hljs-built_in">Connection</span>(<br>        <span class="hljs-type">const</span> sp&lt;EventThread&gt;&amp; eventThread)<br>    : <span class="hljs-built_in">count</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">mEventThread</span>(eventThread), <span class="hljs-built_in">mChannel</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">BitTube</span>())<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>构建完成<code>Connection</code>对象，执行如下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> EventThread::Connection::<span class="hljs-built_in">onFirstRef</span>() &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span><br>    mEventThread-&gt;<span class="hljs-built_in">registerDisplayEventConnection</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">EventThread::registerDisplayEventConnection</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;<br>    Mutex::Autolock _l(mLock);<br>    mDisplayEventConnections.<span class="hljs-built_in">add</span>(connection);<br>    mCondition.<span class="hljs-built_in">broadcast</span>();<br>    <span class="hljs-keyword">return</span> NO_ERROR;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始化<code>Connection</code>之后，将<code>Connection</code>对象添加到<code>mDisplayEventConnections</code>中。</p>
<p><code>mDisplayEventConnections</code>主要负责<strong>保存接收Vsync信号的Connection的容器</strong>. 主要存储的是<code>SurfaceFlinger</code>与<code>App</code>的用来接收<code>Vsync信号</code>。</p>
<h6 id="Connection-getDataChannel"><a href="#Connection-getDataChannel" class="headerlink" title="Connection#getDataChannel"></a>Connection#getDataChannel</h6><blockquote>
<p>获取<code>BitTube</code>对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sp&lt;BitTube&gt; EventThread::Connection::<span class="hljs-built_in">getDataChannel</span>() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> mChannel;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/gui/BitTube.cpp</span><br>BitTube::<span class="hljs-built_in">BitTube</span>(<span class="hljs-type">size_t</span> bufsize) &#123;<br>    <span class="hljs-comment">// 创建socket pair，用于发送事件</span><br>    <span class="hljs-built_in">init</span>(bufsize, bufsize);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BitTube::init</span><span class="hljs-params">(<span class="hljs-type">size_t</span> rcvbuf, <span class="hljs-type">size_t</span> sndbuf)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sockets[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">socketpair</span>(AF_UNIX, SOCK_SEQPACKET, <span class="hljs-number">0</span>, sockets) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">size_t</span> size = DEFAULT_SOCKET_BUFFER_SIZE;<br>        <span class="hljs-comment">// 设置socket buffer</span><br>        <span class="hljs-built_in">setsockopt</span>(sockets[<span class="hljs-number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, <span class="hljs-built_in">sizeof</span>(rcvbuf));<br>        <span class="hljs-built_in">setsockopt</span>(sockets[<span class="hljs-number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, <span class="hljs-built_in">sizeof</span>(sndbuf));<br>        <span class="hljs-comment">// since we don&#x27;t use the &quot;return channel&quot;, we keep it small...</span><br>        <span class="hljs-built_in">setsockopt</span>(sockets[<span class="hljs-number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;size, <span class="hljs-built_in">sizeof</span>(size));<br>        <span class="hljs-built_in">setsockopt</span>(sockets[<span class="hljs-number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;size, <span class="hljs-built_in">sizeof</span>(size));<br>        <span class="hljs-built_in">fcntl</span>(sockets[<span class="hljs-number">0</span>], F_SETFL, O_NONBLOCK);<br>        <span class="hljs-built_in">fcntl</span>(sockets[<span class="hljs-number">1</span>], F_SETFL, O_NONBLOCK);<br>        <span class="hljs-comment">// socket[0]用于接收端，最终通过Binder IPC返回给客户端应用</span><br>        mReceiveFd.<span class="hljs-built_in">reset</span>(sockets[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// socket[1]用于发送端</span><br>        mSendFd.<span class="hljs-built_in">reset</span>(sockets[<span class="hljs-number">1</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mReceiveFd.<span class="hljs-built_in">reset</span>();<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;BitTube: pipe creation failed (%s)&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>BitTube</code>实际是一个<code>Socket</code>，所以<code>EventThread</code>实际通过<code>Socket</code>和<code>MessageQueue</code>通信。</p>
<h6 id="Looper-addFd"><a href="#Looper-addFd" class="headerlink" title="Looper#addFd"></a>Looper#addFd</h6><blockquote>
<p>监听<code>BitTube</code>，一旦收到数据调用<code>cb_eventReceiver()</code></p>
</blockquote>
<p>通过<code>Looper</code>监听<code>BitTube</code>的fd。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这一步主要用于接收<code>Vsync信号</code>的初始化操作</p>
<ol>
<li><code>init()</code>中，创建了<code>EventThread</code>用来接收<code>Vsync信号</code></li>
<li>通过<code>MessageQueue.setEventThread()</code>将<code>EventThread</code>与<code>MessageQueue</code>建立关联。实际内部通过<code>BitTube(Socket)</code>建立两者间的通信。</li>
<li>再通过<code>addFd()</code>监听<code>BitTube</code>的套接字fd，这样就可以监听到数据的变化。</li>
</ol>
<h3 id="SurfaceFlinger-run"><a href="#SurfaceFlinger-run" class="headerlink" title="SurfaceFlinger#run"></a>SurfaceFlinger#run</h3><p>最后执行<code>SurfaceFlinger#run</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">waitForEvent</span>();<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::waitForEvent</span><span class="hljs-params">()</span> </span>&#123;<br>    mEventQueue.<span class="hljs-built_in">waitMessage</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MessageQueue::waitMessage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">flushCommands</span>();<br>        <span class="hljs-type">int32_t</span> ret = mLooper-&gt;<span class="hljs-built_in">pollOnce</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">switch</span> (ret) &#123;<br>            <span class="hljs-keyword">case</span> Looper::POLL_WAKE:<br>            <span class="hljs-keyword">case</span> Looper::POLL_CALLBACK:<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> Looper::POLL_ERROR:<br>                <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Looper::POLL_ERROR&quot;</span>);<br>            <span class="hljs-keyword">case</span> Looper::POLL_TIMEOUT:<br>                <span class="hljs-comment">// timeout (should not happen)</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-comment">// should not happen</span><br>                <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Looper::pollOnce() returned unknown status %d&quot;</span>, ret);<br>                <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>waitMessage()</code>等待消息的到来</p>
<p><img src="/images/Sf%E5%88%9D%E5%A7%8B%E5%8C%96.png" srcset="/img/loading.gif" lazyload alt="Sf初始化"></p>
<h2 id="Vsync信号相关"><a href="#Vsync信号相关" class="headerlink" title="Vsync信号相关"></a>Vsync信号相关</h2><h3 id="接收Vsync"><a href="#接收Vsync" class="headerlink" title="接收Vsync"></a>接收Vsync</h3><h4 id="HWC-hook-vsync"><a href="#HWC-hook-vsync" class="headerlink" title="HWC#hook_vsync"></a>HWC#hook_vsync</h4><p><code>Vsync信号</code>都是由<code>HWComposer</code>发出的，需要从<code>HWC</code>进行分析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span><br>HWComposer::<span class="hljs-built_in">HWComposer</span>(<br>        <span class="hljs-type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,<br>        EventHandler&amp; handler)<br>    : <span class="hljs-built_in">mFlinger</span>(flinger),<br>      <span class="hljs-built_in">mFbDev</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">mHwc</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">mNumDisplays</span>(<span class="hljs-number">1</span>),<br>      <span class="hljs-built_in">mCBContext</span>(<span class="hljs-keyword">new</span> cb_context),<br>      <span class="hljs-built_in">mEventHandler</span>(handler),<br>      <span class="hljs-built_in">mDebugForceFakeVSync</span>(<span class="hljs-literal">false</span>)<br>&#123;<br>        ...<br>    <span class="hljs-keyword">if</span> (mHwc) &#123;<br>        <span class="hljs-keyword">if</span> (mHwc-&gt;registerProcs) &#123;<br>            mCBContext-&gt;hwc = <span class="hljs-keyword">this</span>;<br>            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate; <span class="hljs-comment">//invalidate事件回调</span><br>            mCBContext-&gt;procs.vsync = &amp;hook_vsync;<span class="hljs-comment">//Vsync回调</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hwcHasApiVersion</span>(mHwc, HWC_DEVICE_API_VERSION_1_1))<br>                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;<br>            <span class="hljs-keyword">else</span><br>                mCBContext-&gt;procs.hotplug = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(mCBContext-&gt;procs.zero));<br>            mHwc-&gt;<span class="hljs-built_in">registerProcs</span>(mHwc, &amp;mCBContext-&gt;procs);<br>        &#125;          <br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>hook_vsync</code>处理<code>Vsync信号</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HWComposer::hook_vsync</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> hwc_procs* procs, <span class="hljs-type">int</span> disp,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int64_t</span> timestamp)</span> </span>&#123;<br>    cb_context* ctx = <span class="hljs-built_in">reinterpret_cast</span>&lt;cb_context*&gt;(<br>            <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">hwc_procs_t</span>*&gt;(procs));<br>    ctx-&gt;hwc-&gt;<span class="hljs-built_in">vsync</span>(disp, timestamp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HWComposer::vsync</span><span class="hljs-params">(<span class="hljs-type">int</span> disp, <span class="hljs-type">int64_t</span> timestamp)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">uint32_t</span>(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;<br>        &#123;<br>            Mutex::Autolock _l(mLock);<br><br>            mLastHwVSync[disp] = timestamp;<br>        &#125;<br><br>        <span class="hljs-type">char</span> tag[<span class="hljs-number">16</span>];<br>        <span class="hljs-built_in">snprintf</span>(tag, <span class="hljs-built_in">sizeof</span>(tag), <span class="hljs-string">&quot;HW_VSYNC_%1u&quot;</span>, disp);<br>        mEventHandler.<span class="hljs-built_in">onVSyncReceived</span>(disp, timestamp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当<code>hook_vsync</code>收到<code>Vsync信号</code>时，回调到<code>vsync()</code>，继续调用到<code>mEventHandler.onVsyncReceived()</code></p>
<p><code>mEventHandler</code>是在<code>HWC</code>初始化时赋值的，实际就是<code>SurfaceFlinger</code></p>
<h4 id="Sf-onVSyncReceived"><a href="#Sf-onVSyncReceived" class="headerlink" title="Sf#onVSyncReceived"></a>Sf#onVSyncReceived</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::onVSyncReceived</span><span class="hljs-params">(<span class="hljs-type">int</span> type, <span class="hljs-type">nsecs_t</span> timestamp)</span> </span>&#123;<br>    <span class="hljs-type">bool</span> needsHwVsync = <span class="hljs-literal">false</span>;<br><br>    &#123; <span class="hljs-comment">// Scope for the lock</span><br>        Mutex::Autolock _l(mHWVsyncLock);<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">0</span> &amp;&amp; mPrimaryHWVsyncEnabled) &#123;<br>            needsHwVsync = mPrimaryDispSync.<span class="hljs-built_in">addResyncSample</span>(timestamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (needsHwVsync) &#123;<br>        <span class="hljs-built_in">enableHardwareVsync</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">disableHardwareVsync</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;<br>    sp&lt;VSyncSource&gt; vsyncSrc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DispSyncSource</span>(&amp;mPrimaryDispSync,<br>            vsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;app&quot;</span>);<br>    mEventThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EventThread</span>(vsyncSrc);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::enableHardwareVsync</span><span class="hljs-params">()</span> </span>&#123;<br>    Mutex::Autolock _l(mHWVsyncLock);<br>    <span class="hljs-keyword">if</span> (!mPrimaryHWVsyncEnabled &amp;&amp; mHWVsyncAvailable) &#123;<br>        mPrimaryDispSync.<span class="hljs-built_in">beginResync</span>();<br>        <span class="hljs-comment">//申请Vsync信号</span><br>        mEventControlThread-&gt;<span class="hljs-built_in">setVsyncEnabled</span>(<span class="hljs-literal">true</span>);<br>        mPrimaryHWVsyncEnabled = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="DispSync-addResyncSample"><a href="#DispSync-addResyncSample" class="headerlink" title="DispSync#addResyncSample"></a>DispSync#addResyncSample</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DispSync.cpp</span><br>DispSync::<span class="hljs-built_in">DispSync</span>() :<br>        <span class="hljs-built_in">mRefreshSkipCount</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">mThread</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">DispSyncThread</span>()) &#123;<br>    <span class="hljs-comment">//启动DispSyncThread</span><br>    mThread-&gt;<span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;DispSync&quot;</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);<br><br>    <span class="hljs-built_in">reset</span>();<br>    <span class="hljs-built_in">beginResync</span>();<br><br>    <span class="hljs-keyword">if</span> (kTraceDetailedInfo) &#123;<br>        <span class="hljs-keyword">if</span> (!kIgnorePresentFences) &#123;<br>            <span class="hljs-built_in">addEventListener</span>(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">ZeroPhaseTracer</span>());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h6 id="DispSyncThread-threadLoop"><a href="#DispSyncThread-threadLoop" class="headerlink" title="DispSyncThread#threadLoop"></a>DispSyncThread#threadLoop</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DispSync.cpp   </span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>         ...<br>                <span class="hljs-keyword">if</span> (mPeriod == <span class="hljs-number">0</span>) &#123;<br>                    err = mCond.<span class="hljs-built_in">wait</span>(mMutex);<br>                    <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;<br>                        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;error waiting for new events: %s (%d)&quot;</span>,<br>                                <span class="hljs-built_in">strerror</span>(-err), err);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;        <br>               <span class="hljs-comment">//收集Vsync信号回调的方法</span><br>                callbackInvocations = <span class="hljs-built_in">gatherCallbackInvocationsLocked</span>(now);         <br>       &#125;<br><br>            <span class="hljs-keyword">if</span> (callbackInvocations.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">fireCallbackInvocations</span>(callbackInvocations);<br>            &#125;  <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fireCallbackInvocations</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; callbacks.<span class="hljs-built_in">size</span>(); i++) &#123;<br>          <span class="hljs-comment">//回调callback的 onDispSyncEvent</span><br>            callbacks[i].mCallback-&gt;<span class="hljs-built_in">onDispSyncEvent</span>(callbacks[i].mEventTime);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>DispSyncThread</code>通过<code>mCond.wait()</code>等待被唤醒，被唤醒之后回调到<code>onDispSynvEvent()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DispSync::addResyncSample</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> timestamp)</span> </span>&#123;<br>    <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;<br>    <span class="hljs-type">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;<br>    mResyncSamples[idx] = timestamp;<br><br>    <span class="hljs-keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;<br>        mNumResyncSamples++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mFirstResyncSample = (mFirstResyncSample + <span class="hljs-number">1</span>) % MAX_RESYNC_SAMPLES;<br>    &#125;<br>    <span class="hljs-built_in">updateModelLocked</span>();<br><br>    <span class="hljs-keyword">return</span> mPeriod == <span class="hljs-number">0</span> || mError &gt; kErrorThreshold;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;<br>        ...<br>        mPeriod = durationSum / (mNumResyncSamples - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// Artificially inflate the period if requested.</span><br>        mPeriod += mPeriod * mRefreshSkipCount;<br><br>        mThread-&gt;<span class="hljs-built_in">updateModel</span>(mPeriod, mPhase);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="DispsyncThread-updateModel"><a href="#DispsyncThread-updateModel" class="headerlink" title="DispsyncThread#updateModel"></a>DispsyncThread#updateModel</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateModel</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> period, <span class="hljs-type">nsecs_t</span> phase)</span> </span>&#123;<br>    <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;<br>    mPeriod = period;<br>    mPhase = phase;<br>    mCond.<span class="hljs-built_in">signal</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行<code>updateModel()</code>后，唤醒了<code>DispSyncThread</code></p>
<p>在<code>SurfaceFlinger.init()</code>之后初始化设置的<code>DispSyncSource</code>就是<code>callback</code>，然后回调到<code>onDispSyncEvent</code></p>
<h4 id="Sf-DispSyncSource-onDispSyncEvent"><a href="#Sf-DispSyncSource-onDispSyncEvent" class="headerlink" title="Sf.DispSyncSource#onDispSyncEvent"></a>Sf.DispSyncSource#onDispSyncEvent</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onDispSyncEvent</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> when)</span> </span>&#123;<br>    sp&lt;VSyncSource::Callback&gt; callback;<br>    &#123;<br>        <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mCallbackMutex)</span></span>;<br>        callback = mCallback;<br><br>        <span class="hljs-keyword">if</span> (mTraceVsync) &#123;<br>            mValue = (mValue + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">ATRACE_INT</span>(mVsyncEventLabel.<span class="hljs-built_in">string</span>(), mValue);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">NULL</span>) &#123;<br>        callback-&gt;<span class="hljs-built_in">onVSyncEvent</span>(when);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个<code>callback</code>是在<code>EventThread</code>初始化的时候设置的，所以<code>mCallback</code>就是<code>EventThread</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventThread::enableVSyncLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mUseSoftwareVSync) &#123;<br>        <span class="hljs-comment">// never enable h/w VSYNC when screen is off</span><br>        <span class="hljs-keyword">if</span> (!mVsyncEnabled) &#123;<br>            mVsyncEnabled = <span class="hljs-literal">true</span>;<br>            mVSyncSource-&gt;<span class="hljs-built_in">setCallback</span>(<span class="hljs-built_in">static_cast</span>&lt;VSyncSource::Callback*&gt;(<span class="hljs-keyword">this</span>));<br>            mVSyncSource-&gt;<span class="hljs-built_in">setVSyncEnabled</span>(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>    mDebugVsyncEnabled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">sendVsyncHintOnLocked</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>setCallback()</code>建立<code>EventThread</code>与<code>DispSyncSource</code>之间的关联</p>
<h4 id="EventThread-onVsyncEvent"><a href="#EventThread-onVsyncEvent" class="headerlink" title="EventThread#onVsyncEvent"></a>EventThread#onVsyncEvent</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventThread::onVSyncEvent</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> timestamp)</span> </span>&#123;<br>    Mutex::Autolock _l(mLock);<br>    mVSyncEvent[<span class="hljs-number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<br>    mVSyncEvent[<span class="hljs-number">0</span>].header.id = <span class="hljs-number">0</span>;<br>    mVSyncEvent[<span class="hljs-number">0</span>].header.timestamp = timestamp;<br>    mVSyncEvent[<span class="hljs-number">0</span>].vsync.count++;<br>    mCondition.<span class="hljs-built_in">broadcast</span>();<span class="hljs-comment">//唤醒EventThread</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EventThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    DisplayEventReceiver::Event event;<br>    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;<br>  <span class="hljs-comment">//等待事件发生</span><br>    signalConnections = <span class="hljs-built_in">waitForEvent</span>(&amp;event);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> count = signalConnections.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;<br>        <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;Connection&gt;&amp; <span class="hljs-title">conn</span><span class="hljs-params">(signalConnections[i])</span></span>;<br>        <span class="hljs-comment">// 分发事件给所有的监听者</span><br>        <span class="hljs-type">status_t</span> err = conn-&gt;<span class="hljs-built_in">postEvent</span>(event);<br>        <span class="hljs-keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;<br>          <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">removeDisplayEventConnection</span>(signalConnections[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>EventThread#threadLoop</code>在被唤醒后会执行<code>conn-&gt;postEvent()</code></p>
<h5 id="ET-Connection-postEvent"><a href="#ET-Connection-postEvent" class="headerlink" title="ET.Connection#postEvent"></a>ET.Connection#postEvent</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">status_t</span> EventThread::Connection::<span class="hljs-built_in">postEvent</span>(<br>        <span class="hljs-type">const</span> DisplayEventReceiver::Event&amp; event) &#123;<br>    <span class="hljs-type">ssize_t</span> size = DisplayEventReceiver::<span class="hljs-built_in">sendEvents</span>(mChannel, &amp;event, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> size &lt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">status_t</span>(size) : <span class="hljs-built_in">status_t</span>(NO_ERROR);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/gui/DisplayEventReceiver.cpp</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">DisplayEventReceiver::sendEvents</span><span class="hljs-params">(gui::BitTube* dataChannel,</span></span><br><span class="hljs-params"><span class="hljs-function">        Event <span class="hljs-type">const</span>* events, <span class="hljs-type">size_t</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> gui::BitTube::<span class="hljs-built_in">sendObjects</span>(dataChannel, events, count);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>BitTube</code>发送消息，此时就会触发到<code>MQ#cb_eventReceiver</code></p>
<h4 id="MessageQueue-cb-eventReceiver"><a href="#MessageQueue-cb-eventReceiver" class="headerlink" title="MessageQueue#cb_eventReceiver"></a>MessageQueue#cb_eventReceiver</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MessageQueue::cb_eventReceiver</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> events, <span class="hljs-type">void</span>* data)</span> </span>&#123;<br>    MessageQueue* queue = <span class="hljs-built_in">reinterpret_cast</span>&lt;MessageQueue *&gt;(data);<br>    <span class="hljs-keyword">return</span> queue-&gt;<span class="hljs-built_in">eventReceiver</span>(fd, events);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MessageQueue::eventReceiver</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-comment">/*fd*/</span>, <span class="hljs-type">int</span> <span class="hljs-comment">/*events*/</span>)</span> </span>&#123;<br>    <span class="hljs-type">ssize_t</span> n;<br>    DisplayEventReceiver::Event buffer[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">while</span> ((n = DisplayEventReceiver::<span class="hljs-built_in">getEvents</span>(mEventTube, buffer, <span class="hljs-number">8</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;n ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> INVALIDATE_ON_VSYNC</span><br>                mHandler-&gt;<span class="hljs-built_in">dispatchInvalidate</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                mHandler-&gt;<span class="hljs-built_in">dispatchRefresh</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> MessageQueue::Handler::<span class="hljs-built_in">dispatchRefresh</span>() &#123;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">android_atomic_or</span>(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == <span class="hljs-number">0</span>) &#123;<br>        mQueue.mLooper-&gt;<span class="hljs-built_in">sendMessage</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Message</span>(MessageQueue::REFRESH));<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> MessageQueue::Handler::<span class="hljs-built_in">dispatchInvalidate</span>() &#123;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="hljs-number">0</span>) &#123;<br>        mQueue.mLooper-&gt;<span class="hljs-built_in">sendMessage</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Message</span>(MessageQueue::INVALIDATE));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>回调到<code>MessageQueue.Handler</code>的<code>handleMessage()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> MessageQueue::Handler::<span class="hljs-built_in">handleMessage</span>(<span class="hljs-type">const</span> Message&amp; message) &#123;<br>    <span class="hljs-keyword">switch</span> (message.what) &#123;<br>        <span class="hljs-keyword">case</span> INVALIDATE:<br>            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REFRESH:<br>            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> TRANSACTION:<br>            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskTransaction, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Sf-onMessageReceived"><a href="#Sf-onMessageReceived" class="headerlink" title="Sf#onMessageReceived"></a>Sf#onMessageReceived</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> what)</span> </span>&#123;<br>    <span class="hljs-built_in">ATRACE_CALL</span>();<br>    <span class="hljs-keyword">switch</span> (what) &#123;<br>        <span class="hljs-keyword">case</span> MessageQueue::TRANSACTION: &#123;<br>            <span class="hljs-built_in">handleMessageTransaction</span>();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;<br>            <span class="hljs-type">bool</span> refreshNeeded = <span class="hljs-built_in">handleMessageTransaction</span>();<br>            refreshNeeded |= <span class="hljs-built_in">handleMessageInvalidate</span>();<br>            refreshNeeded |= mRepaintEverything;<br>            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;<br>                <span class="hljs-built_in">signalRefresh</span>();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;<br>            <span class="hljs-built_in">handleMessageRefresh</span>();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/SF%E6%8E%A5%E6%94%B6Vsync%E4%BF%A1%E5%8F%B7.jpg" srcset="/img/loading.gif" lazyload alt="SF接收Vsync信号"></p>
<p>接收Vsync信号主要分为以下几步：</p>
<ol>
<li>HWC收到Vsync信号时，回调到<code>hook_vsync</code>，内部执行到<code>sf#onVsyncReceived()</code></li>
<li>继续执行到<code>DispSync#addResyncSample()</code>，然后到<code>DispSyncThread#updateModel()</code>调用<code>mCondition.broadcast()</code>唤醒<code>EventThread</code></li>
<li>唤醒之后执行到<code>DispSyncSource.onDispSyncEvent()</code>继续执行到<code>EventThread.onVsyncEvent()</code>，其中内部调用了<code>DisplayEventReceiver.sendEvents() -&gt; BitTube.sendObjects()</code>发送消息，<code>Looper</code>监听到<code>BitTube</code>有数据流动，就会回调<code>MessageQueue.cb_eventReceiver()</code></li>
<li>继续通过消息机制，回调到<code>MessageQueue.handleMessage()</code>，最后调用<code>Sf.handleMessageReceived()</code></li>
</ol>
<blockquote>
<p>简化版：</p>
<p><code>Vsync信号</code>由<code>HWC</code>产生，然后回调到<code>DispSyncthread</code>在继续回调到<code>DispSyncSource</code>，继续调用到了<code>EventThread</code>。最后<code>EventThread</code>通过<code>BitTube(Socket)</code>发送消息到<code>MessageQueue</code>，<code>MessageQueue</code>接收到消息后，在回调给<code>SurfaceFlinger</code>。</p>
</blockquote>
<h3 id="处理Vsync"><a href="#处理Vsync" class="headerlink" title="处理Vsync"></a>处理Vsync</h3><p>主要在<code>Sf#onMessageReceived()</code>处理<code>Vsync信号</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> what)</span> </span>&#123;<br>        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;<br>            <span class="hljs-type">bool</span> refreshNeeded = <span class="hljs-built_in">handleMessageTransaction</span>();<br>            refreshNeeded |= <span class="hljs-built_in">handleMessageInvalidate</span>();<br>            refreshNeeded |= mRepaintEverything;<br>            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;<br>                <span class="hljs-built_in">signalRefresh</span>();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;  <br>        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;<br>            <span class="hljs-built_in">handleMessageRefresh</span>();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在接受到<code>Vsync信号</code>后，就会回调到<code>MessageQueue::INVALIDATE</code>，继续向下执行到<code>signalRefresh()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::signalRefresh</span><span class="hljs-params">()</span> </span>&#123;<br>    mEventQueue.<span class="hljs-built_in">refresh</span>();<br>&#125;<br><br><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MessageQueue::refresh</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> INVALIDATE_ON_VSYNC</span><br>    mHandler-&gt;<span class="hljs-built_in">dispatchRefresh</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    mEvents-&gt;<span class="hljs-built_in">requestNextVsync</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;	<br><br><span class="hljs-type">void</span> MessageQueue::Handler::<span class="hljs-built_in">dispatchRefresh</span>() &#123;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">android_atomic_or</span>(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == <span class="hljs-number">0</span>) &#123;<br>        mQueue.mLooper-&gt;<span class="hljs-built_in">sendMessage</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Message</span>(MessageQueue::REFRESH));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Sf-handleMessageRefresh"><a href="#Sf-handleMessageRefresh" class="headerlink" title="Sf#handleMessageRefresh"></a>Sf#handleMessageRefresh</h4><p>最后还是执行到了<code>handleMessageRefresh()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::handleMessageRefresh</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">ATRACE_CALL</span>();<br>    <span class="hljs-built_in">preComposition</span>();<br>    <span class="hljs-built_in">rebuildLayerStacks</span>();<br>    <span class="hljs-built_in">setUpHWComposer</span>();<br>    <span class="hljs-built_in">doDebugFlashRegions</span>();<br>    <span class="hljs-built_in">doComposition</span>();<br>    <span class="hljs-built_in">postComposition</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="preComposition-合成前预处理"><a href="#preComposition-合成前预处理" class="headerlink" title="preComposition-合成前预处理"></a>preComposition-合成前预处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::preComposition</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//是否需要刷新布局</span><br>    <span class="hljs-type">bool</span> needExtraInvalidate = <span class="hljs-literal">false</span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> LayerVector&amp; <span class="hljs-title">layers</span><span class="hljs-params">(mDrawingState.layersSortedByZ)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> count = layers.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;<br>       <span class="hljs-comment">//当前Layer发生了变化</span><br>        <span class="hljs-keyword">if</span> (layers[i]-&gt;<span class="hljs-built_in">onPreComposition</span>()) &#123;<br>            needExtraInvalidate = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (needExtraInvalidate) &#123;<br>      <span class="hljs-comment">//申请下一个Vsync信号</span><br>        <span class="hljs-built_in">signalLayerUpdate</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//frameworks/native/services/surfaceflinger/Layer.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Layer::onPreComposition</span><span class="hljs-params">()</span> </span>&#123;<br>    mRefreshPending = <span class="hljs-literal">false</span>;<br>   <span class="hljs-comment">//有待处理的Buffer帧，</span><br>    <span class="hljs-keyword">return</span> mQueuedFrames &gt; <span class="hljs-number">0</span> || mSidebandStreamChanged;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>preComposition()</code>需要先判断<code>Layer</code>是否发生了变化，没发生变化不需要申请下一次Vsync信号，否则执行<code>signalLayerUpdate()</code>申请下一次Vsync信号。</p>
<h6 id="signalLayerUpdate"><a href="#signalLayerUpdate" class="headerlink" title="signalLayerUpdate"></a>signalLayerUpdate</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::signalLayerUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>    mEventQueue.<span class="hljs-built_in">invalidate</span>();<br>&#125;<br><br><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MessageQueue::invalidate</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> INVALIDATE_ON_VSYNC</span><br>    mEvents-&gt;<span class="hljs-built_in">requestNextVsync</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    mHandler-&gt;<span class="hljs-built_in">dispatchInvalidate</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-comment">//frameworks/native/services/surfaceflinger/EventThread.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventThread::requestNextVsync</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;<br>    Mutex::Autolock _l(mLock);<br>    <span class="hljs-keyword">if</span> (connection-&gt;count &lt; <span class="hljs-number">0</span>) &#123;<br>        connection-&gt;count = <span class="hljs-number">0</span>;<br>        mCondition.<span class="hljs-built_in">broadcast</span>();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>唤醒了<code>EventThread</code>，返回Vsync信号通知。</p>
<h5 id="rebuildLayerStacks-重建Layer"><a href="#rebuildLayerStacks-重建Layer" class="headerlink" title="rebuildLayerStacks-重建Layer"></a>rebuildLayerStacks-重建Layer</h5><blockquote>
<p>遍历<code>Layer</code>，计算和存储每个Layer的<code>dirtyRegion</code>，如果<code>dirtyRegion</code>显示在设备的显示区域内，就表示<code>Layer</code>需要重新绘制。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::rebuildLayerStacks</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// rebuild the visible layer list per screen</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(mVisibleRegionsDirty)) &#123;<br>        <span class="hljs-built_in">ATRACE_CALL</span>();<br>        mVisibleRegionsDirty = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">invalidateHwcGeometry</span>();<br><br>        <span class="hljs-function"><span class="hljs-type">const</span> LayerVector&amp; <span class="hljs-title">layers</span><span class="hljs-params">(mDrawingState.layersSortedByZ)</span></span>;<br>      <span class="hljs-comment">//遍历所有显示设备，计算显示设备中dirtyRegion和 opaqueRegion</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.<span class="hljs-built_in">size</span>() ; dpy++) &#123;<br>            Region opaqueRegion;<span class="hljs-comment">//非透明区域</span><br>            Region dirtyRegion;<span class="hljs-comment">//变化区域，需要刷新</span><br>            Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;<br>            <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>            <span class="hljs-function"><span class="hljs-type">const</span> Transform&amp; <span class="hljs-title">tr</span><span class="hljs-params">(hw-&gt;getTransform())</span></span>;<br>            <span class="hljs-function"><span class="hljs-type">const</span> Rect <span class="hljs-title">bounds</span><span class="hljs-params">(hw-&gt;getBounds())</span></span>;<br>            <span class="hljs-keyword">if</span> (hw-&gt;<span class="hljs-built_in">isDisplayOn</span>()) &#123;<br>              <span class="hljs-comment">//计算Layer的 dirtyRegion和 opaqueRegion</span><br>                SurfaceFlinger::<span class="hljs-built_in">computeVisibleRegions</span>(layers,<br>                        hw-&gt;<span class="hljs-built_in">getLayerStack</span>(), dirtyRegion, opaqueRegion);<br><br>                <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> count = layers.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;<br>                    <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(layers[i])</span></span>;<br>                    <span class="hljs-function"><span class="hljs-type">const</span> Layer::State&amp; <span class="hljs-title">s</span><span class="hljs-params">(layer-&gt;getDrawingState())</span></span>;<br>                    <span class="hljs-keyword">if</span> (s.layerStack == hw-&gt;<span class="hljs-built_in">getLayerStack</span>()) &#123;<br>                        <span class="hljs-function">Region <span class="hljs-title">drawRegion</span><span class="hljs-params">(tr.transform(</span></span><br><span class="hljs-params"><span class="hljs-function">                                layer-&gt;visibleNonTransparentRegion))</span></span>;<br>                        drawRegion.<span class="hljs-built_in">andSelf</span>(bounds);<br>                        <span class="hljs-keyword">if</span> (!drawRegion.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>                            layersSortedByZ.<span class="hljs-built_in">add</span>(layer);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>          <span class="hljs-comment">//按照Z轴由小到大排序</span><br>            hw-&gt;<span class="hljs-built_in">setVisibleLayersSortedByZ</span>(layersSortedByZ);<br>            hw-&gt;undefinedRegion.<span class="hljs-built_in">set</span>(bounds);<br>            hw-&gt;undefinedRegion.<span class="hljs-built_in">subtractSelf</span>(tr.<span class="hljs-built_in">transform</span>(opaqueRegion));<br>            hw-&gt;dirtyRegion.<span class="hljs-built_in">orSelf</span>(dirtyRegion);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最重要的是<code>computeVisibleRegions</code>-对Layer的<code>dirtyRegion</code>和<code>opaqueRegion</code>的计算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::computeVisibleRegions</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> LayerVector&amp; currentLayers, <span class="hljs-type">uint32_t</span> layerStack,</span></span><br><span class="hljs-params"><span class="hljs-function">        Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">size_t</span> i = currentLayers.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        <span class="hljs-type">const</span> sp&lt;Layer&gt;&amp; layer = currentLayers[i];<br><br>        <span class="hljs-comment">// start with the whole surface at its current location</span><br>        <span class="hljs-function"><span class="hljs-type">const</span> Layer::State&amp; <span class="hljs-title">s</span><span class="hljs-params">(layer-&gt;getDrawingState())</span></span>;<br><br>        <span class="hljs-comment">// only consider the layers on the given layer stack</span><br>        <span class="hljs-keyword">if</span> (s.layerStack != layerStack)<br>            <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-comment">//非透明区域</span><br>        Region opaqueRegion;<br>      <span class="hljs-comment">//可见区域</span><br>        Region visibleRegion;<br>      <span class="hljs-comment">//被遮盖区域</span><br>        Region coveredRegion;<br>      <span class="hljs-comment">//透明区域</span><br>        Region transparentRegion;<br><br>        <span class="hljs-comment">// handle hidden surfaces by setting the visible region to empty</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_LIKELY</span>(layer-&gt;<span class="hljs-built_in">isVisible</span>())) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">bool</span> translucent = !layer-&gt;<span class="hljs-built_in">isOpaque</span>(s);<br>            <span class="hljs-function">Rect <span class="hljs-title">bounds</span><span class="hljs-params">(s.transform.transform(layer-&gt;computeBounds()))</span></span>;<br>            visibleRegion.<span class="hljs-built_in">set</span>(bounds);<br>            <span class="hljs-keyword">if</span> (!visibleRegion.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>                <span class="hljs-comment">// Remove the transparent area from the visible region</span><br>                <span class="hljs-keyword">if</span> (translucent) &#123;<br>                    <span class="hljs-function"><span class="hljs-type">const</span> Transform <span class="hljs-title">tr</span><span class="hljs-params">(s.transform)</span></span>;<br>                    <span class="hljs-keyword">if</span> (tr.<span class="hljs-built_in">transformed</span>()) &#123;<br>                        <span class="hljs-keyword">if</span> (tr.<span class="hljs-built_in">preserveRects</span>()) &#123;<br>                            <span class="hljs-comment">// transform the transparent region</span><br>                            transparentRegion = tr.<span class="hljs-built_in">transform</span>(s.activeTransparentRegion);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// transformation too complex, can&#x27;t do the</span><br>                            <span class="hljs-comment">// transparent region optimization.</span><br>                            transparentRegion.<span class="hljs-built_in">clear</span>();<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        transparentRegion = s.activeTransparentRegion;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// compute the opaque region</span><br>                <span class="hljs-type">const</span> <span class="hljs-type">int32_t</span> layerOrientation = s.transform.<span class="hljs-built_in">getOrientation</span>();<br>                <span class="hljs-keyword">if</span> (s.alpha==<span class="hljs-number">255</span> &amp;&amp; !translucent &amp;&amp;<br>                        ((layerOrientation &amp; Transform::ROT_INVALID) == <span class="hljs-literal">false</span>)) &#123;<br>                    <span class="hljs-comment">// the opaque region is the layer&#x27;s footprint</span><br>                    opaqueRegion = visibleRegion;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Clip the covered region to the visible region</span><br>        coveredRegion = aboveCoveredLayers.<span class="hljs-built_in">intersect</span>(visibleRegion);<br><br>        <span class="hljs-comment">// 累加当前Layer和上层Layer的可见区域</span><br>        aboveCoveredLayers.<span class="hljs-built_in">orSelf</span>(visibleRegion);<br><br>        <span class="hljs-comment">// 可见区域减去非透明区域</span><br>        visibleRegion.<span class="hljs-built_in">subtractSelf</span>(aboveOpaqueLayers);<br><br>        <span class="hljs-comment">// 计算脏区</span><br>        <span class="hljs-keyword">if</span> (layer-&gt;contentDirty) &#123;<br>            <span class="hljs-comment">// we need to invalidate the whole region</span><br>            dirty = visibleRegion;<br>            <span class="hljs-comment">// as well, as the old visible region</span><br>            dirty.<span class="hljs-built_in">orSelf</span>(layer-&gt;visibleRegion);<br>            layer-&gt;contentDirty = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">const</span> Region newExposed = visibleRegion - coveredRegion;<br>            <span class="hljs-type">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;<br>            <span class="hljs-type">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;<br>            <span class="hljs-type">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;<br>            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);<br>        &#125;<br>        dirty.<span class="hljs-built_in">subtractSelf</span>(aboveOpaqueLayers);<br>       <span class="hljs-comment">//累加脏区</span><br>        outDirtyRegion.<span class="hljs-built_in">orSelf</span>(dirty);<br>       <span class="hljs-comment">//添加非透明区域</span><br>        aboveOpaqueLayers.<span class="hljs-built_in">orSelf</span>(opaqueRegion);<br>       <span class="hljs-comment">//存储可见区域</span><br>        layer-&gt;<span class="hljs-built_in">setVisibleRegion</span>(visibleRegion);<br>        layer-&gt;<span class="hljs-built_in">setCoveredRegion</span>(coveredRegion);<br>        layer-&gt;<span class="hljs-built_in">setVisibleNonTransparentRegion</span>(<br>                visibleRegion.<span class="hljs-built_in">subtract</span>(transparentRegion));<br>    &#125;<br><br>    outOpaqueRegion = aboveOpaqueLayers;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>按照上述源码，界面显示区域分为如下几种：</p>
<ul>
<li><code>opaqueRegion</code>：非透明区域——表示不完全透明的区域</li>
<li><code>dirtyRegion</code>：需要重绘的区域</li>
<li><code>visibleRegion</code>：可见区域——表示完全不透明的区域</li>
<li><code>coveredRegion</code>：被覆盖区域——被完全不透明区域覆盖的区域</li>
<li><code>transparentRegion</code>：完全透明的区域——一般需要从合成列表中移除</li>
<li><code>aboveOpaqueLayers</code>：所有<code>非透明区域</code>的叠加</li>
<li><code>aboveCoveredLayers</code>：所有<code>可见区域</code>的叠加</li>
</ul>
<p>以平常的应用界面来举例。</p>
<p><code>opaqueRegion</code>：状态栏通常都是半透明的，可以看到时间等信息</p>
<p><code>visibleRegion</code>：当前显示的应用界面，就完全遮盖了后面的内容</p>
<p><code>coveredRegion</code>：桌面应用设置的壁纸。</p>
<blockquote>
<p><code>computeVisibleRegions</code>主要完成了以下几步：</p>
<ol>
<li>在<code>Layer的Z轴</code>从上向下遍历该显示设备中的<code>Layer</code></li>
<li>计算被覆盖区域：<code>aboveCoveredLayers</code>与<code>opaqueRegion</code>的交集</li>
<li>计算可见区域：去除<code>opaqueRegion</code>和<code>aboveOpaqueLayers</code>的交集</li>
<li>计算脏区域</li>
<li>保存到<code>Layer</code>中</li>
</ol>
</blockquote>
<h5 id="setUpHWComposer-构造硬件合成的任务"><a href="#setUpHWComposer-构造硬件合成的任务" class="headerlink" title="setUpHWComposer-构造硬件合成的任务"></a>setUpHWComposer-构造硬件合成的任务</h5><blockquote>
<p><code>Layer</code>交给<code>HWComposer</code>去做图层混合。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::setUpHWComposer</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.<span class="hljs-built_in">size</span>() ; dpy++) &#123;<br>        <span class="hljs-type">bool</span> dirty = !mDisplays[dpy]-&gt;<span class="hljs-built_in">getDirtyRegion</span>(<span class="hljs-literal">false</span>).<span class="hljs-built_in">isEmpty</span>();<br>        <span class="hljs-type">bool</span> empty = mDisplays[dpy]-&gt;<span class="hljs-built_in">getVisibleLayersSortedByZ</span>().<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;<br>       <span class="hljs-comment">//没有脏区域或者可见的Layer，就不需要进行合成</span><br>        <span class="hljs-type">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);<br>      <br>        mDisplays[dpy]-&gt;<span class="hljs-built_in">beginFrame</span>(mustRecompose);<br><br>        <span class="hljs-keyword">if</span> (mustRecompose) &#123;<br>            mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;<br>        &#125;      <br>    &#125;<br>  <br>  <span class="hljs-comment">//构造HWComposer硬件任务</span><br>    <span class="hljs-function">HWComposer&amp; <span class="hljs-title">hwc</span><span class="hljs-params">(getHwComposer())</span></span>;<br>    <span class="hljs-keyword">if</span> (hwc.<span class="hljs-built_in">initCheck</span>() == NO_ERROR) &#123;<br>        <span class="hljs-comment">// build the h/w work list</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(mHwWorkListDirty)) &#123;<br>            mHwWorkListDirty = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.<span class="hljs-built_in">size</span>() ; dpy++) &#123;<br>                <span class="hljs-function">sp&lt;<span class="hljs-type">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int32_t</span> id = hw-&gt;<span class="hljs-built_in">getHwcDisplayId</span>();<br>                <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="hljs-built_in">currentLayers</span>(<br>                        hw-&gt;<span class="hljs-built_in">getVisibleLayersSortedByZ</span>());<br>                    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> count = currentLayers.<span class="hljs-built_in">size</span>();<br>                  <span class="hljs-comment">//在HWC创建任务列表</span><br>                    <span class="hljs-keyword">if</span> (hwc.<span class="hljs-built_in">createWorkList</span>(id, count) == NO_ERROR) &#123;<br>                        HWComposer::LayerListIterator cur = hwc.<span class="hljs-built_in">begin</span>(id);<br>                        <span class="hljs-type">const</span> HWComposer::LayerListIterator end = hwc.<span class="hljs-built_in">end</span>(id);<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;<br>                            <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(currentLayers[i])</span></span>;<br>                            layer-&gt;<span class="hljs-built_in">setGeometry</span>(hw, *cur);<br>                            <span class="hljs-keyword">if</span> (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123;<br>                                cur-&gt;<span class="hljs-built_in">setSkip</span>(<span class="hljs-literal">true</span>);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置每帧的数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.<span class="hljs-built_in">size</span>() ; dpy++) &#123;<br>            <span class="hljs-function">sp&lt;<span class="hljs-type">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int32_t</span> id = hw-&gt;<span class="hljs-built_in">getHwcDisplayId</span>();<br>            <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="hljs-built_in">currentLayers</span>(<br>                    hw-&gt;<span class="hljs-built_in">getVisibleLayersSortedByZ</span>());<br>                <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> count = currentLayers.<span class="hljs-built_in">size</span>();<br>                HWComposer::LayerListIterator cur = hwc.<span class="hljs-built_in">begin</span>(id);<br>                <span class="hljs-type">const</span> HWComposer::LayerListIterator end = hwc.<span class="hljs-built_in">end</span>(id);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;<br>                    <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(currentLayers[i])</span></span>;<br>                    layer-&gt;<span class="hljs-built_in">setPerFrameData</span>(hw, *cur);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">status_t</span> err = hwc.<span class="hljs-built_in">prepare</span>();<br>        <span class="hljs-built_in">ALOGE_IF</span>(err, <span class="hljs-string">&quot;HWComposer::prepare failed (%s)&quot;</span>, <span class="hljs-built_in">strerror</span>(-err));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.<span class="hljs-built_in">size</span>() ; dpy++) &#123;<br>            <span class="hljs-function">sp&lt;<span class="hljs-type">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>            hw-&gt;<span class="hljs-built_in">prepareFrame</span>(hwc);<br>        &#125;<br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="doComposition-执行合成任务"><a href="#doComposition-执行合成任务" class="headerlink" title="doComposition-执行合成任务"></a>doComposition-执行合成任务</h5><blockquote>
<p>前面已经准备好了<code>合成Layer任务</code>和<code>需要合成的数据</code>，现在就需要做图像的混合工作。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::doComposition</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">ATRACE_CALL</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> repaintEverything = <span class="hljs-built_in">android_atomic_and</span>(<span class="hljs-number">0</span>, &amp;mRepaintEverything);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.<span class="hljs-built_in">size</span>() ; dpy++) &#123;<br>        <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>        <span class="hljs-keyword">if</span> (hw-&gt;<span class="hljs-built_in">isDisplayOn</span>()) &#123;<br>            <span class="hljs-comment">// transform the dirty region into this screen&#x27;s coordinate space</span><br>            <span class="hljs-function"><span class="hljs-type">const</span> Region <span class="hljs-title">dirtyRegion</span><span class="hljs-params">(hw-&gt;getDirtyRegion(repaintEverything))</span></span>;<br><br>            <span class="hljs-comment">// repaint the framebuffer (if needed)</span><br>            <span class="hljs-built_in">doDisplayComposition</span>(hw, dirtyRegion);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">postFramebuffer</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>doComposition()</code>主要执行以下两步</p>
<h6 id="doDisplayComposition"><a href="#doDisplayComposition" class="headerlink" title="doDisplayComposition"></a>doDisplayComposition</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::doDisplayComposition</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;<span class="hljs-type">const</span> DisplayDevice&gt;&amp; hw,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> Region&amp; inDirtyRegion)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//是否硬件绘制</span><br>    <span class="hljs-type">bool</span> isHwcDisplay = hw-&gt;<span class="hljs-built_in">getHwcDisplayId</span>() &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!isHwcDisplay &amp;&amp; inDirtyRegion.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>  <br>  ...<br>    <span class="hljs-comment">//进行合成</span><br>       <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">doComposeSurfaces</span>(hw, dirtyRegion)) <span class="hljs-keyword">return</span>;  <br>  ...<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SurfaceFlinger::doComposeSurfaces</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;<span class="hljs-type">const</span> DisplayDevice&gt;&amp; hw, <span class="hljs-type">const</span> Region&amp; dirty)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>    <span class="hljs-type">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="hljs-built_in">layers</span>(hw-&gt;<span class="hljs-built_in">getVisibleLayersSortedByZ</span>());<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> count = layers.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">const</span> Transform&amp; tr = hw-&gt;<span class="hljs-built_in">getTransform</span>();<br>    <span class="hljs-keyword">if</span> (cur != end) &#123;<br>        <span class="hljs-comment">// 使用硬件合成</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count &amp;&amp; cur!=end ; ++i, ++cur) &#123;<br>            <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(layers[i])</span></span>;<br>            <span class="hljs-function"><span class="hljs-type">const</span> Region <span class="hljs-title">clip</span><span class="hljs-params">(dirty.intersect(tr.transform(layer-&gt;visibleRegion)))</span></span>;<br>            <span class="hljs-keyword">if</span> (!clip.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>                <span class="hljs-keyword">switch</span> (cur-&gt;<span class="hljs-built_in">getCompositionType</span>()) &#123;<br>                    <span class="hljs-keyword">case</span> HWC_CURSOR_OVERLAY:<br>                    <span class="hljs-keyword">case</span> HWC_OVERLAY: &#123;<br>                        <span class="hljs-function"><span class="hljs-type">const</span> Layer::State&amp; <span class="hljs-title">state</span><span class="hljs-params">(layer-&gt;getDrawingState())</span></span>;<br>                        <span class="hljs-keyword">if</span> ((cur-&gt;<span class="hljs-built_in">getHints</span>() &amp; HWC_HINT_CLEAR_FB)<br>                                &amp;&amp; i<br>                                &amp;&amp; layer-&gt;<span class="hljs-built_in">isOpaque</span>(state) &amp;&amp; (state.alpha == <span class="hljs-number">0xFF</span>)<br>                                &amp;&amp; hasGlesComposition) &#123;<br>                            <span class="hljs-comment">// never clear the very first layer since we&#x27;re</span><br>                            <span class="hljs-comment">// guaranteed the FB is already cleared</span><br>                            layer-&gt;<span class="hljs-built_in">clearWithOpenGL</span>(hw, clip);<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> HWC_FRAMEBUFFER: &#123;<br>                        layer-&gt;<span class="hljs-built_in">draw</span>(hw, clip);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> HWC_FRAMEBUFFER_TARGET: &#123;<br>                        <span class="hljs-comment">// this should not happen as the iterator shouldn&#x27;t</span><br>                        <span class="hljs-comment">// let us get there.</span><br>                        <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;HWC_FRAMEBUFFER_TARGET found in hwc list (index=%zu)&quot;</span>, i);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            layer-&gt;<span class="hljs-built_in">setAcquireFence</span>(hw, *cur);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 不使用硬件合成</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; ++i) &#123;<br>            <span class="hljs-type">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-built_in">layer</span>(layers[i]);<br>            <span class="hljs-function"><span class="hljs-type">const</span> Region <span class="hljs-title">clip</span><span class="hljs-params">(dirty.intersect(</span></span><br><span class="hljs-params"><span class="hljs-function">                    tr.transform(layer-&gt;visibleRegion)))</span></span>;<br>            <span class="hljs-keyword">if</span> (!clip.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>                layer-&gt;<span class="hljs-built_in">draw</span>(hw, clip);<br>            &#125;<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="postFrameBuffer"><a href="#postFrameBuffer" class="headerlink" title="postFrameBuffer"></a>postFrameBuffer</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::postFramebuffer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ATRACE_CALL</span>();<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">nsecs_t</span> now = <span class="hljs-built_in">systemTime</span>();<br>    mDebugInSwapBuffers = now;<br><br>    <span class="hljs-function">HWComposer&amp; <span class="hljs-title">hwc</span><span class="hljs-params">(getHwComposer())</span></span>;<br>    <span class="hljs-keyword">if</span> (hwc.<span class="hljs-built_in">initCheck</span>() == NO_ERROR) &#123;<br>        <span class="hljs-keyword">if</span> (!hwc.<span class="hljs-built_in">supportsFramebufferTarget</span>()) &#123;<br>            <span class="hljs-comment">// EGL spec says:</span><br>            <span class="hljs-comment">//   &quot;surface must be bound to the calling thread&#x27;s current context,</span><br>            <span class="hljs-comment">//    for the current rendering API.&quot;</span><br>            <span class="hljs-built_in">getDefaultDisplayDevice</span>()-&gt;<span class="hljs-built_in">makeCurrent</span>(mEGLDisplay, mEGLContext);<br>        &#125;<br>        hwc.<span class="hljs-built_in">commit</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">getDefaultDisplayDevice</span>()-&gt;<span class="hljs-built_in">makeCurrent</span>(mEGLDisplay, mEGLContext);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.<span class="hljs-built_in">size</span>() ; dpy++) &#123;<br>        <span class="hljs-function">sp&lt;<span class="hljs-type">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>        <span class="hljs-type">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="hljs-built_in">currentLayers</span>(hw-&gt;<span class="hljs-built_in">getVisibleLayersSortedByZ</span>());<br>        hw-&gt;<span class="hljs-built_in">onSwapBuffersCompleted</span>(hwc);<br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> count = currentLayers.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int32_t</span> id = hw-&gt;<span class="hljs-built_in">getHwcDisplayId</span>();<br>        <span class="hljs-keyword">if</span> (id &gt;=<span class="hljs-number">0</span> &amp;&amp; hwc.<span class="hljs-built_in">initCheck</span>() == NO_ERROR) &#123;<br>            HWComposer::LayerListIterator cur = hwc.<span class="hljs-built_in">begin</span>(id);<br>            <span class="hljs-type">const</span> HWComposer::LayerListIterator end = hwc.<span class="hljs-built_in">end</span>(id);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123;<br>                currentLayers[i]-&gt;<span class="hljs-built_in">onLayerDisplayed</span>(hw, &amp;*cur);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                currentLayers[i]-&gt;<span class="hljs-built_in">onLayerDisplayed</span>(hw, <span class="hljs-literal">NULL</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    mLastSwapBufferTime = <span class="hljs-built_in">systemTime</span>() - now;<br>    mDebugInSwapBuffers = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">uint32_t</span> flipCount = <span class="hljs-built_in">getDefaultDisplayDevice</span>()-&gt;<span class="hljs-built_in">getPageFlipCount</span>();<br>    <span class="hljs-keyword">if</span> (flipCount % LOG_FRAME_STATS_PERIOD == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">logFrameStats</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>doComposition</code>  </p>
<ul>
<li><code>doDisplayComposition</code>：重绘<code>FrameBuffer</code>，并进行合成</li>
<li><code>postFrameBuffer</code>：将数据写入到<code>FrameBuffer</code>然后完成物理屏幕的图像显示</li>
</ul>
<h5 id="postComposition-合成图形结束后的处理"><a href="#postComposition-合成图形结束后的处理" class="headerlink" title="postComposition-合成图形结束后的处理"></a>postComposition-合成图形结束后的处理</h5><blockquote>
<p>此时图层已经混合完成，图像数据也被送到了<code>帧缓冲(FrameBuffer)</code>，并且已经显示在屏幕上了，由<code>postComposition()</code>进行一些收尾工作的处理。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::postComposition</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> LayerVector&amp; <span class="hljs-title">layers</span><span class="hljs-params">(mDrawingState.layersSortedByZ)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> count = layers.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;<br>        layers[i]-&gt;<span class="hljs-built_in">onPostComposition</span>();<br>    &#125;<br>  ...<br>    <span class="hljs-comment">//更新 swapBuffer 记录时间</span><br>    <span class="hljs-type">nsecs_t</span> currentTime = <span class="hljs-built_in">systemTime</span>();<br>    <span class="hljs-keyword">if</span> (mHasPoweredOff) &#123;<br>        mHasPoweredOff = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">nsecs_t</span> period = mPrimaryDispSync.<span class="hljs-built_in">getPeriod</span>();<br>        <span class="hljs-type">nsecs_t</span> elapsedTime = currentTime - mLastSwapTime;<br>        <span class="hljs-type">size_t</span> numPeriods = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(elapsedTime / period);<br>        <span class="hljs-keyword">if</span> (numPeriods &lt; NUM_BUCKETS - <span class="hljs-number">1</span>) &#123;<br>            mFrameBuckets[numPeriods] += elapsedTime;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mFrameBuckets[NUM_BUCKETS - <span class="hljs-number">1</span>] += elapsedTime;<br>        &#125;<br>        mTotalTime += elapsedTime;<br>    &#125;<br>    mLastSwapTime = currentTime;    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/SF%E5%A4%84%E7%90%86Vsync%E4%BF%A1%E5%8F%B7.jpg" srcset="/img/loading.gif" lazyload alt="SF处理Vsync信号"></p>
<h2 id="Android图形缓冲区"><a href="#Android图形缓冲区" class="headerlink" title="Android图形缓冲区"></a>Android图形缓冲区</h2><p>Android的图形缓冲区主要由以下几部分组成：</p>
<ul>
<li><code>Surface</code></li>
<li><code>Layer</code></li>
<li><code>GraphicBuffer</code></li>
<li><code>BufferQueue</code></li>
</ul>
<h3 id="Surface相关"><a href="#Surface相关" class="headerlink" title="Surface相关"></a>Surface相关</h3><blockquote>
<p><strong><code>Surface</code>是提供给<code>图形生产者</code>控制缓冲区的</strong></p>
<p>在<code>软件绘制</code>中，调用<code>drawSoftware(surface)</code>传入<code>Surface缓冲区</code>到<code>native</code>层的<code>SkiaCanvas</code></p>
<p>在<code>硬件绘制</code>中，调用<code>ThreadedRenderer.initalize(surface)</code>传入<code>Surface缓冲区</code>到OpenGL中进行渲染。</p>
<p>当得到<code>Surface缓冲区</code>后，就可以存入<strong>需要绘制的内容</strong>到<code>Surface</code>中。</p>
</blockquote>
<p><code>Surface</code>内部持有<code>BufferQueue中的GraphicBufferProducer</code>，主要负责<strong>创建或获取可用的<code>GraphicBuffer</code>以及提交绘制后的<code>GraphicBuffer</code></strong>。</p>
<h3 id="Layer相关"><a href="#Layer相关" class="headerlink" title="Layer相关"></a>Layer相关</h3><blockquote>
<p><strong><code>Layer</code>是提供给<code>图形消费者</code>获取缓冲区的</strong></p>
<p>在<code>SurfaceFlinger</code>需要消费图形数据，进行图层混合时，在<code>rebuildLayerStacks()</code>进行<code>Layer</code>遍历，取出<code>Layer</code>中的图形数据，进行数据合成处理。</p>
</blockquote>
<p><code>Layer</code>内部持有<code>BufferQueue中的GraphicBufferConsumer</code>，主要负责<strong>获取和释放<code>GraphicBuffer</code></strong></p>
<h3 id="GraphicBuffer"><a href="#GraphicBuffer" class="headerlink" title="GraphicBuffer"></a>GraphicBuffer</h3><blockquote>
<p>真正被分配内存，并能存储图形数据的缓冲区。</p>
</blockquote>
<h3 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h3><blockquote>
<p>存放<code>GraphicBuffer</code>的数组结构，最多可以存储<strong>64</strong>个<code>GraphicBuffer</code></p>
</blockquote>
<p><img src="/images/BufferQueue%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt="BufferQueue执行流程"></p>
<blockquote>
<p>当绘制图像时，首先去创建<code>Surface</code>和<code>Layer</code>，</p>
<p>然后<code>图像生产者</code>通过<code>Surface</code>调用<code>dequeue()</code>申请一块<code>GraphicBuffer</code>，在其上绘制图像</p>
<p>绘制完毕后，通过<code>Surface</code>调用<code>queue()</code>把绘制好的<code>GraphicBuffer</code>返回到<code>BufferQueue</code>中。</p>
<p>收到<code>HWComposer</code>发出的<code>Vsync信号后</code>，<code>SurfaceFlinger</code>通过<code>Layer</code>调用<code>acquire()</code>获取绘制好的<code>GraphicBuffer</code>进行合成与处理</p>
<p>处理完毕后通过<code>Layer</code>调用<code>release()</code>释放<code>GraphicBuffer</code>并返回到<code>BufferQueue</code>中。</p>
</blockquote>
<h3 id="缓冲区创建流程"><a href="#缓冲区创建流程" class="headerlink" title="缓冲区创建流程"></a>缓冲区创建流程</h3><h4 id="Activity创建图形缓冲区"><a href="#Activity创建图形缓冲区" class="headerlink" title="Activity创建图形缓冲区"></a>Activity创建图形缓冲区</h4><p>其中最常见的场景在<code>ViewRootImpl</code>的创建过程中，在其中执行了<code>Surface</code>的创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewRootImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ViewParent</span>,<br>        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks &#123;<br>          ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Surface</span> <span class="hljs-variable">mSurface</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Surface</span>();<br>          <br>        &#125;<br></code></pre></td></tr></table></figure>

<p>主要在<code>WindowManagerGlobal.addView()</code>构造的<code>ViewRootImpl</code>对象。</p>
<p>此时创建的只是Java层的<code>Surface</code>，还需要绑定Native层的<code>Surface</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> &#123;<br>               <span class="hljs-comment">//执行绘制流程 测量-布局-绘制</span><br>                requestLayout();<br>                <span class="hljs-keyword">if</span> ((mWindowAttributes.inputFeatures<br>                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="hljs-number">0</span>) &#123;<br>                  <span class="hljs-comment">//触摸事件回调</span><br>                    mInputChannel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputChannel</span>();<br>                &#125;<br>                mForceDecorViewVisibility = (mWindowAttributes.privateFlags<br>                        &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    mOrigWindowType = mWindowAttributes.type;<br>                    mAttachInfo.mRecomputeGlobalAttributes = <span class="hljs-literal">true</span>;<br>                    collectViewAttributes();<br>                   <span class="hljs-comment">//添加窗口</span><br>                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,<br>                            getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,<br>                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,<br>                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);<br>                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                   ...<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (restore) &#123;<br>                        attrs.restore();<br>                    &#125;<br>                &#125;      <br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>setView()</code>主要做了两件事情：</p>
<ul>
<li><code>requestLayout</code>：主要是执行到<code>relayoutWindow</code>创建了<code>Surface</code>和<code>Layer</code></li>
<li><code>addToDisplay</code>：创建了<code>SurfaceComponentClient</code></li>
</ul>
<p><code>requestLayout</code>需要在<code>addToDisplay</code>执行完毕后才可以执行。</p>
<br>

<h5 id="WS-addToDisplay"><a href="#WS-addToDisplay" class="headerlink" title="WS#addToDisplay"></a>WS#addToDisplay</h5><p><code>WS#addToDisplay()</code>执行过程</p>
<p><code>WindowSession</code>表示<strong>Java层的Window和WMS通信的对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//com.android.server.wm.Session</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IWindowSession</span>.Stub <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBinder</span>.DeathRecipient &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addToDisplayWithoutInputChannel</span><span class="hljs-params">(IWindow window, <span class="hljs-type">int</span> seq, WindowManager.LayoutParams attrs,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> viewVisibility, <span class="hljs-type">int</span> displayId, Rect outContentInsets, Rect outStableInsets)</span> &#123;<br>        <span class="hljs-keyword">return</span> mService.addWindow(<span class="hljs-built_in">this</span>, window, seq, attrs, viewVisibility, displayId,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rect</span>() <span class="hljs-comment">/* outFrame */</span>, outContentInsets, outStableInsets, <span class="hljs-literal">null</span> <span class="hljs-comment">/* outOutsets */</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayCutout</span>.ParcelableWrapper() <span class="hljs-comment">/* cutout */</span>, <span class="hljs-literal">null</span> <span class="hljs-comment">/* outInputChannel */</span>);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>mService</code>表示的就是<code>WindowManagerService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//WindowManagerService.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addWindow</span><span class="hljs-params">(Session session, IWindow client, <span class="hljs-type">int</span> seq,</span><br><span class="hljs-params">            LayoutParams attrs, <span class="hljs-type">int</span> viewVisibility, <span class="hljs-type">int</span> displayId, Rect outFrame,</span><br><span class="hljs-params">            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span><br><span class="hljs-params">            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel)</span> &#123;<br>      ...      <br>      <span class="hljs-keyword">synchronized</span>(mWindowMap) &#123;<br>            <span class="hljs-type">AppWindowToken</span> <span class="hljs-variable">atoken</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasParent</span> <span class="hljs-operator">=</span> parentWindow != <span class="hljs-literal">null</span>;<br>          <span class="hljs-comment">//创建WindowToken</span><br>            <span class="hljs-type">WindowToken</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> displayContent.getWindowToken(<br>                    hasParent ? parentWindow.mAttrs.token : attrs.token);        <br>        ...<br>          <span class="hljs-comment">//创建WindowState对象</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">WindowState</span> <span class="hljs-variable">win</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowState</span>(<span class="hljs-built_in">this</span>, session, client, token, parentWindow,<br>                    appOp[<span class="hljs-number">0</span>], seq, attrs, viewVisibility, session.mUid,<br>                    session.mCanAddInternalSystemWindow); <br>        ...<br>          <span class="hljs-comment">//附加窗口</span><br>            win.attach();<br>            mWindowMap.put(client.asBinder(), win);          <br>      &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>这里重点关注<code>WindowState#attach</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//WindowState.java</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Attaching &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; token=&quot;</span> + mToken);<br>        mSession.windowAddedLocked(mAttrs.packageName);<br>    &#125;<br><br><span class="hljs-comment">//Session.java</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowAddedLocked</span><span class="hljs-params">(String packageName)</span> &#123;<br>        mPackageName = packageName;<br>        mRelayoutTag = <span class="hljs-string">&quot;relayoutWindow: &quot;</span> + mPackageName;<br>        <span class="hljs-keyword">if</span> (mSurfaceSession == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (WindowManagerService.localLOGV) Slog.v(<br>                TAG_WM, <span class="hljs-string">&quot;First window added to &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot;, creating SurfaceSession&quot;</span>);<br>            mSurfaceSession = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SurfaceSession</span>();<br>          ...<br>        &#125;<br>        mNumWindow++;<br>    &#125;<br><br><span class="hljs-comment">//SurfaceSession.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SurfaceSession</span><span class="hljs-params">()</span> &#123;<br>        mNativeClient = nativeCreate();<br>    &#125;<br><br><span class="hljs-comment">//android_view_SurfaceSession.cpp</span><br><span class="hljs-keyword">static</span> jlong <span class="hljs-title function_">nativeCreate</span><span class="hljs-params">(JNIEnv* env, jclass clazz)</span> &#123;<br>    SurfaceComposerClient* client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SurfaceComposerClient</span>();<br>    client-&gt;incStrong((<span class="hljs-keyword">void</span>*)nativeCreate);<br>    <span class="hljs-keyword">return</span> reinterpret_cast&lt;jlong&gt;(client);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过上述步骤最后创建了<code>SurfaceComponentClient</code></p>
<p><code>addToDisplay</code>执行完毕后，回调到<code>performTraversals()</code></p>
<h5 id="WS-relayoutWindow"><a href="#WS-relayoutWindow" class="headerlink" title="WS#relayoutWindow"></a>WS#relayoutWindow</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performTraversals</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">layoutRequested</span> <span class="hljs-operator">=</span> mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>      ...<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">surfaceGenerationId</span> <span class="hljs-operator">=</span> mSurface.getGenerationId();<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isViewVisible</span> <span class="hljs-operator">=</span> viewVisibility == View.VISIBLE;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">windowRelayoutWasForced</span> <span class="hljs-operator">=</span> mForceNextWindowRelayout;<br>        <span class="hljs-keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||<br>                viewVisibilityChanged || params != <span class="hljs-literal">null</span> || mForceNextWindowRelayout) &#123;<br>            mForceNextWindowRelayout = <span class="hljs-literal">false</span>;<br>          ...<br>            <span class="hljs-keyword">try</span> &#123;            <br>             relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);<br>              ...<br>            &#125;<span class="hljs-keyword">catch</span>(RemoteException e)&#123;<br>              <br>            &#125;<br>            <span class="hljs-keyword">if</span> (!mStopped || mReportNextDraw) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">focusChangedDueToTouchMode</span> <span class="hljs-operator">=</span> ensureTouchModeLocally(<br>                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()<br>                        || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||<br>                        updatedConfiguration) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">childWidthMeasureSpec</span> <span class="hljs-operator">=</span> getRootMeasureSpec(mWidth, lp.width);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">childHeightMeasureSpec</span> <span class="hljs-operator">=</span> getRootMeasureSpec(mHeight, lp.height);<br>                  <span class="hljs-comment">//执行测量流程</span><br>                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);  <br>                  ...<br>                &#125;<br>            &#125;<br>          <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">didLayout</span> <span class="hljs-operator">=</span> layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>        <span class="hljs-keyword">if</span> (didLayout) &#123;<br>          <span class="hljs-comment">//执行布局过程</span><br>            performLayout(lp, mWidth, mHeight);<br>        &#125;<br>      &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelDraw</span> <span class="hljs-operator">=</span> mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;<br>        <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;<br>            <span class="hljs-keyword">if</span> (mPendingTransitions != <span class="hljs-literal">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;<br>                    mPendingTransitions.get(i).startChangingAnimations();<br>                &#125;<br>                mPendingTransitions.clear();<br>            &#125;<br>           <span class="hljs-comment">//执行绘制流程</span><br>            performDraw();<br>        &#125; <br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>performTraversals()</code>主要做了以下几步：</p>
<ol>
<li><code>relayoutWindow</code>——创建<code>Surface</code>和<code>Layout</code></li>
<li><code>performMeasure</code>——测量过程</li>
<li><code>performLayout</code>——布局过程</li>
<li><code>performDraw</code>——绘制过程</li>
</ol>
<p>接下来主要分析<code>relayoutWindow</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">relayoutWindow</span><span class="hljs-params">(WindowManager.LayoutParams params, <span class="hljs-type">int</span> viewVisibility,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> insetsPending)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>      ...<br>        <span class="hljs-type">int</span> <span class="hljs-variable">relayoutResult</span> <span class="hljs-operator">=</span> mWindowSession.relayout(mWindow, mSeq, params,<br>                (<span class="hljs-type">int</span>) (mView.getMeasuredWidth() * appScale + <span class="hljs-number">0.5f</span>),<br>                (<span class="hljs-type">int</span>) (mView.getMeasuredHeight() * appScale + <span class="hljs-number">0.5f</span>), viewVisibility,<br>                insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="hljs-number">0</span>, frameNumber,<br>                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,<br>                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingDisplayCutout,<br>                mPendingMergedConfiguration, mSurface);      <br>    &#125;<br><br><span class="hljs-comment">//Session.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">relayout</span><span class="hljs-params">(IWindow window, <span class="hljs-type">int</span> seq, WindowManager.LayoutParams attrs,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> requestedWidth, <span class="hljs-type">int</span> requestedHeight, <span class="hljs-type">int</span> viewFlags, <span class="hljs-type">int</span> flags, <span class="hljs-type">long</span> frameNumber,</span><br><span class="hljs-params">            Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets,</span><br><span class="hljs-params">            Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span><br><span class="hljs-params">            DisplayCutout.ParcelableWrapper cutout, MergedConfiguration mergedConfiguration,</span><br><span class="hljs-params">            Surface outSurface)</span> &#123;<br>      ...<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> mService.relayoutWindow(<span class="hljs-built_in">this</span>, window, seq, attrs,<br>                requestedWidth, requestedHeight, viewFlags, flags, frameNumber,<br>                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,<br>                outStableInsets, outsets, outBackdropFrame, cutout,<br>                mergedConfiguration, outSurface);<br>      ...<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-comment">//WindowManagerService.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">relayoutWindow</span><span class="hljs-params">(Session session, IWindow client, <span class="hljs-type">int</span> seq, LayoutParams attrs,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> requestedWidth, <span class="hljs-type">int</span> requestedHeight, <span class="hljs-type">int</span> viewVisibility, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">            <span class="hljs-type">long</span> frameNumber, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span><br><span class="hljs-params">            Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,</span><br><span class="hljs-params">            DisplayCutout.ParcelableWrapper outCutout, MergedConfiguration mergedConfiguration,</span><br><span class="hljs-params">            Surface outSurface)</span> &#123;<br>      ...<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">shouldRelayout</span> <span class="hljs-operator">=</span> viewVisibility == View.VISIBLE &amp;&amp;<br>                    (win.mAppToken == <span class="hljs-literal">null</span> || win.mAttrs.type == TYPE_APPLICATION_STARTING<br>                            || !win.mAppToken.isClientHidden());        <br>            <span class="hljs-keyword">if</span> (shouldRelayout) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-comment">//创建SurfaceControl</span><br>                    result = createSurfaceControl(outSurface, result, win, winAnimator);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                  ...<br>                &#125;              <br>            &#125;<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>

<p>接下来执行到<code>createSurfaceControl</code></p>
<h6 id="WMS-createSurfaceControl"><a href="#WMS-createSurfaceControl" class="headerlink" title="WMS#createSurfaceControl"></a>WMS#createSurfaceControl</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">createSurfaceControl</span><span class="hljs-params">(Surface outSurface, <span class="hljs-type">int</span> result, WindowState win,</span><br><span class="hljs-params">        WindowStateAnimator winAnimator)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!win.mHasSurface) &#123;<br>        result |= RELAYOUT_RES_SURFACE_CHANGED;<br>    &#125;<br><br>    WindowSurfaceController surfaceController;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="hljs-string">&quot;createSurfaceControl&quot;</span>);<br>      <span class="hljs-comment">//创建SurfaceControl</span><br>        surfaceController = winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (surfaceController != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//创建Surface</span><br>        surfaceController.getSurface(outSurface);<br>        <span class="hljs-keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(TAG_WM, <span class="hljs-string">&quot;  OUT SURFACE &quot;</span> + outSurface + <span class="hljs-string">&quot;: copied&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// For some reason there isn&#x27;t a surface.  Clear the</span><br>        <span class="hljs-comment">// caller&#x27;s object so they see the same state.</span><br>        Slog.w(TAG_WM, <span class="hljs-string">&quot;Failed to create surface control for &quot;</span> + win);<br>        outSurface.release();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>createSurfaceControl()</code>主要执行了两步：</p>
<ul>
<li><code>createSurfaceLocked</code>——创建Layer</li>
<li><code>SurfaceControl#getSurface</code>——创建Surface</li>
</ul>
<h6 id="WMS-createSurfaceLocked"><a href="#WMS-createSurfaceLocked" class="headerlink" title="WMS#createSurfaceLocked"></a>WMS#createSurfaceLocked</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//com/android/server/wm/WindowStateAnimator.java</span><br>    WindowSurfaceController <span class="hljs-title function_">createSurfaceLocked</span><span class="hljs-params">(<span class="hljs-type">int</span> windowType, <span class="hljs-type">int</span> ownerUid)</span> &#123;<br>      ...<br>            mSurfaceController = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowSurfaceController</span>(mSession.mSurfaceSession,<br>                    attrs.getTitle().toString(), width, height, format, flags, <span class="hljs-built_in">this</span>,<br>                    windowType, ownerUid);      <br>      ...<br>    &#125;<br><br><span class="hljs-comment">//WindowSurfaceController.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WindowSurfaceController</span><span class="hljs-params">(SurfaceSession s, String name, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> format,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> flags, WindowStateAnimator animator, <span class="hljs-type">int</span> windowType, <span class="hljs-type">int</span> ownerUid)</span> &#123;<br>      ...<br>        <span class="hljs-keyword">final</span> SurfaceControl.<span class="hljs-type">Builder</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> win.makeSurface()<br>                .setParent(win.getSurfaceControl())<br>                .setName(name)<br>                .setSize(w, h)<br>                .setFormat(format)<br>                .setFlags(flags)<br>                .setMetadata(windowType, ownerUid);<br>        mSurfaceControl = b.build();      <br>      ...<br>    &#125;<br><br><span class="hljs-comment">//SurfaceControl.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>      ...<br>        <span class="hljs-keyword">public</span> SurfaceControl <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (mWidth &lt;= <span class="hljs-number">0</span> || mHeight &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                        <span class="hljs-string">&quot;width and height must be set&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SurfaceControl</span>(mSession, mName, mWidth, mHeight, mFormat,<br>                    mFlags, mParent, mWindowType, mOwnerUid);<br>        &#125;      <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SurfaceControl</span><span class="hljs-params">(SurfaceSession session, String name, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> format, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">            SurfaceControl parent, <span class="hljs-type">int</span> windowType, <span class="hljs-type">int</span> ownerUid)</span><br>                    <span class="hljs-keyword">throws</span> OutOfResourcesException, IllegalArgumentException &#123;<br>      ...<br>        mNativeObject = nativeCreate(session, name, w, h, format, flags,<br>            parent != <span class="hljs-literal">null</span> ? parent.mNativeObject : <span class="hljs-number">0</span>, windowType, ownerUid);<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>执行<code>nativeCreate</code>切换到Native层执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/core/jni/android_view_SurfaceControl.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> jlong <span class="hljs-title">nativeCreate</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span><br><span class="hljs-params"><span class="hljs-function">        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,</span></span><br><span class="hljs-params"><span class="hljs-function">        jint windowType, jint ownerUid)</span> </span>&#123;<br>    <span class="hljs-function">ScopedUtfChars <span class="hljs-title">name</span><span class="hljs-params">(env, nameStr)</span></span>;<br>    <span class="hljs-function">sp&lt;SurfaceComposerClient&gt; <span class="hljs-title">client</span><span class="hljs-params">(android_view_SurfaceSession_getClient(env, sessionObj))</span></span>;<br>    SurfaceControl *parent = <span class="hljs-built_in">reinterpret_cast</span>&lt;SurfaceControl*&gt;(parentObject);<br>    sp&lt;SurfaceControl&gt; surface;<br>    <span class="hljs-type">status_t</span> err = client-&gt;<span class="hljs-built_in">createSurfaceChecked</span>(<br>            <span class="hljs-built_in">String8</span>(name.<span class="hljs-built_in">c_str</span>()), w, h, format, &amp;surface, flags, parent, windowType, ownerUid);<br>  ...<br><br>    surface-&gt;<span class="hljs-built_in">incStrong</span>((<span class="hljs-type">void</span> *)nativeCreate);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;jlong&gt;(surface.<span class="hljs-built_in">get</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>createSurfaceChecked()</code>后续的流程会创建<code>Layer</code></p>
<h6 id="SurfaceControl-getSurface"><a href="#SurfaceControl-getSurface" class="headerlink" title="SurfaceControl#getSurface"></a>SurfaceControl#getSurface</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//WindowSurfaceController.java</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">getSurface</span><span class="hljs-params">(Surface outSurface)</span> &#123;<br>        outSurface.copyFrom(mSurfaceControl);<br>    &#125;<br><br><span class="hljs-comment">//Surface.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFrom</span><span class="hljs-params">(SurfaceControl other)</span> &#123;<br>      ...<br>        <span class="hljs-comment">//创建Surface</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">newNativeObject</span> <span class="hljs-operator">=</span> nativeGetFromSurfaceControl(surfaceControlPtr);<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>在<code>nativeGetFromSurfaceControl()</code>创建<code>Surface</code></p>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>先执行<code>ViewRootImpl#setView()</code>，其中会执行</p>
<ul>
<li><p><code>requestLayout</code></p>
<p>内部执行<code>ViewRootImpl#performTraversals()</code>，接下去执行<code>WMS#relayoutWindow()</code>，然后是<code>WMS#createSurfaceControl</code>，分为两步：</p>
<ul>
<li><code>createSurfaceLocked</code>：创建<code>SurfaceControl</code>，内部执行<code>android_view_surfaceControl#nativeCreate</code>，执行<code>SurfaceComponentClient#createSurface</code>，创建<code>Layer</code>对象。</li>
<li><code>WindowSurfaceController#getSurface</code>：执行到<code>Surface#copyFrom()</code>，调用到<code>nativeGetFromSurfaceControl()</code>，内部调用到<code>SurfaceControl#getSurface()</code>去创建<code>Surface</code></li>
</ul>
<p>创建<code>Surface</code>和<code>Layer</code>完毕后，继续执行View的绘制流程<code>measure-&gt;layout-&gt;draw</code></p>
</li>
<li><p><code>WindowSession#addToDisplay()</code></p>
<p>执行到<code>WMS#addWindow()</code>，继续到<code>Session#windowAddedLocked()</code>，切换到<code>Native</code>层执行<code>android_view_surfaceSession#native_create()</code>在其中创建了<code>SurfaceComponentClient</code>。</p>
</li>
</ul>
</blockquote>
<p><img src="/images/SF-Surface%E5%92%8CLayer%E5%88%9B%E5%BB%BA%E5%87%86%E5%A4%87.jpg" srcset="/img/loading.gif" lazyload alt="SF-Surface&#x2F;Layer创建准备"></p>
<h4 id="Surface、Layer的创建"><a href="#Surface、Layer的创建" class="headerlink" title="Surface、Layer的创建"></a>Surface、Layer的创建</h4><p>根据上节源码分析可以知道，<code>Surface、Layer</code>的创建主要分为以下几步</p>
<h5 id="创建SurfaceComponentClient"><a href="#创建SurfaceComponentClient" class="headerlink" title="创建SurfaceComponentClient"></a>创建SurfaceComponentClient</h5><blockquote>
<p>App进程与<code>SurfaceFlinger</code>沟通的桥梁。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceComposerClient::onFirstRef</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">sp&lt;ISurfaceComposer&gt; <span class="hljs-title">sf</span><span class="hljs-params">(ComposerService::getComposerService())</span></span>;<br>    <span class="hljs-keyword">if</span> (sf != <span class="hljs-number">0</span> &amp;&amp; mStatus == NO_INIT) &#123;<br>        <span class="hljs-keyword">auto</span> rootProducer = mParent.<span class="hljs-built_in">promote</span>();<br>        sp&lt;ISurfaceComposerClient&gt; conn;<br>        conn = (rootProducer != <span class="hljs-literal">nullptr</span>) ? sf-&gt;<span class="hljs-built_in">createScopedConnection</span>(rootProducer) :<br>                sf-&gt;<span class="hljs-built_in">createConnection</span>();<br>      ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中<code>ComposerService</code>就是<code>SurfaceFlinger</code>的Binder代理对象，<code>SurfaceComponentClient</code>通过<code>ComposerService</code>与<code>SurfaceFlinger</code>进行通信。</p>
<h6 id="ComposerService"><a href="#ComposerService" class="headerlink" title="ComposerService"></a>ComposerService</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="hljs-comment">/*static*/</span> <span class="hljs-function">sp&lt;ISurfaceComposer&gt; <span class="hljs-title">ComposerService::getComposerService</span><span class="hljs-params">()</span> </span>&#123;<br>    ComposerService&amp; instance = ComposerService::<span class="hljs-built_in">getInstance</span>();<br>    <span class="hljs-keyword">if</span> (instance.mComposerService == <span class="hljs-literal">NULL</span>) &#123;<br>        ComposerService::<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">connectLocked</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance.mComposerService;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ComposerService::connectLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> String16 <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">&quot;SurfaceFlinger&quot;</span>)</span></span>;<br>  <span class="hljs-comment">//获取SurfaceFlinger 服务</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getService</span>(name, &amp;mComposerService) != NO_ERROR) &#123;<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">250000</span>);<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(mComposerService != <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//native/libs/binder/include/binder/IServiceManager.h</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">getService</span><span class="hljs-params">(<span class="hljs-type">const</span> String16&amp; name, sp&lt;INTERFACE&gt;* outService)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> sp&lt;IServiceManager&gt; sm = <span class="hljs-built_in">defaultServiceManager</span>();<br>    <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">NULL</span>) &#123;<br>        *outService = <span class="hljs-built_in">interface_cast</span>&lt;INTERFACE&gt;(sm-&gt;<span class="hljs-built_in">getService</span>(name));<br>        <span class="hljs-keyword">if</span> ((*outService) != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> NO_ERROR;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NAME_NOT_FOUND;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="SurfaceFlinger-createConnection"><a href="#SurfaceFlinger-createConnection" class="headerlink" title="SurfaceFlinger#createConnection"></a>SurfaceFlinger#createConnection</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function">sp&lt;ISurfaceComposerClient&gt; <span class="hljs-title">SurfaceFlinger::createConnection</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">initClient</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Client</span>(<span class="hljs-keyword">this</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> sp&lt;ISurfaceComposerClient&gt; <span class="hljs-title">initClient</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;Client&gt;&amp; client)</span> </span>&#123;<br>  <span class="hljs-comment">//检查Client是否合法</span><br>    <span class="hljs-type">status_t</span> err = client-&gt;<span class="hljs-built_in">initCheck</span>();<br>    <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>        <span class="hljs-keyword">return</span> client;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中<code>Client</code>内部封装的是<strong>创建和销毁Layer和Surface的操作函数。</strong></p>
<blockquote>
<p><code>Client</code>实现了<code>ISurfaceComposerClient</code>接口，<code>SurfaceComposerClient</code>通过<code>Client</code>和<code>SurfaceFlinger</code>进行通讯。</p>
<p>除此之外还可以创建<code>Surface</code>以及维护<code>Layer</code>对象。</p>
</blockquote>
<h5 id="创建SurfaceControl并创建Layer"><a href="#创建SurfaceControl并创建Layer" class="headerlink" title="创建SurfaceControl并创建Layer"></a>创建SurfaceControl并创建Layer</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">SurfaceComposerClient::createSurfaceChecked</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> String8&amp; name,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint32_t</span> w,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint32_t</span> h,</span></span><br><span class="hljs-params"><span class="hljs-function">        PixelFormat format,</span></span><br><span class="hljs-params"><span class="hljs-function">        sp&lt;SurfaceControl&gt;* outSurface,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint32_t</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">        SurfaceControl* parent,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> windowType,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> ownerUid)</span></span><br><span class="hljs-function"></span>&#123;<br>    sp&lt;SurfaceControl&gt; sur;<br>    <span class="hljs-type">status_t</span> err = mStatus;<br>      <br>        err = mClient-&gt;<span class="hljs-built_in">createSurface</span>(name, w, h, format, flags, parentHandle,<br>                windowType, ownerUid, &amp;handle, &amp;gbp);<br>        <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>            *outSurface = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SurfaceControl</span>(<span class="hljs-keyword">this</span>, handle, gbp, <span class="hljs-literal">true</span> <span class="hljs-comment">/* owned */</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="Client-createSurface"><a href="#Client-createSurface" class="headerlink" title="Client#createSurface"></a>Client#createSurface</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/Client.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">Client::createSurface</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> String8&amp; name,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint32_t</span> w, <span class="hljs-type">uint32_t</span> h, PixelFormat format, <span class="hljs-type">uint32_t</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; parentHandle, <span class="hljs-type">int32_t</span> windowType, <span class="hljs-type">int32_t</span> ownerUid,</span></span><br><span class="hljs-params"><span class="hljs-function">        sp&lt;IBinder&gt;* handle,</span></span><br><span class="hljs-params"><span class="hljs-function">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageCreateLayer</span> : <span class="hljs-keyword">public</span> MessageBase &#123;<br>        SurfaceFlinger* flinger;<br>        Client* client;<br>        sp&lt;IBinder&gt;* handle;<br>        sp&lt;IGraphicBufferProducer&gt;* gbp;<br>        <span class="hljs-type">status_t</span> result;<br>        <span class="hljs-type">const</span> String8&amp; name;<br>        <span class="hljs-type">uint32_t</span> w, h;<br>        PixelFormat format;<br>        <span class="hljs-type">uint32_t</span> flags;<br>        sp&lt;Layer&gt;* parent;<br>        <span class="hljs-type">int32_t</span> windowType;<br>        <span class="hljs-type">int32_t</span> ownerUid;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">handler</span><span class="hljs-params">()</span> </span>&#123;<br>            result = flinger-&gt;<span class="hljs-built_in">createLayer</span>(name, client, w, h, format, flags,<br>                    windowType, ownerUid, handle, gbp, parent);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br>  <br>    sp&lt;MessageBase&gt; msg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MessageCreateLayer</span>(mFlinger.<span class="hljs-built_in">get</span>(),<br>            name, <span class="hljs-keyword">this</span>, w, h, format, flags, handle,<br>            windowType, ownerUid, gbp, &amp;parent);<br>    mFlinger-&gt;<span class="hljs-built_in">postMessageSync</span>(msg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.<span class="hljs-built_in">get</span>() )-&gt;<span class="hljs-built_in">getResult</span>();  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>postMessageSync()</code>发送消息，处理后回调到<code>handler()</code>，继续执行<code>createLayer()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">SurfaceFlinger::createLayer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> String8&amp; name,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;Client&gt;&amp; client,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint32_t</span> w, <span class="hljs-type">uint32_t</span> h, PixelFormat format, <span class="hljs-type">uint32_t</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> windowType, <span class="hljs-type">int32_t</span> ownerUid, sp&lt;IBinder&gt;* handle,</span></span><br><span class="hljs-params"><span class="hljs-function">        sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* parent)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>    <span class="hljs-keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;<br>        <span class="hljs-keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:<br>            result = <span class="hljs-built_in">createBufferLayer</span>(client,<br>                    uniqueName, w, h, flags, format,<br>                    handle, gbp, &amp;layer);<br><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> ISurfaceComposerClient::eFXSurfaceColor:<br>            result = <span class="hljs-built_in">createColorLayer</span>(client,<br>                    uniqueName, w, h, flags,<br>                    handle, &amp;layer);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            result = BAD_VALUE;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>  ...  <br>  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">SurfaceFlinger::createBufferLayer</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;Client&gt;&amp; client,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> String8&amp; name, <span class="hljs-type">uint32_t</span> w, <span class="hljs-type">uint32_t</span> h, <span class="hljs-type">uint32_t</span> flags, PixelFormat&amp; format,</span></span><br><span class="hljs-params"><span class="hljs-function">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span></span><br><span class="hljs-function"></span>&#123;<br> ...<br>   <span class="hljs-comment">//创建Layer对象</span><br>    sp&lt;BufferLayer&gt; layer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferLayer</span>(<span class="hljs-keyword">this</span>, client, name, w, h, flags);   <br> ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>createSurface</code>执行到最后，构建出<code>Layer</code>对象。</p>
<h6 id="new-SurfaceControl"><a href="#new-SurfaceControl" class="headerlink" title="new SurfaceControl"></a>new SurfaceControl</h6><blockquote>
<p><code>SurfaceControl</code>主要作用就是<strong>维护Surface</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/SurfaceControl.cpp</span><br>SurfaceControl::<span class="hljs-built_in">SurfaceControl</span>(<br>        <span class="hljs-type">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,<br>        <span class="hljs-type">const</span> sp&lt;IBinder&gt;&amp; handle,<br>        <span class="hljs-type">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbp,<br>        <span class="hljs-type">bool</span> owned)<br>    : <span class="hljs-built_in">mClient</span>(client), <span class="hljs-built_in">mHandle</span>(handle), <span class="hljs-built_in">mGraphicBufferProducer</span>(gbp), <span class="hljs-built_in">mOwned</span>(owned)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建SurfaceControl之后，仅仅是设置了<code>mClient</code>以及创建了<code>GraphicBufferProducer</code>对象。</p>
<h5 id="通过SurfaceControl创建Surface"><a href="#通过SurfaceControl创建Surface" class="headerlink" title="通过SurfaceControl创建Surface"></a>通过SurfaceControl创建Surface</h5><p>此时已经创建完毕<code>Surfacecontrol</code>和<code>Layer</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">SurfaceControl::getSurface</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    Mutex::Autolock _l(mLock);<br>    <span class="hljs-keyword">if</span> (mSurfaceData == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">generateSurfaceLocked</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> mSurfaceData;<br>&#125;<br><br><span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">SurfaceControl::generateSurfaceLocked</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//构造Surface对象</span><br>    mSurfaceData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Surface</span>(mGraphicBufferProducer, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">return</span> mSurfaceData;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Native</code>层的<code>Surface</code>创建完毕后，返回到<code>Java</code>层进行赋值。</p>
<p><img src="/images/SF-Buffer%E3%80%81Layer%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt="SF-Buffer、Layer创建过程"></p>
<h4 id="BufferQueue的创建"><a href="#BufferQueue的创建" class="headerlink" title="BufferQueue的创建"></a>BufferQueue的创建</h4><p>在创建<code>Layer</code>完成后，后续就会继续去创建<code>BufferQueue</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//BufferLayer.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BufferLayer::onFirstRef</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span><br>    sp&lt;IGraphicBufferProducer&gt; producer;<br>    sp&lt;IGraphicBufferConsumer&gt; consumer;<br>  <span class="hljs-comment">//创建BufferQueue对象</span><br>    BufferQueue::<span class="hljs-built_in">createBufferQueue</span>(&amp;producer, &amp;consumer, <span class="hljs-literal">true</span>);<br>    mProducer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MonitoredProducer</span>(producer, mFlinger, <span class="hljs-keyword">this</span>);<br>    mConsumer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferLayerConsumer</span>(consumer,<br>            mFlinger-&gt;<span class="hljs-built_in">getRenderEngine</span>(), mTextureName, <span class="hljs-keyword">this</span>);<br>    mConsumer-&gt;<span class="hljs-built_in">setConsumerUsageBits</span>(<span class="hljs-built_in">getEffectiveUsage</span>(<span class="hljs-number">0</span>));<br>    mConsumer-&gt;<span class="hljs-built_in">setContentsChangedListener</span>(<span class="hljs-keyword">this</span>);<br>    mConsumer-&gt;<span class="hljs-built_in">setName</span>(mName);<br><br>    <span class="hljs-keyword">if</span> (mFlinger-&gt;<span class="hljs-built_in">isLayerTripleBufferingDisabled</span>()) &#123;<br>        mProducer-&gt;<span class="hljs-built_in">setMaxDequeuedBufferCount</span>(<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;<span class="hljs-type">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mFlinger-&gt;getDefaultDisplayDevice())</span></span>;<br>    <span class="hljs-built_in">updateTransformHint</span>(hw);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueue.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BufferQueue::createBufferQueue</span><span class="hljs-params">(sp&lt;IGraphicBufferProducer&gt;* outProducer,</span></span><br><span class="hljs-params"><span class="hljs-function">        sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">bool</span> consumerIsSurfaceFlinger)</span> </span>&#123;<br>  <span class="hljs-comment">//创建BufferQueueCore</span><br>    <span class="hljs-function">sp&lt;BufferQueueCore&gt; <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BufferQueueCore())</span></span>;<br>  <span class="hljs-comment">//创建BufferQueueProducer</span><br>    <span class="hljs-function">sp&lt;IGraphicBufferProducer&gt; <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BufferQueueProducer(core, consumerIsSurfaceFlinger))</span></span>;<br>  <span class="hljs-comment">//创建BufferQueueConsumer</span><br>    <span class="hljs-function">sp&lt;IGraphicBufferConsumer&gt; <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BufferQueueConsumer(core))</span></span>;<br>  <br>    *outProducer = producer;<br>    *outConsumer = consumer;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>createBufferQueue</code>主要创建以下三个对象：</p>
<ul>
<li><code>BufferQueueCore</code></li>
<li><code>BufferQueueProducer</code></li>
<li><code>BufferQueueConsumer</code></li>
</ul>
<h5 id="BufferQueueCore"><a href="#BufferQueueCore" class="headerlink" title="BufferQueueCore"></a>BufferQueueCore</h5><blockquote>
<p>主要用来存放<code>GraphicBuffer</code>，并且存放最多<strong>64</strong>个。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/include/gui/BufferQueueCore.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferQueueCore</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> RefBase &#123;<br><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferQueueProducer</span>;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferQueueConsumer</span>;<br><span class="hljs-keyword">public</span>:<br>  ...<br><span class="hljs-keyword">private</span>:<br>  ...<br>    BufferQueueDefs::SlotsType mSlots;<br>    Fifo mQueue;<br>    std::set&lt;<span class="hljs-type">int</span>&gt; mFreeSlots;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; mFreeBuffers;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; mUnusedSlots;<br>    std::set&lt;<span class="hljs-type">int</span>&gt; mActiveBuffers;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要有以下几个对象：</p>
<ul>
<li><code>mSlots</code>：大小为<code>NUM_BUFFER_SLOTS(64)</code>的数组，存储数据为<code>BufferSlot</code></li>
<li><code>mQueue</code>：以<code>先进先出对了</code>存放<code>生产者生产的数据-BufferItem</code>，保证按照顺序取出</li>
<li><code>mFreeSlots</code>：尚未绑定<code>GraphicBuffer</code>且<code>state = FREE</code>的<code>BufferSlot</code>的<code>index</code>集合</li>
<li><code>mFreeBuffers</code>：已经绑定了<code>GraphicBuffer</code>且<code>state = FREE</code>的<code>BufferSlot</code>的<code>index</code>集合</li>
<li><code>mActiveBuffers</code>：已经绑定了<code>GraphicBuffer</code>且<code>state!=FREE</code>的<code>BufferSlot</code>的<code>index</code>集合</li>
<li><code>mUnusedSlots</code>：没有绑定<code>GraphicBuffer</code>且没有状态的<code>BufferSlot</code>的<code>index</code>集合</li>
</ul>
<p>主要介绍<code>BufferSlot</code>，<code>BufferQueueCore</code>基本是<code>BufferSlot</code>的各种集合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BufferSlot</span> &#123;<br><br>    <span class="hljs-built_in">BufferSlot</span>()<br>    : <span class="hljs-built_in">mGraphicBuffer</span>(<span class="hljs-literal">nullptr</span>),<br>      <span class="hljs-built_in">mBufferState</span>(),<br>  ...<br>   <span class="hljs-comment">//绑定的 GraphicBuffer</span><br>    sp&lt;GraphicBuffer&gt; mGraphicBuffer;<br>   <span class="hljs-comment">//绑定的BufferSlot 状态</span><br>    BufferState mBufferState;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BufferState</span> &#123;<br><br>    <span class="hljs-comment">// All slots are initially FREE (not dequeued, queued, acquired, or shared).</span><br>    <span class="hljs-built_in">BufferState</span>()<br>    : <span class="hljs-built_in">mDequeueCount</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">mQueueCount</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">mAcquireCount</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">mShared</span>(<span class="hljs-literal">false</span>) &#123;<br>    &#125;<br>  <br>    <span class="hljs-comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span><br>    <span class="hljs-comment">// --------|---------|---------------|-------------|---------------|</span><br>    <span class="hljs-comment">// FREE    |  false  |       0       |      0      |       0       |</span><br>    <span class="hljs-comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span><br>    <span class="hljs-comment">// QUEUED  |  false  |       0       |      1      |       0       |</span><br>    <span class="hljs-comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span><br>    <span class="hljs-comment">// SHARED  |  true   |      any      |     any     |      any      |      </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要由两部分构成：</p>
<ul>
<li><code>mGraphicBuffer</code>：<code>BufferSlot</code>所绑定的<code>GraphicBuffer</code></li>
<li><code>mBufferState</code>：表示当前<code>BufferSlot</code>的状态，主要有以下几种状态：<ul>
<li><code>FREE</code>：空闲状态，存入<code>mFreeSlots</code></li>
<li><code>DEQUEUED</code>：被<code>生产者</code>获取，待绘制数据</li>
<li><code>QUEUED</code>：被<code>BufferQueue</code>获取，待<code>消费者</code>获取。</li>
<li><code>ACQUIRED</code>：被<code>消费者</code>获取，待获取绘制数据</li>
<li><code>SHARED</code>：处于共享状态。</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>BufferQueueCore</code>设置了这么多的<code>BufferSlot</code>集合，主要为了<strong>分类BufferSlot时更高效</strong>。</p>
</blockquote>
<p><img src="/images/SF-BufferQueueCore.jpg" srcset="/img/loading.gif" lazyload alt="SF-BufferQueueCore"></p>
<h5 id="BufferQueueProducer"><a href="#BufferQueueProducer" class="headerlink" title="BufferQueueProducer"></a>BufferQueueProducer</h5><blockquote>
<p><code>Surface</code>中持有<code>BufferQueueProducer</code>的BP代理对象-<code>IGraphicBufferProducer</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span><br>BufferQueueProducer::<span class="hljs-built_in">BufferQueueProducer</span>(<span class="hljs-type">const</span> sp&lt;BufferQueueCore&gt;&amp; core,<br>        <span class="hljs-type">bool</span> consumerIsSurfaceFlinger) :<br>    <span class="hljs-built_in">mCore</span>(core),<br>    <span class="hljs-built_in">mSlots</span>(core-&gt;mSlots),<br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferQueueProducer::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height, PixelFormat format,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">uint64_t</span> usage, <span class="hljs-type">uint64_t</span>* outBufferAge,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;<br> ... <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferQueueProducer::queueBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> slot,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;<br>  ...<br>&#125;<br>  <br></code></pre></td></tr></table></figure>

<p>初始化了<code>mCore</code>和<code>mSlots</code>对象</p>
<pre><code class=" mermaid">graph TD
A(new &lt;br&gt;BufferQueueProducer)
B(赋值BufferQueueCore到mCore)
C(赋值mSlots)
A---&gt;B
A---&gt;C
</code></pre>



<h6 id="dequeueBuffer"><a href="#dequeueBuffer" class="headerlink" title="dequeueBuffer"></a>dequeueBuffer</h6><blockquote>
<p>向<code>BufferQueue</code>申请一块<code>GraphicBuffer</code>。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>为<code>DEQUEUED</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferQueueProducer::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height, PixelFormat format,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">uint64_t</span> usage, <span class="hljs-type">uint64_t</span>* outBufferAge,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;<br>            <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">waitForFreeSlotThenRelock</span>(FreeSlotCaller::Dequeue,<br>                    &amp;found);<br>           ...     <br>        &#125;<br>      <span class="hljs-comment">//判断寻找的 BufferSlot是否与 申请的宽高、格式一致</span><br>        <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="hljs-title">buffer</span><span class="hljs-params">(mSlots[found].mGraphicBuffer)</span></span>;<br>        <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferSlot == found &amp;&amp;<br>                buffer-&gt;<span class="hljs-built_in">needsReallocation</span>(width, height, format, BQ_LAYER_COUNT, usage)) &#123;<br>            <span class="hljs-built_in">BQ_LOGE</span>(<span class="hljs-string">&quot;dequeueBuffer: cannot re-allocate a shared&quot;</span><br>                    <span class="hljs-string">&quot;buffer&quot;</span>);<br><br>            <span class="hljs-keyword">return</span> BAD_VALUE;<br>        &#125;  <br>  ...<br>        <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferSlot != found) &#123;<br>          <span class="hljs-comment">//添加 GraphicBuffer 的index到 mActiveBuffers</span><br>            mCore-&gt;mActiveBuffers.<span class="hljs-built_in">insert</span>(found);<br>        &#125;<br>        *outSlot = found;  <br>  ...<br>      <span class="hljs-comment">//标记 选中的BufferSlot状态为 DEQUEUED</span><br>        mSlots[found].mBufferState.<span class="hljs-built_in">dequeue</span>();<br><br>      <span class="hljs-comment">//找到了空的 GraphicBuffer，就进行初始化。</span><br>        <span class="hljs-keyword">if</span> ((buffer == <span class="hljs-literal">NULL</span>) ||<br>                buffer-&gt;<span class="hljs-built_in">needsReallocation</span>(width, height, format, BQ_LAYER_COUNT, usage))<br>        &#123;<br>            mSlots[found].mAcquireCalled = <span class="hljs-literal">false</span>;<br>            mSlots[found].mGraphicBuffer = <span class="hljs-literal">NULL</span>;<br>            mSlots[found].mRequestBufferCalled = <span class="hljs-literal">false</span>;<br>            mSlots[found].mEglDisplay = EGL_NO_DISPLAY;<br>            mSlots[found].mEglFence = EGL_NO_SYNC_KHR;<br>            mSlots[found].mFence = Fence::NO_FENCE;<br>            mCore-&gt;mBufferAge = <span class="hljs-number">0</span>;<br>            mCore-&gt;mIsAllocating = <span class="hljs-literal">true</span>;<br><br>            returnFlags |= BUFFER_NEEDS_REALLOCATION;<br>        &#125; <br>      ...<br>    <span class="hljs-keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;<br>        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">GraphicBuffer</span>(<br>                width, height, format, BQ_LAYER_COUNT, usage,u<br>                &#123;mConsumerName.<span class="hljs-built_in">string</span>(), mConsumerName.<span class="hljs-built_in">size</span>()&#125;);<br>      &#123;<br>            <span class="hljs-keyword">if</span> (error == NO_ERROR &amp;&amp; !mCore-&gt;mIsAbandoned) &#123;<br>                graphicBuffer-&gt;<span class="hljs-built_in">setGenerationNumber</span>(mCore-&gt;mGenerationNumber);<br>              <span class="hljs-comment">//将新创建的GraphicBuffer放到 BufferSlot中</span><br>                mSlots[*outSlot].mGraphicBuffer = graphicBuffer;<br>            &#125;      <br>      &#125;<br>    &#125;<br>  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferQueueProducer::waitForFreeSlotThenRelock</span><span class="hljs-params">(FreeSlotCaller caller,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span>* found)</span> <span class="hljs-type">const</span> </span>&#123;<br>  ...<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> maxBufferCount = mCore-&gt;<span class="hljs-built_in">getMaxBufferCountLocked</span>();<br>       <span class="hljs-comment">//请求是否太多</span><br>        <span class="hljs-type">bool</span> tooManyBuffers = mCore-&gt;mQueue.<span class="hljs-built_in">size</span>()<br>                            &gt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(maxBufferCount);<br>        <span class="hljs-keyword">if</span> (tooManyBuffers) &#123;<br>          <span class="hljs-comment">//请求过多时，就会进入阻塞状态</span><br>            <span class="hljs-built_in">BQ_LOGV</span>(<span class="hljs-string">&quot;r%s: queue size is %zu, waiting&quot;</span>, callerString,<br>                    mCore-&gt;mQueue.<span class="hljs-built_in">size</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot !=<br>                    BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                *found = mCore-&gt;mSharedBufferSlot;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (caller == FreeSlotCaller::Dequeue) &#123;<br>                    <span class="hljs-comment">// 寻找已经绑定GraphicBuffer 但 State = FREE的 BufferSlot</span><br>                    <span class="hljs-type">int</span> slot = <span class="hljs-built_in">getFreeBufferLocked</span>();<br>                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                        *found = slot;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCore-&gt;mAllowAllocation) &#123;<br>                        *found = <span class="hljs-built_in">getFreeSlotLocked</span>();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// 寻找尚未绑定GraphicBuffer 但 State = FREE 的BufferSlot</span><br>                    <span class="hljs-type">int</span> slot = <span class="hljs-built_in">getFreeSlotLocked</span>();<br>                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                        *found = slot;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        *found = <span class="hljs-built_in">getFreeBufferLocked</span>();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>edequeueBuffer</code>主要做了以下几步：</p>
<ul>
<li><p>通过<code>waitForFreeSlotThenRelock</code>寻找空闲的<code>BufferSlot</code>，需要判断当前是否与申请<code>width、height、format</code>一致，不一致则需要重新请求</p>
<p><code>waitForFreeSlotThenRelock</code>主要实现了以下几步：</p>
<ul>
<li><code>getFreeBufferLocked</code>：直接使用已经绑定的<code>GraphicBuffer</code></li>
<li><code>getFreeSlotLocked</code>：需要新建一个<code>GraphicBuffer</code>与其绑定</li>
</ul>
</li>
<li><p>把找到的<code>BufferSlot</code>的<code>index</code>放到<code>mActiveSlots</code>中</p>
</li>
<li><p>如果找到的<code>BufferSlot</code>中的<code>GraphicBuffer</code>为null，需要初始化<code>BufferSlot</code></p>
</li>
<li><p>如果需要重新创建<code>GraphicBuffer</code>，并把新建的<code>GraphicBuffer</code>放在找到的<code>BufferSlot</code>中</p>
</li>
</ul>
<blockquote>
<p>尝试寻找一个<code>BufferSlot</code>，并且<code>width,height,format</code>都符合要求，如果没有绑定<code>GraphicBuffer</code>，就需要新建一个并且进行绑定，然后设置<code>BufferSlot</code>的<code>BufferState</code>为<code>DEQUEUED</code>，最后返回在<code>mSlots</code>的<code>index</code>回去。</p>
</blockquote>
<p><img src="/images/SF-BufferQueue-dequeueBuffer.jpg" srcset="/img/loading.gif" lazyload alt="SF-BufferQueue-dequeueBuffer"></p>
<h6 id="queueBuffer"><a href="#queueBuffer" class="headerlink" title="queueBuffer"></a>queueBuffer</h6><blockquote>
<p>在<code>生产者</code>填充数据到<code>GraphicBuffer</code>完毕后，通过<code>queueBuffer</code>把<code>GraphicBuffer</code>放回到<code>BufferQueue</code>。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>QUEUED</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferQueueProducer::queueBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> slot,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//消费者回调</span><br>    sp&lt;IConsumerListener&gt; frameAvailableListener;<br>    sp&lt;IConsumerListener&gt; frameReplacedListener;<br>    <span class="hljs-type">int</span> callbackTicket = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint64_t</span> currentFrameNumber = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//需要插入mQueue的 数据结构</span><br>    BufferItem item;<br>  ...<br>  &#123;<br>    ...<br>        <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="hljs-title">graphicBuffer</span><span class="hljs-params">(mSlots[slot].mGraphicBuffer)</span></span>;    <br>        mSlots[slot].mBufferState.<span class="hljs-built_in">queue</span>();<br>       <span class="hljs-comment">//构造BufferItem对象</span><br>        item.mAcquireCalled = mSlots[slot].mAcquireCalled;<br>        item.mGraphicBuffer = mSlots[slot].mGraphicBuffer;<br>        item.mCrop = crop;<br>        item.mTransform = transform &amp;<br>                ~<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);<br>        item.mTransformToDisplayInverse =<br>                (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != <span class="hljs-number">0</span>;<br>        item.mScalingMode = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(scalingMode);<br>        item.mTimestamp = requestedPresentTimestamp;<br>        item.mIsAutoTimestamp = isAutoTimestamp;<br>        item.mDataSpace = dataSpace;<br>        item.mHdrMetadata = hdrMetadata;<br>        item.mFrameNumber = currentFrameNumber;<br>        item.mSlot = slot;<br>        item.mFence = acquireFence;<br>        item.mFenceTime = acquireFenceTime;<br>        item.mIsDroppable = mCore-&gt;mAsyncMode ||<br>                mCore-&gt;mDequeueBufferCannotBlock ||<br>                (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == slot);<br>        item.mSurfaceDamage = surfaceDamage;<br>        item.mQueuedBuffer = <span class="hljs-literal">true</span>;<br>        item.mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mAutoRefresh;<br>        item.mApi = mCore-&gt;mConnectedApi;    <br>    <br>        <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>          <span class="hljs-comment">//添加BufferItem</span><br>            mCore-&gt;mQueue.<span class="hljs-built_in">push_back</span>(item);<br>            frameAvailableListener = mCore-&gt;mConsumerListener;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">const</span> BufferItem&amp; last = mCore-&gt;mQueue.<span class="hljs-built_in">itemAt</span>(<br>                    mCore-&gt;mQueue.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (last.mIsDroppable) &#123;<br>              <span class="hljs-comment">//替换mQueue最后一位 为新的BufferItem</span><br>                mCore-&gt;mQueue.<span class="hljs-built_in">editItemAt</span>(mCore-&gt;mQueue.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) = item;<br>                frameReplacedListener = mCore-&gt;mConsumerListener;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//添加 BufferItem</span><br>                mCore-&gt;mQueue.<span class="hljs-built_in">push_back</span>(item);<br>                frameAvailableListener = mCore-&gt;mConsumerListener;<br>            &#125;               <br>        &#125;<br>    ...<br>      <br>        <span class="hljs-keyword">if</span> (frameAvailableListener != <span class="hljs-literal">NULL</span>) &#123;<br>          <span class="hljs-comment">//回调 onFrameAvaliaable 通知消费者有新的数据入队</span><br>            frameAvailableListener-&gt;<span class="hljs-built_in">onFrameAvailable</span>(item);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (frameReplacedListener != <span class="hljs-literal">NULL</span>) &#123;<br>            frameReplacedListener-&gt;<span class="hljs-built_in">onFrameReplaced</span>(item);<br>        &#125;      <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>queueBuffer</code>主要执行了以下几步：</p>
<ul>
<li>根据传入的<code>slot</code>从<code>mSlots</code>获取对应的<code>BufferSlot</code>，并设置对应的<code>BufferState</code>为<code>QUEUED</code></li>
<li>根据获取的<code>BufferSlot</code>构造出<code>BufferItem</code>，并添加到<code>mQueues</code>中</li>
<li>最后回调到<code>frameAvaliableListener.onFrameAvaliable()</code>通知<code>消费者</code>有新数据入队，可以进行获取。</li>
</ul>
<pre><code class=" mermaid">graph TD
A(queueBuffer)
B(&quot;获取mSlots[slot].mGraphicBuffer&quot;)
C(&quot;mSlots[slot].mBufferState.queue()&quot;)
A--&gt;B
A---&gt;C
D(&quot;设置BufferState状态为QUEUED&quot;)
D---C
E(&quot;组装BufferItem&quot;)
B--&gt;E
F&#123;&quot;last&lt;br&gt;.mIsDroppable&quot;&#125;
E---&gt;F
G(&quot;mQueue.push_back(item)&quot;)
H(&quot;mQueue.editItemAt(last)==item&quot;)
F--&gt;|Y| H
F--&gt;|N| G
J(&quot;frameAvailableListener-&gt;onFrameAvailable(item)&quot;)
H--&gt;J
G--&gt;J
I(&quot;通知消费者有数据入队，消费者可以获取数据&quot;)
K(&quot;最后一条数据是否有效？&quot;)
K---F
I---J
</code></pre>



<h5 id="BufferQueueConsumer"><a href="#BufferQueueConsumer" class="headerlink" title="BufferQueueConsumer"></a>BufferQueueConsumer</h5><blockquote>
<p><code>SurfaceFlinger</code>通过<code>BufferQueueConsumer</code>来获取以及释放<code>GraphicBuffer</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueConsumer.cpp</span><br>BufferQueueConsumer::<span class="hljs-built_in">BufferQueueConsumer</span>(<span class="hljs-type">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :<br>    <span class="hljs-built_in">mCore</span>(core),<br>    <span class="hljs-built_in">mSlots</span>(core-&gt;mSlots),<br>    <span class="hljs-built_in">mConsumerName</span>() &#123;&#125;<br></code></pre></td></tr></table></figure>

<p><code>BufferQueueConsumer</code>只是设置了<code>mCore</code>和<code>mSlots</code>的两个参数。</p>
<h6 id="acquireBuffer"><a href="#acquireBuffer" class="headerlink" title="acquireBuffer"></a>acquireBuffer</h6><blockquote>
<p><code>消费者</code>向<code>BufferQueue</code>申请<code>已被填充数据的GraphicBuffer</code>进行消费。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>ACQUIRED</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueConsumer.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferQueueConsumer::acquireBuffer</span><span class="hljs-params">(BufferItem* outBuffer,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">nsecs_t</span> expectedPresent, <span class="hljs-type">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br> ... <br>      <span class="hljs-comment">//生产者注册回调</span><br>       sp&lt;IProducerListener&gt; listener;<br>   <span class="hljs-comment">//如果队列为空则返回空</span><br>        <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.<span class="hljs-built_in">empty</span>() &amp;&amp; !sharedBufferAvailable) &#123;<br>            <span class="hljs-keyword">return</span> NO_BUFFER_AVAILABLE;<br>        &#125;<br>    <span class="hljs-comment">//获取队列的第一条数据</span><br>        BufferQueueCore::<span class="hljs-function">Fifo::iterator <span class="hljs-title">front</span><span class="hljs-params">(mCore-&gt;mQueue.begin())</span></span>; <br>        <span class="hljs-keyword">if</span> (sharedBufferAvailable &amp;&amp; mCore-&gt;mQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">//共享Buffer模式</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//从front获取对应的slot</span><br>            slot = front-&gt;mSlot;<br>            *outBuffer = *front;<br>        &#125;<br>  ...<br>                <span class="hljs-keyword">if</span> (!front-&gt;mIsStale) &#123;<br>                    <span class="hljs-comment">// Front buffer is still in mSlots, so mark the slot as free</span><br>                    mSlots[front-&gt;mSlot].mBufferState.<span class="hljs-built_in">freeQueued</span>();<br>                  <span class="hljs-comment">//存在已经被消费的BufferSlot</span><br>                    listener = mCore-&gt;mConnectedProducerListener;                  <br>                &#125;<br>        <span class="hljs-keyword">if</span> (!outBuffer-&gt;mIsStale) &#123;<br>            mSlots[slot].mAcquireCalled = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// Don&#x27;t decrease the queue count if the BufferItem wasn&#x27;t</span><br>            <span class="hljs-comment">// previously in the queue. This happens in shared buffer mode when</span><br>            <span class="hljs-comment">// the queue is empty and the BufferItem is created above.</span><br>            <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>                mSlots[slot].mBufferState.<span class="hljs-built_in">acquireNotInQueue</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//更新BufferState 为 ACQUIRED</span><br>                mSlots[slot].mBufferState.<span class="hljs-built_in">acquire</span>();<br>            &#125;<br>            mSlots[slot].mFence = Fence::NO_FENCE;<br>        &#125;    <br>       <span class="hljs-comment">//从队列中移除</span><br>        mCore-&gt;mQueue.<span class="hljs-built_in">erase</span>(front);   <br>  <br>      <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numDroppedBuffers; ++i) &#123;<br>          <span class="hljs-comment">//回调生产者 有数据被消费</span><br>            listener-&gt;<span class="hljs-built_in">onBufferReleased</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>acquireBuffer</code>主要有以下几步：</p>
<ul>
<li>从<code>mQueue</code>中获取第一个元素</li>
<li>改变第一个<code>BufferSlot</code>的<code>BufferState</code>为<code>ACQUIRED</code></li>
<li>再将该<code>BufferSlot</code>从<code>mQueue</code>中移除</li>
<li>如果存在已被消费的数据则回调<code>onBufferReleased</code></li>
</ul>
<pre><code class=" mermaid">graph TB
A(&quot;acquireBuffer()&quot;)
C&#123;&quot;mQueue.empty()&quot;&#125;
A--&gt;C
D(&quot;NO_BUFFER_AVALIABLE&quot;)
C---&gt;|Y| D
E(&quot;front = &lt;br&gt;mCore-&gt;mQueue.begin()&quot;)
F(&quot;获取第一条BufferSlot&quot;)
F---E
C---&gt;|N| E
G(&quot;mSlots[slot].mBufferState.acquire()&quot;)
H(&quot;slot = front-&gt;mSlot&quot;)
E--&gt;H
H---&gt;G
J(&quot;设置BufferSlot的BufferState状态为ACQUIRED&quot;)
J---G
K(&quot;mCore-&gt;mQueue.erase(front)&quot;)
L(&quot;从mQueue中移除front&quot;)
L---K
G--&gt;K

</code></pre>





<h6 id="releaseBuffer"><a href="#releaseBuffer" class="headerlink" title="releaseBuffer"></a>releaseBuffer</h6><blockquote>
<p><code>消费者</code>消费完毕后，通知<code>BufferQueueCore</code>已消费完毕，并返回<code>空GraphicBuffer</code>到<code>BufferQueue</code></p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>FREE</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueConsumer.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferQueueConsumer::releaseBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> slot, <span class="hljs-type">uint64_t</span> frameNumber,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;Fence&gt;&amp; releaseFence, EGLDisplay eglDisplay,</span></span><br><span class="hljs-params"><span class="hljs-function">        EGLSyncKHR eglFence)</span> </span>&#123;<br>  ...<br>    sp&lt;IProducerListener&gt; listener;<br>    &#123; <span class="hljs-comment">// Autolock scope</span><br>      ...<br>        mSlots[slot].mEglDisplay = eglDisplay;<br>        mSlots[slot].mEglFence = eglFence;<br>        mSlots[slot].mFence = releaseFence;<br>      <span class="hljs-comment">//设置 BufferSlot状态为 FREE</span><br>        mSlots[slot].mBufferState.<span class="hljs-built_in">release</span>();     <br>      ...<br>        <span class="hljs-keyword">if</span> (!mSlots[slot].mBufferState.<span class="hljs-built_in">isShared</span>()) &#123;<br>            mCore-&gt;mActiveBuffers.<span class="hljs-built_in">erase</span>(slot);<br>          <span class="hljs-comment">//将BufferSlot放入 mFreeBuffers</span><br>            mCore-&gt;mFreeBuffers.<span class="hljs-built_in">push_back</span>(slot);<br>        &#125;<br><br>        listener = mCore-&gt;mConnectedProducerListener;        <br>    &#125;<br>    <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-comment">//通知生产者有数据被消费</span><br>        listener-&gt;<span class="hljs-built_in">onBufferReleased</span>();<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>releaseBuffer</code>主要有以下几步：</p>
<ul>
<li>将使用完的<code>BufferSlot</code>的<code>BufferState</code>转换为<code>FREE</code></li>
<li>被消费完的<code>BufferSlot</code>的<code>index</code>放回到<code>mFreeBuffers</code>供后续的<code>生产者</code>继续获取</li>
<li>最后通知生产者有数据被消费，生产者可以准备生产数据。</li>
</ul>
<pre><code class=" mermaid">graph TD
A(&quot;releaseBuffer()&quot;)
B(&quot;mSlots[slot].mBufferState.release()&quot;)
C(&quot;mFreeBuffers.push_back(slot)&quot;)
D(&quot;listener-&gt;onBufferReleased&quot;)

A---&gt;B
B---&gt;C
C---&gt;D

E(&quot;设置BufferSlot状态为FREE&quot;)
F(&quot;存入mFreeBuffers待使用&quot;)
G(&quot;通知 生产者 数据被消费，可以准备生产数据&quot;)

E---B
F---C
G---D
</code></pre>





<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/BufferSlot%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98%E8%BF%87%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt="BufferSlot状态转变过程"></p>
<h4 id="GraphicBuffer的创建"><a href="#GraphicBuffer的创建" class="headerlink" title="GraphicBuffer的创建"></a>GraphicBuffer的创建</h4><blockquote>
<p><code>GraphicBuffer</code>是基本单元，所有的交互都是基于它进行的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferQueueProducer::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height, PixelFormat format,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">uint64_t</span> usage, <span class="hljs-type">uint64_t</span>* outBufferAge,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;<br>  ...<br>        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">GraphicBuffer</span>(<br>                width, height, format, BQ_LAYER_COUNT, usage,<br>                &#123;mConsumerName.<span class="hljs-built_in">string</span>(), mConsumerName.<span class="hljs-built_in">size</span>()&#125;);<br>  ...<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要在<code>dequeueBuffer</code>进行的创建过程。在<code>生产者</code>的使用场景下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/ui/GraphicBuffer.cpp</span><br>GraphicBuffer::<span class="hljs-built_in">GraphicBuffer</span>(<span class="hljs-type">uint32_t</span> inWidth, <span class="hljs-type">uint32_t</span> inHeight,<br>        PixelFormat inFormat, <span class="hljs-type">uint32_t</span> inLayerCount, <span class="hljs-type">uint64_t</span> usage, std::string requestorName)<br>    : <span class="hljs-built_in">GraphicBuffer</span>()<br>&#123;<br>    mInitCheck = <span class="hljs-built_in">initWithSize</span>(inWidth, inHeight, inFormat, inLayerCount,<br>            usage, std::<span class="hljs-built_in">move</span>(requestorName));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">GraphicBuffer::initWithSize</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> inWidth, <span class="hljs-type">uint32_t</span> inHeight,</span></span><br><span class="hljs-params"><span class="hljs-function">        PixelFormat inFormat, <span class="hljs-type">uint32_t</span> inLayerCount, <span class="hljs-type">uint64_t</span> inUsage,</span></span><br><span class="hljs-params"><span class="hljs-function">        std::string requestorName)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//GraphicBuffer的内存分配器</span><br>    GraphicBufferAllocator&amp; allocator = GraphicBufferAllocator::<span class="hljs-built_in">get</span>();<br>    <span class="hljs-type">uint32_t</span> outStride = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//为GraphicBuffer分配内存</span><br>    <span class="hljs-type">status_t</span> err = allocator.<span class="hljs-built_in">allocate</span>(inWidth, inHeight, inFormat, inLayerCount,<br>            inUsage, &amp;handle, &amp;outStride, mId,<br>            std::<span class="hljs-built_in">move</span>(requestorName));<br>    <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>        mBufferMapper.<span class="hljs-built_in">getTransportSize</span>(handle, &amp;mTransportNumFds, &amp;mTransportNumInts);<br><br>        width = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(inWidth);<br>        height = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(inHeight);<br>        format = inFormat;<br>        layerCount = inLayerCount;<br>        usage = inUsage;<br>        usage_deprecated = <span class="hljs-built_in">int</span>(usage);<br>        stride = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(outStride);<br>    &#125;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>GraphicBuffer</code>创建过程主要执行了以下几步：</p>
<ul>
<li>获取<code>GraphicBufferAllocator</code>，这个是<code>GraphicBuffer</code>的内存分配器</li>
<li>再调用<code>allocate()</code>进行内存分配</li>
</ul>
<p>其中<code>GraphicBufferAllocator</code>的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/ui/GraphicBufferAllocator.cpp</span><br>GraphicBufferAllocator::<span class="hljs-built_in">GraphicBufferAllocator</span>()<br>  : <span class="hljs-built_in">mMapper</span>(GraphicBufferMapper::<span class="hljs-built_in">getInstance</span>()),<br>    <span class="hljs-built_in">mAllocator</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Gralloc2::Allocator&gt;(<br>                mMapper.<span class="hljs-built_in">getGrallocMapper</span>()))<br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">GraphicBufferAllocator::allocate</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> width, <span class="hljs-type">uint32_t</span> height,</span></span><br><span class="hljs-params"><span class="hljs-function">        PixelFormat format, <span class="hljs-type">uint32_t</span> layerCount, <span class="hljs-type">uint64_t</span> usage,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">buffer_handle_t</span>* handle, <span class="hljs-type">uint32_t</span>* stride,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint64_t</span> <span class="hljs-comment">/*graphicBufferId*/</span>, std::string requestorName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ATRACE_CALL</span>();<br><br>    <span class="hljs-comment">// make sure to not allocate a N x 0 or 0 x N buffer, since this is</span><br>    <span class="hljs-comment">// allowed from an API stand-point allocate a 1x1 buffer instead.</span><br>    <span class="hljs-keyword">if</span> (!width || !height)<br>        width = height = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// Ensure that layerCount is valid.</span><br>    <span class="hljs-keyword">if</span> (layerCount &lt; <span class="hljs-number">1</span>)<br>        layerCount = <span class="hljs-number">1</span>;<br><br>    Gralloc2::IMapper::BufferDescriptorInfo info = &#123;&#125;;<br>    info.width = width;<br>    info.height = height;<br>    info.layerCount = layerCount;<br>    info.format = <span class="hljs-built_in">static_cast</span>&lt;Gralloc2::PixelFormat&gt;(format);<br>    info.usage = usage;<br><br>    Gralloc2::Error error = mAllocator-&gt;<span class="hljs-built_in">allocate</span>(info, stride, handle);<br>    <span class="hljs-keyword">if</span> (error == Gralloc2::Error::NONE) &#123;<br>        Mutex::Autolock _l(sLock);<br>        <span class="hljs-function">KeyedVector&lt;<span class="hljs-type">buffer_handle_t</span>, <span class="hljs-type">alloc_rec_t</span>&gt;&amp; <span class="hljs-title">list</span><span class="hljs-params">(sAllocList)</span></span>;<br>        <span class="hljs-type">uint32_t</span> bpp = <span class="hljs-built_in">bytesPerPixel</span>(format);<br>        <span class="hljs-type">alloc_rec_t</span> rec;<br>        rec.width = width;<br>        rec.height = height;<br>        rec.stride = *stride;<br>        rec.format = format;<br>        rec.layerCount = layerCount;<br>        rec.usage = usage;<br>        rec.size = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(height * (*stride) * bpp);<br>        rec.requestorName = std::<span class="hljs-built_in">move</span>(requestorName);<br>        list.<span class="hljs-built_in">add</span>(*handle, rec);<br><br>        <span class="hljs-keyword">return</span> NO_ERROR;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Failed to allocate (%u x %u) layerCount %u format %d &quot;</span><br>                <span class="hljs-string">&quot;usage %&quot;</span> PRIx64 <span class="hljs-string">&quot;: %d&quot;</span>,<br>                width, height, layerCount, format, usage,<br>                error);<br>        <span class="hljs-keyword">return</span> NO_MEMORY;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;TODO 对<code>GraphicBufferAllocator</code>进行分析</p>
<h3 id="图形缓冲区在图像生产者的使用"><a href="#图形缓冲区在图像生产者的使用" class="headerlink" title="图形缓冲区在图像生产者的使用"></a>图形缓冲区在<code>图像生产者</code>的使用</h3><blockquote>
<p>Android中的<code>图像生产者</code>如<code>Skia、OpenGL、Vulkan</code>。负责<strong>将绘制的数据放在图形缓冲区中</strong></p>
</blockquote>
<p>Android中的图像绘制分为以下两种，主要区别在于<strong>是否开启硬件加速</strong>。</p>
<p>未开启就是<code>软件绘制</code>，若开启就执行<code>硬件绘制</code>流程。</p>
<h4 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h4><p><code>软件绘制</code>的入口函数位于<code>ViewRootImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">drawSoftware</span><span class="hljs-params">(Surface surface, AttachInfo attachInfo, <span class="hljs-type">int</span> xoff, <span class="hljs-type">int</span> yoff,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> &#123;<br>        <span class="hljs-keyword">final</span> Canvas canvas;<br>           <span class="hljs-comment">//从surface获取Canvas</span><br>            canvas = mSurface.lockCanvas(dirty);<br>           <span class="hljs-comment">//在canvas上进行绘制</span><br>            mView.draw(canvas);<br>           <span class="hljs-comment">//将绘制内容提交给SF进行合成</span><br>            surface.unlockCanvasAndPost(canvas);      <br>      <br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>drawSoftware()</code>主要分为以下几步：</p>
<pre><code class=" mermaid">graph LR
classDef someclass fill:#f96;
A(&quot;drawSoftware()&lt;br&gt;软件绘制&quot;)
B(&quot;lockCanvas()&lt;br&gt;获取Canvas&quot;)
C(&quot;draw(canvas)&lt;br&gt;在Canvas进行绘制&quot;)
D(&quot;unlockCanvasAndPost()&lt;br&gt;提交绘制完成的GraphicBuffer&lt;br&gt;到SurfaceFlinger进行合成&quot;)
A--&gt;B:::someclass
A--&gt;C
A--&gt;D:::someclass
</code></pre>



<h5 id="lockCanvas"><a href="#lockCanvas" class="headerlink" title="lockCanvas"></a>lockCanvas</h5><blockquote>
<p>获取<code>Canvas</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Surface.java</span><br>    <span class="hljs-keyword">public</span> Canvas <span class="hljs-title function_">lockCanvas</span><span class="hljs-params">(Rect inOutDirty)</span><br>            <span class="hljs-keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException &#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            checkNotReleasedLocked();<br>            <span class="hljs-keyword">if</span> (mLockedObject != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Surface was already locked&quot;</span>);<br>            &#125;<br>            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);<br>            <span class="hljs-keyword">return</span> mCanvas;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/core/jni/android_view_Surface.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> jlong <span class="hljs-title">nativeLockCanvas</span><span class="hljs-params">(JNIEnv* env, jclass clazz,</span></span><br><span class="hljs-params"><span class="hljs-function">        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;<br>    <span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">surface</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;<br>  ...<br>    <span class="hljs-function">Rect <span class="hljs-title">dirtyRect</span><span class="hljs-params">(Rect::EMPTY_RECT)</span></span>;<br>    Rect* dirtyRectPtr = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (dirtyRectObj) &#123;<br>        dirtyRect.left   = env-&gt;<span class="hljs-built_in">GetIntField</span>(dirtyRectObj, gRectClassInfo.left);<br>        dirtyRect.top    = env-&gt;<span class="hljs-built_in">GetIntField</span>(dirtyRectObj, gRectClassInfo.top);<br>        dirtyRect.right  = env-&gt;<span class="hljs-built_in">GetIntField</span>(dirtyRectObj, gRectClassInfo.right);<br>        dirtyRect.bottom = env-&gt;<span class="hljs-built_in">GetIntField</span>(dirtyRectObj, gRectClassInfo.bottom);<br>        dirtyRectPtr = &amp;dirtyRect;<br>    &#125;<br><br>    ANativeWindow_Buffer outBuffer;<br>  <span class="hljs-comment">//获取绘制图形的GraphicBuffer</span><br>    <span class="hljs-type">status_t</span> err = surface-&gt;<span class="hljs-built_in">lock</span>(&amp;outBuffer, dirtyRectPtr);  <br>  ...<br>    SkImageInfo info = SkImageInfo::<span class="hljs-built_in">Make</span>(outBuffer.width, outBuffer.height,<br>                                         <span class="hljs-built_in">convertPixelFormat</span>(outBuffer.format),<br>                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888<br>                                                 ? kOpaque_SkAlphaType : kPremul_SkAlphaType,<br>                                         GraphicsJNI::<span class="hljs-built_in">defaultColorSpace</span>());<br><br>    SkBitmap bitmap;<br>    <span class="hljs-type">ssize_t</span> bpr = outBuffer.stride * <span class="hljs-built_in">bytesPerPixel</span>(outBuffer.format);<br>    bitmap.<span class="hljs-built_in">setInfo</span>(info, bpr);<br>    <span class="hljs-keyword">if</span> (outBuffer.width &gt; <span class="hljs-number">0</span> &amp;&amp; outBuffer.height &gt; <span class="hljs-number">0</span>) &#123;<br>        bitmap.<span class="hljs-built_in">setPixels</span>(outBuffer.bits);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// be safe with an empty bitmap.</span><br>        bitmap.<span class="hljs-built_in">setPixels</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>   <span class="hljs-comment">//新建Canvas对象</span><br>    Canvas* nativeCanvas = GraphicsJNI::<span class="hljs-built_in">getNativeCanvas</span>(env, canvasObj);<br>    nativeCanvas-&gt;<span class="hljs-built_in">setBitmap</span>(bitmap);    <br>  <br>    <span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">lockedSurface</span><span class="hljs-params">(surface)</span></span>;<br>    lockedSurface-&gt;<span class="hljs-built_in">incStrong</span>(&amp;sRefBaseOwner);<br>   <span class="hljs-comment">//返回最后的Canvas对象</span><br>    <span class="hljs-keyword">return</span> (jlong) lockedSurface.<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要通过<code>surface#lock</code>获取<code>GraphicBuffer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">Surface::lock</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>    <span class="hljs-type">status_t</span> err = <span class="hljs-built_in">dequeueBuffer</span>(&amp;out, &amp;fenceFd);<br>  ...<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后通过<code>dequeueBuffer</code>获取<code>GraphicBuffer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Surface::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-type">android_native_buffer_t</span>** buffer, <span class="hljs-type">int</span>* fenceFd)</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//申请一块GraphicBuffer</span><br>    <span class="hljs-type">status_t</span> result = mGraphicBufferProducer-&gt;<span class="hljs-built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, reqWidth, reqHeight,<br>                                                            reqFormat, reqUsage, &amp;mBufferAge,<br>                                                            enableFrameTimestamps ? &amp;frameTimestamps<br>                                                                                  : <span class="hljs-literal">nullptr</span>);    <br>  ...<br>    <span class="hljs-keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mReportRemovedBuffers &amp;&amp; (gbuf != <span class="hljs-literal">nullptr</span>)) &#123;<br>            mRemovedBuffers.<span class="hljs-built_in">push_back</span>(gbuf);<br>        &#125;<br>      <span class="hljs-comment">//映射 GraphicBuffer</span><br>        result = mGraphicBufferProducer-&gt;<span class="hljs-built_in">requestBuffer</span>(buf, &amp;gbuf);<br>        <span class="hljs-keyword">if</span> (result != NO_ERROR) &#123;<br>            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d&quot;</span>, result);<br>            mGraphicBufferProducer-&gt;<span class="hljs-built_in">cancelBuffer</span>(buf, fence);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要执行了以下两步：</p>
<ol>
<li><code>dequeueBuffer</code>：申请<code>GraphicBuffer</code></li>
<li><code>requestBuffer</code>：使用<code>GraphicBuffer</code></li>
</ol>
<p>其中<code>requestBuffer</code>通过<strong>共享内存</strong>方式获取<code>GraphicBuffer</code>数据</p>
<pre><code class=" mermaid">graph TB

 E(&quot;nativeLockCanvas()&quot;)
 F(&quot;Surface-&gt;lock()&quot;)
 G(&quot;Surface::dequeueBuffer()&lt;br&gt;获取待绘制的GraphicBuffer&quot;)
 H(&quot;mGraphicProducer&lt;br&gt;.requestBuffer()&lt;br&gt;使用GraphicBuffer&quot;)
 E--&gt;F
 F--&gt;G
 G--&gt;J
 J--&gt;H
J(&quot;mGraphicProducer&lt;br&gt;.dequeueBuffer()&quot;)

</code></pre>





<h5 id="draw-Canvas"><a href="#draw-Canvas" class="headerlink" title="draw(Canvas)"></a>draw(Canvas)</h5><blockquote>
<p>在Canvas上绘制图形</p>
</blockquote>
<h5 id="unlockCanvasAndPost"><a href="#unlockCanvasAndPost" class="headerlink" title="unlockCanvasAndPost()"></a>unlockCanvasAndPost()</h5><blockquote>
<p>提交绘制完成的GraphicBuffer到SurfaceFlinger进行合成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Surface.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlockCanvasAndPost</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            checkNotReleasedLocked();<br><br>            <span class="hljs-keyword">if</span> (mHwuiContext != <span class="hljs-literal">null</span>) &#123;<br>                mHwuiContext.unlockAndPost(canvas);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//软件绘制提交</span><br>                unlockSwCanvasAndPost(canvas);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlockSwCanvasAndPost</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            nativeUnlockCanvasAndPost(mLockedObject, canvas);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            nativeRelease(mLockedObject);<br>            mLockedObject = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/core/jni/android_view_Surface.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">nativeUnlockCanvasAndPost</span><span class="hljs-params">(JNIEnv* env, jclass clazz,</span></span><br><span class="hljs-params"><span class="hljs-function">        jlong nativeObject, jobject canvasObj)</span> </span>&#123;<br>    <span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">surface</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isSurfaceValid</span>(surface)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// detach the canvas from the surface</span><br>    Canvas* nativeCanvas = GraphicsJNI::<span class="hljs-built_in">getNativeCanvas</span>(env, canvasObj);<br>    nativeCanvas-&gt;<span class="hljs-built_in">setBitmap</span>(<span class="hljs-built_in">SkBitmap</span>());<br><br>    <span class="hljs-comment">// unlock surface</span><br>    <span class="hljs-type">status_t</span> err = surface-&gt;<span class="hljs-built_in">unlockAndPost</span>();<br>    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">doThrowIAE</span>(env);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继续通过<code>Surface#unlockAndPost()</code>执行提交过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">Surface::unlockAndPost</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (mLockedBuffer == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Surface::unlockAndPost failed, no locked buffer&quot;</span>);<br>        <span class="hljs-keyword">return</span> INVALID_OPERATION;<br>    &#125;<br><br>    <span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">status_t</span> err = mLockedBuffer-&gt;<span class="hljs-built_in">unlockAsync</span>(&amp;fd);<br><br>    err = <span class="hljs-built_in">queueBuffer</span>(mLockedBuffer.<span class="hljs-built_in">get</span>(), fd);<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Surface::queueBuffer</span><span class="hljs-params">(<span class="hljs-type">android_native_buffer_t</span>* buffer, <span class="hljs-type">int</span> fenceFd)</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//根据传入的GraphicBufer 获取对应的 BufferSlot位置</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">getSlotFromBufferLocked</span>(buffer);<br>  ...<br>    <span class="hljs-comment">//把获取到的数据 放回到BufferQueue中</span><br>    <span class="hljs-type">status_t</span> err = mGraphicerProducer-&gt;<span class="hljs-built_in">queueBuffer</span>(i, input, &amp;output);    <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后通过<code>queueBuffer</code>提交<code>GraphicBuffer</code>。</p>
<pre><code class=" mermaid">graph TB
A(&quot;unlockCanvasAndPost()&quot;)
B(&quot;unlockSwCanvasAndPost()&quot;)
C(&quot;Surface::unlockAndPost&quot;)
A--&gt;B
B--&quot;nativeUnlockCanvasAndPost()&quot;--&gt;C
D(&quot;Surface::queueBuffer&quot;)
C--&gt;D
E(&quot;i = &lt;br&gt;getSlotFromBufferLocked()&quot;)
G(&quot;根据传入的Buffer获取对应mSlots中的index&quot;)
G---E
D---&gt;E
F(&quot;mGraphicProducer&lt;br&gt;.queueBuffer(i)&quot;)
H(&quot;通过queueBuffer放回数据&quot;)
E--&gt;F
H---F
</code></pre>

<h4 id="硬件绘制"><a href="#硬件绘制" class="headerlink" title="硬件绘制"></a>硬件绘制</h4><p>具体执行流程可以参考<a href="/2020/10/27/Android-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/" title="Android硬件加速">Android硬件加速</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/libs/hwui/renderthread/CanvasContext.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CanvasContext::draw</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//获取GraphicBuffer</span><br>    Frame frame = mRenderPipeline-&gt;<span class="hljs-built_in">getFrame</span>();<br>  ...<br>    <span class="hljs-comment">//绘制图形到 GraphicBuffer上</span><br>    <span class="hljs-type">bool</span> drew = mRenderPipeline-&gt;<span class="hljs-built_in">draw</span>(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,<br>                                      mContentDrawBounds, mOpaque, mWideColorGamut, mLightInfo,<br>                                      mRenderNodes, &amp;(<span class="hljs-built_in">profiler</span>()));    <br>  ...<br>    <span class="hljs-comment">//提交绘制完成的GraphicBuffer到 SurfaceFlinger进行合成</span><br>    <span class="hljs-type">bool</span> requireSwap = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> didSwap =<br>            mRenderPipeline-&gt;<span class="hljs-built_in">swapBuffers</span>(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="OpenGLPipeline-getFrame"><a href="#OpenGLPipeline-getFrame" class="headerlink" title="OpenGLPipeline#getFrame"></a>OpenGLPipeline#getFrame</h5><blockquote>
<p>从<code>BufferQueue</code>获取<code>GraphicBuffer</code>准备绘制图形</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/libs/hwui/renderthread/OpenGLPipeline.cpp</span><br><span class="hljs-function">Frame <span class="hljs-title">OpenGLPipeline::getFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mEglManager.<span class="hljs-built_in">beginFrame</span>(mEglSurface);<br>&#125;<br><br><span class="hljs-comment">//base/libs/hwui/renderthread/EglManager.cpp</span><br><span class="hljs-function">Frame <span class="hljs-title">EglManager::beginFrame</span><span class="hljs-params">(EGLSurface surface)</span> </span>&#123;<br>    <span class="hljs-built_in">makeCurrent</span>(surface);  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EglManager::makeCurrent</span><span class="hljs-params">(EGLSurface surface, EGLint* errOut)</span> </span>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">eglMakeCurrent</span>(mEglDisplay, surface, surface, mEglContext)) &#123;<br>        <span class="hljs-keyword">if</span> (errOut) &#123;<br>            *errOut = <span class="hljs-built_in">eglGetError</span>();<br>        &#125;<br>    &#125;<br>    mCurrentSurface = surface; <br>  ...<br>&#125;<br><br><span class="hljs-comment">//native/opengl/libagl/egl.cpp</span><br><span class="hljs-function">EGLBoolean <span class="hljs-title">eglMakeCurrent</span><span class="hljs-params">(  EGLDisplay dpy, EGLSurface draw,</span></span><br><span class="hljs-params"><span class="hljs-function">                            EGLSurface read, EGLContext ctx)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (ctx == EGL_NO_CONTEXT) &#123;<br>        <span class="hljs-comment">// if we&#x27;re detaching, we need the current context</span><br>        current_ctx = (EGLContext)<span class="hljs-built_in">getGlThreadSpecific</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">egl_surface_t</span>* d = (<span class="hljs-type">egl_surface_t</span>*)draw;<br>        <span class="hljs-type">egl_surface_t</span>* r = (<span class="hljs-type">egl_surface_t</span>*)read;<br>    &#125;  <br>  ...<br>            <span class="hljs-keyword">if</span> (d) &#123;<br>              <span class="hljs-comment">//创建GraphicBuffer</span><br>                <span class="hljs-keyword">if</span> (d-&gt;<span class="hljs-built_in">connect</span>() == EGL_FALSE) &#123;<br>                    <span class="hljs-keyword">return</span> EGL_FALSE;<br>                &#125;<br>                d-&gt;ctx = ctx;<br>                d-&gt;<span class="hljs-built_in">bindDrawSurface</span>(gl);<br>            &#125;<br>  ...<br>&#125;<br><br><span class="hljs-function">EGLBoolean <span class="hljs-title">egl_window_surface_v2_t::connect</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>      <span class="hljs-comment">// dequeue a buffer</span><br>    <span class="hljs-type">int</span> fenceFd = <span class="hljs-number">-1</span>;<br>   <span class="hljs-comment">//Surface是 ANativeWindow 的子类，实际调用的就是Surface#dequeueBuffer</span><br>    <span class="hljs-keyword">if</span> (nativeWindow-&gt;<span class="hljs-built_in">dequeueBuffer</span>(nativeWindow, &amp;buffer,<br>            &amp;fenceFd) != NO_ERROR) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">setError</span>(EGL_BAD_ALLOC, EGL_FALSE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>OpenGLPipeline#getFrame()</code>最后通过<code>Surface#dequeueBuffer()</code>获取<code>GraphicBuffer</code></p>
<h5 id="OpenGLPipeline-draw"><a href="#OpenGLPipeline-draw" class="headerlink" title="OpenGLPipeline#draw"></a>OpenGLPipeline#draw</h5><blockquote>
<p>将图像绘制到获取的<code>GraphicBuffer</code>上</p>
</blockquote>
<h5 id="OpenGLPipeline-swapBuffers"><a href="#OpenGLPipeline-swapBuffers" class="headerlink" title="OpenGLPipeline#swapBuffers"></a>OpenGLPipeline#swapBuffers</h5><blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/libs/hwui/renderthread/OpenGLPipeline.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OpenGLPipeline::swapBuffers</span><span class="hljs-params">(<span class="hljs-type">const</span> Frame&amp; frame, <span class="hljs-type">bool</span> drew, <span class="hljs-type">const</span> SkRect&amp; screenDirty,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 FrameInfo* currentFrameInfo, <span class="hljs-type">bool</span>* requireSwap)</span> </span>&#123;<br><br>  ...<br>    <span class="hljs-keyword">if</span> (*requireSwap &amp;&amp; (<span class="hljs-built_in">CC_UNLIKELY</span>(!mEglManager.<span class="hljs-built_in">swapBuffers</span>(frame, screenDirty)))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> *requireSwap;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在向下执行到<code>EglManager#swapBuffers()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/libs/hwui/renderthread/EglManager.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EglManager::swapBuffers</span><span class="hljs-params">(<span class="hljs-type">const</span> Frame&amp; frame, <span class="hljs-type">const</span> SkRect&amp; screenDirty)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(Properties::waitForGpuCompletion)) &#123;<br>        <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;Finishing GPU work&quot;</span>);<br>        <span class="hljs-built_in">fence</span>();<br>    &#125;<br><br>    EGLint rects[<span class="hljs-number">4</span>];<br>    frame.<span class="hljs-built_in">map</span>(screenDirty, rects);<br>    <span class="hljs-built_in">eglSwapBuffersWithDamageKHR</span>(mEglDisplay, frame.mSurface, rects, screenDirty.<span class="hljs-built_in">isEmpty</span>() ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//native/opengl/libs/EGL/eglApi.cpp</span><br><span class="hljs-function">EGLBoolean <span class="hljs-title">eglSwapBuffersWithDamageKHR</span><span class="hljs-params">(EGLDisplay dpy, EGLSurface draw,</span></span><br><span class="hljs-params"><span class="hljs-function">        EGLint *rects, EGLint n_rects)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (n_rects == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> s-&gt;cnx-&gt;egl.<span class="hljs-built_in">eglSwapBuffers</span>(dp-&gt;disp.dpy, s-&gt;surface);<br>    &#125;<br>  ...<br>    <span class="hljs-keyword">if</span> (s-&gt;cnx-&gt;egl.eglSwapBuffersWithDamageKHR) &#123;<br>      <span class="hljs-comment">//调用自身</span><br>        <span class="hljs-keyword">return</span> s-&gt;cnx-&gt;egl.<span class="hljs-built_in">eglSwapBuffersWithDamageKHR</span>(dp-&gt;disp.dpy, s-&gt;surface,<br>                rects, n_rects);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> s-&gt;cnx-&gt;egl.<span class="hljs-built_in">eglSwapBuffers</span>(dp-&gt;disp.dpy, s-&gt;surface);<br>    &#125;  <br> <br>&#125;<br><br><span class="hljs-comment">//native/opengl/libagl/egl.cpp</span><br><span class="hljs-function">EGLBoolean <span class="hljs-title">eglSwapBuffers</span><span class="hljs-params">(EGLDisplay dpy, EGLSurface draw)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// post the surface</span><br>    d-&gt;<span class="hljs-built_in">swapBuffers</span>();<br>   ...<br>    <span class="hljs-keyword">return</span> EGL_TRUE;<br>&#125;<br><br><span class="hljs-function">EGLBoolean <span class="hljs-title">egl_window_surface_v2_t::swapBuffers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>    <span class="hljs-built_in">unlock</span>(buffer);<br>    previousBuffer = buffer;<br>  <span class="hljs-comment">//提交GraphicBuffer</span><br>    nativeWindow-&gt;<span class="hljs-built_in">queueBuffer</span>(nativeWindow, buffer, <span class="hljs-number">-1</span>);<br>    buffer = <span class="hljs-number">0</span>;<br>  ...<br>    <span class="hljs-comment">//重新申请 GraphicBuffer</span><br>    <span class="hljs-keyword">if</span> (nativeWindow-&gt;<span class="hljs-built_in">dequeueBuffer</span>(nativeWindow, &amp;buffer, &amp;fenceFd) == NO_ERROR) &#123;<br>        <span class="hljs-function">sp&lt;Fence&gt; <span class="hljs-title">fence</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Fence(fenceFd))</span></span>;<br>      ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>swapBuffers()</code>主要执行以下两步：</p>
<ul>
<li><code>Surface#queueBuffer</code>：提交<code>GraphicBuffer</code>到<code>BufferQueue</code>中</li>
<li><code>Surface#dequeueBuffer</code>：从<code>BufferQueue</code>中获取空闲的<code>BufferQueue</code>并获取其中的<code>GraphicBuffer</code>进行图像绘制</li>
</ul>
<p>&#x2F;&#x2F;TODO 流程图</p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>图像缓冲区的使用场景主要有两种：<code>软件绘制</code>和<code>硬件绘制</code>。</p>
<p>主要执行以下几步：</p>
<ol>
<li><code>dequeueBuffer</code>获取<code>GraphicBuffer</code></li>
<li>进行<code>GraphicBuffer</code>内存绑定操作<ul>
<li>软件绘制：<code>GBQ#requestBuffer</code></li>
<li>硬件绘制：<code>egl#lock</code></li>
</ul>
</li>
<li>在<code>GraphicBuffer</code>进行图像绘制</li>
<li><code>queueBuffer</code>提交<code>GraphicBuffer</code>到<code>BufferQueue</code>中</li>
</ol>
<h3 id="图形缓冲区在图像消费者的使用"><a href="#图形缓冲区在图像消费者的使用" class="headerlink" title="图形缓冲区在图像消费者的使用"></a>图形缓冲区在<code>图像消费者</code>的使用</h3><blockquote>
<p><code>图像消费者</code>主要就是<code>SurfaceFlinger</code></p>
</blockquote>
<p>主要执行流程参考<a href="#Vsync%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3">Vsync信号相关</a></p>
<p>收到<code>Vsync信号</code>会回调到<code>SurfaceFlinger</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> what)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (what) &#123;<br>        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;<br>          <span class="hljs-comment">//判断是否有丢帧</span><br>            <span class="hljs-type">bool</span> frameMissed = !mHadClientComposition &amp;&amp;<br>                    mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;<br>                    (mPreviousPresentFence-&gt;<span class="hljs-built_in">getSignalTime</span>() ==<br>                            Fence::SIGNAL_TIME_PENDING);<br>            <span class="hljs-keyword">if</span> (frameMissed) &#123;<br>                mTimeStats.<span class="hljs-built_in">incrementMissedFrames</span>();<br>                <span class="hljs-keyword">if</span> (mPropagateBackpressure) &#123;<br>                  <span class="hljs-comment">//需要执行 申请Vsync信号过程</span><br>                    <span class="hljs-built_in">signalLayerUpdate</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>          <span class="hljs-comment">//需要重新刷新</span><br>            <span class="hljs-type">bool</span> refreshNeeded = <span class="hljs-built_in">handleMessageTransaction</span>();<br>            refreshNeeded |= <span class="hljs-built_in">handleMessageInvalidate</span>();<br>            refreshNeeded |= mRepaintEverything;<br>            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;<br>              <span class="hljs-comment">//执行刷新过程</span><br>                <span class="hljs-built_in">signalRefresh</span>();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;<br>            <span class="hljs-built_in">handleMessageRefresh</span>();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>handleMessageRefresh</code>流程在上面的<a href="#%E5%A4%84%E7%90%86Vsync">处理Vsync</a>已经介绍过，包括<code>signalLayerUpdate()</code>以及<code>signalRefresh()</code>都有相关的介绍。</p>
<p>在<code>SurfaceFlinger</code>与<code>BufferQueue</code>相关的操作都位于<code>handleMessageInvalidate()</code>中</p>
<h4 id="SF-handleMessageInvalidate"><a href="#SF-handleMessageInvalidate" class="headerlink" title="SF#handleMessageInvalidate"></a>SF#handleMessageInvalidate</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SurfaceFlinger::handleMessageInvalidate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">handlePageFlip</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SurfaceFlinger::handlePageFlip</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;<br>        <span class="hljs-function"><span class="hljs-type">const</span> Region <span class="hljs-title">dirty</span><span class="hljs-params">(layer-&gt;latchBuffer(visibleRegions, latchTime))</span></span>;<br>        layer-&gt;<span class="hljs-built_in">useSurfaceDamage</span>();<br>        <span class="hljs-built_in">invalidateLayerStack</span>(layer, dirty);<br>        <span class="hljs-keyword">if</span> (layer-&gt;<span class="hljs-built_in">isBufferLatched</span>()) &#123;<br>            newDataLatched = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中<code>layer</code>的实现为<code>BufferLayer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="hljs-function">Region <span class="hljs-title">BufferLayer::latchBuffer</span><span class="hljs-params">(<span class="hljs-type">bool</span>&amp; recomputeVisibleRegions, <span class="hljs-type">nsecs_t</span> latchTime)</span> </span>&#123;<br>  ...<br>    <span class="hljs-type">bool</span> queuedBuffer = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">status_t</span> updateResult =<br>            mConsumer-&gt;<span class="hljs-built_in">updateTexImage</span>(&amp;r, mFlinger-&gt;mPrimaryDispSync,<br>                                                    &amp;mAutoRefresh, &amp;queuedBuffer,<br>                                                    mLastFrameNumberReceived);  <br>  ...<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p><code>mConsumer</code>指的对象为<code>BufferLayerConsumer</code></p>
<h5 id="BufferLayerConsumer-updateTexImage"><a href="#BufferLayerConsumer-updateTexImage" class="headerlink" title="BufferLayerConsumer#updateTexImage"></a>BufferLayerConsumer#updateTexImage</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/BufferLayerConsumer.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferLayerConsumer::updateTexImage</span><span class="hljs-params">(BufferRejecter* rejecter, <span class="hljs-type">const</span> DispSync&amp; dispSync,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">bool</span>* autoRefresh, <span class="hljs-type">bool</span>* queuedBuffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br>  ...<br>    BufferItem item;<br><br>    <span class="hljs-comment">// Acquire the next buffer.</span><br>    <span class="hljs-comment">// In asynchronous mode the list is guaranteed to be one buffer</span><br>    <span class="hljs-comment">// deep, while in synchronous mode we use the oldest buffer.</span><br>    <span class="hljs-comment">// 从BufferQueue获取已绘制完成的 GraphicBuffer</span><br>    <span class="hljs-type">status_t</span> err = <span class="hljs-built_in">acquireBufferLocked</span>(&amp;item, <span class="hljs-built_in">computeExpectedPresent</span>(dispSync), maxFrameNumber);<br>  <br>    <span class="hljs-comment">// Release the previous buffer.</span><br>    <span class="hljs-comment">//释放已经使用完成的 GraphicBuffer并返回到BufferQueue</span><br>    err = <span class="hljs-built_in">updateAndReleaseLocked</span>(item, &amp;mPendingRelease);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>updateTexImage</code>主要执行以下两步：</p>
<h6 id="acquireBufferLocked"><a href="#acquireBufferLocked" class="headerlink" title="acquireBufferLocked"></a>acquireBufferLocked</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferLayerConsumer::acquireBufferLocked</span><span class="hljs-params">(BufferItem* item, <span class="hljs-type">nsecs_t</span> presentWhen,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                  <span class="hljs-type">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br>    <span class="hljs-type">status_t</span> err = ConsumerBase::<span class="hljs-built_in">acquireBufferLocked</span>(item, presentWhen, maxFrameNumber);<br>    <span class="hljs-keyword">return</span> NO_ERROR;<br>&#125;<br><br><span class="hljs-comment">//native/libs/gui/ConsumerBase.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">ConsumerBase::acquireBufferLocked</span><span class="hljs-params">(BufferItem *item,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">nsecs_t</span> presentWhen, <span class="hljs-type">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br>   <br>    <span class="hljs-type">status_t</span> err = mConsumer-&gt;<span class="hljs-built_in">acquireBuffer</span>(item, presentWhen, maxFrameNumber);<br><br>    <span class="hljs-keyword">if</span> (item-&gt;mGraphicBuffer != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mSlots[item-&gt;mSlot].mGraphicBuffer != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">freeBufferLocked</span>(item-&gt;mSlot);<br>        &#125;<br>        mSlots[item-&gt;mSlot].mGraphicBuffer = item-&gt;mGraphicBuffer;<br>    &#125;<br><br>    mSlots[item-&gt;mSlot].mFrameNumber = item-&gt;mFrameNumber;<br>    mSlots[item-&gt;mSlot].mFence = item-&gt;mFence;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后是通过<code>acquireBuffer</code>从<code>BufferQueue</code>获取<code>已绘制完成的GraphicBuffer</code></p>
<h6 id="updateAndReleaseLocked"><a href="#updateAndReleaseLocked" class="headerlink" title="updateAndReleaseLocked"></a>updateAndReleaseLocked</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">BufferLayerConsumer::updateAndReleaseLocked</span><span class="hljs-params">(<span class="hljs-type">const</span> BufferItem&amp; item,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                     PendingRelease* pendingRelease)</span> </span>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) &#123;<br>        <span class="hljs-keyword">if</span> (pendingRelease == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-type">status_t</span> status =<br>                    <span class="hljs-built_in">releaseBufferLocked</span>(mCurrentTexture, mCurrentTextureImage-&gt;<span class="hljs-built_in">graphicBuffer</span>());<br>        &#125;<br>    &#125;<br>  ...<br>&#125;<br><br><span class="hljs-comment">//native/libs/gui/ConsumerBase.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">ConsumerBase::releaseBufferLocked</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> slot, <span class="hljs-type">const</span> sp&lt;GraphicBuffer&gt; graphicBuffer,</span></span><br><span class="hljs-params"><span class="hljs-function">        EGLDisplay display, EGLSyncKHR eglFence)</span> </span>&#123;<br>  ...<br>    <span class="hljs-type">status_t</span> err = mConsumer-&gt;<span class="hljs-built_in">releaseBuffer</span>(slot, mSlots[slot].mFrameNumber,<br>            display, eglFence, mSlots[slot].mFence);<br>    <span class="hljs-keyword">if</span> (err == IGraphicBufferConsumer::STALE_BUFFER_SLOT) &#123;<br>      <span class="hljs-comment">//重置BufferSlot数据</span><br>        <span class="hljs-built_in">freeBufferLocked</span>(slot);<br>    &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后是通过<code>releaseBuffer()</code>把<code>使用完成的GraphicBuffer</code>返回到<code>BufferQueue</code>中</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/">SurfaceFlinger 解读</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tyuiof/article/details/108434845">掌握Android图像显示原理-上</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/" class="print-no-link">#Android</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Android-SurfaceFlinger解析</div>
      <div>http://example.com/2020/12/21/Android-SurfaceFlinger解析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Leo-Wxy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年12月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/16/Ubuntu18-04-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/" title="Ubuntu18.04 双系统安装笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Ubuntu18.04 双系统安装笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/14/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/" title="Android性能优化-自动内存分析">
                        <span class="hidden-mobile">Android性能优化-自动内存分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
