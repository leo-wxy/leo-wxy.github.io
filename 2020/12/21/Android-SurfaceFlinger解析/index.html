

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Android-SurfaceFlinger解析 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android-SurfaceFlinger解析">
              
                Android-SurfaceFlinger解析
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-21 15:06" pubdate>
        2020年12月21日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      231
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android-SurfaceFlinger解析</h1>
            
            <div class="markdown-body">
              <blockquote>
<p> 基于<code>Android 6.0</code>源码进行分析</p>
</blockquote>
<p><code>SurfaceFlinger</code>是Android系统中最重要的<strong>图像消费者</strong>，Activity绘制的界面图像，都会传递到<code>SurfaceFlinger</code>中。</p>
<p>主要作用：<strong>接收图像缓冲区数据，然后交给HWComposer或OpenGL合成，合成完毕后再返回。</strong></p>
<p><img src="/images/SurfaceFlinger执行流程.jpg" srcset="/img/loading.gif" alt="SurfaceFlinger执行流程"></p>
<h2 id="SurfaceFlinger初始化"><a href="#SurfaceFlinger初始化" class="headerlink" title="SurfaceFlinger初始化"></a>SurfaceFlinger初始化</h2><p><code>init</code>通过执行<code>surfaceflinger.rc</code>文件，然后就执行到了<code>main_surfaceflinger.cpp</code>开始初始化流程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp<br><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>**) &#123;<br>    signal(SIGPIPE, SIG_IGN);<br><br>    hardware::configureRpcThreadpool(1 /* maxThreads */,<br>            <span class="hljs-literal">false</span> /* callerWillJoin */);<br><br>    startGraphicsAllocatorService();<br><br>   //设置支持最多 4个 binder线程执行<br>    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);<br><br>    // start the thread pool<br>    sp&lt;ProcessState&gt; ps(ProcessState::self());<br>    ps-&gt;startThreadPool();<br><br>    //构建 Surfaceflinger实例<br>    sp&lt;SurfaceFlinger&gt; flinger = <span class="hljs-keyword">new</span> SurfaceFlinger();<br><br>    // 执行初始化流程<br>    flinger-&gt;init();<br><br>    // 通过ServiceManager注册 SurfaceFlinger服务<br>    sp&lt;IServiceManager&gt; sm(defaultServiceManager());<br>    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="hljs-literal">false</span>,<br>                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);<br><br>    startDisplayService(); // dependency on SF getting registered above<br><br>    // 开始运行<br>    flinger-&gt;run();<br><br>    <span class="hljs-keyword">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="new-SurfaceFlinger"><a href="#new-SurfaceFlinger" class="headerlink" title="new SurfaceFlinger"></a>new SurfaceFlinger</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp<br><span class="hljs-keyword">void</span> SurfaceFlinger::onFirstRef()<br>&#123;<br>    mEventQueue-&gt;init(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>mEventQueue</code>执行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/MessageQueue.cpp<br><span class="hljs-keyword">void</span> MessageQueue::init(<span class="hljs-keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger) &#123;<br>    mFlinger = flinger;<br>    mLooper = <span class="hljs-keyword">new</span> Looper(<span class="hljs-literal">true</span>);<br>    mHandler = <span class="hljs-keyword">new</span> Handler(*<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>初始化<code>Handler</code></p>
<h3 id="SurfaceFlinger-init"><a href="#SurfaceFlinger-init" class="headerlink" title="SurfaceFlinger#init"></a>SurfaceFlinger#init</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::init() &#123;<br>    ALOGI(  "SurfaceFlinger's main thread ready to run. "<br>            "Initializing graphics H/W...");<br><br>    ALOGI("Phase offest NS: %" PRId64 "", vsyncPhaseOffsetNs);<br><br>    Mutex::Autolock _l(mStateLock);<br><br>    // start the EventThread<br>    mEventThreadSource =<br>            <span class="hljs-built_in">std</span>::make_unique&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs,<br>                                             <span class="hljs-literal">true</span>, "app");<br>    mEventThread = <span class="hljs-built_in">std</span>::make_unique&lt;impl::EventThread&gt;(mEventThreadSource.get(),<br>                                                       [<span class="hljs-keyword">this</span>]() &#123; resyncWithRateLimit(); &#125;,<br>                                                       impl::EventThread::InterceptVSyncsCallback(),<br>                                                       "appEventThread");<br>    mSfEventThreadSource =<br>            <span class="hljs-built_in">std</span>::make_unique&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync,<br>                                             SurfaceFlinger::sfVsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, "sf");<br><br>    mSFEventThread =<br>            <span class="hljs-built_in">std</span>::make_unique&lt;impl::EventThread&gt;(mSfEventThreadSource.get(),<br>                                                [<span class="hljs-keyword">this</span>]() &#123; resyncWithRateLimit(); &#125;,<br>                                                [<span class="hljs-keyword">this</span>](nsecs_t timestamp) &#123;<br>                                                    mInterceptor-&gt;saveVSyncEvent(timestamp);<br>                                                &#125;,<br>                                                "sfEventThread");<br>    mEventQueue-&gt;setEventThread(mSFEventThread.get());<br>    mVsyncModulator.setEventThread(mSFEventThread.get());<br><br>    // Get a RenderEngine <span class="hljs-keyword">for</span> the given display / config (can't fail)<br>    getBE().mRenderEngine =<br>            RE::impl::RenderEngine::create(HAL_PIXEL_FORMAT_RGBA_8888,<br>                                           hasWideColorDisplay<br>                                                   ? RE::RenderEngine::WIDE_COLOR_SUPPORT<br>                                                   : 0);<br>  <br>    getBE().mHwc.reset(<br>            <span class="hljs-keyword">new</span> HWComposer(<span class="hljs-built_in">std</span>::make_unique&lt;Hwc2::impl::Composer&gt;(getBE().mHwcServiceName)));<br>    getBE().mHwc-&gt;registerCallback(<span class="hljs-keyword">this</span>, getBE().mComposerSequenceId);<br>    // Process any initial hotplug <span class="hljs-keyword">and</span> resulting display changes.<br>    processDisplayHotplugEventsLocked();<br>    LOG_ALWAYS_FATAL_IF(!getBE().mHwc-&gt;isConnected(HWC_DISPLAY_PRIMARY),<br>            "Registered composer callback but didn't create the <span class="hljs-keyword">default</span> primary display");<br><br>    // make the <span class="hljs-keyword">default</span> display GLContext current so that we can create textures<br>    // when creating Layers (which may happens before we render something)<br>    getDefaultDisplayDeviceLocked()-&gt;makeCurrent();<br><br>    mEventControlThread = <span class="hljs-built_in">std</span>::make_unique&lt;impl::EventControlThread&gt;(<br>            [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">bool</span> enabled) &#123; setVsyncEnabled(HWC_DISPLAY_PRIMARY, enabled); &#125;);<br><br>    // initialize our drawing state<br>    mDrawingState = mCurrentState;<br><br>    // <span class="hljs-built_in">set</span> initial conditions (e.g. unblank <span class="hljs-keyword">default</span> device)<br>    initializeDisplays();<br><br>    getBE().mRenderEngine-&gt;primeCache();<br><br>    // Inform native graphics APIs whether the present timestamp is supported:<br>    <span class="hljs-keyword">if</span> (getHwComposer().hasCapability(<br>            HWC2::Capability::PresentFenceIsNotReliable)) &#123;<br>        mStartPropertySetThread = <span class="hljs-keyword">new</span> StartPropertySetThread(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mStartPropertySetThread = <span class="hljs-keyword">new</span> StartPropertySetThread(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mStartPropertySetThread-&gt;Start() != NO_ERROR) &#123;<br>        ALOGE("Run StartPropertySetThread failed!");<br>    &#125;<br><br>    mLegacySrgbSaturationMatrix = getBE().mHwc-&gt;getDataspaceSaturationMatrix(HWC_DISPLAY_PRIMARY,<br>            Dataspace::SRGB_LINEAR);<br><br>    ALOGV("Done initializing");<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="创建HWComposer"><a href="#创建HWComposer" class="headerlink" title="创建HWComposer"></a>创建HWComposer</h4><blockquote>
<p><code>HWComposer</code>代表着硬件显示设备。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp<br>HWComposer::HWComposer(<br>        <span class="hljs-keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,<br>        EventHandler&amp; handler)<br>    : mFlinger(flinger),<br>      mFbDev(0), mHwc(0), mNumDisplays(1),<br>      mCBContext(<span class="hljs-keyword">new</span> cb_context),<br>      mEventHandler(handler),<br>      mDebugForceFakeVSync(<span class="hljs-literal">false</span>)<br>&#123;<br>    ...     <br>    <span class="hljs-keyword">bool</span> needVSyncThread = <span class="hljs-literal">true</span>;<br><br>    // Note: some devices may insist that the FB HAL be opened before HWC.<br>    <span class="hljs-keyword">int</span> fberr = loadFbHalModule();<br>    loadHwcModule();//加载HWComposer模块<br><br>    // these display IDs are always reserved<br>    <span class="hljs-keyword">for</span> (size_t i=0 ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;<br>        mAllocatedDisplayIDs.markBit(i);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mHwc) &#123;<br>        ALOGI("Using %s version %u.%u", HWC_HARDWARE_COMPOSER,<br>              (hwcApiVersion(mHwc) &gt;&gt; 24) &amp; 0xff,<br>              (hwcApiVersion(mHwc) &gt;&gt; 16) &amp; 0xff);<br>        <span class="hljs-keyword">if</span> (mHwc-&gt;registerProcs) &#123;<br>            mCBContext-&gt;hwc = <span class="hljs-keyword">this</span>;<br>            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;<br>          //vsync信号回调方法<br>            mCBContext-&gt;procs.vsync = &amp;hook_vsync;<br>            <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))<br>                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;<br>            <span class="hljs-keyword">else</span><br>                mCBContext-&gt;procs.hotplug = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-built_in">memset</span>(mCBContext-&gt;procs.zero, 0, <span class="hljs-keyword">sizeof</span>(mCBContext-&gt;procs.zero));<br>          //注册回调函数<br>            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);<br>        &#125;<br><br>        // don't need a vsync thread <span class="hljs-keyword">if</span> we have a hardware composer<br>        needVSyncThread = <span class="hljs-literal">false</span>;<br>        // always turn vsync off when we start<br>        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);<br><br>        // the number of displays we actually have depends on the<br>        // hw composer version<br>        <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) &#123;<br>            // 1.3 adds support <span class="hljs-keyword">for</span> <span class="hljs-keyword">virtual</span> displays<br>            mNumDisplays = MAX_HWC_DISPLAYS;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;<br>            // 1.1 adds support <span class="hljs-keyword">for</span> multiple displays<br>            mNumDisplays = NUM_BUILTIN_DISPLAYS;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mNumDisplays = 1;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (needVSyncThread) &#123;<br>        // 不支持硬件Vsync的设备，则使用`VsyncThread`模拟发出Vsync信号<br>        mVSyncThread = <span class="hljs-keyword">new</span> VSyncThread(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Vsync信号</code>本身由显示驱动发出，如果不支持硬件<code>Vsync</code>，则使用<code>VsyncThread</code>模拟发出信号。</p>
<h4 id="初始化显示设备"><a href="#初始化显示设备" class="headerlink" title="初始化显示设备"></a>初始化显示设备</h4><h4 id="运行EventThread线程"><a href="#运行EventThread线程" class="headerlink" title="运行EventThread线程"></a>运行EventThread线程</h4><blockquote>
<p><code>EventThread</code>主要用来接收<code>Vsync信号</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::init() &#123;<br>  ...<br>        // start the EventThread<br>    sp&lt;VSyncSource&gt; vsyncSrc = <span class="hljs-keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,<br>            vsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, "app");<br>  //创建App的Vsync信号接收线程<br>    mEventThread = <span class="hljs-keyword">new</span> EventThread(vsyncSrc);<br>    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="hljs-keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,<br>            sfVsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, "sf");<br>   //创建Sf的Vsync信号接收线程<br>    mSFEventThread = <span class="hljs-keyword">new</span> EventThread(sfVsyncSrc);<br>    mEventQueue.setEventThread(mSFEventThread);<br>...<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="DispSyncSource"><a href="#DispSyncSource" class="headerlink" title="DispSyncSource"></a>DispSyncSource</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DispSyncSource(DispSync* dispSync, nsecs_t phaseOffset, <span class="hljs-keyword">bool</span> traceVsync,<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* label) :<br>        mValue(0),<br>        mTraceVsync(traceVsync),<br>        mVsyncOnLabel(String8::format("VsyncOn-%s", label)),<br>        mVsyncEventLabel(String8::format("VSYNC-%s", label)),<br>        mDispSync(dispSync),<br>        mCallbackMutex(),<br>        mCallback(),<br>        mVsyncMutex(),<br>        mPhaseOffset(phaseOffset),<br>        mEnabled(<span class="hljs-literal">false</span>) &#123;&#125;<br></code></pre></td></tr></table></figure>
<h5 id="EventThread"><a href="#EventThread" class="headerlink" title="EventThread"></a>EventThread</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">EventThread::EventThread(<span class="hljs-keyword">const</span> sp&lt;VSyncSource&gt;&amp; src)<br>    : mVSyncSource(src),<br>      mUseSoftwareVSync(<span class="hljs-literal">false</span>),<br>      mVsyncEnabled(<span class="hljs-literal">false</span>),<br>      mDebugVsyncEnabled(<span class="hljs-literal">false</span>),<br>      mVsyncHintSent(<span class="hljs-literal">false</span>) &#123;<br><br>    <span class="hljs-keyword">for</span> (int32_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;<br>        mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<br>        mVSyncEvent[i].header.id = 0;<br>        mVSyncEvent[i].header.timestamp = 0;<br>        mVSyncEvent[i].vsync.count =  0;<br>    &#125;<br>    struct sigevent se;<br>    se.sigev_notify = SIGEV_THREAD;<br>    se.sigev_value.sival_ptr = <span class="hljs-keyword">this</span>;<br>    se.sigev_notify_function = vsyncOffCallback;<br>    se.sigev_notify_attributes = <span class="hljs-literal">NULL</span>;<br>    timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> EventThread::onFirstRef() &#123;<br>  //运行EventThread线程<br>    run("EventThread", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);<br>&#125;<br><br><span class="hljs-keyword">bool</span> EventThread::threadLoop() &#123;<br>    DisplayEventReceiver::Event event;<br>    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;<br>  //等待事件发生<br>    signalConnections = waitForEvent(&amp;event);<br><br>    <span class="hljs-keyword">const</span> size_t count = signalConnections.size();<br>    <span class="hljs-keyword">for</span> (size_t i=0 ; i&lt;count ; i++) &#123;<br>        <span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; conn(signalConnections[i]);<br>        // 分发事件给所有的监听者<br>        status_t err = conn-&gt;postEvent(event);<br>        <span class="hljs-keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;<br>          <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err &lt; 0) &#123;<br>            removeDisplayEventConnection(signalConnections[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent(<br>        DisplayEventReceiver::Event* event)<br>&#123;<br>    Mutex::Autolock _l(mLock);<br>    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        // Here we figure out <span class="hljs-keyword">if</span> we need to enable <span class="hljs-keyword">or</span> disable vsyncs<br>        <span class="hljs-keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;<br>            disableVSyncLocked();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;<br>            enableVSyncLocked();<br>        &#125;<br><br>        // note: !timestamp implies signalConnections.isEmpty(), because we<br>        // don't populate signalConnections <span class="hljs-keyword">if</span> there's no vsync pending<br>        <span class="hljs-keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;<br>            // wait <span class="hljs-keyword">for</span> something to happen<br>            <span class="hljs-keyword">if</span> (waitForVSync) &#123;<br>                <span class="hljs-keyword">bool</span> softwareSync = mUseSoftwareVSync;<br>                nsecs_t timeout = softwareSync ? ms2ns(16) : ms2ns(1000);<br>                <span class="hljs-keyword">if</span> (mCondition.waitRelative(mLock, timeout) == TIMED_OUT) &#123;<br>                    <span class="hljs-keyword">if</span> (!softwareSync) &#123;<br>                        ALOGW("Timed out waiting <span class="hljs-keyword">for</span> hw vsync; faking it");<br>                    &#125;<br>                    mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<br>                    mVSyncEvent[0].header.id = DisplayDevice::DISPLAY_PRIMARY;<br>                    mVSyncEvent[0].header.timestamp = systemTime(SYSTEM_TIME_MONOTONIC);<br>                    mVSyncEvent[0].vsync.count++;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mCondition.wait(mLock);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (signalConnections.isEmpty());<br><br>    <span class="hljs-keyword">return</span> signalConnections;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建<code>EventThread</code>线程完毕后，执行<code>threadLoop</code>，通过<code>waitForEvent()</code>等待事件通知。</p>
<p>等待通过<code>mCondition.wait()</code>实现</p>
<h5 id="MessaqeQueue-setEventThread"><a href="#MessaqeQueue-setEventThread" class="headerlink" title="MessaqeQueue#setEventThread"></a>MessaqeQueue#setEventThread</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/MessageQueue.cpp<br><span class="hljs-keyword">void</span> MessageQueue::setEventThread(<span class="hljs-keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)<br>&#123;<br>    mEventThread = eventThread;<br>    mEvents = eventThread-&gt;createEventConnection();<br>    mEventTube = mEvents-&gt;getDataChannel();<br>    mLooper-&gt;addFd(mEventTube-&gt;getFd(), 0, Looper::EVENT_INPUT,<br>            MessageQueue::cb_eventReceiver, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要执行了以下几步：</p>
<h6 id="EventThread-createEventConnection"><a href="#EventThread-createEventConnection" class="headerlink" title="EventThread#createEventConnection"></a>EventThread#createEventConnection</h6><blockquote>
<p>新建<code>BitTube</code>对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/EventThread.cpp<br>sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Connection(<span class="hljs-keyword">const_cast</span>&lt;EventThread*&gt;(<span class="hljs-keyword">this</span>));<br>&#125;<br><br>EventThread::Connection::Connection(<br>        <span class="hljs-keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)<br>    : count(-1), mEventThread(eventThread), mChannel(<span class="hljs-keyword">new</span> BitTube())<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>构建完成<code>Connection</code>对象，执行如下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> EventThread::Connection::onFirstRef() &#123;<br>    // NOTE: mEventThread doesn't hold a strong reference on us<br>    mEventThread-&gt;registerDisplayEventConnection(<span class="hljs-keyword">this</span>);<br>&#125;<br><br>status_t EventThread::registerDisplayEventConnection(<br>        <span class="hljs-keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;<br>    Mutex::Autolock _l(mLock);<br>    mDisplayEventConnections.add(connection);<br>    mCondition.broadcast();<br>    <span class="hljs-keyword">return</span> NO_ERROR;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>初始化<code>Connection</code>之后，将<code>Connection</code>对象添加到<code>mDisplayEventConnections</code>中。</p>
<p><code>mDisplayEventConnections</code>主要负责<strong>保存接收Vsync信号的Connection的容器</strong>. 主要存储的是<code>SurfaceFlinger</code>与<code>App</code>的用来接收<code>Vsync信号</code>。</p>
<h6 id="Connection-getDataChannel"><a href="#Connection-getDataChannel" class="headerlink" title="Connection#getDataChannel"></a>Connection#getDataChannel</h6><blockquote>
<p>获取<code>BitTube</code>对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sp&lt;BitTube&gt; EventThread::Connection::getDataChannel() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> mChannel;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/libs/gui/BitTube.cpp<br>BitTube::BitTube(size_t bufsize) &#123;<br>    // 创建socket pair，用于发送事件<br>    init(bufsize, bufsize);<br>&#125;<br><br><span class="hljs-keyword">void</span> BitTube::init(size_t rcvbuf, size_t sndbuf) &#123;<br>    <span class="hljs-keyword">int</span> sockets[2];<br>    <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets) == 0) &#123;<br>        size_t size = DEFAULT_SOCKET_BUFFER_SIZE;<br>        // 设置socket buffer<br>        setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, <span class="hljs-keyword">sizeof</span>(rcvbuf));<br>        setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, <span class="hljs-keyword">sizeof</span>(sndbuf));<br>        // since we don't use the "<span class="hljs-keyword">return</span> channel", we keep it small...<br>        setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;size, <span class="hljs-keyword">sizeof</span>(size));<br>        setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;size, <span class="hljs-keyword">sizeof</span>(size));<br>        fcntl(sockets[0], F_SETFL, O_NONBLOCK);<br>        fcntl(sockets[1], F_SETFL, O_NONBLOCK);<br>        // socket[0]用于接收端，最终通过Binder IPC返回给客户端应用<br>        mReceiveFd.reset(sockets[0]);<br>        // socket[1]用于发送端<br>        mSendFd.reset(sockets[1]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mReceiveFd.reset();<br>        ALOGE("BitTube: pipe creation failed (%s)", strerror(errno));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>BitTube</code>实际是一个<code>Socket</code>，所以<code>EventThread</code>实际通过<code>Socket</code>和<code>MessageQueue</code>通信。</p>
<h6 id="Looper-addFd"><a href="#Looper-addFd" class="headerlink" title="Looper#addFd"></a>Looper#addFd</h6><blockquote>
<p>监听<code>BitTube</code>，一旦收到数据调用<code>cb_eventReceiver()</code></p>
</blockquote>
<p>通过<code>Looper</code>监听<code>BitTube</code>的fd。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这一步主要用于接收<code>Vsync信号</code>的初始化操作</p>
<ol>
<li><code>init()</code>中，创建了<code>EventThread</code>用来接收<code>Vsync信号</code></li>
<li>通过<code>MessageQueue.setEventThread()</code>将<code>EventThread</code>与<code>MessageQueue</code>建立关联。实际内部通过<code>BitTube(Socket)</code>建立两者间的通信。</li>
<li>再通过<code>addFd()</code>监听<code>BitTube</code>的套接字fd，这样就可以监听到数据的变化。</li>
</ol>
<h3 id="SurfaceFlinger-run"><a href="#SurfaceFlinger-run" class="headerlink" title="SurfaceFlinger#run"></a>SurfaceFlinger#run</h3><p>最后执行<code>SurfaceFlinger#run</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::run() &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        waitForEvent();<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> SurfaceFlinger::waitForEvent() &#123;<br>    mEventQueue.waitMessage();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/MessageQueue.cpp<br><span class="hljs-keyword">void</span> MessageQueue::waitMessage() &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        IPCThreadState::self()-&gt;flushCommands();<br>        int32_t ret = mLooper-&gt;pollOnce(-1);<br>        <span class="hljs-keyword">switch</span> (ret) &#123;<br>            <span class="hljs-keyword">case</span> Looper::POLL_WAKE:<br>            <span class="hljs-keyword">case</span> Looper::POLL_CALLBACK:<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> Looper::POLL_ERROR:<br>                ALOGE("Looper::POLL_ERROR");<br>            <span class="hljs-keyword">case</span> Looper::POLL_TIMEOUT:<br>                // timeout (should <span class="hljs-keyword">not</span> happen)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">default</span>:<br>                // should <span class="hljs-keyword">not</span> happen<br>                ALOGE("Looper::pollOnce() returned unknown status %d", ret);<br>                <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>waitMessage()</code>等待消息的到来</p>
<p><img src="/images/Sf初始化.png" srcset="/img/loading.gif" alt="Sf初始化"></p>
<h2 id="Vsync信号相关"><a href="#Vsync信号相关" class="headerlink" title="Vsync信号相关"></a>Vsync信号相关</h2><h3 id="接收Vsync"><a href="#接收Vsync" class="headerlink" title="接收Vsync"></a>接收Vsync</h3><h4 id="HWC-hook-vsync"><a href="#HWC-hook-vsync" class="headerlink" title="HWC#hook_vsync"></a>HWC#hook_vsync</h4><p><code>Vsync信号</code>都是由<code>HWComposer</code>发出的，需要从<code>HWC</code>进行分析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp<br>HWComposer::HWComposer(<br>        <span class="hljs-keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,<br>        EventHandler&amp; handler)<br>    : mFlinger(flinger),<br>      mFbDev(0), mHwc(0), mNumDisplays(1),<br>      mCBContext(<span class="hljs-keyword">new</span> cb_context),<br>      mEventHandler(handler),<br>      mDebugForceFakeVSync(<span class="hljs-literal">false</span>)<br>&#123;<br>        ...<br>    <span class="hljs-keyword">if</span> (mHwc) &#123;<br>        <span class="hljs-keyword">if</span> (mHwc-&gt;registerProcs) &#123;<br>            mCBContext-&gt;hwc = <span class="hljs-keyword">this</span>;<br>            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate; //invalidate事件回调<br>            mCBContext-&gt;procs.vsync = &amp;hook_vsync;//Vsync回调<br>            <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))<br>                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;<br>            <span class="hljs-keyword">else</span><br>                mCBContext-&gt;procs.hotplug = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-built_in">memset</span>(mCBContext-&gt;procs.zero, 0, <span class="hljs-keyword">sizeof</span>(mCBContext-&gt;procs.zero));<br>            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);<br>        &#125;          <br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>hook_vsync</code>处理<code>Vsync信号</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> HWComposer::hook_vsync(<span class="hljs-keyword">const</span> struct hwc_procs* procs, <span class="hljs-keyword">int</span> disp,<br>        int64_t timestamp) &#123;<br>    cb_context* ctx = <span class="hljs-keyword">reinterpret_cast</span>&lt;cb_context*&gt;(<br>            <span class="hljs-keyword">const_cast</span>&lt;hwc_procs_t*&gt;(procs));<br>    ctx-&gt;hwc-&gt;vsync(disp, timestamp);<br>&#125;<br><br><span class="hljs-keyword">void</span> HWComposer::vsync(<span class="hljs-keyword">int</span> disp, int64_t timestamp) &#123;<br>    <span class="hljs-keyword">if</span> (uint32_t(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;<br>        &#123;<br>            Mutex::Autolock _l(mLock);<br><br>            mLastHwVSync[disp] = timestamp;<br>        &#125;<br><br>        <span class="hljs-keyword">char</span> tag[16];<br>        <span class="hljs-built_in">snprintf</span>(tag, <span class="hljs-keyword">sizeof</span>(tag), "HW_VSYNC_%1u", disp);<br>        mEventHandler.onVSyncReceived(disp, timestamp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当<code>hook_vsync</code>收到<code>Vsync信号</code>时，回调到<code>vsync()</code>，继续调用到<code>mEventHandler.onVsyncReceived()</code></p>
<p><code>mEventHandler</code>是在<code>HWC</code>初始化时赋值的，实际就是<code>SurfaceFlinger</code></p>
<h4 id="Sf-onVSyncReceived"><a href="#Sf-onVSyncReceived" class="headerlink" title="Sf#onVSyncReceived"></a>Sf#onVSyncReceived</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::onVSyncReceived(<span class="hljs-keyword">int</span> type, nsecs_t timestamp) &#123;<br>    <span class="hljs-keyword">bool</span> needsHwVsync = <span class="hljs-literal">false</span>;<br><br>    &#123; // Scope <span class="hljs-keyword">for</span> the lock<br>        Mutex::Autolock _l(mHWVsyncLock);<br>        <span class="hljs-keyword">if</span> (type == 0 &amp;&amp; mPrimaryHWVsyncEnabled) &#123;<br>            needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (needsHwVsync) &#123;<br>        enableHardwareVsync();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        disableHardwareVsync(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> SurfaceFlinger::init() &#123;<br>    sp&lt;VSyncSource&gt; vsyncSrc = <span class="hljs-keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,<br>            vsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, "app");<br>    mEventThread = <span class="hljs-keyword">new</span> EventThread(vsyncSrc);<br>&#125;<br><br><span class="hljs-keyword">void</span> SurfaceFlinger::enableHardwareVsync() &#123;<br>    Mutex::Autolock _l(mHWVsyncLock);<br>    <span class="hljs-keyword">if</span> (!mPrimaryHWVsyncEnabled &amp;&amp; mHWVsyncAvailable) &#123;<br>        mPrimaryDispSync.beginResync();<br>        //申请Vsync信号<br>        mEventControlThread-&gt;setVsyncEnabled(<span class="hljs-literal">true</span>);<br>        mPrimaryHWVsyncEnabled = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="DispSync-addResyncSample"><a href="#DispSync-addResyncSample" class="headerlink" title="DispSync#addResyncSample"></a>DispSync#addResyncSample</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/DispSync.cpp<br>DispSync::DispSync() :<br>        mRefreshSkipCount(0),<br>        mThread(<span class="hljs-keyword">new</span> DispSyncThread()) &#123;<br>    //启动DispSyncThread<br>    mThread-&gt;run("DispSync", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);<br><br>    reset();<br>    beginResync();<br><br>    <span class="hljs-keyword">if</span> (kTraceDetailedInfo) &#123;<br>        <span class="hljs-keyword">if</span> (!kIgnorePresentFences) &#123;<br>            addEventListener(0, <span class="hljs-keyword">new</span> ZeroPhaseTracer());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="DispSyncThread-threadLoop"><a href="#DispSyncThread-threadLoop" class="headerlink" title="DispSyncThread#threadLoop"></a>DispSyncThread#threadLoop</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/DispSync.cpp   <br><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> threadLoop() &#123;<br>  ...<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>         ...<br>                <span class="hljs-keyword">if</span> (mPeriod == 0) &#123;<br>                    err = mCond.wait(mMutex);<br>                    <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;<br>                        ALOGE("error waiting <span class="hljs-keyword">for</span> <span class="hljs-keyword">new</span> events: %s (%d)",<br>                                strerror(-err), err);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;        <br>               //收集Vsync信号回调的方法<br>                callbackInvocations = gatherCallbackInvocationsLocked(now);         <br>       &#125;<br><br>            <span class="hljs-keyword">if</span> (callbackInvocations.size() &gt; 0) &#123;<br>                fireCallbackInvocations(callbackInvocations);<br>            &#125;  <br>    &#125;<br><br>    <span class="hljs-keyword">void</span> fireCallbackInvocations(<span class="hljs-keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks) &#123;<br>        <span class="hljs-keyword">for</span> (size_t i = 0; i &lt; callbacks.size(); i++) &#123;<br>          //回调callback的 onDispSyncEvent<br>            callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>DispSyncThread</code>通过<code>mCond.wait()</code>等待被唤醒，被唤醒之后回调到<code>onDispSynvEvent()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> DispSync::addResyncSample(nsecs_t timestamp) &#123;<br>    Mutex::Autolock lock(mMutex);<br>    size_t idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;<br>    mResyncSamples[idx] = timestamp;<br><br>    <span class="hljs-keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;<br>        mNumResyncSamples++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mFirstResyncSample = (mFirstResyncSample + 1) % MAX_RESYNC_SAMPLES;<br>    &#125;<br>    updateModelLocked();<br><br>    <span class="hljs-keyword">return</span> mPeriod == 0 || mError &gt; kErrorThreshold;<br>&#125;<br><br><span class="hljs-keyword">void</span> DispSync::updateModelLocked() &#123;<br>    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;<br>        ...<br>        mPeriod = durationSum / (mNumResyncSamples - 1);<br><br>        // Artificially inflate the period <span class="hljs-keyword">if</span> requested.<br>        mPeriod += mPeriod * mRefreshSkipCount;<br><br>        mThread-&gt;updateModel(mPeriod, mPhase);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="DispsyncThread-updateModel"><a href="#DispsyncThread-updateModel" class="headerlink" title="DispsyncThread#updateModel"></a>DispsyncThread#updateModel</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> updateModel(nsecs_t period, nsecs_t phase) &#123;<br>    Mutex::Autolock lock(mMutex);<br>    mPeriod = period;<br>    mPhase = phase;<br>    mCond.signal();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行<code>updateModel()</code>后，唤醒了<code>DispSyncThread</code></p>
<p>在<code>SurfaceFlinger.init()</code>之后初始化设置的<code>DispSyncSource</code>就是<code>callback</code>，然后回调到<code>onDispSyncEvent</code></p>
<h4 id="Sf-DispSyncSource-onDispSyncEvent"><a href="#Sf-DispSyncSource-onDispSyncEvent" class="headerlink" title="Sf.DispSyncSource#onDispSyncEvent"></a>Sf.DispSyncSource#onDispSyncEvent</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> onDispSyncEvent(nsecs_t when) &#123;<br>    sp&lt;VSyncSource::Callback&gt; callback;<br>    &#123;<br>        Mutex::Autolock lock(mCallbackMutex);<br>        callback = mCallback;<br><br>        <span class="hljs-keyword">if</span> (mTraceVsync) &#123;<br>            mValue = (mValue + 1) % 2;<br>            ATRACE_INT(mVsyncEventLabel.<span class="hljs-built_in">string</span>(), mValue);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">NULL</span>) &#123;<br>        callback-&gt;onVSyncEvent(when);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个<code>callback</code>是在<code>EventThread</code>初始化的时候设置的，所以<code>mCallback</code>就是<code>EventThread</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> EventThread::enableVSyncLocked() &#123;<br>    <span class="hljs-keyword">if</span> (!mUseSoftwareVSync) &#123;<br>        // never enable h/w VSYNC when screen is off<br>        <span class="hljs-keyword">if</span> (!mVsyncEnabled) &#123;<br>            mVsyncEnabled = <span class="hljs-literal">true</span>;<br>            mVSyncSource-&gt;setCallback(<span class="hljs-keyword">static_cast</span>&lt;VSyncSource::Callback*&gt;(<span class="hljs-keyword">this</span>));<br>            mVSyncSource-&gt;setVSyncEnabled(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>    mDebugVsyncEnabled = <span class="hljs-literal">true</span>;<br>    sendVsyncHintOnLocked();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>setCallback()</code>建立<code>EventThread</code>与<code>DispSyncSource</code>之间的关联</p>
<h4 id="EventThread-onVsyncEvent"><a href="#EventThread-onVsyncEvent" class="headerlink" title="EventThread#onVsyncEvent"></a>EventThread#onVsyncEvent</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> EventThread::onVSyncEvent(nsecs_t timestamp) &#123;<br>    Mutex::Autolock _l(mLock);<br>    mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<br>    mVSyncEvent[0].header.id = 0;<br>    mVSyncEvent[0].header.timestamp = timestamp;<br>    mVSyncEvent[0].vsync.count++;<br>    mCondition.broadcast();//唤醒EventThread<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> EventThread::threadLoop() &#123;<br>    DisplayEventReceiver::Event event;<br>    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;<br>  //等待事件发生<br>    signalConnections = waitForEvent(&amp;event);<br><br>    <span class="hljs-keyword">const</span> size_t count = signalConnections.size();<br>    <span class="hljs-keyword">for</span> (size_t i=0 ; i&lt;count ; i++) &#123;<br>        <span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; conn(signalConnections[i]);<br>        // 分发事件给所有的监听者<br>        status_t err = conn-&gt;postEvent(event);<br>        <span class="hljs-keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;<br>          <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err &lt; 0) &#123;<br>            removeDisplayEventConnection(signalConnections[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>EventThread#threadLoop</code>在被唤醒后会执行<code>conn-&gt;postEvent()</code></p>
<h5 id="ET-Connection-postEvent"><a href="#ET-Connection-postEvent" class="headerlink" title="ET.Connection#postEvent"></a>ET.Connection#postEvent</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">status_t EventThread::Connection::postEvent(<br>        <span class="hljs-keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;<br>    ssize_t size = DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1);<br>    <span class="hljs-keyword">return</span> size &lt; 0 ? status_t(size) : status_t(NO_ERROR);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/libs/gui/DisplayEventReceiver.cpp<br>ssize_t DisplayEventReceiver::sendEvents(gui::BitTube* dataChannel,<br>        Event <span class="hljs-keyword">const</span>* events, size_t count)<br>&#123;<br>    <span class="hljs-keyword">return</span> gui::BitTube::sendObjects(dataChannel, events, count);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>BitTube</code>发送消息，此时就会触发到<code>MQ#cb_eventReceiver</code></p>
<h4 id="MessageQueue-cb-eventReceiver"><a href="#MessageQueue-cb-eventReceiver" class="headerlink" title="MessageQueue#cb_eventReceiver"></a>MessageQueue#cb_eventReceiver</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> MessageQueue::cb_eventReceiver(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span>* data) &#123;<br>    MessageQueue* <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">reinterpret_cast</span>&lt;MessageQueue *&gt;(data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>-&gt;eventReceiver(fd, events);<br>&#125;<br><br><span class="hljs-keyword">int</span> MessageQueue::eventReceiver(<span class="hljs-keyword">int</span> /*fd*/, <span class="hljs-keyword">int</span> /*events*/) &#123;<br>    ssize_t n;<br>    DisplayEventReceiver::Event buffer[8];<br>    <span class="hljs-keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, 8)) &gt; 0) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=0 ; i&lt;n ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;<br>#<span class="hljs-keyword">if</span> INVALIDATE_ON_VSYNC<br>                mHandler-&gt;dispatchInvalidate();<br>#<span class="hljs-keyword">else</span><br>                mHandler-&gt;dispatchRefresh();<br>#endif<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> 1;<br>&#125;<br><br><span class="hljs-keyword">void</span> MessageQueue::Handler::dispatchRefresh() &#123;<br>    <span class="hljs-keyword">if</span> ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == 0) &#123;<br>        mQueue.mLooper-&gt;sendMessage(<span class="hljs-keyword">this</span>, Message(MessageQueue::REFRESH));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;<br>    <span class="hljs-keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == 0) &#123;<br>        mQueue.mLooper-&gt;sendMessage(<span class="hljs-keyword">this</span>, Message(MessageQueue::INVALIDATE));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>回调到<code>MessageQueue.Handler</code>的<code>handleMessage()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> MessageQueue::Handler::handleMessage(<span class="hljs-keyword">const</span> Message&amp; message) &#123;<br>    <span class="hljs-keyword">switch</span> (message.what) &#123;<br>        <span class="hljs-keyword">case</span> INVALIDATE:<br>            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;onMessageReceived(message.what);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REFRESH:<br>            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;onMessageReceived(message.what);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> TRANSACTION:<br>            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;onMessageReceived(message.what);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Sf-onMessageReceived"><a href="#Sf-onMessageReceived" class="headerlink" title="Sf#onMessageReceived"></a>Sf#onMessageReceived</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::onMessageReceived(int32_t what) &#123;<br>    ATRACE_CALL();<br>    <span class="hljs-keyword">switch</span> (what) &#123;<br>        <span class="hljs-keyword">case</span> MessageQueue::TRANSACTION: &#123;<br>            handleMessageTransaction();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;<br>            <span class="hljs-keyword">bool</span> refreshNeeded = handleMessageTransaction();<br>            refreshNeeded |= handleMessageInvalidate();<br>            refreshNeeded |= mRepaintEverything;<br>            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;<br>                signalRefresh();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;<br>            handleMessageRefresh();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/SF接收Vsync信号.jpg" srcset="/img/loading.gif" alt="SF接收Vsync信号"></p>
<p>接收Vsync信号主要分为以下几步：</p>
<ol>
<li>HWC收到Vsync信号时，回调到<code>hook_vsync</code>，内部执行到<code>sf#onVsyncReceived()</code></li>
<li>继续执行到<code>DispSync#addResyncSample()</code>，然后到<code>DispSyncThread#updateModel()</code>调用<code>mCondition.broadcast()</code>唤醒<code>EventThread</code></li>
<li>唤醒之后执行到<code>DispSyncSource.onDispSyncEvent()</code>继续执行到<code>EventThread.onVsyncEvent()</code>，其中内部调用了<code>DisplayEventReceiver.sendEvents() -&gt; BitTube.sendObjects()</code>发送消息，<code>Looper</code>监听到<code>BitTube</code>有数据流动，就会回调<code>MessageQueue.cb_eventReceiver()</code></li>
<li>继续通过消息机制，回调到<code>MessageQueue.handleMessage()</code>，最后调用<code>Sf.handleMessageReceived()</code></li>
</ol>
<blockquote>
<p>简化版：</p>
<p><code>Vsync信号</code>由<code>HWC</code>产生，然后回调到<code>DispSyncthread</code>在继续回调到<code>DispSyncSource</code>，继续调用到了<code>EventThread</code>。最后<code>EventThread</code>通过<code>BitTube(Socket)</code>发送消息到<code>MessageQueue</code>，<code>MessageQueue</code>接收到消息后，在回调给<code>SurfaceFlinger</code>。</p>
</blockquote>
<h3 id="处理Vsync"><a href="#处理Vsync" class="headerlink" title="处理Vsync"></a>处理Vsync</h3><p>主要在<code>Sf#onMessageReceived()</code>处理<code>Vsync信号</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::onMessageReceived(int32_t what) &#123;<br>        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;<br>            <span class="hljs-keyword">bool</span> refreshNeeded = handleMessageTransaction();<br>            refreshNeeded |= handleMessageInvalidate();<br>            refreshNeeded |= mRepaintEverything;<br>            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;<br>                signalRefresh();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;  <br>        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;<br>            handleMessageRefresh();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在接受到<code>Vsync信号</code>后，就会回调到<code>MessageQueue::INVALIDATE</code>，继续向下执行到<code>signalRefresh()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp<br><span class="hljs-keyword">void</span> SurfaceFlinger::signalRefresh() &#123;<br>    mEventQueue.refresh();<br>&#125;<br><br>//frameworks/native/services/surfaceflinger/MessageQueue.cpp<br><span class="hljs-keyword">void</span> MessageQueue::refresh() &#123;<br>#<span class="hljs-keyword">if</span> INVALIDATE_ON_VSYNC<br>    mHandler-&gt;dispatchRefresh();<br>#<span class="hljs-keyword">else</span><br>    mEvents-&gt;requestNextVsync();<br>#endif<br>&#125;	<br><br><span class="hljs-keyword">void</span> MessageQueue::Handler::dispatchRefresh() &#123;<br>    <span class="hljs-keyword">if</span> ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == 0) &#123;<br>        mQueue.mLooper-&gt;sendMessage(<span class="hljs-keyword">this</span>, Message(MessageQueue::REFRESH));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Sf-handleMessageRefresh"><a href="#Sf-handleMessageRefresh" class="headerlink" title="Sf#handleMessageRefresh"></a>Sf#handleMessageRefresh</h4><p>最后还是执行到了<code>handleMessageRefresh()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::handleMessageRefresh() &#123;<br>    ATRACE_CALL();<br>    preComposition();<br>    rebuildLayerStacks();<br>    setUpHWComposer();<br>    doDebugFlashRegions();<br>    doComposition();<br>    postComposition();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="preComposition-合成前预处理"><a href="#preComposition-合成前预处理" class="headerlink" title="preComposition-合成前预处理"></a>preComposition-合成前预处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::preComposition()<br>&#123;<br>    //是否需要刷新布局<br>    <span class="hljs-keyword">bool</span> needExtraInvalidate = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">const</span> LayerVector&amp; layers(mDrawingState.layersSortedByZ);<br>    <span class="hljs-keyword">const</span> size_t count = layers.size();<br>    <span class="hljs-keyword">for</span> (size_t i=0 ; i&lt;count ; i++) &#123;<br>       //当前Layer发生了变化<br>        <span class="hljs-keyword">if</span> (layers[i]-&gt;onPreComposition()) &#123;<br>            needExtraInvalidate = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (needExtraInvalidate) &#123;<br>      //申请下一个Vsync信号<br>        signalLayerUpdate();<br>    &#125;<br>&#125;<br><br>//frameworks/native/services/surfaceflinger/Layer.cpp<br><span class="hljs-keyword">bool</span> Layer::onPreComposition() &#123;<br>    mRefreshPending = <span class="hljs-literal">false</span>;<br>   //有待处理的Buffer帧，<br>    <span class="hljs-keyword">return</span> mQueuedFrames &gt; 0 || mSidebandStreamChanged;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>preComposition()</code>需要先判断<code>Layer</code>是否发生了变化，没发生变化不需要申请下一次Vsync信号，否则执行<code>signalLayerUpdate()</code>申请下一次Vsync信号。</p>
<h6 id="signalLayerUpdate"><a href="#signalLayerUpdate" class="headerlink" title="signalLayerUpdate"></a>signalLayerUpdate</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp<br><span class="hljs-keyword">void</span> SurfaceFlinger::signalLayerUpdate() &#123;<br>    mEventQueue.invalidate();<br>&#125;<br><br>//frameworks/native/services/surfaceflinger/MessageQueue.cpp<br><span class="hljs-keyword">void</span> MessageQueue::invalidate() &#123;<br>#<span class="hljs-keyword">if</span> INVALIDATE_ON_VSYNC<br>    mEvents-&gt;requestNextVsync();<br>#<span class="hljs-keyword">else</span><br>    mHandler-&gt;dispatchInvalidate();<br>#endif<br>&#125;<br><br>//frameworks/native/services/surfaceflinger/EventThread.cpp<br><span class="hljs-keyword">void</span> EventThread::requestNextVsync(<br>        <span class="hljs-keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;<br>    Mutex::Autolock _l(mLock);<br>    <span class="hljs-keyword">if</span> (connection-&gt;count &lt; 0) &#123;<br>        connection-&gt;count = 0;<br>        mCondition.broadcast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>唤醒了<code>EventThread</code>，返回Vsync信号通知。</p>
<h5 id="rebuildLayerStacks-重建Layer"><a href="#rebuildLayerStacks-重建Layer" class="headerlink" title="rebuildLayerStacks-重建Layer"></a>rebuildLayerStacks-重建Layer</h5><blockquote>
<p>遍历<code>Layer</code>，计算和存储每个Layer的<code>dirtyRegion</code>，如果<code>dirtyRegion</code>显示在设备的显示区域内，就表示<code>Layer</code>需要重新绘制。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::rebuildLayerStacks() &#123;<br>    // rebuild the visible layer <span class="hljs-built_in">list</span> per screen<br>    <span class="hljs-keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;<br>        ATRACE_CALL();<br>        mVisibleRegionsDirty = <span class="hljs-literal">false</span>;<br>        invalidateHwcGeometry();<br><br>        <span class="hljs-keyword">const</span> LayerVector&amp; layers(mDrawingState.layersSortedByZ);<br>      //遍历所有显示设备，计算显示设备中dirtyRegion和 opaqueRegion<br>        <span class="hljs-keyword">for</span> (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>            Region opaqueRegion;//非透明区域<br>            Region dirtyRegion;//变化区域，需要刷新<br>            Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;<br>            <span class="hljs-keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);<br>            <span class="hljs-keyword">const</span> Transform&amp; tr(hw-&gt;getTransform());<br>            <span class="hljs-keyword">const</span> Rect bounds(hw-&gt;getBounds());<br>            <span class="hljs-keyword">if</span> (hw-&gt;isDisplayOn()) &#123;<br>              //计算Layer的 dirtyRegion和 opaqueRegion<br>                SurfaceFlinger::computeVisibleRegions(layers,<br>                        hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion);<br><br>                <span class="hljs-keyword">const</span> size_t count = layers.size();<br>                <span class="hljs-keyword">for</span> (size_t i=0 ; i&lt;count ; i++) &#123;<br>                    <span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);<br>                    <span class="hljs-keyword">const</span> Layer::State&amp; s(layer-&gt;getDrawingState());<br>                    <span class="hljs-keyword">if</span> (s.layerStack == hw-&gt;getLayerStack()) &#123;<br>                        Region drawRegion(tr.transform(<br>                                layer-&gt;visibleNonTransparentRegion));<br>                        drawRegion.andSelf(bounds);<br>                        <span class="hljs-keyword">if</span> (!drawRegion.isEmpty()) &#123;<br>                            layersSortedByZ.add(layer);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>          //按照Z轴由小到大排序<br>            hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ);<br>            hw-&gt;undefinedRegion.<span class="hljs-built_in">set</span>(bounds);<br>            hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));<br>            hw-&gt;dirtyRegion.orSelf(dirtyRegion);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最重要的是<code>computeVisibleRegions</code>-对Layer的<code>dirtyRegion</code>和<code>opaqueRegion</code>的计算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp<br><span class="hljs-keyword">void</span> SurfaceFlinger::computeVisibleRegions(<br>        <span class="hljs-keyword">const</span> LayerVector&amp; currentLayers, uint32_t layerStack,<br>        Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)<br>&#123;<br> size_t i = currentLayers.size();<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        <span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; layer = currentLayers[i];<br><br>        // start with the whole surface at its current location<br>        <span class="hljs-keyword">const</span> Layer::State&amp; s(layer-&gt;getDrawingState());<br><br>        // only consider the layers on the given layer <span class="hljs-built_in">stack</span><br>        <span class="hljs-keyword">if</span> (s.layerStack != layerStack)<br>            <span class="hljs-keyword">continue</span>;<br>      //非透明区域<br>        Region opaqueRegion;<br>      //可见区域<br>        Region visibleRegion;<br>      //被遮盖区域<br>        Region coveredRegion;<br>      //透明区域<br>        Region transparentRegion;<br><br>        // handle hidden surfaces by setting the visible region to empty<br>        <span class="hljs-keyword">if</span> (CC_LIKELY(layer-&gt;isVisible())) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> translucent = !layer-&gt;isOpaque(s);<br>            Rect bounds(s.transform.transform(layer-&gt;computeBounds()));<br>            visibleRegion.<span class="hljs-built_in">set</span>(bounds);<br>            <span class="hljs-keyword">if</span> (!visibleRegion.isEmpty()) &#123;<br>                // Remove the transparent area from the visible region<br>                <span class="hljs-keyword">if</span> (translucent) &#123;<br>                    <span class="hljs-keyword">const</span> Transform tr(s.transform);<br>                    <span class="hljs-keyword">if</span> (tr.transformed()) &#123;<br>                        <span class="hljs-keyword">if</span> (tr.preserveRects()) &#123;<br>                            // transform the transparent region<br>                            transparentRegion = tr.transform(s.activeTransparentRegion);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            // transformation too <span class="hljs-keyword">complex</span>, can't <span class="hljs-keyword">do</span> the<br>                            // transparent region optimization.<br>                            transparentRegion.clear();<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        transparentRegion = s.activeTransparentRegion;<br>                    &#125;<br>                &#125;<br><br>                // compute the opaque region<br>                <span class="hljs-keyword">const</span> int32_t layerOrientation = s.transform.getOrientation();<br>                <span class="hljs-keyword">if</span> (s.alpha==255 &amp;&amp; !translucent &amp;&amp;<br>                        ((layerOrientation &amp; Transform::ROT_INVALID) == <span class="hljs-literal">false</span>)) &#123;<br>                    // the opaque region is the layer's footprint<br>                    opaqueRegion = visibleRegion;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        // Clip the covered region to the visible region<br>        coveredRegion = aboveCoveredLayers.intersect(visibleRegion);<br><br>        // 累加当前Layer和上层Layer的可见区域<br>        aboveCoveredLayers.orSelf(visibleRegion);<br><br>        // 可见区域减去非透明区域<br>        visibleRegion.subtractSelf(aboveOpaqueLayers);<br><br>        // 计算脏区<br>        <span class="hljs-keyword">if</span> (layer-&gt;contentDirty) &#123;<br>            // we need to invalidate the whole region<br>            dirty = visibleRegion;<br>            // as well, as the old visible region<br>            dirty.orSelf(layer-&gt;visibleRegion);<br>            layer-&gt;contentDirty = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> Region newExposed = visibleRegion - coveredRegion;<br>            <span class="hljs-keyword">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;<br>            <span class="hljs-keyword">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;<br>            <span class="hljs-keyword">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;<br>            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);<br>        &#125;<br>        dirty.subtractSelf(aboveOpaqueLayers);<br>       //累加脏区<br>        outDirtyRegion.orSelf(dirty);<br>       //添加非透明区域<br>        aboveOpaqueLayers.orSelf(opaqueRegion);<br>       //存储可见区域<br>        layer-&gt;setVisibleRegion(visibleRegion);<br>        layer-&gt;setCoveredRegion(coveredRegion);<br>        layer-&gt;setVisibleNonTransparentRegion(<br>                visibleRegion.subtract(transparentRegion));<br>    &#125;<br><br>    outOpaqueRegion = aboveOpaqueLayers;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>按照上述源码，界面显示区域分为如下几种：</p>
<ul>
<li><code>opaqueRegion</code>：非透明区域——表示不完全透明的区域</li>
<li><code>dirtyRegion</code>：需要重绘的区域</li>
<li><code>visibleRegion</code>：可见区域——表示完全不透明的区域</li>
<li><code>coveredRegion</code>：被覆盖区域——被完全不透明区域覆盖的区域</li>
<li><code>transparentRegion</code>：完全透明的区域——一般需要从合成列表中移除</li>
<li><code>aboveOpaqueLayers</code>：所有<code>非透明区域</code>的叠加</li>
<li><code>aboveCoveredLayers</code>：所有<code>可见区域</code>的叠加</li>
</ul>
<p>以平常的应用界面来举例。</p>
<p><code>opaqueRegion</code>：状态栏通常都是半透明的，可以看到时间等信息</p>
<p><code>visibleRegion</code>：当前显示的应用界面，就完全遮盖了后面的内容</p>
<p><code>coveredRegion</code>：桌面应用设置的壁纸。</p>
<blockquote>
<p><code>computeVisibleRegions</code>主要完成了以下几步：</p>
<ol>
<li>在<code>Layer的Z轴</code>从上向下遍历该显示设备中的<code>Layer</code></li>
<li>计算被覆盖区域：<code>aboveCoveredLayers</code>与<code>opaqueRegion</code>的交集</li>
<li>计算可见区域：去除<code>opaqueRegion</code>和<code>aboveOpaqueLayers</code>的交集</li>
<li>计算脏区域</li>
<li>保存到<code>Layer</code>中</li>
</ol>
</blockquote>
<h5 id="setUpHWComposer-构造硬件合成的任务"><a href="#setUpHWComposer-构造硬件合成的任务" class="headerlink" title="setUpHWComposer-构造硬件合成的任务"></a>setUpHWComposer-构造硬件合成的任务</h5><blockquote>
<p><code>Layer</code>交给<code>HWComposer</code>去做图层混合。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::setUpHWComposer() &#123;<br>  <br>    <span class="hljs-keyword">for</span> (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>        <span class="hljs-keyword">bool</span> dirty = !mDisplays[dpy]-&gt;getDirtyRegion(<span class="hljs-literal">false</span>).isEmpty();<br>        <span class="hljs-keyword">bool</span> empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == 0;<br>        <span class="hljs-keyword">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;<br>       //没有脏区域或者可见的Layer，就不需要进行合成<br>        <span class="hljs-keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);<br>      <br>        mDisplays[dpy]-&gt;beginFrame(mustRecompose);<br><br>        <span class="hljs-keyword">if</span> (mustRecompose) &#123;<br>            mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;<br>        &#125;      <br>    &#125;<br>  <br>  //构造HWComposer硬件任务<br>    HWComposer&amp; hwc(getHwComposer());<br>    <span class="hljs-keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;<br>        // build the h/w work <span class="hljs-built_in">list</span><br>        <span class="hljs-keyword">if</span> (CC_UNLIKELY(mHwWorkListDirty)) &#123;<br>            mHwWorkListDirty = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>                sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);<br>                <span class="hljs-keyword">const</span> int32_t id = hw-&gt;getHwcDisplayId();<br>                <span class="hljs-keyword">if</span> (id &gt;= 0) &#123;<br>                    <span class="hljs-keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(<br>                        hw-&gt;getVisibleLayersSortedByZ());<br>                    <span class="hljs-keyword">const</span> size_t count = currentLayers.size();<br>                  //在HWC创建任务列表<br>                    <span class="hljs-keyword">if</span> (hwc.createWorkList(id, count) == NO_ERROR) &#123;<br>                        HWComposer::LayerListIterator cur = hwc.begin(id);<br>                        <span class="hljs-keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);<br>                        <span class="hljs-keyword">for</span> (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;<br>                            <span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);<br>                            layer-&gt;setGeometry(hw, *cur);<br>                            <span class="hljs-keyword">if</span> (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123;<br>                                cur-&gt;setSkip(<span class="hljs-literal">true</span>);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        // 设置每帧的数据<br>        <span class="hljs-keyword">for</span> (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>            sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);<br>            <span class="hljs-keyword">const</span> int32_t id = hw-&gt;getHwcDisplayId();<br>            <span class="hljs-keyword">if</span> (id &gt;= 0) &#123;<br>                <span class="hljs-keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(<br>                    hw-&gt;getVisibleLayersSortedByZ());<br>                <span class="hljs-keyword">const</span> size_t count = currentLayers.size();<br>                HWComposer::LayerListIterator cur = hwc.begin(id);<br>                <span class="hljs-keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);<br>                <span class="hljs-keyword">for</span> (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;<br>                    <span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);<br>                    layer-&gt;setPerFrameData(hw, *cur);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        status_t err = hwc.prepare();<br>        ALOGE_IF(err, "HWComposer::prepare failed (%s)", strerror(-err));<br><br>        <span class="hljs-keyword">for</span> (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>            sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);<br>            hw-&gt;prepareFrame(hwc);<br>        &#125;<br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="doComposition-执行合成任务"><a href="#doComposition-执行合成任务" class="headerlink" title="doComposition-执行合成任务"></a>doComposition-执行合成任务</h5><blockquote>
<p>前面已经准备好了<code>合成Layer任务</code>和<code>需要合成的数据</code>，现在就需要做图像的混合工作。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp<br><span class="hljs-keyword">void</span> SurfaceFlinger::doComposition() &#123;<br>    ATRACE_CALL();<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> repaintEverything = android_atomic_and(0, &amp;mRepaintEverything);<br>    <span class="hljs-keyword">for</span> (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>        <span class="hljs-keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);<br>        <span class="hljs-keyword">if</span> (hw-&gt;isDisplayOn()) &#123;<br>            // transform the dirty region into <span class="hljs-keyword">this</span> screen's coordinate space<br>            <span class="hljs-keyword">const</span> Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything));<br><br>            // repaint the framebuffer (<span class="hljs-keyword">if</span> needed)<br>            doDisplayComposition(hw, dirtyRegion);<br>        &#125;<br>    &#125;<br>    postFramebuffer();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>doComposition()</code>主要执行以下两步</p>
<h6 id="doDisplayComposition"><a href="#doDisplayComposition" class="headerlink" title="doDisplayComposition"></a>doDisplayComposition</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> SurfaceFlinger::doDisplayComposition(<span class="hljs-keyword">const</span> sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt;&amp; hw,<br>        <span class="hljs-keyword">const</span> Region&amp; inDirtyRegion)<br>&#123;<br>  //是否硬件绘制<br>    <span class="hljs-keyword">bool</span> isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= 0;<br>    <span class="hljs-keyword">if</span> (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>  <br>  ...<br>    //进行合成<br>       <span class="hljs-keyword">if</span> (!doComposeSurfaces(hw, dirtyRegion)) <span class="hljs-keyword">return</span>;  <br>  ...<br>    <br>&#125;<br><br><span class="hljs-keyword">bool</span> SurfaceFlinger::doComposeSurfaces(<span class="hljs-keyword">const</span> sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt;&amp; hw, <span class="hljs-keyword">const</span> Region&amp; dirty)<br>&#123;<br>  ...<br>    <span class="hljs-keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; layers(hw-&gt;getVisibleLayersSortedByZ());<br>    <span class="hljs-keyword">const</span> size_t count = layers.size();<br>    <span class="hljs-keyword">const</span> Transform&amp; tr = hw-&gt;getTransform();<br>    <span class="hljs-keyword">if</span> (cur != end) &#123;<br>        // 使用硬件合成<br>        <span class="hljs-keyword">for</span> (size_t i=0 ; i&lt;count &amp;&amp; cur!=end ; ++i, ++cur) &#123;<br>            <span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);<br>            <span class="hljs-keyword">const</span> Region clip(dirty.intersect(tr.transform(layer-&gt;visibleRegion)));<br>            <span class="hljs-keyword">if</span> (!clip.isEmpty()) &#123;<br>                <span class="hljs-keyword">switch</span> (cur-&gt;getCompositionType()) &#123;<br>                    <span class="hljs-keyword">case</span> HWC_CURSOR_OVERLAY:<br>                    <span class="hljs-keyword">case</span> HWC_OVERLAY: &#123;<br>                        <span class="hljs-keyword">const</span> Layer::State&amp; state(layer-&gt;getDrawingState());<br>                        <span class="hljs-keyword">if</span> ((cur-&gt;getHints() &amp; HWC_HINT_CLEAR_FB)<br>                                &amp;&amp; i<br>                                &amp;&amp; layer-&gt;isOpaque(state) &amp;&amp; (state.alpha == 0xFF)<br>                                &amp;&amp; hasGlesComposition) &#123;<br>                            // never clear the very first layer since we're<br>                            // guaranteed the FB is already cleared<br>                            layer-&gt;clearWithOpenGL(hw, clip);<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> HWC_FRAMEBUFFER: &#123;<br>                        layer-&gt;draw(hw, clip);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> HWC_FRAMEBUFFER_TARGET: &#123;<br>                        // <span class="hljs-keyword">this</span> should <span class="hljs-keyword">not</span> happen as the iterator shouldn't<br>                        // let us get there.<br>                        ALOGW("HWC_FRAMEBUFFER_TARGET found in hwc <span class="hljs-built_in">list</span> (index=%zu)", i);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            layer-&gt;setAcquireFence(hw, *cur);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // 不使用硬件合成<br>        <span class="hljs-keyword">for</span> (size_t i=0 ; i&lt;count ; ++i) &#123;<br>            <span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);<br>            <span class="hljs-keyword">const</span> Region clip(dirty.intersect(<br>                    tr.transform(layer-&gt;visibleRegion)));<br>            <span class="hljs-keyword">if</span> (!clip.isEmpty()) &#123;<br>                layer-&gt;draw(hw, clip);<br>            &#125;<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="postFrameBuffer"><a href="#postFrameBuffer" class="headerlink" title="postFrameBuffer"></a>postFrameBuffer</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp<br><span class="hljs-keyword">void</span> SurfaceFlinger::postFramebuffer()<br>&#123;<br>    ATRACE_CALL();<br><br>    <span class="hljs-keyword">const</span> nsecs_t now = systemTime();<br>    mDebugInSwapBuffers = now;<br><br>    HWComposer&amp; hwc(getHwComposer());<br>    <span class="hljs-keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;<br>        <span class="hljs-keyword">if</span> (!hwc.supportsFramebufferTarget()) &#123;<br>            // EGL spec says:<br>            //   "surface must be bound to the calling thread's current context,<br>            //    <span class="hljs-keyword">for</span> the current rendering API."<br>            getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);<br>        &#125;<br>        hwc.commit();<br>    &#125;<br><br>    getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);<br><br>    <span class="hljs-keyword">for</span> (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>        sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);<br>        <span class="hljs-keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(hw-&gt;getVisibleLayersSortedByZ());<br>        hw-&gt;onSwapBuffersCompleted(hwc);<br>        <span class="hljs-keyword">const</span> size_t count = currentLayers.size();<br>        int32_t id = hw-&gt;getHwcDisplayId();<br>        <span class="hljs-keyword">if</span> (id &gt;=0 &amp;&amp; hwc.initCheck() == NO_ERROR) &#123;<br>            HWComposer::LayerListIterator cur = hwc.begin(id);<br>            <span class="hljs-keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);<br>            <span class="hljs-keyword">for</span> (size_t i = 0; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123;<br>                currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (size_t i = 0; i &lt; count; i++) &#123;<br>                currentLayers[i]-&gt;onLayerDisplayed(hw, <span class="hljs-literal">NULL</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    mLastSwapBufferTime = systemTime() - now;<br>    mDebugInSwapBuffers = 0;<br><br>    uint32_t flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();<br>    <span class="hljs-keyword">if</span> (flipCount % LOG_FRAME_STATS_PERIOD == 0) &#123;<br>        logFrameStats();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>doComposition</code>  </p>
<ul>
<li><code>doDisplayComposition</code>：重绘<code>FrameBuffer</code>，并进行合成</li>
<li><code>postFrameBuffer</code>：将数据写入到<code>FrameBuffer</code>然后完成物理屏幕的图像显示</li>
</ul>
<h5 id="postComposition-合成图形结束后的处理"><a href="#postComposition-合成图形结束后的处理" class="headerlink" title="postComposition-合成图形结束后的处理"></a>postComposition-合成图形结束后的处理</h5><blockquote>
<p>此时图层已经混合完成，图像数据也被送到了<code>帧缓冲(FrameBuffer)</code>，并且已经显示在屏幕上了，由<code>postComposition()</code>进行一些收尾工作的处理。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp<br><span class="hljs-keyword">void</span> SurfaceFlinger::postComposition()<br>&#123;<br>    <span class="hljs-keyword">const</span> LayerVector&amp; layers(mDrawingState.layersSortedByZ);<br>    <span class="hljs-keyword">const</span> size_t count = layers.size();<br>    <span class="hljs-keyword">for</span> (size_t i=0 ; i&lt;count ; i++) &#123;<br>        layers[i]-&gt;onPostComposition();<br>    &#125;<br>  ...<br>    //更新 swapBuffer 记录时间<br>    nsecs_t currentTime = systemTime();<br>    <span class="hljs-keyword">if</span> (mHasPoweredOff) &#123;<br>        mHasPoweredOff = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        nsecs_t period = mPrimaryDispSync.getPeriod();<br>        nsecs_t elapsedTime = currentTime - mLastSwapTime;<br>        size_t numPeriods = <span class="hljs-keyword">static_cast</span>&lt;size_t&gt;(elapsedTime / period);<br>        <span class="hljs-keyword">if</span> (numPeriods &lt; NUM_BUCKETS - 1) &#123;<br>            mFrameBuckets[numPeriods] += elapsedTime;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mFrameBuckets[NUM_BUCKETS - 1] += elapsedTime;<br>        &#125;<br>        mTotalTime += elapsedTime;<br>    &#125;<br>    mLastSwapTime = currentTime;    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/SF处理Vsync信号.jpg" srcset="/img/loading.gif" alt="SF处理Vsync信号"></p>
<h2 id="Android图形缓冲区"><a href="#Android图形缓冲区" class="headerlink" title="Android图形缓冲区"></a>Android图形缓冲区</h2><p>Android的图形缓冲区主要由以下几部分组成：</p>
<ul>
<li><code>Surface</code></li>
<li><code>Layer</code></li>
<li><code>GraphicBuffer</code></li>
<li><code>BufferQueue</code></li>
</ul>
<h3 id="Surface相关"><a href="#Surface相关" class="headerlink" title="Surface相关"></a>Surface相关</h3><blockquote>
<p><strong><code>Surface</code>是提供给<code>图形生产者</code>控制缓冲区的</strong></p>
<p>在<code>软件绘制</code>中，调用<code>drawSoftware(surface)</code>传入<code>Surface缓冲区</code>到<code>native</code>层的<code>SkiaCanvas</code></p>
<p>在<code>硬件绘制</code>中，调用<code>ThreadedRenderer.initalize(surface)</code>传入<code>Surface缓冲区</code>到OpenGL中进行渲染。</p>
<p>当得到<code>Surface缓冲区</code>后，就可以存入<strong>需要绘制的内容</strong>到<code>Surface</code>中。</p>
</blockquote>
<p><code>Surface</code>内部持有<code>BufferQueue中的GraphicBufferProducer</code>，主要负责<strong>创建或获取可用的<code>GraphicBuffer</code>以及提交绘制后的<code>GraphicBuffer</code></strong>。</p>
<h3 id="Layer相关"><a href="#Layer相关" class="headerlink" title="Layer相关"></a>Layer相关</h3><blockquote>
<p><strong><code>Layer</code>是提供给<code>图形消费者</code>获取缓冲区的</strong></p>
<p>在<code>SurfaceFlinger</code>需要消费图形数据，进行图层混合时，在<code>rebuildLayerStacks()</code>进行<code>Layer</code>遍历，取出<code>Layer</code>中的图形数据，进行数据合成处理。</p>
</blockquote>
<p><code>Layer</code>内部持有<code>BufferQueue中的GraphicBufferConsumer</code>，主要负责<strong>获取和释放<code>GraphicBuffer</code></strong></p>
<h3 id="GraphicBuffer"><a href="#GraphicBuffer" class="headerlink" title="GraphicBuffer"></a>GraphicBuffer</h3><blockquote>
<p>真正被分配内存，并能存储图形数据的缓冲区。</p>
</blockquote>
<h3 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h3><blockquote>
<p>存放<code>GraphicBuffer</code>的数组结构，最多可以存储<strong>64</strong>个<code>GraphicBuffer</code></p>
</blockquote>
<p><img src="/images/BufferQueue执行流程.jpg" srcset="/img/loading.gif" alt="BufferQueue执行流程"></p>
<blockquote>
<p>当绘制图像时，首先去创建<code>Surface</code>和<code>Layer</code>，</p>
<p>然后<code>图像生产者</code>通过<code>Surface</code>调用<code>dequeue()</code>申请一块<code>GraphicBuffer</code>，在其上绘制图像</p>
<p>绘制完毕后，通过<code>Surface</code>调用<code>queue()</code>把绘制好的<code>GraphicBuffer</code>返回到<code>BufferQueue</code>中。</p>
<p>收到<code>HWComposer</code>发出的<code>Vsync信号后</code>，<code>SurfaceFlinger</code>通过<code>Layer</code>调用<code>acquire()</code>获取绘制好的<code>GraphicBuffer</code>进行合成与处理</p>
<p>处理完毕后通过<code>Layer</code>调用<code>release()</code>释放<code>GraphicBuffer</code>并返回到<code>BufferQueue</code>中。</p>
</blockquote>
<h3 id="缓冲区创建流程"><a href="#缓冲区创建流程" class="headerlink" title="缓冲区创建流程"></a>缓冲区创建流程</h3><h4 id="Activity创建图形缓冲区"><a href="#Activity创建图形缓冲区" class="headerlink" title="Activity创建图形缓冲区"></a>Activity创建图形缓冲区</h4><p>其中最常见的场景在<code>ViewRootImpl</code>的创建过程中，在其中执行了<code>Surface</code>的创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class ViewRootImpl implements ViewParent,<br>        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks &#123;<br>          ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Surface mSurface = new Surface();<br>          <br>        &#125;<br></code></pre></td></tr></table></figure>
<p>主要在<code>WindowManagerGlobal.addView()</code>构造的<code>ViewRootImpl</code>对象。</p>
<p>此时创建的只是Java层的<code>Surface</code>，还需要绑定Native层的<code>Surface</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;<br>               //执行绘制流程 测量-布局-绘制<br>                requestLayout();<br>                <span class="hljs-keyword">if</span> ((mWindowAttributes.inputFeatures<br>                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;<br>                  //触摸事件回调<br>                    mInputChannel = new InputChannel();<br>                &#125;<br>                mForceDecorViewVisibility = (mWindowAttributes.privateFlags<br>                        &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    mOrigWindowType = mWindowAttributes.type;<br>                    mAttachInfo.mRecomputeGlobalAttributes = <span class="hljs-keyword">true</span>;<br>                    collectViewAttributes();<br>                   //添加窗口<br>                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,<br>                            getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,<br>                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,<br>                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);<br>                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                   ...<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (restore) &#123;<br>                        attrs.restore();<br>                    &#125;<br>                &#125;      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>setView()</code>主要做了两件事情：</p>
<ul>
<li><code>requestLayout</code>：主要是执行到<code>relayoutWindow</code>创建了<code>Surface</code>和<code>Layer</code></li>
<li><code>addToDisplay</code>：创建了<code>SurfaceComponentClient</code></li>
</ul>
<p><code>requestLayout</code>需要在<code>addToDisplay</code>执行完毕后才可以执行。</p>
<p><br></p>
<h5 id="WS-addToDisplay"><a href="#WS-addToDisplay" class="headerlink" title="WS#addToDisplay"></a>WS#addToDisplay</h5><p><code>WS#addToDisplay()</code>执行过程</p>
<p><code>WindowSession</code>表示<strong>Java层的Window和WMS通信的对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">//com.android.server.wm.Session<br>class Session extends IWindowSession.Stub implements IBinder.DeathRecipient &#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> addToDisplayWithoutInputChannel(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,<br>            <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets) &#123;<br>        return mService.addWindow(<span class="hljs-keyword">this</span>, window, seq, attrs, viewVisibility, displayId,<br>                new Rect() /* outFrame */, outContentInsets, outStableInsets, <span class="hljs-keyword">null</span> /* outOutsets */,<br>                new DisplayCutout.ParcelableWrapper() /* cutout */, <span class="hljs-keyword">null</span> /* outInputChannel */);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>mService</code>表示的就是<code>WindowManagerService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">//WindowManagerService.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> addWindow(Session session, IWindow client, <span class="hljs-keyword">int</span> seq,<br>            LayoutParams attrs, <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outFrame,<br>            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,<br>            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel) &#123;<br>      ...      <br>      <span class="hljs-keyword">synchronized</span>(mWindowMap) &#123;<br>            AppWindowToken atoken = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hasParent = parentWindow != <span class="hljs-keyword">null</span>;<br>          //创建WindowToken<br>            WindowToken token = displayContent.getWindowToken(<br>                    hasParent ? parentWindow.mAttrs.token : attrs.token);        <br>        ...<br>          //创建WindowState对象<br>            <span class="hljs-keyword">final</span> WindowState win = new WindowState(<span class="hljs-keyword">this</span>, session, client, token, parentWindow,<br>                    appOp[0], seq, attrs, viewVisibility, session.mUid,<br>                    session.mCanAddInternalSystemWindow); <br>        ...<br>          //附加窗口<br>            win.attach();<br>            mWindowMap.put(client.asBinder(), win);          <br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里重点关注<code>WindowState#attach</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">//WindowState.java<br>    <span class="hljs-keyword">void</span> attach() &#123;<br>        <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, "Attaching " + <span class="hljs-keyword">this</span> + " token=" + mToken);<br>        mSession.windowAddedLocked(mAttrs.packageName);<br>    &#125;<br><br>//Session.java<br>    <span class="hljs-keyword">void</span> windowAddedLocked(String packageName) &#123;<br>        mPackageName = packageName;<br>        mRelayoutTag = "relayoutWindow: " + mPackageName;<br>        <span class="hljs-keyword">if</span> (mSurfaceSession == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (WindowManagerService.localLOGV) Slog.v(<br>                TAG_WM, "First window added to " + <span class="hljs-keyword">this</span> + ", creating SurfaceSession");<br>            mSurfaceSession = new SurfaceSession();<br>          ...<br>        &#125;<br>        mNumWindow++;<br>    &#125;<br><br>//SurfaceSession.java<br><span class="hljs-keyword">public</span> SurfaceSession() &#123;<br>        mNativeClient = nativeCreate();<br>    &#125;<br><br>//android_view_SurfaceSession.cpp<br><span class="hljs-keyword">static</span> jlong nativeCreate(JNIEnv* env, jclass clazz) &#123;<br>    SurfaceComposerClient* client = new SurfaceComposerClient();<br>    client-&gt;incStrong((<span class="hljs-keyword">void</span>*)nativeCreate);<br>    return reinterpret_cast&lt;jlong&gt;(client);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>经过上述步骤最后创建了<code>SurfaceComponentClient</code></p>
<p><code>addToDisplay</code>执行完毕后，回调到<code>performTraversals()</code></p>
<h5 id="WS-relayoutWindow"><a href="#WS-relayoutWindow" class="headerlink" title="WS#relayoutWindow"></a>WS#relayoutWindow</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performTraversals() &#123;<br>        <span class="hljs-keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>      ...<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> surfaceGenerationId = mSurface.getGenerationId();<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isViewVisible = viewVisibility == View.VISIBLE;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> windowRelayoutWasForced = mForceNextWindowRelayout;<br>        <span class="hljs-keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||<br>                viewVisibilityChanged || params != <span class="hljs-keyword">null</span> || mForceNextWindowRelayout) &#123;<br>            mForceNextWindowRelayout = <span class="hljs-keyword">false</span>;<br>          ...<br>            <span class="hljs-keyword">try</span> &#123;            <br>             relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);<br>              ...<br>            &#125;<span class="hljs-keyword">catch</span>(RemoteException e)&#123;<br>              <br>            &#125;<br>            <span class="hljs-keyword">if</span> (!mStopped || mReportNextDraw) &#123;<br>                <span class="hljs-keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(<br>                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);<br>                <span class="hljs-keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()<br>                        || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||<br>                        updatedConfiguration) &#123;<br>                    <span class="hljs-keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);<br>                    <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);<br>                  //执行测量流程<br>                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);  <br>                  ...<br>                &#125;<br>            &#125;<br>          <br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>        <span class="hljs-keyword">if</span> (didLayout) &#123;<br>          //执行布局过程<br>            performLayout(lp, mWidth, mHeight);<br>        &#125;<br>      &#125;<br>        <span class="hljs-keyword">boolean</span> cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;<br>        <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;<br>            <span class="hljs-keyword">if</span> (mPendingTransitions != <span class="hljs-keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;<br>                    mPendingTransitions.get(i).startChangingAnimations();<br>                &#125;<br>                mPendingTransitions.clear();<br>            &#125;<br>           //执行绘制流程<br>            performDraw();<br>        &#125; <br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>performTraversals()</code>主要做了以下几步：</p>
<ol>
<li><code>relayoutWindow</code>——创建<code>Surface</code>和<code>Layout</code></li>
<li><code>performMeasure</code>——测量过程</li>
<li><code>performLayout</code>——布局过程</li>
<li><code>performDraw</code>——绘制过程</li>
</ol>
<p>接下来主要分析<code>relayoutWindow</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> relayoutWindow(WindowManager.LayoutParams params, <span class="hljs-keyword">int</span> viewVisibility,<br>            <span class="hljs-keyword">boolean</span> insetsPending) <span class="hljs-keyword">throws</span> RemoteException &#123;<br>      ...<br>        <span class="hljs-keyword">int</span> relayoutResult = mWindowSession.relayout(mWindow, mSeq, params,<br>                (<span class="hljs-keyword">int</span>) (mView.getMeasuredWidth() * appScale + 0.5f),<br>                (<span class="hljs-keyword">int</span>) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility,<br>                insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, frameNumber,<br>                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,<br>                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingDisplayCutout,<br>                mPendingMergedConfiguration, mSurface);      <br>    &#125;<br><br>//Session.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> relayout(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,<br>            <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">int</span> viewFlags, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">long</span> frameNumber,<br>            Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets,<br>            Rect outStableInsets, Rect outsets, Rect outBackdropFrame,<br>            DisplayCutout.ParcelableWrapper cutout, MergedConfiguration mergedConfiguration,<br>            Surface outSurface) &#123;<br>      ...<br>        <span class="hljs-keyword">int</span> res = mService.relayoutWindow(<span class="hljs-keyword">this</span>, window, seq, attrs,<br>                requestedWidth, requestedHeight, viewFlags, flags, frameNumber,<br>                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,<br>                outStableInsets, outsets, outBackdropFrame, cutout,<br>                mergedConfiguration, outSurface);<br>      ...<br>        return res;<br>    &#125;<br><br>//WindowManagerService.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> relayoutWindow(Session session, IWindow client, <span class="hljs-keyword">int</span> seq, LayoutParams attrs,<br>            <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> flags,<br>            <span class="hljs-keyword">long</span> frameNumber, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,<br>            Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,<br>            DisplayCutout.ParcelableWrapper outCutout, MergedConfiguration mergedConfiguration,<br>            Surface outSurface) &#123;<br>      ...<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;<br>                    (win.mAppToken == <span class="hljs-keyword">null</span> || win.mAttrs.type == TYPE_APPLICATION_STARTING<br>                            || !win.mAppToken.isClientHidden());        <br>            <span class="hljs-keyword">if</span> (shouldRelayout) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                  //创建SurfaceControl<br>                    result = createSurfaceControl(outSurface, result, win, winAnimator);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                  ...<br>                &#125;              <br>            &#125;<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p>接下来执行到<code>createSurfaceControl</code></p>
<h6 id="WMS-createSurfaceControl"><a href="#WMS-createSurfaceControl" class="headerlink" title="WMS#createSurfaceControl"></a>WMS#createSurfaceControl</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> createSurfaceControl(Surface outSurface, <span class="hljs-keyword">int</span> result, WindowState win,<br>        WindowStateAnimator winAnimator) &#123;<br>    <span class="hljs-keyword">if</span> (!win.mHasSurface) &#123;<br>        result |= RELAYOUT_RES_SURFACE_CHANGED;<br>    &#125;<br><br>    WindowSurfaceController surfaceController;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "createSurfaceControl");<br>      //创建SurfaceControl<br>        surfaceController = winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (surfaceController != <span class="hljs-keyword">null</span>) &#123;<br>      //创建Surface<br>        surfaceController.getSurface(outSurface);<br>        <span class="hljs-keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(TAG_WM, "  OUT SURFACE " + outSurface + ": copied");<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // For some reason there isn't a surface.  Clear the<br>        // caller's object so they see the same state.<br>        Slog.w(TAG_WM, "Failed to create surface control <span class="hljs-keyword">for</span> " + win);<br>        outSurface.release();<br>    &#125;<br><br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>createSurfaceControl()</code>主要执行了两步：</p>
<ul>
<li><code>createSurfaceLocked</code>——创建Layer</li>
<li><code>SurfaceControl#getSurface</code>——创建Surface</li>
</ul>
<h6 id="WMS-createSurfaceLocked"><a href="#WMS-createSurfaceLocked" class="headerlink" title="WMS#createSurfaceLocked"></a>WMS#createSurfaceLocked</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">//com/android/server/wm/WindowStateAnimator.java<br>    WindowSurfaceController createSurfaceLocked(<span class="hljs-keyword">int</span> windowType, <span class="hljs-keyword">int</span> ownerUid) &#123;<br>      ...<br>            mSurfaceController = new WindowSurfaceController(mSession.mSurfaceSession,<br>                    attrs.getTitle().toString(), width, height, format, flags, <span class="hljs-keyword">this</span>,<br>                    windowType, ownerUid);      <br>      ...<br>    &#125;<br><br>//WindowSurfaceController.java<br>    <span class="hljs-keyword">public</span> WindowSurfaceController(SurfaceSession s, String name, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> format,<br>            <span class="hljs-keyword">int</span> flags, WindowStateAnimator animator, <span class="hljs-keyword">int</span> windowType, <span class="hljs-keyword">int</span> ownerUid) &#123;<br>      ...<br>        <span class="hljs-keyword">final</span> SurfaceControl.Builder b = win.makeSurface()<br>                .setParent(win.getSurfaceControl())<br>                .setName(name)<br>                .setSize(w, h)<br>                .setFormat(format)<br>                .setFlags(flags)<br>                .setMetadata(windowType, ownerUid);<br>        mSurfaceControl = b.build();      <br>      ...<br>    &#125;<br><br>//SurfaceControl.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> class Builder &#123;<br>      ...<br>        <span class="hljs-keyword">public</span> SurfaceControl build() &#123;<br>            <span class="hljs-keyword">if</span> (mWidth &lt;= 0 || mHeight &lt;= 0) &#123;<br>                throw new IllegalArgumentException(<br>                        "width and height must be set");<br>            &#125;<br>            return new SurfaceControl(mSession, mName, mWidth, mHeight, mFormat,<br>                    mFlags, mParent, mWindowType, mOwnerUid);<br>        &#125;      <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> SurfaceControl(SurfaceSession session, String name, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> format, <span class="hljs-keyword">int</span> flags,<br>            SurfaceControl parent, <span class="hljs-keyword">int</span> windowType, <span class="hljs-keyword">int</span> ownerUid)<br>                    <span class="hljs-keyword">throws</span> OutOfResourcesException, IllegalArgumentException &#123;<br>      ...<br>        mNativeObject = nativeCreate(session, name, w, h, format, flags,<br>            parent != <span class="hljs-keyword">null</span> ? parent.mNativeObject : 0, windowType, ownerUid);<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>执行<code>nativeCreate</code>切换到Native层执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//base/core/jni/android_view_SurfaceControl.cpp<br><span class="hljs-keyword">static</span> jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj,<br>        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,<br>        jint windowType, jint ownerUid) &#123;<br>    ScopedUtfChars name(env, nameStr);<br>    sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));<br>    SurfaceControl *parent = <span class="hljs-keyword">reinterpret_cast</span>&lt;SurfaceControl*&gt;(parentObject);<br>    sp&lt;SurfaceControl&gt; surface;<br>    status_t err = client-&gt;createSurfaceChecked(<br>            String8(name.c_str()), w, h, format, &amp;surface, flags, parent, windowType, ownerUid);<br>  ...<br><br>    surface-&gt;incStrong((<span class="hljs-keyword">void</span> *)nativeCreate);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>createSurfaceChecked()</code>后续的流程会创建<code>Layer</code></p>
<h6 id="SurfaceControl-getSurface"><a href="#SurfaceControl-getSurface" class="headerlink" title="SurfaceControl#getSurface"></a>SurfaceControl#getSurface</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">//WindowSurfaceController.java<br>    <span class="hljs-keyword">void</span> getSurface(Surface outSurface) &#123;<br>        outSurface.copyFrom(mSurfaceControl);<br>    &#125;<br><br>//Surface.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> copyFrom(SurfaceControl other) &#123;<br>      ...<br>        //创建Surface<br>        <span class="hljs-keyword">long</span> newNativeObject = nativeGetFromSurfaceControl(surfaceControlPtr);<br><br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>nativeGetFromSurfaceControl()</code>创建<code>Surface</code></p>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>先执行<code>ViewRootImpl#setView()</code>，其中会执行</p>
<ul>
<li><p><code>requestLayout</code></p>
<p>内部执行<code>ViewRootImpl#performTraversals()</code>，接下去执行<code>WMS#relayoutWindow()</code>，然后是<code>WMS#createSurfaceControl</code>，分为两步：</p>
<ul>
<li><code>createSurfaceLocked</code>：创建<code>SurfaceControl</code>，内部执行<code>android_view_surfaceControl#nativeCreate</code>，执行<code>SurfaceComponentClient#createSurface</code>，创建<code>Layer</code>对象。</li>
<li><code>WindowSurfaceController#getSurface</code>：执行到<code>Surface#copyFrom()</code>，调用到<code>nativeGetFromSurfaceControl()</code>，内部调用到<code>SurfaceControl#getSurface()</code>去创建<code>Surface</code></li>
</ul>
<p>创建<code>Surface</code>和<code>Layer</code>完毕后，继续执行View的绘制流程<code>measure-&gt;layout-&gt;draw</code></p>
</li>
<li><p><code>WindowSession#addToDisplay()</code></p>
<p>执行到<code>WMS#addWindow()</code>，继续到<code>Session#windowAddedLocked()</code>，切换到<code>Native</code>层执行<code>android_view_surfaceSession#native_create()</code>在其中创建了<code>SurfaceComponentClient</code>。</p>
</li>
</ul>
</blockquote>
<p><img src="/images/SF-Surface和Layer创建准备.jpg" srcset="/img/loading.gif" alt="SF-Surface/Layer创建准备"></p>
<h4 id="Surface、Layer的创建"><a href="#Surface、Layer的创建" class="headerlink" title="Surface、Layer的创建"></a>Surface、Layer的创建</h4><p>根据上节源码分析可以知道，<code>Surface、Layer</code>的创建主要分为以下几步</p>
<h5 id="创建SurfaceComponentClient"><a href="#创建SurfaceComponentClient" class="headerlink" title="创建SurfaceComponentClient"></a>创建SurfaceComponentClient</h5><blockquote>
<p>App进程与<code>SurfaceFlinger</code>沟通的桥梁。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/SurfaceComposerClient.cpp<br><span class="hljs-keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;<br>    sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());<br>    <span class="hljs-keyword">if</span> (sf != 0 &amp;&amp; mStatus == NO_INIT) &#123;<br>        <span class="hljs-keyword">auto</span> rootProducer = mParent.promote();<br>        sp&lt;ISurfaceComposerClient&gt; conn;<br>        conn = (rootProducer != <span class="hljs-literal">nullptr</span>) ? sf-&gt;createScopedConnection(rootProducer) :<br>                sf-&gt;createConnection();<br>      ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>ComposerService</code>就是<code>SurfaceFlinger</code>的Binder代理对象，<code>SurfaceComponentClient</code>通过<code>ComposerService</code>与<code>SurfaceFlinger</code>进行通信。</p>
<h6 id="ComposerService"><a href="#ComposerService" class="headerlink" title="ComposerService"></a>ComposerService</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/SurfaceComposerClient.cpp<br>/*<span class="hljs-keyword">static</span>*/ sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123;<br>    ComposerService&amp; instance = ComposerService::getInstance();<br>    <span class="hljs-keyword">if</span> (instance.mComposerService == <span class="hljs-literal">NULL</span>) &#123;<br>        ComposerService::getInstance().connectLocked();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance.mComposerService;<br>&#125;<br><br><span class="hljs-keyword">void</span> ComposerService::connectLocked() &#123;<br>    <span class="hljs-keyword">const</span> String16 name("SurfaceFlinger");<br>  //获取SurfaceFlinger 服务<br>    <span class="hljs-keyword">while</span> (getService(name, &amp;mComposerService) != NO_ERROR) &#123;<br>        usleep(250000);<br>    &#125;<br>    assert(mComposerService != <span class="hljs-literal">NULL</span>);<br>&#125;<br><br>//native/libs/binder/include/binder/IServiceManager.h<br>status_t getService(<span class="hljs-keyword">const</span> String16&amp; name, sp&lt;INTERFACE&gt;* outService)<br>&#123;<br>    <span class="hljs-keyword">const</span> sp&lt;IServiceManager&gt; sm = defaultServiceManager();<br>    <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">NULL</span>) &#123;<br>        *outService = interface_cast&lt;INTERFACE&gt;(sm-&gt;getService(name));<br>        <span class="hljs-keyword">if</span> ((*outService) != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> NO_ERROR;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NAME_NOT_FOUND;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="SurfaceFlinger-createConnection"><a href="#SurfaceFlinger-createConnection" class="headerlink" title="SurfaceFlinger#createConnection"></a>SurfaceFlinger#createConnection</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/services/surfaceflinger/SurfaceFlinger.cpp<br>sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection() &#123;<br>    <span class="hljs-keyword">return</span> initClient(<span class="hljs-keyword">new</span> Client(<span class="hljs-keyword">this</span>));<br>&#125;<br><br><span class="hljs-keyword">static</span> sp&lt;ISurfaceComposerClient&gt; initClient(<span class="hljs-keyword">const</span> sp&lt;Client&gt;&amp; client) &#123;<br>  //检查Client是否合法<br>    status_t err = client-&gt;initCheck();<br>    <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>        <span class="hljs-keyword">return</span> client;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>Client</code>内部封装的是<strong>创建和销毁Layer和Surface的操作函数。</strong></p>
<blockquote>
<p><code>Client</code>实现了<code>ISurfaceComposerClient</code>接口，<code>SurfaceComposerClient</code>通过<code>Client</code>和<code>SurfaceFlinger</code>进行通讯。</p>
<p>除此之外还可以创建<code>Surface</code>以及维护<code>Layer</code>对象。</p>
</blockquote>
<h5 id="创建SurfaceControl并创建Layer"><a href="#创建SurfaceControl并创建Layer" class="headerlink" title="创建SurfaceControl并创建Layer"></a>创建SurfaceControl并创建Layer</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">status_t SurfaceComposerClient::createSurfaceChecked(<br>        <span class="hljs-keyword">const</span> String8&amp; name,<br>        uint32_t w,<br>        uint32_t h,<br>        PixelFormat format,<br>        sp&lt;SurfaceControl&gt;* outSurface,<br>        uint32_t flags,<br>        SurfaceControl* parent,<br>        int32_t windowType,<br>        int32_t ownerUid)<br>&#123;<br>    sp&lt;SurfaceControl&gt; sur;<br>    status_t err = mStatus;<br>      <br>        err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle,<br>                windowType, ownerUid, &amp;handle, &amp;gbp);<br>        <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>            *outSurface = <span class="hljs-keyword">new</span> SurfaceControl(<span class="hljs-keyword">this</span>, handle, gbp, <span class="hljs-literal">true</span> /* owned */);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="Client-createSurface"><a href="#Client-createSurface" class="headerlink" title="Client#createSurface"></a>Client#createSurface</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/services/surfaceflinger/Client.cpp<br>status_t Client::createSurface(<br>        <span class="hljs-keyword">const</span> String8&amp; name,<br>        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,<br>        <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; parentHandle, int32_t windowType, int32_t ownerUid,<br>        sp&lt;IBinder&gt;* handle,<br>        sp&lt;IGraphicBufferProducer&gt;* gbp)<br>&#123;<br>    class MessageCreateLayer : <span class="hljs-keyword">public</span> MessageBase &#123;<br>        SurfaceFlinger* flinger;<br>        Client* client;<br>        sp&lt;IBinder&gt;* handle;<br>        sp&lt;IGraphicBufferProducer&gt;* gbp;<br>        status_t result;<br>        <span class="hljs-keyword">const</span> String8&amp; name;<br>        uint32_t w, h;<br>        PixelFormat format;<br>        uint32_t flags;<br>        sp&lt;Layer&gt;* parent;<br>        int32_t windowType;<br>        int32_t ownerUid;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> handler() &#123;<br>            result = flinger-&gt;createLayer(name, client, w, h, format, flags,<br>                    windowType, ownerUid, handle, gbp, parent);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br>  <br>    sp&lt;MessageBase&gt; msg = <span class="hljs-keyword">new</span> MessageCreateLayer(mFlinger.get(),<br>            name, <span class="hljs-keyword">this</span>, w, h, format, flags, handle,<br>            windowType, ownerUid, gbp, &amp;parent);<br>    mFlinger-&gt;postMessageSync(msg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>postMessageSync()</code>发送消息，处理后回调到<code>handler()</code>，继续执行<code>createLayer()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/services/surfaceflinger/SurfaceFlinger.cpp<br>status_t SurfaceFlinger::createLayer(<br>        <span class="hljs-keyword">const</span> String8&amp; name,<br>        <span class="hljs-keyword">const</span> sp&lt;Client&gt;&amp; client,<br>        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,<br>        int32_t windowType, int32_t ownerUid, sp&lt;IBinder&gt;* handle,<br>        sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* parent)<br>&#123;<br>  ...<br>    <span class="hljs-keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;<br>        <span class="hljs-keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:<br>            result = createBufferLayer(client,<br>                    uniqueName, w, h, flags, format,<br>                    handle, gbp, &amp;layer);<br><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> ISurfaceComposerClient::eFXSurfaceColor:<br>            result = createColorLayer(client,<br>                    uniqueName, w, h, flags,<br>                    handle, &amp;layer);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            result = BAD_VALUE;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>  ...  <br>  <br>&#125;<br><br>status_t SurfaceFlinger::createBufferLayer(<span class="hljs-keyword">const</span> sp&lt;Client&gt;&amp; client,<br>        <span class="hljs-keyword">const</span> String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format,<br>        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)<br>&#123;<br> ...<br>   //创建Layer对象<br>    sp&lt;BufferLayer&gt; layer = <span class="hljs-keyword">new</span> BufferLayer(<span class="hljs-keyword">this</span>, client, name, w, h, flags);   <br> ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>createSurface</code>执行到最后，构建出<code>Layer</code>对象。</p>
<h6 id="new-SurfaceControl"><a href="#new-SurfaceControl" class="headerlink" title="new SurfaceControl"></a>new SurfaceControl</h6><blockquote>
<p><code>SurfaceControl</code>主要作用就是<strong>维护Surface</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/SurfaceControl.cpp<br>SurfaceControl::SurfaceControl(<br>        <span class="hljs-keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,<br>        <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; handle,<br>        <span class="hljs-keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbp,<br>        <span class="hljs-keyword">bool</span> owned)<br>    : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp), mOwned(owned)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建SurfaceControl之后，仅仅是设置了<code>mClient</code>以及创建了<code>GraphicBufferProducer</code>对象。</p>
<h5 id="通过SurfaceControl创建Surface"><a href="#通过SurfaceControl创建Surface" class="headerlink" title="通过SurfaceControl创建Surface"></a>通过SurfaceControl创建Surface</h5><p>此时已经创建完毕<code>Surfacecontrol</code>和<code>Layer</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//<br>sp&lt;Surface&gt; SurfaceControl::getSurface() <span class="hljs-keyword">const</span><br>&#123;<br>    Mutex::Autolock _l(mLock);<br>    <span class="hljs-keyword">if</span> (mSurfaceData == 0) &#123;<br>        <span class="hljs-keyword">return</span> generateSurfaceLocked();<br>    &#125;<br>    <span class="hljs-keyword">return</span> mSurfaceData;<br>&#125;<br><br>sp&lt;Surface&gt; SurfaceControl::generateSurfaceLocked() <span class="hljs-keyword">const</span><br>&#123;<br>  //构造Surface对象<br>    mSurfaceData = <span class="hljs-keyword">new</span> Surface(mGraphicBufferProducer, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">return</span> mSurfaceData;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Native</code>层的<code>Surface</code>创建完毕后，返回到<code>Java</code>层进行赋值。</p>
<p><img src="/images/SF-Buffer、Layer创建过程.jpg" srcset="/img/loading.gif" alt="SF-Buffer、Layer创建过程"></p>
<h4 id="BufferQueue的创建"><a href="#BufferQueue的创建" class="headerlink" title="BufferQueue的创建"></a>BufferQueue的创建</h4><p>在创建<code>Layer</code>完成后，后续就会继续去创建<code>BufferQueue</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//BufferLayer.cpp<br><span class="hljs-keyword">void</span> BufferLayer::onFirstRef() &#123;<br>    // Creates a custom BufferQueue <span class="hljs-keyword">for</span> SurfaceFlingerConsumer to use<br>    sp&lt;IGraphicBufferProducer&gt; producer;<br>    sp&lt;IGraphicBufferConsumer&gt; consumer;<br>  //创建BufferQueue对象<br>    BufferQueue::createBufferQueue(&amp;producer, &amp;consumer, <span class="hljs-literal">true</span>);<br>    mProducer = <span class="hljs-keyword">new</span> MonitoredProducer(producer, mFlinger, <span class="hljs-keyword">this</span>);<br>    mConsumer = <span class="hljs-keyword">new</span> BufferLayerConsumer(consumer,<br>            mFlinger-&gt;getRenderEngine(), mTextureName, <span class="hljs-keyword">this</span>);<br>    mConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));<br>    mConsumer-&gt;setContentsChangedListener(<span class="hljs-keyword">this</span>);<br>    mConsumer-&gt;setName(mName);<br><br>    <span class="hljs-keyword">if</span> (mFlinger-&gt;isLayerTripleBufferingDisabled()) &#123;<br>        mProducer-&gt;setMaxDequeuedBufferCount(2);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());<br>    updateTransformHint(hw);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/BufferQueue.cpp<br><span class="hljs-keyword">void</span> BufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer,<br>        sp&lt;IGraphicBufferConsumer&gt;* outConsumer,<br>        <span class="hljs-keyword">bool</span> consumerIsSurfaceFlinger) &#123;<br>  //创建BufferQueueCore<br>    sp&lt;BufferQueueCore&gt; core(<span class="hljs-keyword">new</span> BufferQueueCore());<br>  //创建BufferQueueProducer<br>    sp&lt;IGraphicBufferProducer&gt; producer(<span class="hljs-keyword">new</span> BufferQueueProducer(core, consumerIsSurfaceFlinger));<br>  //创建BufferQueueConsumer<br>    sp&lt;IGraphicBufferConsumer&gt; consumer(<span class="hljs-keyword">new</span> BufferQueueConsumer(core));<br>  <br>    *outProducer = producer;<br>    *outConsumer = consumer;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>createBufferQueue</code>主要创建以下三个对象：</p>
<ul>
<li><code>BufferQueueCore</code></li>
<li><code>BufferQueueProducer</code></li>
<li><code>BufferQueueConsumer</code></li>
</ul>
<h5 id="BufferQueueCore"><a href="#BufferQueueCore" class="headerlink" title="BufferQueueCore"></a>BufferQueueCore</h5><blockquote>
<p>主要用来存放<code>GraphicBuffer</code>，并且存放最多<strong>64</strong>个。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/include/gui/BufferQueueCore.h<br>class BufferQueueCore : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> RefBase &#123;<br><br>    <span class="hljs-keyword">friend</span> class BufferQueueProducer;<br>    <span class="hljs-keyword">friend</span> class BufferQueueConsumer;<br><span class="hljs-keyword">public</span>:<br>  ...<br><span class="hljs-keyword">private</span>:<br>  ...<br>    BufferQueueDefs::SlotsType mSlots;<br>    Fifo mQueue;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; mFreeSlots;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; mFreeBuffers;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; mUnusedSlots;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; mActiveBuffers;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要有以下几个对象：</p>
<ul>
<li><code>mSlots</code>：大小为<code>NUM_BUFFER_SLOTS(64)</code>的数组，存储数据为<code>BufferSlot</code></li>
<li><code>mQueue</code>：以<code>先进先出对了</code>存放<code>生产者生产的数据-BufferItem</code>，保证按照顺序取出</li>
<li><code>mFreeSlots</code>：尚未绑定<code>GraphicBuffer</code>且<code>state = FREE</code>的<code>BufferSlot</code>的<code>index</code>集合</li>
<li><code>mFreeBuffers</code>：已经绑定了<code>GraphicBuffer</code>且<code>state = FREE</code>的<code>BufferSlot</code>的<code>index</code>集合</li>
<li><code>mActiveBuffers</code>：已经绑定了<code>GraphicBuffer</code>且<code>state!=FREE</code>的<code>BufferSlot</code>的<code>index</code>集合</li>
<li><code>mUnusedSlots</code>：没有绑定<code>GraphicBuffer</code>且没有状态的<code>BufferSlot</code>的<code>index</code>集合</li>
</ul>
<p>主要介绍<code>BufferSlot</code>，<code>BufferQueueCore</code>基本是<code>BufferSlot</code>的各种集合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//<br>struct BufferSlot &#123;<br><br>    BufferSlot()<br>    : mGraphicBuffer(<span class="hljs-literal">nullptr</span>),<br>      mBufferState(),<br>  ...<br>   //绑定的 GraphicBuffer<br>    sp&lt;GraphicBuffer&gt; mGraphicBuffer;<br>   //绑定的BufferSlot 状态<br>    BufferState mBufferState;<br>&#125;<br><br>struct BufferState &#123;<br><br>    // All slots are initially FREE (<span class="hljs-keyword">not</span> dequeued, queued, acquired, <span class="hljs-keyword">or</span> shared).<br>    BufferState()<br>    : mDequeueCount(0),<br>      mQueueCount(0),<br>      mAcquireCount(0),<br>      mShared(<span class="hljs-literal">false</span>) &#123;<br>    &#125;<br>  <br>    //         | mShared | mDequeueCount | mQueueCount | mAcquireCount |<br>    // --------|---------|---------------|-------------|---------------|<br>    // FREE    |  <span class="hljs-literal">false</span>  |       0       |      0      |       0       |<br>    // DEQUEUED|  <span class="hljs-literal">false</span>  |       1       |      0      |       0       |<br>    // QUEUED  |  <span class="hljs-literal">false</span>  |       0       |      1      |       0       |<br>    // ACQUIRED|  <span class="hljs-literal">false</span>  |       0       |      0      |       1       |<br>    // SHARED  |  <span class="hljs-literal">true</span>   |      any      |     any     |      any      |      <br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要由两部分构成：</p>
<ul>
<li><code>mGraphicBuffer</code>：<code>BufferSlot</code>所绑定的<code>GraphicBuffer</code></li>
<li><code>mBufferState</code>：表示当前<code>BufferSlot</code>的状态，主要有以下几种状态：<ul>
<li><code>FREE</code>：空闲状态，存入<code>mFreeSlots</code></li>
<li><code>DEQUEUED</code>：被<code>生产者</code>获取，待绘制数据</li>
<li><code>QUEUED</code>：被<code>BufferQueue</code>获取，待<code>消费者</code>获取。</li>
<li><code>ACQUIRED</code>：被<code>消费者</code>获取，待获取绘制数据</li>
<li><code>SHARED</code>：处于共享状态。</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>BufferQueueCore</code>设置了这么多的<code>BufferSlot</code>集合，主要为了<strong>分类BufferSlot时更高效</strong>。</p>
</blockquote>
<p><img src="/images/SF-BufferQueueCore.jpg" srcset="/img/loading.gif" alt="SF-BufferQueueCore"></p>
<h5 id="BufferQueueProducer"><a href="#BufferQueueProducer" class="headerlink" title="BufferQueueProducer"></a>BufferQueueProducer</h5><blockquote>
<p><code>Surface</code>中持有<code>BufferQueueProducer</code>的BP代理对象-<code>IGraphicBufferProducer</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/BufferQueueProducer.cpp<br>BufferQueueProducer::BufferQueueProducer(<span class="hljs-keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core,<br>        <span class="hljs-keyword">bool</span> consumerIsSurfaceFlinger) :<br>    mCore(core),<br>    mSlots(core-&gt;mSlots),<br>...<br>&#125;<br><br>status_t BufferQueueProducer::dequeueBuffer(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,<br>                                            uint32_t width, uint32_t height, PixelFormat format,<br>                                            uint64_t usage, uint64_t* outBufferAge,<br>                                            FrameEventHistoryDelta* outTimestamps) &#123;<br> ... <br>&#125;<br><br>status_t BufferQueueProducer::queueBuffer(<span class="hljs-keyword">int</span> slot,<br>        <span class="hljs-keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>初始化了<code>mCore</code>和<code>mSlots</code>对象</p>
<pre><code class=" mermaid">graph TD
A(new &lt;br&gt;BufferQueueProducer)
B(赋值BufferQueueCore到mCore)
C(赋值mSlots)
A---&gt;B
A---&gt;C
</code></pre>
<h6 id="dequeueBuffer"><a href="#dequeueBuffer" class="headerlink" title="dequeueBuffer"></a>dequeueBuffer</h6><blockquote>
<p>向<code>BufferQueue</code>申请一块<code>GraphicBuffer</code>。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>为<code>DEQUEUED</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/BufferQueueProducer.cpp<br>status_t BufferQueueProducer::dequeueBuffer(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,<br>                                            uint32_t width, uint32_t height, PixelFormat format,<br>                                            uint64_t usage, uint64_t* outBufferAge,<br>                                            FrameEventHistoryDelta* outTimestamps) &#123;<br>        <span class="hljs-keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;<br>            status_t status = waitForFreeSlotThenRelock(FreeSlotCaller::Dequeue,<br>                    &amp;found);<br>           ...     <br>        &#125;<br>      //判断寻找的 BufferSlot是否与 申请的宽高、格式一致<br>        <span class="hljs-keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer(mSlots[found].mGraphicBuffer);<br>        <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferSlot == found &amp;&amp;<br>                buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage)) &#123;<br>            BQ_LOGE("dequeueBuffer: cannot re-allocate a shared"<br>                    "buffer");<br><br>            <span class="hljs-keyword">return</span> BAD_VALUE;<br>        &#125;  <br>  ...<br>        <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferSlot != found) &#123;<br>          //添加 GraphicBuffer 的index到 mActiveBuffers<br>            mCore-&gt;mActiveBuffers.insert(found);<br>        &#125;<br>        *outSlot = found;  <br>  ...<br>      //标记 选中的BufferSlot状态为 DEQUEUED<br>        mSlots[found].mBufferState.dequeue();<br><br>      //找到了空的 GraphicBuffer，就进行初始化。<br>        <span class="hljs-keyword">if</span> ((buffer == <span class="hljs-literal">NULL</span>) ||<br>                buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage))<br>        &#123;<br>            mSlots[found].mAcquireCalled = <span class="hljs-literal">false</span>;<br>            mSlots[found].mGraphicBuffer = <span class="hljs-literal">NULL</span>;<br>            mSlots[found].mRequestBufferCalled = <span class="hljs-literal">false</span>;<br>            mSlots[found].mEglDisplay = EGL_NO_DISPLAY;<br>            mSlots[found].mEglFence = EGL_NO_SYNC_KHR;<br>            mSlots[found].mFence = Fence::NO_FENCE;<br>            mCore-&gt;mBufferAge = 0;<br>            mCore-&gt;mIsAllocating = <span class="hljs-literal">true</span>;<br><br>            returnFlags |= BUFFER_NEEDS_REALLOCATION;<br>        &#125; <br>      ...<br>    <span class="hljs-keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;<br>        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="hljs-keyword">new</span> GraphicBuffer(<br>                width, height, format, BQ_LAYER_COUNT, usage,u<br>                &#123;mConsumerName.<span class="hljs-built_in">string</span>(), mConsumerName.size()&#125;);<br>      &#123;<br>            <span class="hljs-keyword">if</span> (error == NO_ERROR &amp;&amp; !mCore-&gt;mIsAbandoned) &#123;<br>                graphicBuffer-&gt;setGenerationNumber(mCore-&gt;mGenerationNumber);<br>              //将新创建的GraphicBuffer放到 BufferSlot中<br>                mSlots[*outSlot].mGraphicBuffer = graphicBuffer;<br>            &#125;      <br>      &#125;<br>    &#125;<br>  <br>&#125;<br><br>status_t BufferQueueProducer::waitForFreeSlotThenRelock(FreeSlotCaller caller,<br>        <span class="hljs-keyword">int</span>* found) <span class="hljs-keyword">const</span> &#123;<br>  ...<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxBufferCount = mCore-&gt;getMaxBufferCountLocked();<br>       //请求是否太多<br>        <span class="hljs-keyword">bool</span> tooManyBuffers = mCore-&gt;mQueue.size()<br>                            &gt; <span class="hljs-keyword">static_cast</span>&lt;size_t&gt;(maxBufferCount);<br>        <span class="hljs-keyword">if</span> (tooManyBuffers) &#123;<br>          //请求过多时，就会进入阻塞状态<br>            BQ_LOGV("r%s: <span class="hljs-built_in">queue</span> size is %zu, waiting", callerString,<br>                    mCore-&gt;mQueue.size());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot !=<br>                    BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                *found = mCore-&gt;mSharedBufferSlot;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (caller == FreeSlotCaller::Dequeue) &#123;<br>                    // 寻找已经绑定GraphicBuffer 但 State = FREE的 BufferSlot<br>                    <span class="hljs-keyword">int</span> slot = getFreeBufferLocked();<br>                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                        *found = slot;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCore-&gt;mAllowAllocation) &#123;<br>                        *found = getFreeSlotLocked();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span><br>                    // 寻找尚未绑定GraphicBuffer 但 State = FREE 的BufferSlot<br>                    <span class="hljs-keyword">int</span> slot = getFreeSlotLocked();<br>                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                        *found = slot;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        *found = getFreeBufferLocked();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>edequeueBuffer</code>主要做了以下几步：</p>
<ul>
<li><p>通过<code>waitForFreeSlotThenRelock</code>寻找空闲的<code>BufferSlot</code>，需要判断当前是否与申请<code>width、height、format</code>一致，不一致则需要重新请求</p>
<p><code>waitForFreeSlotThenRelock</code>主要实现了以下几步：</p>
<ul>
<li><code>getFreeBufferLocked</code>：直接使用已经绑定的<code>GraphicBuffer</code></li>
<li><code>getFreeSlotLocked</code>：需要新建一个<code>GraphicBuffer</code>与其绑定</li>
</ul>
</li>
<li><p>把找到的<code>BufferSlot</code>的<code>index</code>放到<code>mActiveSlots</code>中</p>
</li>
<li><p>如果找到的<code>BufferSlot</code>中的<code>GraphicBuffer</code>为null，需要初始化<code>BufferSlot</code></p>
</li>
<li><p>如果需要重新创建<code>GraphicBuffer</code>，并把新建的<code>GraphicBuffer</code>放在找到的<code>BufferSlot</code>中</p>
</li>
</ul>
<blockquote>
<p>尝试寻找一个<code>BufferSlot</code>，并且<code>width,height,format</code>都符合要求，如果没有绑定<code>GraphicBuffer</code>，就需要新建一个并且进行绑定，然后设置<code>BufferSlot</code>的<code>BufferState</code>为<code>DEQUEUED</code>，最后返回在<code>mSlots</code>的<code>index</code>回去。</p>
</blockquote>
<p><img src="/images/SF-BufferQueue-dequeueBuffer.jpg" srcset="/img/loading.gif" alt="SF-BufferQueue-dequeueBuffer"></p>
<h6 id="queueBuffer"><a href="#queueBuffer" class="headerlink" title="queueBuffer"></a>queueBuffer</h6><blockquote>
<p>在<code>生产者</code>填充数据到<code>GraphicBuffer</code>完毕后，通过<code>queueBuffer</code>把<code>GraphicBuffer</code>放回到<code>BufferQueue</code>。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>QUEUED</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/BufferQueueProducer.cpp<br>status_t BufferQueueProducer::queueBuffer(<span class="hljs-keyword">int</span> slot,<br>        <span class="hljs-keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;<br>  ...<br>    //消费者回调<br>    sp&lt;IConsumerListener&gt; frameAvailableListener;<br>    sp&lt;IConsumerListener&gt; frameReplacedListener;<br>    <span class="hljs-keyword">int</span> callbackTicket = 0;<br>    uint64_t currentFrameNumber = 0;<br>  //需要插入mQueue的 数据结构<br>    BufferItem item;<br>  ...<br>  &#123;<br>    ...<br>        <span class="hljs-keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; graphicBuffer(mSlots[slot].mGraphicBuffer);    <br>        mSlots[slot].mBufferState.<span class="hljs-built_in">queue</span>();<br>       //构造BufferItem对象<br>        item.mAcquireCalled = mSlots[slot].mAcquireCalled;<br>        item.mGraphicBuffer = mSlots[slot].mGraphicBuffer;<br>        item.mCrop = crop;<br>        item.mTransform = transform &amp;<br>                ~<span class="hljs-keyword">static_cast</span>&lt;uint32_t&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);<br>        item.mTransformToDisplayInverse =<br>                (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != 0;<br>        item.mScalingMode = <span class="hljs-keyword">static_cast</span>&lt;uint32_t&gt;(scalingMode);<br>        item.mTimestamp = requestedPresentTimestamp;<br>        item.mIsAutoTimestamp = isAutoTimestamp;<br>        item.mDataSpace = dataSpace;<br>        item.mHdrMetadata = hdrMetadata;<br>        item.mFrameNumber = currentFrameNumber;<br>        item.mSlot = slot;<br>        item.mFence = acquireFence;<br>        item.mFenceTime = acquireFenceTime;<br>        item.mIsDroppable = mCore-&gt;mAsyncMode ||<br>                mCore-&gt;mDequeueBufferCannotBlock ||<br>                (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == slot);<br>        item.mSurfaceDamage = surfaceDamage;<br>        item.mQueuedBuffer = <span class="hljs-literal">true</span>;<br>        item.mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mAutoRefresh;<br>        item.mApi = mCore-&gt;mConnectedApi;    <br>    <br>        <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;<br>          //添加BufferItem<br>            mCore-&gt;mQueue.push_back(item);<br>            frameAvailableListener = mCore-&gt;mConsumerListener;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> BufferItem&amp; last = mCore-&gt;mQueue.itemAt(<br>                    mCore-&gt;mQueue.size() - 1);<br>            <span class="hljs-keyword">if</span> (last.mIsDroppable) &#123;<br>              //替换mQueue最后一位 为新的BufferItem<br>                mCore-&gt;mQueue.editItemAt(mCore-&gt;mQueue.size() - 1) = item;<br>                frameReplacedListener = mCore-&gt;mConsumerListener;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              //添加 BufferItem<br>                mCore-&gt;mQueue.push_back(item);<br>                frameAvailableListener = mCore-&gt;mConsumerListener;<br>            &#125;               <br>        &#125;<br>    ...<br>      <br>        <span class="hljs-keyword">if</span> (frameAvailableListener != <span class="hljs-literal">NULL</span>) &#123;<br>          //回调 onFrameAvaliaable 通知消费者有新的数据入队<br>            frameAvailableListener-&gt;onFrameAvailable(item);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (frameReplacedListener != <span class="hljs-literal">NULL</span>) &#123;<br>            frameReplacedListener-&gt;onFrameReplaced(item);<br>        &#125;      <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>queueBuffer</code>主要执行了以下几步：</p>
<ul>
<li>根据传入的<code>slot</code>从<code>mSlots</code>获取对应的<code>BufferSlot</code>，并设置对应的<code>BufferState</code>为<code>QUEUED</code></li>
<li>根据获取的<code>BufferSlot</code>构造出<code>BufferItem</code>，并添加到<code>mQueues</code>中</li>
<li>最后回调到<code>frameAvaliableListener.onFrameAvaliable()</code>通知<code>消费者</code>有新数据入队，可以进行获取。</li>
</ul>
<pre><code class=" mermaid">graph TD
A(queueBuffer)
B(&quot;获取mSlots[slot].mGraphicBuffer&quot;)
C(&quot;mSlots[slot].mBufferState.queue()&quot;)
A--&gt;B
A---&gt;C
D(&quot;设置BufferState状态为QUEUED&quot;)
D---C
E(&quot;组装BufferItem&quot;)
B--&gt;E
F&#123;&quot;last&lt;br&gt;.mIsDroppable&quot;&#125;
E---&gt;F
G(&quot;mQueue.push_back(item)&quot;)
H(&quot;mQueue.editItemAt(last)==item&quot;)
F--&gt;|Y| H
F--&gt;|N| G
J(&quot;frameAvailableListener-&gt;onFrameAvailable(item)&quot;)
H--&gt;J
G--&gt;J
I(&quot;通知消费者有数据入队，消费者可以获取数据&quot;)
K(&quot;最后一条数据是否有效？&quot;)
K---F
I---J
</code></pre>
<h5 id="BufferQueueConsumer"><a href="#BufferQueueConsumer" class="headerlink" title="BufferQueueConsumer"></a>BufferQueueConsumer</h5><blockquote>
<p><code>SurfaceFlinger</code>通过<code>BufferQueueConsumer</code>来获取以及释放<code>GraphicBuffer</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/BufferQueueConsumer.cpp<br>BufferQueueConsumer::BufferQueueConsumer(<span class="hljs-keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :<br>    mCore(core),<br>    mSlots(core-&gt;mSlots),<br>    mConsumerName() &#123;&#125;<br></code></pre></td></tr></table></figure>
<p><code>BufferQueueConsumer</code>只是设置了<code>mCore</code>和<code>mSlots</code>的两个参数。</p>
<h6 id="acquireBuffer"><a href="#acquireBuffer" class="headerlink" title="acquireBuffer"></a>acquireBuffer</h6><blockquote>
<p><code>消费者</code>向<code>BufferQueue</code>申请<code>已被填充数据的GraphicBuffer</code>进行消费。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>ACQUIRED</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/BufferQueueConsumer.cpp<br>status_t BufferQueueConsumer::acquireBuffer(BufferItem* outBuffer,<br>        nsecs_t expectedPresent, uint64_t maxFrameNumber) &#123;<br> ... <br>      //生产者注册回调<br>       sp&lt;IProducerListener&gt; listener;<br>   //如果队列为空则返回空<br>        <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.empty() &amp;&amp; !sharedBufferAvailable) &#123;<br>            <span class="hljs-keyword">return</span> NO_BUFFER_AVAILABLE;<br>        &#125;<br>    //获取队列的第一条数据<br>        BufferQueueCore::Fifo::iterator front(mCore-&gt;mQueue.begin()); <br>        <span class="hljs-keyword">if</span> (sharedBufferAvailable &amp;&amp; mCore-&gt;mQueue.empty()) &#123;<br>            //共享Buffer模式<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            //从front获取对应的slot<br>            slot = front-&gt;mSlot;<br>            *outBuffer = *front;<br>        &#125;<br>  ...<br>                <span class="hljs-keyword">if</span> (!front-&gt;mIsStale) &#123;<br>                    // Front buffer is still in mSlots, so mark the slot as <span class="hljs-built_in">free</span><br>                    mSlots[front-&gt;mSlot].mBufferState.freeQueued();<br>                  //存在已经被消费的BufferSlot<br>                    listener = mCore-&gt;mConnectedProducerListener;                  <br>                &#125;<br>        <span class="hljs-keyword">if</span> (!outBuffer-&gt;mIsStale) &#123;<br>            mSlots[slot].mAcquireCalled = <span class="hljs-literal">true</span>;<br>            // Don't decrease the <span class="hljs-built_in">queue</span> count <span class="hljs-keyword">if</span> the BufferItem wasn't<br>            // previously in the <span class="hljs-built_in">queue</span>. This happens in shared buffer mode when<br>            // the <span class="hljs-built_in">queue</span> is empty <span class="hljs-keyword">and</span> the BufferItem is created above.<br>            <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;<br>                mSlots[slot].mBufferState.acquireNotInQueue();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              //更新BufferState 为 ACQUIRED<br>                mSlots[slot].mBufferState.acquire();<br>            &#125;<br>            mSlots[slot].mFence = Fence::NO_FENCE;<br>        &#125;    <br>       //从队列中移除<br>        mCore-&gt;mQueue.erase(front);   <br>  <br>      <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; numDroppedBuffers; ++i) &#123;<br>          //回调生产者 有数据被消费<br>            listener-&gt;onBufferReleased();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>acquireBuffer</code>主要有以下几步：</p>
<ul>
<li>从<code>mQueue</code>中获取第一个元素</li>
<li>改变第一个<code>BufferSlot</code>的<code>BufferState</code>为<code>ACQUIRED</code></li>
<li>再将该<code>BufferSlot</code>从<code>mQueue</code>中移除</li>
<li>如果存在已被消费的数据则回调<code>onBufferReleased</code></li>
</ul>
<pre><code class=" mermaid">graph TB
A(&quot;acquireBuffer()&quot;)
C&#123;&quot;mQueue.empty()&quot;&#125;
A--&gt;C
D(&quot;NO_BUFFER_AVALIABLE&quot;)
C---&gt;|Y| D
E(&quot;front = &lt;br&gt;mCore-&gt;mQueue.begin()&quot;)
F(&quot;获取第一条BufferSlot&quot;)
F---E
C---&gt;|N| E
G(&quot;mSlots[slot].mBufferState.acquire()&quot;)
H(&quot;slot = front-&gt;mSlot&quot;)
E--&gt;H
H---&gt;G
J(&quot;设置BufferSlot的BufferState状态为ACQUIRED&quot;)
J---G
K(&quot;mCore-&gt;mQueue.erase(front)&quot;)
L(&quot;从mQueue中移除front&quot;)
L---K
G--&gt;K
</code></pre>
<h6 id="releaseBuffer"><a href="#releaseBuffer" class="headerlink" title="releaseBuffer"></a>releaseBuffer</h6><blockquote>
<p><code>消费者</code>消费完毕后，通知<code>BufferQueueCore</code>已消费完毕，并返回<code>空GraphicBuffer</code>到<code>BufferQueue</code></p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>FREE</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/BufferQueueConsumer.cpp<br>status_t BufferQueueConsumer::releaseBuffer(<span class="hljs-keyword">int</span> slot, uint64_t frameNumber,<br>        <span class="hljs-keyword">const</span> sp&lt;Fence&gt;&amp; releaseFence, EGLDisplay eglDisplay,<br>        EGLSyncKHR eglFence) &#123;<br>  ...<br>    sp&lt;IProducerListener&gt; listener;<br>    &#123; // Autolock scope<br>      ...<br>        mSlots[slot].mEglDisplay = eglDisplay;<br>        mSlots[slot].mEglFence = eglFence;<br>        mSlots[slot].mFence = releaseFence;<br>      //设置 BufferSlot状态为 FREE<br>        mSlots[slot].mBufferState.release();     <br>      ...<br>        <span class="hljs-keyword">if</span> (!mSlots[slot].mBufferState.isShared()) &#123;<br>            mCore-&gt;mActiveBuffers.erase(slot);<br>          //将BufferSlot放入 mFreeBuffers<br>            mCore-&gt;mFreeBuffers.push_back(slot);<br>        &#125;<br><br>        listener = mCore-&gt;mConnectedProducerListener;        <br>    &#125;<br>    <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">NULL</span>) &#123;<br>      //通知生产者有数据被消费<br>        listener-&gt;onBufferReleased();<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>releaseBuffer</code>主要有以下几步：</p>
<ul>
<li>将使用完的<code>BufferSlot</code>的<code>BufferState</code>转换为<code>FREE</code></li>
<li>被消费完的<code>BufferSlot</code>的<code>index</code>放回到<code>mFreeBuffers</code>供后续的<code>生产者</code>继续获取</li>
<li>最后通知生产者有数据被消费，生产者可以准备生产数据。</li>
</ul>
<pre><code class=" mermaid">graph TD
A(&quot;releaseBuffer()&quot;)
B(&quot;mSlots[slot].mBufferState.release()&quot;)
C(&quot;mFreeBuffers.push_back(slot)&quot;)
D(&quot;listener-&gt;onBufferReleased&quot;)

A---&gt;B
B---&gt;C
C---&gt;D

E(&quot;设置BufferSlot状态为FREE&quot;)
F(&quot;存入mFreeBuffers待使用&quot;)
G(&quot;通知 生产者 数据被消费，可以准备生产数据&quot;)

E---B
F---C
G---D
</code></pre>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/BufferSlot状态转变过程.jpg" srcset="/img/loading.gif" alt="BufferSlot状态转变过程"></p>
<h4 id="GraphicBuffer的创建"><a href="#GraphicBuffer的创建" class="headerlink" title="GraphicBuffer的创建"></a>GraphicBuffer的创建</h4><blockquote>
<p><code>GraphicBuffer</code>是基本单元，所有的交互都是基于它进行的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/BufferQueueProducer.cpp<br>status_t BufferQueueProducer::dequeueBuffer(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,<br>                                            uint32_t width, uint32_t height, PixelFormat format,<br>                                            uint64_t usage, uint64_t* outBufferAge,<br>                                            FrameEventHistoryDelta* outTimestamps) &#123;<br>  ...<br>        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="hljs-keyword">new</span> GraphicBuffer(<br>                width, height, format, BQ_LAYER_COUNT, usage,<br>                &#123;mConsumerName.<span class="hljs-built_in">string</span>(), mConsumerName.size()&#125;);<br>  ...<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要在<code>dequeueBuffer</code>进行的创建过程。在<code>生产者</code>的使用场景下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/ui/GraphicBuffer.cpp<br>GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight,<br>        PixelFormat inFormat, uint32_t inLayerCount, uint64_t usage, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> requestorName)<br>    : GraphicBuffer()<br>&#123;<br>    mInitCheck = initWithSize(inWidth, inHeight, inFormat, inLayerCount,<br>            usage, <span class="hljs-built_in">std</span>::move(requestorName));<br>&#125;<br><br>status_t GraphicBuffer::initWithSize(uint32_t inWidth, uint32_t inHeight,<br>        PixelFormat inFormat, uint32_t inLayerCount, uint64_t inUsage,<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> requestorName)<br>&#123;<br>  //GraphicBuffer的内存分配器<br>    GraphicBufferAllocator&amp; allocator = GraphicBufferAllocator::get();<br>    uint32_t outStride = 0;<br>  //为GraphicBuffer分配内存<br>    status_t err = allocator.allocate(inWidth, inHeight, inFormat, inLayerCount,<br>            inUsage, &amp;handle, &amp;outStride, mId,<br>            <span class="hljs-built_in">std</span>::move(requestorName));<br>    <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>        mBufferMapper.getTransportSize(handle, &amp;mTransportNumFds, &amp;mTransportNumInts);<br><br>        width = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(inWidth);<br>        height = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(inHeight);<br>        format = inFormat;<br>        layerCount = inLayerCount;<br>        usage = inUsage;<br>        usage_deprecated = <span class="hljs-keyword">int</span>(usage);<br>        stride = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(outStride);<br>    &#125;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>GraphicBuffer</code>创建过程主要执行了以下几步：</p>
<ul>
<li>获取<code>GraphicBufferAllocator</code>，这个是<code>GraphicBuffer</code>的内存分配器</li>
<li>再调用<code>allocate()</code>进行内存分配</li>
</ul>
<p>其中<code>GraphicBufferAllocator</code>的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/ui/GraphicBufferAllocator.cpp<br>GraphicBufferAllocator::GraphicBufferAllocator()<br>  : mMapper(GraphicBufferMapper::getInstance()),<br>    mAllocator(<span class="hljs-built_in">std</span>::make_unique&lt;Gralloc2::Allocator&gt;(<br>                mMapper.getGrallocMapper()))<br>&#123;<br>&#125;<br><br>status_t GraphicBufferAllocator::allocate(uint32_t width, uint32_t height,<br>        PixelFormat format, uint32_t layerCount, uint64_t usage,<br>        buffer_handle_t* handle, uint32_t* stride,<br>        uint64_t /*graphicBufferId*/, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> requestorName)<br>&#123;<br>    ATRACE_CALL();<br><br>    // make sure to <span class="hljs-keyword">not</span> allocate a N x 0 <span class="hljs-keyword">or</span> 0 x N buffer, since <span class="hljs-keyword">this</span> is<br>    // allowed from an API stand-point allocate a 1x1 buffer instead.<br>    <span class="hljs-keyword">if</span> (!width || !height)<br>        width = height = 1;<br><br>    // Ensure that layerCount is valid.<br>    <span class="hljs-keyword">if</span> (layerCount &lt; 1)<br>        layerCount = 1;<br><br>    Gralloc2::IMapper::BufferDescriptorInfo info = &#123;&#125;;<br>    info.width = width;<br>    info.height = height;<br>    info.layerCount = layerCount;<br>    info.format = <span class="hljs-keyword">static_cast</span>&lt;Gralloc2::PixelFormat&gt;(format);<br>    info.usage = usage;<br><br>    Gralloc2::Error error = mAllocator-&gt;allocate(info, stride, handle);<br>    <span class="hljs-keyword">if</span> (error == Gralloc2::Error::NONE) &#123;<br>        Mutex::Autolock _l(sLock);<br>        KeyedVector&lt;buffer_handle_t, alloc_rec_t&gt;&amp; <span class="hljs-built_in">list</span>(sAllocList);<br>        uint32_t bpp = bytesPerPixel(format);<br>        alloc_rec_t rec;<br>        rec.width = width;<br>        rec.height = height;<br>        rec.stride = *stride;<br>        rec.format = format;<br>        rec.layerCount = layerCount;<br>        rec.usage = usage;<br>        rec.size = <span class="hljs-keyword">static_cast</span>&lt;size_t&gt;(height * (*stride) * bpp);<br>        rec.requestorName = <span class="hljs-built_in">std</span>::move(requestorName);<br>        <span class="hljs-built_in">list</span>.add(*handle, rec);<br><br>        <span class="hljs-keyword">return</span> NO_ERROR;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ALOGE("Failed to allocate (%u x %u) layerCount %u format %d "<br>                "usage %" PRIx64 ": %d",<br>                width, height, layerCount, format, usage,<br>                error);<br>        <span class="hljs-keyword">return</span> NO_MEMORY;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>//TODO 对<code>GraphicBufferAllocator</code>进行分析</p>
<h3 id="图形缓冲区在图像生产者的使用"><a href="#图形缓冲区在图像生产者的使用" class="headerlink" title="图形缓冲区在图像生产者的使用"></a>图形缓冲区在<code>图像生产者</code>的使用</h3><blockquote>
<p>Android中的<code>图像生产者</code>如<code>Skia、OpenGL、Vulkan</code>。负责<strong>将绘制的数据放在图形缓冲区中</strong></p>
</blockquote>
<p>Android中的图像绘制分为以下两种，主要区别在于<strong>是否开启硬件加速</strong>。</p>
<p>未开启就是<code>软件绘制</code>，若开启就执行<code>硬件绘制</code>流程。</p>
<h4 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h4><p><code>软件绘制</code>的入口函数位于<code>ViewRootImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> drawSoftware(Surface surface, AttachInfo attachInfo, <span class="hljs-keyword">int</span> xoff, <span class="hljs-keyword">int</span> yoff,<br>            <span class="hljs-keyword">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets) &#123;<br>        <span class="hljs-keyword">final</span> Canvas canvas;<br>           //从surface获取Canvas<br>            canvas = mSurface.lockCanvas(dirty);<br>           //在canvas上进行绘制<br>            mView.draw(canvas);<br>           //将绘制内容提交给SF进行合成<br>            surface.unlockCanvasAndPost(canvas);      <br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>drawSoftware()</code>主要分为以下几步：</p>
<pre><code class=" mermaid">graph LR
classDef someclass fill:#f96;
A(&quot;drawSoftware()&lt;br&gt;软件绘制&quot;)
B(&quot;lockCanvas()&lt;br&gt;获取Canvas&quot;)
C(&quot;draw(canvas)&lt;br&gt;在Canvas进行绘制&quot;)
D(&quot;unlockCanvasAndPost()&lt;br&gt;提交绘制完成的GraphicBuffer&lt;br&gt;到SurfaceFlinger进行合成&quot;)
A--&gt;B:::someclass
A--&gt;C
A--&gt;D:::someclass
</code></pre>
<h5 id="lockCanvas"><a href="#lockCanvas" class="headerlink" title="lockCanvas"></a>lockCanvas</h5><blockquote>
<p>获取<code>Canvas</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">//Surface.java<br>    <span class="hljs-keyword">public</span> Canvas lockCanvas(Rect inOutDirty)<br>            <span class="hljs-keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException &#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            checkNotReleasedLocked();<br>            <span class="hljs-keyword">if</span> (mLockedObject != 0) &#123;<br>                throw new IllegalArgumentException("Surface was already locked");<br>            &#125;<br>            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);<br>            return mCanvas;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//base/core/jni/android_view_Surface.cpp<br><span class="hljs-keyword">static</span> jlong nativeLockCanvas(JNIEnv* env, jclass clazz,<br>        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) &#123;<br>    sp&lt;Surface&gt; surface(<span class="hljs-keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));<br>  ...<br>    Rect dirtyRect(Rect::EMPTY_RECT);<br>    Rect* dirtyRectPtr = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (dirtyRectObj) &#123;<br>        dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);<br>        dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);<br>        dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);<br>        dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);<br>        dirtyRectPtr = &amp;dirtyRect;<br>    &#125;<br><br>    ANativeWindow_Buffer outBuffer;<br>  //获取绘制图形的GraphicBuffer<br>    status_t err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);  <br>  ...<br>    SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,<br>                                         convertPixelFormat(outBuffer.format),<br>                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888<br>                                                 ? kOpaque_SkAlphaType : kPremul_SkAlphaType,<br>                                         GraphicsJNI::defaultColorSpace());<br><br>    SkBitmap bitmap;<br>    ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);<br>    bitmap.setInfo(info, bpr);<br>    <span class="hljs-keyword">if</span> (outBuffer.width &gt; 0 &amp;&amp; outBuffer.height &gt; 0) &#123;<br>        bitmap.setPixels(outBuffer.bits);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // be safe with an empty bitmap.<br>        bitmap.setPixels(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>   //新建Canvas对象<br>    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);<br>    nativeCanvas-&gt;setBitmap(bitmap);    <br>  <br>    sp&lt;Surface&gt; lockedSurface(surface);<br>    lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);<br>   //返回最后的Canvas对象<br>    <span class="hljs-keyword">return</span> (jlong) lockedSurface.get();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要通过<code>surface#lock</code>获取<code>GraphicBuffer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/Surface.cpp<br>status_t Surface::lock(<br>        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)<br>&#123;<br>  ...<br>    status_t err = dequeueBuffer(&amp;out, &amp;fenceFd);<br>  ...<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后通过<code>dequeueBuffer</code>获取<code>GraphicBuffer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/Surface.cpp<br><span class="hljs-keyword">int</span> Surface::dequeueBuffer(android_native_buffer_t** buffer, <span class="hljs-keyword">int</span>* fenceFd) &#123;<br>  ...<br>    //申请一块GraphicBuffer<br>    status_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight,<br>                                                            reqFormat, reqUsage, &amp;mBufferAge,<br>                                                            enableFrameTimestamps ? &amp;frameTimestamps<br>                                                                                  : <span class="hljs-literal">nullptr</span>);    <br>  ...<br>    <span class="hljs-keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mReportRemovedBuffers &amp;&amp; (gbuf != <span class="hljs-literal">nullptr</span>)) &#123;<br>            mRemovedBuffers.push_back(gbuf);<br>        &#125;<br>      //映射 GraphicBuffer<br>        result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);<br>        <span class="hljs-keyword">if</span> (result != NO_ERROR) &#123;<br>            ALOGE("dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d", result);<br>            mGraphicBufferProducer-&gt;cancelBuffer(buf, fence);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要执行了以下两步：</p>
<ol>
<li><code>dequeueBuffer</code>：申请<code>GraphicBuffer</code></li>
<li><code>requestBuffer</code>：使用<code>GraphicBuffer</code></li>
</ol>
<p>其中<code>requestBuffer</code>通过<strong>共享内存</strong>方式获取<code>GraphicBuffer</code>数据</p>
<pre><code class=" mermaid">graph TB

 E(&quot;nativeLockCanvas()&quot;)
 F(&quot;Surface-&gt;lock()&quot;)
 G(&quot;Surface::dequeueBuffer()&lt;br&gt;获取待绘制的GraphicBuffer&quot;)
 H(&quot;mGraphicProducer&lt;br&gt;.requestBuffer()&lt;br&gt;使用GraphicBuffer&quot;)
 E--&gt;F
 F--&gt;G
 G--&gt;J
 J--&gt;H
J(&quot;mGraphicProducer&lt;br&gt;.dequeueBuffer()&quot;)
</code></pre>
<h5 id="draw-Canvas"><a href="#draw-Canvas" class="headerlink" title="draw(Canvas)"></a>draw(Canvas)</h5><blockquote>
<p>在Canvas上绘制图形</p>
</blockquote>
<h5 id="unlockCanvasAndPost"><a href="#unlockCanvasAndPost" class="headerlink" title="unlockCanvasAndPost()"></a>unlockCanvasAndPost()</h5><blockquote>
<p>提交绘制完成的GraphicBuffer到SurfaceFlinger进行合成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">//Surface.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> unlockCanvasAndPost(Canvas canvas) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            checkNotReleasedLocked();<br><br>            <span class="hljs-keyword">if</span> (mHwuiContext != <span class="hljs-keyword">null</span>) &#123;<br>                mHwuiContext.unlockAndPost(canvas);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              //软件绘制提交<br>                unlockSwCanvasAndPost(canvas);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> unlockSwCanvasAndPost(Canvas canvas) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            nativeUnlockCanvasAndPost(mLockedObject, canvas);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            nativeRelease(mLockedObject);<br>            mLockedObject = 0;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//base/core/jni/android_view_Surface.cpp<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz,<br>        jlong nativeObject, jobject canvasObj) &#123;<br>    sp&lt;Surface&gt; surface(<span class="hljs-keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));<br>    <span class="hljs-keyword">if</span> (!isSurfaceValid(surface)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    // detach the canvas from the surface<br>    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);<br>    nativeCanvas-&gt;setBitmap(SkBitmap());<br><br>    // unlock surface<br>    status_t err = surface-&gt;unlockAndPost();<br>    <span class="hljs-keyword">if</span> (err &lt; 0) &#123;<br>        doThrowIAE(env);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>继续通过<code>Surface#unlockAndPost()</code>执行提交过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/gui/Surface.cpp<br>status_t Surface::unlockAndPost()<br>&#123;<br>    <span class="hljs-keyword">if</span> (mLockedBuffer == 0) &#123;<br>        ALOGE("Surface::unlockAndPost failed, no locked buffer");<br>        <span class="hljs-keyword">return</span> INVALID_OPERATION;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> fd = -1;<br>    status_t err = mLockedBuffer-&gt;unlockAsync(&amp;fd);<br><br>    err = queueBuffer(mLockedBuffer.get(), fd);<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-keyword">int</span> Surface::queueBuffer(android_native_buffer_t* buffer, <span class="hljs-keyword">int</span> fenceFd) &#123;<br>  ...<br>    //根据传入的GraphicBufer 获取对应的 BufferSlot位置<br>    <span class="hljs-keyword">int</span> i = getSlotFromBufferLocked(buffer);<br>  ...<br>    //把获取到的数据 放回到BufferQueue中<br>    status_t err = mGraphicerProducer-&gt;queueBuffer(i, input, &amp;output);    <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后通过<code>queueBuffer</code>提交<code>GraphicBuffer</code>。</p>
<pre><code class=" mermaid">graph TB
A(&quot;unlockCanvasAndPost()&quot;)
B(&quot;unlockSwCanvasAndPost()&quot;)
C(&quot;Surface::unlockAndPost&quot;)
A--&gt;B
B--&quot;nativeUnlockCanvasAndPost()&quot;--&gt;C
D(&quot;Surface::queueBuffer&quot;)
C--&gt;D
E(&quot;i = &lt;br&gt;getSlotFromBufferLocked()&quot;)
G(&quot;根据传入的Buffer获取对应mSlots中的index&quot;)
G---E
D---&gt;E
F(&quot;mGraphicProducer&lt;br&gt;.queueBuffer(i)&quot;)
H(&quot;通过queueBuffer放回数据&quot;)
E--&gt;F
H---F
</code></pre>
<h4 id="硬件绘制"><a href="#硬件绘制" class="headerlink" title="硬件绘制"></a>硬件绘制</h4><p>具体执行流程可以参考{% post_link Android-硬件加速%}</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//base/libs/hwui/renderthread/CanvasContext.cpp<br><span class="hljs-keyword">void</span> CanvasContext::draw() &#123;<br>  ...<br>    //获取GraphicBuffer<br>    Frame frame = mRenderPipeline-&gt;getFrame();<br>  ...<br>    //绘制图形到 GraphicBuffer上<br>    <span class="hljs-keyword">bool</span> drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,<br>                                      mContentDrawBounds, mOpaque, mWideColorGamut, mLightInfo,<br>                                      mRenderNodes, &amp;(profiler()));    <br>  ...<br>    //提交绘制完成的GraphicBuffer到 SurfaceFlinger进行合成<br>    <span class="hljs-keyword">bool</span> requireSwap = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">bool</span> didSwap =<br>            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="OpenGLPipeline-getFrame"><a href="#OpenGLPipeline-getFrame" class="headerlink" title="OpenGLPipeline#getFrame"></a>OpenGLPipeline#getFrame</h5><blockquote>
<p>从<code>BufferQueue</code>获取<code>GraphicBuffer</code>准备绘制图形</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//base/libs/hwui/renderthread/OpenGLPipeline.cpp<br>Frame OpenGLPipeline::getFrame() &#123;<br>    <span class="hljs-keyword">return</span> mEglManager.beginFrame(mEglSurface);<br>&#125;<br><br>//base/libs/hwui/renderthread/EglManager.cpp<br>Frame EglManager::beginFrame(EGLSurface surface) &#123;<br>    makeCurrent(surface);  <br>&#125;<br><br><span class="hljs-keyword">bool</span> EglManager::makeCurrent(EGLSurface surface, EGLint* errOut) &#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (!eglMakeCurrent(mEglDisplay, surface, surface, mEglContext)) &#123;<br>        <span class="hljs-keyword">if</span> (errOut) &#123;<br>            *errOut = eglGetError();<br>        &#125;<br>    &#125;<br>    mCurrentSurface = surface; <br>  ...<br>&#125;<br><br>//native/opengl/libagl/egl.cpp<br>EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,<br>                            EGLSurface read, EGLContext ctx)<br>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (ctx == EGL_NO_CONTEXT) &#123;<br>        // <span class="hljs-keyword">if</span> we're detaching, we need the current context<br>        current_ctx = (EGLContext)getGlThreadSpecific();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        egl_surface_t* d = (egl_surface_t*)draw;<br>        egl_surface_t* r = (egl_surface_t*)read;<br>    &#125;  <br>  ...<br>            <span class="hljs-keyword">if</span> (d) &#123;<br>              //创建GraphicBuffer<br>                <span class="hljs-keyword">if</span> (d-&gt;connect() == EGL_FALSE) &#123;<br>                    <span class="hljs-keyword">return</span> EGL_FALSE;<br>                &#125;<br>                d-&gt;ctx = ctx;<br>                d-&gt;bindDrawSurface(gl);<br>            &#125;<br>  ...<br>&#125;<br><br>EGLBoolean egl_window_surface_v2_t::connect() <br>&#123;<br>      // dequeue a buffer<br>    <span class="hljs-keyword">int</span> fenceFd = -1;<br>   //Surface是 ANativeWindow 的子类，实际调用的就是Surface#dequeueBuffer<br>    <span class="hljs-keyword">if</span> (nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer,<br>            &amp;fenceFd) != NO_ERROR) &#123;<br>        <span class="hljs-keyword">return</span> setError(EGL_BAD_ALLOC, EGL_FALSE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>OpenGLPipeline#getFrame()</code>最后通过<code>Surface#dequeueBuffer()</code>获取<code>GraphicBuffer</code></p>
<h5 id="OpenGLPipeline-draw"><a href="#OpenGLPipeline-draw" class="headerlink" title="OpenGLPipeline#draw"></a>OpenGLPipeline#draw</h5><blockquote>
<p>将图像绘制到获取的<code>GraphicBuffer</code>上</p>
</blockquote>
<h5 id="OpenGLPipeline-swapBuffers"><a href="#OpenGLPipeline-swapBuffers" class="headerlink" title="OpenGLPipeline#swapBuffers"></a>OpenGLPipeline#swapBuffers</h5><blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//base/libs/hwui/renderthread/OpenGLPipeline.cpp<br><span class="hljs-keyword">bool</span> OpenGLPipeline::swapBuffers(<span class="hljs-keyword">const</span> Frame&amp; frame, <span class="hljs-keyword">bool</span> drew, <span class="hljs-keyword">const</span> SkRect&amp; screenDirty,<br>                                 FrameInfo* currentFrameInfo, <span class="hljs-keyword">bool</span>* requireSwap) &#123;<br><br>  ...<br>    <span class="hljs-keyword">if</span> (*requireSwap &amp;&amp; (CC_UNLIKELY(!mEglManager.swapBuffers(frame, screenDirty)))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> *requireSwap;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在向下执行到<code>EglManager#swapBuffers()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//base/libs/hwui/renderthread/EglManager.cpp<br><span class="hljs-keyword">bool</span> EglManager::swapBuffers(<span class="hljs-keyword">const</span> Frame&amp; frame, <span class="hljs-keyword">const</span> SkRect&amp; screenDirty) &#123;<br>    <span class="hljs-keyword">if</span> (CC_UNLIKELY(Properties::waitForGpuCompletion)) &#123;<br>        ATRACE_NAME("Finishing GPU work");<br>        fence();<br>    &#125;<br><br>    EGLint rects[4];<br>    frame.<span class="hljs-built_in">map</span>(screenDirty, rects);<br>    eglSwapBuffersWithDamageKHR(mEglDisplay, frame.mSurface, rects, screenDirty.isEmpty() ? 0 : 1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>//native/opengl/libs/EGL/eglApi.cpp<br>EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface draw,<br>        EGLint *rects, EGLint n_rects)<br>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (n_rects == 0) &#123;<br>        <span class="hljs-keyword">return</span> s-&gt;cnx-&gt;egl.eglSwapBuffers(dp-&gt;disp.dpy, s-&gt;surface);<br>    &#125;<br>  ...<br>    <span class="hljs-keyword">if</span> (s-&gt;cnx-&gt;egl.eglSwapBuffersWithDamageKHR) &#123;<br>      //调用自身<br>        <span class="hljs-keyword">return</span> s-&gt;cnx-&gt;egl.eglSwapBuffersWithDamageKHR(dp-&gt;disp.dpy, s-&gt;surface,<br>                rects, n_rects);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> s-&gt;cnx-&gt;egl.eglSwapBuffers(dp-&gt;disp.dpy, s-&gt;surface);<br>    &#125;  <br> <br>&#125;<br><br>//native/opengl/libagl/egl.cpp<br>EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface draw)<br>&#123;<br>    // post the surface<br>    d-&gt;swapBuffers();<br>   ...<br>    <span class="hljs-keyword">return</span> EGL_TRUE;<br>&#125;<br><br>EGLBoolean egl_window_surface_v2_t::swapBuffers()<br>&#123;<br>  ...<br>    unlock(buffer);<br>    previousBuffer = buffer;<br>  //提交GraphicBuffer<br>    nativeWindow-&gt;queueBuffer(nativeWindow, buffer, -1);<br>    buffer = 0;<br>  ...<br>    //重新申请 GraphicBuffer<br>    <span class="hljs-keyword">if</span> (nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer, &amp;fenceFd) == NO_ERROR) &#123;<br>        sp&lt;Fence&gt; fence(<span class="hljs-keyword">new</span> Fence(fenceFd));<br>      ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>swapBuffers()</code>主要执行以下两步：</p>
<ul>
<li><code>Surface#queueBuffer</code>：提交<code>GraphicBuffer</code>到<code>BufferQueue</code>中</li>
<li><code>Surface#dequeueBuffer</code>：从<code>BufferQueue</code>中获取空闲的<code>BufferQueue</code>并获取其中的<code>GraphicBuffer</code>进行图像绘制</li>
</ul>
<p>//TODO 流程图</p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>图像缓冲区的使用场景主要有两种：<code>软件绘制</code>和<code>硬件绘制</code>。</p>
<p>主要执行以下几步：</p>
<ol>
<li><code>dequeueBuffer</code>获取<code>GraphicBuffer</code></li>
<li>进行<code>GraphicBuffer</code>内存绑定操作<ul>
<li>软件绘制：<code>GBQ#requestBuffer</code></li>
<li>硬件绘制：<code>egl#lock</code></li>
</ul>
</li>
<li>在<code>GraphicBuffer</code>进行图像绘制</li>
<li><code>queueBuffer</code>提交<code>GraphicBuffer</code>到<code>BufferQueue</code>中</li>
</ol>
<h3 id="图形缓冲区在图像消费者的使用"><a href="#图形缓冲区在图像消费者的使用" class="headerlink" title="图形缓冲区在图像消费者的使用"></a>图形缓冲区在<code>图像消费者</code>的使用</h3><blockquote>
<p><code>图像消费者</code>主要就是<code>SurfaceFlinger</code></p>
</blockquote>
<p>主要执行流程参考<a href="#Vsync信号相关">Vsync信号相关</a></p>
<p>收到<code>Vsync信号</code>会回调到<code>SurfaceFlinger</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/services/surfaceflinger/SurfaceFlinger.cpp<br><span class="hljs-keyword">void</span> SurfaceFlinger::onMessageReceived(int32_t what) &#123;<br>    <span class="hljs-keyword">switch</span> (what) &#123;<br>        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;<br>          //判断是否有丢帧<br>            <span class="hljs-keyword">bool</span> frameMissed = !mHadClientComposition &amp;&amp;<br>                    mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;<br>                    (mPreviousPresentFence-&gt;getSignalTime() ==<br>                            Fence::SIGNAL_TIME_PENDING);<br>            <span class="hljs-keyword">if</span> (frameMissed) &#123;<br>                mTimeStats.incrementMissedFrames();<br>                <span class="hljs-keyword">if</span> (mPropagateBackpressure) &#123;<br>                  //需要执行 申请Vsync信号过程<br>                    signalLayerUpdate();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>          //需要重新刷新<br>            <span class="hljs-keyword">bool</span> refreshNeeded = handleMessageTransaction();<br>            refreshNeeded |= handleMessageInvalidate();<br>            refreshNeeded |= mRepaintEverything;<br>            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;<br>              //执行刷新过程<br>                signalRefresh();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;<br>            handleMessageRefresh();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>handleMessageRefresh</code>流程在上面的<a href="#处理Vsync">处理Vsync</a>已经介绍过，包括<code>signalLayerUpdate()</code>以及<code>signalRefresh()</code>都有相关的介绍。</p>
<p>在<code>SurfaceFlinger</code>与<code>BufferQueue</code>相关的操作都位于<code>handleMessageInvalidate()</code>中</p>
<h4 id="SF-handleMessageInvalidate"><a href="#SF-handleMessageInvalidate" class="headerlink" title="SF#handleMessageInvalidate"></a>SF#handleMessageInvalidate</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> SurfaceFlinger::handleMessageInvalidate() &#123;<br>    <span class="hljs-keyword">return</span> handlePageFlip();<br>&#125;<br><br><span class="hljs-keyword">bool</span> SurfaceFlinger::handlePageFlip()<br>&#123;<br>  ...<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;<br>        <span class="hljs-keyword">const</span> Region dirty(layer-&gt;latchBuffer(visibleRegions, latchTime));<br>        layer-&gt;useSurfaceDamage();<br>        invalidateLayerStack(layer, dirty);<br>        <span class="hljs-keyword">if</span> (layer-&gt;isBufferLatched()) &#123;<br>            newDataLatched = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>layer</code>的实现为<code>BufferLayer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/services/surfaceflinger/BufferLayer.cpp<br>Region BufferLayer::latchBuffer(<span class="hljs-keyword">bool</span>&amp; recomputeVisibleRegions, nsecs_t latchTime) &#123;<br>  ...<br>    <span class="hljs-keyword">bool</span> queuedBuffer = <span class="hljs-literal">false</span>;<br>    status_t updateResult =<br>            mConsumer-&gt;updateTexImage(&amp;r, mFlinger-&gt;mPrimaryDispSync,<br>                                                    &amp;mAutoRefresh, &amp;queuedBuffer,<br>                                                    mLastFrameNumberReceived);  <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>mConsumer</code>指的对象为<code>BufferLayerConsumer</code></p>
<h5 id="BufferLayerConsumer-updateTexImage"><a href="#BufferLayerConsumer-updateTexImage" class="headerlink" title="BufferLayerConsumer#updateTexImage"></a>BufferLayerConsumer#updateTexImage</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/services/surfaceflinger/BufferLayerConsumer.cpp<br>status_t BufferLayerConsumer::updateTexImage(BufferRejecter* rejecter, <span class="hljs-keyword">const</span> DispSync&amp; dispSync,<br>                                             <span class="hljs-keyword">bool</span>* autoRefresh, <span class="hljs-keyword">bool</span>* queuedBuffer,<br>                                             uint64_t maxFrameNumber) &#123;<br>  ...<br>    BufferItem item;<br><br>    // Acquire the next buffer.<br>    // In asynchronous mode the <span class="hljs-built_in">list</span> is guaranteed to be one buffer<br>    // deep, <span class="hljs-keyword">while</span> in synchronous mode we use the oldest buffer.<br>    // 从BufferQueue获取已绘制完成的 GraphicBuffer<br>    status_t err = acquireBufferLocked(&amp;item, computeExpectedPresent(dispSync), maxFrameNumber);<br>  <br>    // Release the previous buffer.<br>    //释放已经使用完成的 GraphicBuffer并返回到BufferQueue<br>    err = updateAndReleaseLocked(item, &amp;mPendingRelease);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>updateTexImage</code>主要执行以下两步：</p>
<h6 id="acquireBufferLocked"><a href="#acquireBufferLocked" class="headerlink" title="acquireBufferLocked"></a>acquireBufferLocked</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">status_t BufferLayerConsumer::acquireBufferLocked(BufferItem* item, nsecs_t presentWhen,<br>                                                  uint64_t maxFrameNumber) &#123;<br>    status_t err = ConsumerBase::acquireBufferLocked(item, presentWhen, maxFrameNumber);<br>    <span class="hljs-keyword">return</span> NO_ERROR;<br>&#125;<br><br>//native/libs/gui/ConsumerBase.cpp<br>status_t ConsumerBase::acquireBufferLocked(BufferItem *item,<br>        nsecs_t presentWhen, uint64_t maxFrameNumber) &#123;<br>   <br>    status_t err = mConsumer-&gt;acquireBuffer(item, presentWhen, maxFrameNumber);<br><br>    <span class="hljs-keyword">if</span> (item-&gt;mGraphicBuffer != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mSlots[item-&gt;mSlot].mGraphicBuffer != <span class="hljs-literal">NULL</span>) &#123;<br>            freeBufferLocked(item-&gt;mSlot);<br>        &#125;<br>        mSlots[item-&gt;mSlot].mGraphicBuffer = item-&gt;mGraphicBuffer;<br>    &#125;<br><br>    mSlots[item-&gt;mSlot].mFrameNumber = item-&gt;mFrameNumber;<br>    mSlots[item-&gt;mSlot].mFence = item-&gt;mFence;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后是通过<code>acquireBuffer</code>从<code>BufferQueue</code>获取<code>已绘制完成的GraphicBuffer</code></p>
<h6 id="updateAndReleaseLocked"><a href="#updateAndReleaseLocked" class="headerlink" title="updateAndReleaseLocked"></a>updateAndReleaseLocked</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">status_t BufferLayerConsumer::updateAndReleaseLocked(<span class="hljs-keyword">const</span> BufferItem&amp; item,<br>                                                     PendingRelease* pendingRelease) &#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) &#123;<br>        <span class="hljs-keyword">if</span> (pendingRelease == <span class="hljs-literal">nullptr</span>) &#123;<br>            status_t status =<br>                    releaseBufferLocked(mCurrentTexture, mCurrentTextureImage-&gt;graphicBuffer());<br>        &#125;<br>    &#125;<br>  ...<br>&#125;<br><br>//native/libs/gui/ConsumerBase.cpp<br>status_t ConsumerBase::releaseBufferLocked(<br>        <span class="hljs-keyword">int</span> slot, <span class="hljs-keyword">const</span> sp&lt;GraphicBuffer&gt; graphicBuffer,<br>        EGLDisplay display, EGLSyncKHR eglFence) &#123;<br>  ...<br>    status_t err = mConsumer-&gt;releaseBuffer(slot, mSlots[slot].mFrameNumber,<br>            display, eglFence, mSlots[slot].mFence);<br>    <span class="hljs-keyword">if</span> (err == IGraphicBufferConsumer::STALE_BUFFER_SLOT) &#123;<br>      //重置BufferSlot数据<br>        freeBufferLocked(slot);<br>    &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后是通过<code>releaseBuffer()</code>把<code>使用完成的GraphicBuffer</code>返回到<code>BufferQueue</code>中</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">SurfaceFlinger 解读</a></p>
<p><a href="https://blog.csdn.net/tyuiof/article/details/108434845" target="_blank" rel="noopener">掌握Android图像显示原理-上</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/16/Ubuntu18-04-双系统安装笔记/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Ubuntu18.04 双系统安装笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/14/Android性能优化-自动内存分析/">
                        <span class="hidden-mobile">Android性能优化-自动内存分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
