

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <title>Android-SurfaceFlinger解析 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/dracula.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.5","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android-SurfaceFlinger解析">
              
                Android-SurfaceFlinger解析
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-21 15:06" pubdate>
        2020年12月21日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      151
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android-SurfaceFlinger解析</h1>
            
            <div class="markdown-body">
              <blockquote>
<p> 基于<code>Android 6.0</code>源码进行分析</p>
</blockquote>
<p><code>SurfaceFlinger</code>是Android系统中最重要的<strong>图像消费者</strong>，Activity绘制的界面图像，都会传递到<code>SurfaceFlinger</code>中。</p>
<p>主要作用：<strong>接收图像缓冲区数据，然后交给HWComposer或OpenGL合成，合成完毕后再返回。</strong></p>
<p><img src="/images/SurfaceFlinger执行流程.jpg" srcset="/img/loading.gif" alt="SurfaceFlinger执行流程"></p>
<h2 id="SurfaceFlinger初始化"><a href="#SurfaceFlinger初始化" class="headerlink" title="SurfaceFlinger初始化"></a>SurfaceFlinger初始化</h2><p><code>init</code>通过执行<code>surfaceflinger.rc</code>文件，然后就执行到了<code>main_surfaceflinger.cpp</code>开始初始化流程</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>**)</span> </span>&#123;
    signal(SIGPIPE, SIG_IGN);

    hardware::configureRpcThreadpool(<span class="hljs-number">1</span> <span class="hljs-comment">/* maxThreads */</span>,
            <span class="hljs-literal">false</span> <span class="hljs-comment">/* callerWillJoin */</span>);

    startGraphicsAllocatorService();

   <span class="hljs-comment">//设置支持最多 4个 binder线程执行</span>
    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="hljs-number">4</span>);

    <span class="hljs-comment">// start the thread pool</span>
    <span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ps</span><span class="hljs-params">(ProcessState::self())</span></span>;
    ps-&gt;startThreadPool();

    <span class="hljs-comment">//构建 Surfaceflinger实例</span>
    sp&lt;SurfaceFlinger&gt; flinger = <span class="hljs-keyword">new</span> SurfaceFlinger();

    <span class="hljs-comment">// 执行初始化流程</span>
    flinger-&gt;init();

    <span class="hljs-comment">// 通过ServiceManager注册 SurfaceFlinger服务</span>
    <span class="hljs-function">sp&lt;IServiceManager&gt; <span class="hljs-title">sm</span><span class="hljs-params">(defaultServiceManager())</span></span>;
    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="hljs-literal">false</span>,
                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);

    startDisplayService(); <span class="hljs-comment">// dependency on SF getting registered above</span>

    <span class="hljs-comment">// 开始运行</span>
    flinger-&gt;run();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>
<h3 id="new-SurfaceFlinger"><a href="#new-SurfaceFlinger" class="headerlink" title="new SurfaceFlinger"></a>new SurfaceFlinger</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onFirstRef</span><span class="hljs-params">()</span>
</span>&#123;
    mEventQueue-&gt;init(<span class="hljs-keyword">this</span>);
&#125;</code></pre></div>
<p><code>mEventQueue</code>执行初始化</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::init</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span> </span>&#123;
    mFlinger = flinger;
    mLooper = <span class="hljs-keyword">new</span> Looper(<span class="hljs-literal">true</span>);
    mHandler = <span class="hljs-keyword">new</span> Handler(*<span class="hljs-keyword">this</span>);
&#125;</code></pre></div>
<p>初始化<code>Handler</code></p>
<h3 id="SurfaceFlinger-init"><a href="#SurfaceFlinger-init" class="headerlink" title="SurfaceFlinger#init"></a>SurfaceFlinger#init</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;
    ALOGI(  <span class="hljs-string">"SurfaceFlinger's main thread ready to run. "</span>
            <span class="hljs-string">"Initializing graphics H/W..."</span>);

    ALOGI(<span class="hljs-string">"Phase offest NS: %"</span> PRId64 <span class="hljs-string">""</span>, vsyncPhaseOffsetNs);

    Mutex::Autolock _l(mStateLock);

    <span class="hljs-comment">// start the EventThread</span>
    mEventThreadSource =
            <span class="hljs-built_in">std</span>::make_unique&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs,
                                             <span class="hljs-literal">true</span>, <span class="hljs-string">"app"</span>);
    mEventThread = <span class="hljs-built_in">std</span>::make_unique&lt;impl::EventThread&gt;(mEventThreadSource.get(),
                                                       [<span class="hljs-keyword">this</span>]() &#123; resyncWithRateLimit(); &#125;,
                                                       impl::EventThread::InterceptVSyncsCallback(),
                                                       <span class="hljs-string">"appEventThread"</span>);
    mSfEventThreadSource =
            <span class="hljs-built_in">std</span>::make_unique&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync,
                                             SurfaceFlinger::sfVsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">"sf"</span>);

    mSFEventThread =
            <span class="hljs-built_in">std</span>::make_unique&lt;impl::EventThread&gt;(mSfEventThreadSource.get(),
                                                [<span class="hljs-keyword">this</span>]() &#123; resyncWithRateLimit(); &#125;,
                                                [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">nsecs_t</span> timestamp) &#123;
                                                    mInterceptor-&gt;saveVSyncEvent(timestamp);
                                                &#125;,
                                                <span class="hljs-string">"sfEventThread"</span>);
    mEventQueue-&gt;setEventThread(mSFEventThread.get());
    mVsyncModulator.setEventThread(mSFEventThread.get());

    <span class="hljs-comment">// Get a RenderEngine for the given display / config (can't fail)</span>
    getBE().mRenderEngine =
            RE::impl::RenderEngine::create(HAL_PIXEL_FORMAT_RGBA_8888,
                                           hasWideColorDisplay
                                                   ? RE::RenderEngine::WIDE_COLOR_SUPPORT
                                                   : <span class="hljs-number">0</span>);
    LOG_ALWAYS_FATAL_IF(getBE().mRenderEngine == <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"couldn't create RenderEngine"</span>);

    LOG_ALWAYS_FATAL_IF(mVrFlingerRequestsDisplay,
            <span class="hljs-string">"Starting with vr flinger active is not currently supported."</span>);
    getBE().mHwc.reset(
            <span class="hljs-keyword">new</span> HWComposer(<span class="hljs-built_in">std</span>::make_unique&lt;Hwc2::impl::Composer&gt;(getBE().mHwcServiceName)));
    getBE().mHwc-&gt;registerCallback(<span class="hljs-keyword">this</span>, getBE().mComposerSequenceId);
    <span class="hljs-comment">// Process any initial hotplug and resulting display changes.</span>
    processDisplayHotplugEventsLocked();
    LOG_ALWAYS_FATAL_IF(!getBE().mHwc-&gt;isConnected(HWC_DISPLAY_PRIMARY),
            <span class="hljs-string">"Registered composer callback but didn't create the default primary display"</span>);

    <span class="hljs-comment">// make the default display GLContext current so that we can create textures</span>
    <span class="hljs-comment">// when creating Layers (which may happens before we render something)</span>
    getDefaultDisplayDeviceLocked()-&gt;makeCurrent();

    <span class="hljs-keyword">if</span> (useVrFlinger) &#123;
        <span class="hljs-keyword">auto</span> vrFlingerRequestDisplayCallback = [<span class="hljs-keyword">this</span>] (<span class="hljs-keyword">bool</span> requestDisplay) &#123;
            <span class="hljs-comment">// This callback is called from the vr flinger dispatch thread. We</span>
            <span class="hljs-comment">// need to call signalTransaction(), which requires holding</span>
            <span class="hljs-comment">// mStateLock when we're not on the main thread. Acquiring</span>
            <span class="hljs-comment">// mStateLock from the vr flinger dispatch thread might trigger a</span>
            <span class="hljs-comment">// deadlock in surface flinger (see b/66916578), so post a message</span>
            <span class="hljs-comment">// to be handled on the main thread instead.</span>
            sp&lt;LambdaMessage&gt; message = <span class="hljs-keyword">new</span> LambdaMessage([=]() &#123;
                ALOGI(<span class="hljs-string">"VR request display mode: requestDisplay=%d"</span>, requestDisplay);
                mVrFlingerRequestsDisplay = requestDisplay;
                signalTransaction();
            &#125;);
            postMessageAsync(message);
        &#125;;
        mVrFlinger = dvr::VrFlinger::Create(getBE().mHwc-&gt;getComposer(),
                getBE().mHwc-&gt;getHwcDisplayId(HWC_DISPLAY_PRIMARY).value_or(<span class="hljs-number">0</span>),
                vrFlingerRequestDisplayCallback);
        <span class="hljs-keyword">if</span> (!mVrFlinger) &#123;
            ALOGE(<span class="hljs-string">"Failed to start vrflinger"</span>);
        &#125;
    &#125;

    mEventControlThread = <span class="hljs-built_in">std</span>::make_unique&lt;impl::EventControlThread&gt;(
            [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">bool</span> enabled) &#123; setVsyncEnabled(HWC_DISPLAY_PRIMARY, enabled); &#125;);

    <span class="hljs-comment">// initialize our drawing state</span>
    mDrawingState = mCurrentState;

    <span class="hljs-comment">// set initial conditions (e.g. unblank default device)</span>
    initializeDisplays();

    getBE().mRenderEngine-&gt;primeCache();

    <span class="hljs-comment">// Inform native graphics APIs whether the present timestamp is supported:</span>
    <span class="hljs-keyword">if</span> (getHwComposer().hasCapability(
            HWC2::Capability::PresentFenceIsNotReliable)) &#123;
        mStartPropertySetThread = <span class="hljs-keyword">new</span> StartPropertySetThread(<span class="hljs-literal">false</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        mStartPropertySetThread = <span class="hljs-keyword">new</span> StartPropertySetThread(<span class="hljs-literal">true</span>);
    &#125;

    <span class="hljs-keyword">if</span> (mStartPropertySetThread-&gt;Start() != NO_ERROR) &#123;
        ALOGE(<span class="hljs-string">"Run StartPropertySetThread failed!"</span>);
    &#125;

    mLegacySrgbSaturationMatrix = getBE().mHwc-&gt;getDataspaceSaturationMatrix(HWC_DISPLAY_PRIMARY,
            Dataspace::SRGB_LINEAR);

    ALOGV(<span class="hljs-string">"Done initializing"</span>);
&#125;</code></pre></div>
<h4 id="创建HWComposer"><a href="#创建HWComposer" class="headerlink" title="创建HWComposer"></a>创建HWComposer</h4><blockquote>
<p><code>HWComposer</code>代表着硬件显示设备。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span>
HWComposer::HWComposer(
        <span class="hljs-keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,
        EventHandler&amp; handler)
    : mFlinger(flinger),
      mFbDev(<span class="hljs-number">0</span>), mHwc(<span class="hljs-number">0</span>), mNumDisplays(<span class="hljs-number">1</span>),
      mCBContext(<span class="hljs-keyword">new</span> cb_context),
      mEventHandler(handler),
      mDebugForceFakeVSync(<span class="hljs-literal">false</span>)
&#123;
    ...     
    <span class="hljs-keyword">bool</span> needVSyncThread = <span class="hljs-literal">true</span>;

    <span class="hljs-comment">// Note: some devices may insist that the FB HAL be opened before HWC.</span>
    <span class="hljs-keyword">int</span> fberr = loadFbHalModule();
    loadHwcModule();<span class="hljs-comment">//加载HWComposer模块</span>

    <span class="hljs-comment">// these display IDs are always reserved</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;
        mAllocatedDisplayIDs.markBit(i);
    &#125;

    <span class="hljs-keyword">if</span> (mHwc) &#123;
        ALOGI(<span class="hljs-string">"Using %s version %u.%u"</span>, HWC_HARDWARE_COMPOSER,
              (hwcApiVersion(mHwc) &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>,
              (hwcApiVersion(mHwc) &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>);
        <span class="hljs-keyword">if</span> (mHwc-&gt;registerProcs) &#123;
            mCBContext-&gt;hwc = <span class="hljs-keyword">this</span>;
            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;
          <span class="hljs-comment">//vsync信号回调方法</span>
            mCBContext-&gt;procs.vsync = &amp;hook_vsync;
            <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))
                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;
            <span class="hljs-keyword">else</span>
                mCBContext-&gt;procs.hotplug = <span class="hljs-literal">NULL</span>;
            <span class="hljs-built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mCBContext-&gt;procs.zero));
          <span class="hljs-comment">//注册回调函数</span>
            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);
        &#125;

        <span class="hljs-comment">// don't need a vsync thread if we have a hardware composer</span>
        needVSyncThread = <span class="hljs-literal">false</span>;
        <span class="hljs-comment">// always turn vsync off when we start</span>
        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="hljs-number">0</span>);

        <span class="hljs-comment">// the number of displays we actually have depends on the</span>
        <span class="hljs-comment">// hw composer version</span>
        <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) &#123;
            <span class="hljs-comment">// 1.3 adds support for virtual displays</span>
            mNumDisplays = MAX_HWC_DISPLAYS;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;
            <span class="hljs-comment">// 1.1 adds support for multiple displays</span>
            mNumDisplays = NUM_BUILTIN_DISPLAYS;
        &#125; <span class="hljs-keyword">else</span> &#123;
            mNumDisplays = <span class="hljs-number">1</span>;
        &#125;
    &#125;


    <span class="hljs-keyword">if</span> (needVSyncThread) &#123;
        <span class="hljs-comment">// 不支持硬件Vsync的设备，则使用`VsyncThread`模拟发出Vsync信号</span>
        mVSyncThread = <span class="hljs-keyword">new</span> VSyncThread(*<span class="hljs-keyword">this</span>);
    &#125;
&#125;</code></pre></div>
<p><code>Vsync信号</code>本身由显示驱动发出，如果不支持硬件<code>Vsync</code>，则使用<code>VsyncThread</code>模拟发出信号。</p>
<h4 id="初始化显示设备"><a href="#初始化显示设备" class="headerlink" title="初始化显示设备"></a>初始化显示设备</h4><h4 id="运行EventThread线程"><a href="#运行EventThread线程" class="headerlink" title="运行EventThread线程"></a>运行EventThread线程</h4><blockquote>
<p><code>EventThread</code>主要用来接收<code>Vsync信号</code>。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;
  ...
        <span class="hljs-comment">// start the EventThread</span>
    sp&lt;VSyncSource&gt; vsyncSrc = <span class="hljs-keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,
            vsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">"app"</span>);
  <span class="hljs-comment">//创建App的Vsync信号接收线程</span>
    mEventThread = <span class="hljs-keyword">new</span> EventThread(vsyncSrc);
    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="hljs-keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,
            sfVsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">"sf"</span>);
   <span class="hljs-comment">//创建Sf的Vsync信号接收线程</span>
    mSFEventThread = <span class="hljs-keyword">new</span> EventThread(sfVsyncSrc);
    mEventQueue.setEventThread(mSFEventThread);
...
&#125;</code></pre></div>
<h5 id="DispSyncSource"><a href="#DispSyncSource" class="headerlink" title="DispSyncSource"></a>DispSyncSource</h5><div class="hljs"><pre><code class="hljs cpp">DispSyncSource(DispSync* dispSync, <span class="hljs-keyword">nsecs_t</span> phaseOffset, <span class="hljs-keyword">bool</span> traceVsync,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* label) :
        mValue(<span class="hljs-number">0</span>),
        mTraceVsync(traceVsync),
        mVsyncOnLabel(String8::format(<span class="hljs-string">"VsyncOn-%s"</span>, label)),
        mVsyncEventLabel(String8::format(<span class="hljs-string">"VSYNC-%s"</span>, label)),
        mDispSync(dispSync),
        mCallbackMutex(),
        mCallback(),
        mVsyncMutex(),
        mPhaseOffset(phaseOffset),
        mEnabled(<span class="hljs-literal">false</span>) &#123;&#125;</code></pre></div>
<h5 id="EventThread"><a href="#EventThread" class="headerlink" title="EventThread"></a>EventThread</h5><div class="hljs"><pre><code class="hljs cpp">EventThread::EventThread(<span class="hljs-keyword">const</span> sp&lt;VSyncSource&gt;&amp; src)
    : mVSyncSource(src),
      mUseSoftwareVSync(<span class="hljs-literal">false</span>),
      mVsyncEnabled(<span class="hljs-literal">false</span>),
      mDebugVsyncEnabled(<span class="hljs-literal">false</span>),
      mVsyncHintSent(<span class="hljs-literal">false</span>) &#123;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i=<span class="hljs-number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;
        mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;
        mVSyncEvent[i].header.id = <span class="hljs-number">0</span>;
        mVSyncEvent[i].header.timestamp = <span class="hljs-number">0</span>;
        mVSyncEvent[i].vsync.count =  <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigevent</span> <span class="hljs-title">se</span>;</span>
    se.sigev_notify = SIGEV_THREAD;
    se.sigev_value.sival_ptr = <span class="hljs-keyword">this</span>;
    se.sigev_notify_function = vsyncOffCallback;
    se.sigev_notify_attributes = <span class="hljs-literal">NULL</span>;
    timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThread::onFirstRef</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-comment">//运行EventThread线程</span>
    run(<span class="hljs-string">"EventThread"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);
&#125;

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EventThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;
    DisplayEventReceiver::Event event;
    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;
  <span class="hljs-comment">//等待事件发生</span>
    signalConnections = waitForEvent(&amp;event);

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = signalConnections.size();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;
        <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; <span class="hljs-title">conn</span><span class="hljs-params">(signalConnections[i])</span></span>;
        <span class="hljs-comment">// 分发事件给所有的监听者</span>
        <span class="hljs-keyword">status_t</span> err = conn-&gt;postEvent(event);
        <span class="hljs-keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;
          
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;
            removeDisplayEventConnection(signalConnections[i]);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; <span class="hljs-title">EventThread::waitForEvent</span><span class="hljs-params">(
        DisplayEventReceiver::Event* event)</span>
</span>&#123;
    Mutex::Autolock _l(mLock);
    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;

    <span class="hljs-keyword">do</span> &#123;
        <span class="hljs-comment">// Here we figure out if we need to enable or disable vsyncs</span>
        <span class="hljs-keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;
            disableVSyncLocked();
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;
            enableVSyncLocked();
        &#125;

        <span class="hljs-comment">// note: !timestamp implies signalConnections.isEmpty(), because we</span>
        <span class="hljs-comment">// don't populate signalConnections if there's no vsync pending</span>
        <span class="hljs-keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;
            <span class="hljs-comment">// wait for something to happen</span>
            <span class="hljs-keyword">if</span> (waitForVSync) &#123;
                <span class="hljs-keyword">bool</span> softwareSync = mUseSoftwareVSync;
                <span class="hljs-keyword">nsecs_t</span> timeout = softwareSync ? ms2ns(<span class="hljs-number">16</span>) : ms2ns(<span class="hljs-number">1000</span>);
                <span class="hljs-keyword">if</span> (mCondition.waitRelative(mLock, timeout) == TIMED_OUT) &#123;
                    <span class="hljs-keyword">if</span> (!softwareSync) &#123;
                        ALOGW(<span class="hljs-string">"Timed out waiting for hw vsync; faking it"</span>);
                    &#125;
                    mVSyncEvent[<span class="hljs-number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;
                    mVSyncEvent[<span class="hljs-number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;
                    mVSyncEvent[<span class="hljs-number">0</span>].header.timestamp = systemTime(SYSTEM_TIME_MONOTONIC);
                    mVSyncEvent[<span class="hljs-number">0</span>].vsync.count++;
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                mCondition.wait(mLock);
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">while</span> (signalConnections.isEmpty());

    <span class="hljs-keyword">return</span> signalConnections;
&#125;</code></pre></div>
<p>创建<code>EventThread</code>线程完毕后，执行<code>threadLoop</code>，通过<code>waitForEvent()</code>等待事件通知。</p>
<p>等待通过<code>mCondition.wait()</code>实现</p>
<h5 id="MessaqeQueue-setEventThread"><a href="#MessaqeQueue-setEventThread" class="headerlink" title="MessaqeQueue#setEventThread"></a>MessaqeQueue#setEventThread</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::setEventThread</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span>
</span>&#123;
    mEventThread = eventThread;
    mEvents = eventThread-&gt;createEventConnection();
    mEventTube = mEvents-&gt;getDataChannel();
    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="hljs-number">0</span>, Looper::EVENT_INPUT,
            MessageQueue::cb_eventReceiver, <span class="hljs-keyword">this</span>);
&#125;</code></pre></div>
<p>主要执行了以下几步：</p>
<h6 id="EventThread-createEventConnection"><a href="#EventThread-createEventConnection" class="headerlink" title="EventThread#createEventConnection"></a>EventThread#createEventConnection</h6><blockquote>
<p>新建<code>BitTube</code>对象</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/EventThread.cpp</span>
<span class="hljs-function">sp&lt;EventThread::Connection&gt; <span class="hljs-title">EventThread::createEventConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Connection(<span class="hljs-keyword">const_cast</span>&lt;EventThread*&gt;(<span class="hljs-keyword">this</span>));
&#125;

EventThread::Connection::Connection(
        <span class="hljs-keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)
    : count(<span class="hljs-number">-1</span>), mEventThread(eventThread), mChannel(<span class="hljs-keyword">new</span> BitTube())
&#123;
&#125;</code></pre></div>
<p>构建完成<code>Connection</code>对象，执行如下代码</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> EventThread::Connection::onFirstRef() &#123;
    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> mEventThread doesn't hold a strong reference on us</span>
    mEventThread-&gt;registerDisplayEventConnection(<span class="hljs-keyword">this</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">EventThread::registerDisplayEventConnection</span><span class="hljs-params">(
        <span class="hljs-keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;
    Mutex::Autolock _l(mLock);
    mDisplayEventConnections.add(connection);
    mCondition.broadcast();
    <span class="hljs-keyword">return</span> NO_ERROR;
&#125;</code></pre></div>
<p>初始化<code>Connection</code>之后，将<code>Connection</code>对象添加到<code>mDisplayEventConnections</code>中。</p>
<p><code>mDisplayEventConnections</code>主要负责<strong>保存接收Vsync信号的Connection的容器</strong>. 主要存储的是<code>SurfaceFlinger</code>与<code>App</code>的用来接收<code>Vsync信号</code>。</p>
<h6 id="Connection-getDataChannel"><a href="#Connection-getDataChannel" class="headerlink" title="Connection#getDataChannel"></a>Connection#getDataChannel</h6><blockquote>
<p>获取<code>BitTube</code>对象</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp">sp&lt;BitTube&gt; EventThread::Connection::getDataChannel() <span class="hljs-keyword">const</span> &#123;
    <span class="hljs-keyword">return</span> mChannel;
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/gui/BitTube.cpp</span>
BitTube::BitTube(<span class="hljs-keyword">size_t</span> bufsize) &#123;
    <span class="hljs-comment">// 创建socket pair，用于发送事件</span>
    init(bufsize, bufsize);
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BitTube::init</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> rcvbuf, <span class="hljs-keyword">size_t</span> sndbuf)</span> </span>&#123;
    <span class="hljs-keyword">int</span> sockets[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="hljs-number">0</span>, sockets) == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">size_t</span> size = DEFAULT_SOCKET_BUFFER_SIZE;
        <span class="hljs-comment">// 设置socket buffer</span>
        setsockopt(sockets[<span class="hljs-number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, <span class="hljs-keyword">sizeof</span>(rcvbuf));
        setsockopt(sockets[<span class="hljs-number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, <span class="hljs-keyword">sizeof</span>(sndbuf));
        <span class="hljs-comment">// since we don't use the "return channel", we keep it small...</span>
        setsockopt(sockets[<span class="hljs-number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;size, <span class="hljs-keyword">sizeof</span>(size));
        setsockopt(sockets[<span class="hljs-number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;size, <span class="hljs-keyword">sizeof</span>(size));
        fcntl(sockets[<span class="hljs-number">0</span>], F_SETFL, O_NONBLOCK);
        fcntl(sockets[<span class="hljs-number">1</span>], F_SETFL, O_NONBLOCK);
        <span class="hljs-comment">// socket[0]用于接收端，最终通过Binder IPC返回给客户端应用</span>
        mReceiveFd.reset(sockets[<span class="hljs-number">0</span>]);
        <span class="hljs-comment">// socket[1]用于发送端</span>
        mSendFd.reset(sockets[<span class="hljs-number">1</span>]);
    &#125; <span class="hljs-keyword">else</span> &#123;
        mReceiveFd.reset();
        ALOGE(<span class="hljs-string">"BitTube: pipe creation failed (%s)"</span>, strerror(errno));
    &#125;
&#125;</code></pre></div>
<p><code>BitTube</code>实际是一个<code>Socket</code>，所以<code>EventThread</code>实际通过<code>Socket</code>和<code>MessageQueue</code>通信。</p>
<h6 id="Looper-addFd"><a href="#Looper-addFd" class="headerlink" title="Looper#addFd"></a>Looper#addFd</h6><blockquote>
<p>监听<code>BitTube</code>，一旦收到数据调用<code>cb_eventReceiver()</code></p>
</blockquote>
<p>通过<code>Looper</code>监听<code>BitTube</code>的fd。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这一步主要用于接收<code>Vsync信号</code>的初始化操作</p>
<ol>
<li><code>init()</code>中，创建了<code>EventThread</code>用来接收<code>Vsync信号</code></li>
<li>通过<code>MessageQueue.setEventThread()</code>将<code>EventThread</code>与<code>MessageQueue</code>建立关联。实际内部通过<code>BitTube(Socket)</code>建立两者间的通信。</li>
<li>再通过<code>addFd()</code>监听<code>BitTube</code>的套接字fd，这样就可以监听到数据的变化。</li>
</ol>
<h3 id="SurfaceFlinger-run"><a href="#SurfaceFlinger-run" class="headerlink" title="SurfaceFlinger#run"></a>SurfaceFlinger#run</h3><p>最后执行<code>SurfaceFlinger#run</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::run</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">do</span> &#123;
        waitForEvent();
    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::waitForEvent</span><span class="hljs-params">()</span> </span>&#123;
    mEventQueue.waitMessage();
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::waitMessage</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">do</span> &#123;
        IPCThreadState::self()-&gt;flushCommands();
        <span class="hljs-keyword">int32_t</span> ret = mLooper-&gt;pollOnce(<span class="hljs-number">-1</span>);
        <span class="hljs-keyword">switch</span> (ret) &#123;
            <span class="hljs-keyword">case</span> Looper::POLL_WAKE:
            <span class="hljs-keyword">case</span> Looper::POLL_CALLBACK:
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">case</span> Looper::POLL_ERROR:
                ALOGE(<span class="hljs-string">"Looper::POLL_ERROR"</span>);
            <span class="hljs-keyword">case</span> Looper::POLL_TIMEOUT:
                <span class="hljs-comment">// timeout (should not happen)</span>
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-comment">// should not happen</span>
                ALOGE(<span class="hljs-string">"Looper::pollOnce() returned unknown status %d"</span>, ret);
                <span class="hljs-keyword">continue</span>;
        &#125;
    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);
&#125;</code></pre></div>
<p>通过<code>waitMessage()</code>等待消息的到来</p>
<h2 id="Vsync信号相关"><a href="#Vsync信号相关" class="headerlink" title="Vsync信号相关"></a>Vsync信号相关</h2><h3 id="接收Vsync"><a href="#接收Vsync" class="headerlink" title="接收Vsync"></a>接收Vsync</h3><h4 id="HWC-hook-vsync"><a href="#HWC-hook-vsync" class="headerlink" title="HWC#hook_vsync"></a>HWC#hook_vsync</h4><p><code>Vsync信号</code>都是由<code>HWComposer</code>发出的，需要从<code>HWC</code>进行分析</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span>
HWComposer::HWComposer(
        <span class="hljs-keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,
        EventHandler&amp; handler)
    : mFlinger(flinger),
      mFbDev(<span class="hljs-number">0</span>), mHwc(<span class="hljs-number">0</span>), mNumDisplays(<span class="hljs-number">1</span>),
      mCBContext(<span class="hljs-keyword">new</span> cb_context),
      mEventHandler(handler),
      mDebugForceFakeVSync(<span class="hljs-literal">false</span>)
&#123;
        ...
    <span class="hljs-keyword">if</span> (mHwc) &#123;
        <span class="hljs-keyword">if</span> (mHwc-&gt;registerProcs) &#123;
            mCBContext-&gt;hwc = <span class="hljs-keyword">this</span>;
            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate; <span class="hljs-comment">//invalidate事件回调</span>
            mCBContext-&gt;procs.vsync = &amp;hook_vsync;<span class="hljs-comment">//Vsync回调</span>
            <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))
                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;
            <span class="hljs-keyword">else</span>
                mCBContext-&gt;procs.hotplug = <span class="hljs-literal">NULL</span>;
            <span class="hljs-built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mCBContext-&gt;procs.zero));
            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);
        &#125;          
&#125;</code></pre></div>
<p>通过<code>hook_vsync</code>处理<code>Vsync信号</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HWComposer::hook_vsync</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct hwc_procs* procs, <span class="hljs-keyword">int</span> disp,
        <span class="hljs-keyword">int64_t</span> timestamp)</span> </span>&#123;
    cb_context* ctx = <span class="hljs-keyword">reinterpret_cast</span>&lt;cb_context*&gt;(
            <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">hwc_procs_t</span>*&gt;(procs));
    ctx-&gt;hwc-&gt;vsync(disp, timestamp);
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HWComposer::vsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> disp, <span class="hljs-keyword">int64_t</span> timestamp)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">uint32_t</span>(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;
        &#123;
            Mutex::Autolock _l(mLock);

            mLastHwVSync[disp] = timestamp;
        &#125;

        <span class="hljs-keyword">char</span> tag[<span class="hljs-number">16</span>];
        <span class="hljs-built_in">snprintf</span>(tag, <span class="hljs-keyword">sizeof</span>(tag), <span class="hljs-string">"HW_VSYNC_%1u"</span>, disp);
        mEventHandler.onVSyncReceived(disp, timestamp);
    &#125;
&#125;</code></pre></div>
<p>当<code>hook_vsync</code>收到<code>Vsync信号</code>时，回调到<code>vsync()</code>，继续调用到<code>mEventHandler.onVsyncReceived()</code></p>
<p><code>mEventHandler</code>是在<code>HWC</code>初始化时赋值的，实际就是<code>SurfaceFlinger</code></p>
<h4 id="Sf-onVSyncReceived"><a href="#Sf-onVSyncReceived" class="headerlink" title="Sf#onVSyncReceived"></a>Sf#onVSyncReceived</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onVSyncReceived</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">nsecs_t</span> timestamp)</span> </span>&#123;
    <span class="hljs-keyword">bool</span> needsHwVsync = <span class="hljs-literal">false</span>;

    &#123; <span class="hljs-comment">// Scope for the lock</span>
        Mutex::Autolock _l(mHWVsyncLock);
        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">0</span> &amp;&amp; mPrimaryHWVsyncEnabled) &#123;
            needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);
        &#125;
    &#125;

    <span class="hljs-keyword">if</span> (needsHwVsync) &#123;
        enableHardwareVsync();
    &#125; <span class="hljs-keyword">else</span> &#123;
        disableHardwareVsync(<span class="hljs-literal">false</span>);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;
    sp&lt;VSyncSource&gt; vsyncSrc = <span class="hljs-keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,
            vsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">"app"</span>);
    mEventThread = <span class="hljs-keyword">new</span> EventThread(vsyncSrc);
&#125;</code></pre></div>
<h5 id="DispSync-addResyncSample"><a href="#DispSync-addResyncSample" class="headerlink" title="DispSync#addResyncSample"></a>DispSync#addResyncSample</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DispSync.cpp</span>
DispSync::DispSync() :
        mRefreshSkipCount(<span class="hljs-number">0</span>),
        mThread(<span class="hljs-keyword">new</span> DispSyncThread()) &#123;
    <span class="hljs-comment">//启动DispSyncThread</span>
    mThread-&gt;run(<span class="hljs-string">"DispSync"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);

    reset();
    beginResync();

    <span class="hljs-keyword">if</span> (kTraceDetailedInfo) &#123;
        <span class="hljs-keyword">if</span> (!kIgnorePresentFences) &#123;
            addEventListener(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ZeroPhaseTracer());
        &#125;
    &#125;
&#125;</code></pre></div>
<h6 id="DispSyncThread-threadLoop"><a href="#DispSyncThread-threadLoop" class="headerlink" title="DispSyncThread#threadLoop"></a>DispSyncThread#threadLoop</h6><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DispSync.cpp   </span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">threadLoop</span><span class="hljs-params">()</span> </span>&#123;
  ...
       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
         ...
                <span class="hljs-keyword">if</span> (mPeriod == <span class="hljs-number">0</span>) &#123;
                    err = mCond.wait(mMutex);
                    <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;
                        ALOGE(<span class="hljs-string">"error waiting for new events: %s (%d)"</span>,
                                strerror(-err), err);
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    &#125;
                    <span class="hljs-keyword">continue</span>;
                &#125;        
               <span class="hljs-comment">//收集Vsync信号回调的方法</span>
                callbackInvocations = gatherCallbackInvocationsLocked(now);         
       &#125;

            <span class="hljs-keyword">if</span> (callbackInvocations.size() &gt; <span class="hljs-number">0</span>) &#123;
                fireCallbackInvocations(callbackInvocations);
            &#125;  
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fireCallbackInvocations</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; callbacks.size(); i++) &#123;
          <span class="hljs-comment">//回调callback的 onDispSyncEvent</span>
            callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);
        &#125;
    &#125;</code></pre></div>
<p><code>DispSyncThread</code>通过<code>mCond.wait()</code>等待被唤醒，被唤醒之后回调到<code>onDispSynvEvent()</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DispSync::addResyncSample</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> timestamp)</span> </span>&#123;
    <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;
    <span class="hljs-keyword">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;
    mResyncSamples[idx] = timestamp;

    <span class="hljs-keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;
        mNumResyncSamples++;
    &#125; <span class="hljs-keyword">else</span> &#123;
        mFirstResyncSample = (mFirstResyncSample + <span class="hljs-number">1</span>) % MAX_RESYNC_SAMPLES;
    &#125;
    updateModelLocked();

    <span class="hljs-keyword">return</span> mPeriod == <span class="hljs-number">0</span> || mError &gt; kErrorThreshold;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;
        ...
        mPeriod = durationSum / (mNumResyncSamples - <span class="hljs-number">1</span>);

        <span class="hljs-comment">// Artificially inflate the period if requested.</span>
        mPeriod += mPeriod * mRefreshSkipCount;

        mThread-&gt;updateModel(mPeriod, mPhase);
    &#125;
&#125;</code></pre></div>
<h5 id="DispsyncThread-updateModel"><a href="#DispsyncThread-updateModel" class="headerlink" title="DispsyncThread#updateModel"></a>DispsyncThread#updateModel</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateModel</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> period, <span class="hljs-keyword">nsecs_t</span> phase)</span> </span>&#123;
    <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;
    mPeriod = period;
    mPhase = phase;
    mCond.signal();
&#125;</code></pre></div>
<p>执行<code>updateModel()</code>后，唤醒了<code>DispSyncThread</code></p>
<p>在<code>SurfaceFlinger.init()</code>之后初始化设置的<code>DispSyncSource</code>就是<code>callbakc</code>，然后回调到<code>onDispSyncEvent</code></p>
<h4 id="Sf-DispSyncSource-onDispSyncEvent"><a href="#Sf-DispSyncSource-onDispSyncEvent" class="headerlink" title="Sf.DispSyncSource#onDispSyncEvent"></a>Sf.DispSyncSource#onDispSyncEvent</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDispSyncEvent</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> when)</span> </span>&#123;
    sp&lt;VSyncSource::Callback&gt; callback;
    &#123;
        <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mCallbackMutex)</span></span>;
        callback = mCallback;

        <span class="hljs-keyword">if</span> (mTraceVsync) &#123;
            mValue = (mValue + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;
            ATRACE_INT(mVsyncEventLabel.<span class="hljs-built_in">string</span>(), mValue);
        &#125;
    &#125;

    <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">NULL</span>) &#123;
        callback-&gt;onVSyncEvent(when);
    &#125;
&#125;</code></pre></div>
<p>这个<code>callback</code>是在<code>EventThread</code>初始化的时候设置的，所以<code>mCallback</code>就是<code>EventThread</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThread::enableVSyncLocked</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!mUseSoftwareVSync) &#123;
        <span class="hljs-comment">// never enable h/w VSYNC when screen is off</span>
        <span class="hljs-keyword">if</span> (!mVsyncEnabled) &#123;
            mVsyncEnabled = <span class="hljs-literal">true</span>;
            mVSyncSource-&gt;setCallback(<span class="hljs-keyword">static_cast</span>&lt;VSyncSource::Callback*&gt;(<span class="hljs-keyword">this</span>));
            mVSyncSource-&gt;setVSyncEnabled(<span class="hljs-literal">true</span>);
        &#125;
    &#125;
    mDebugVsyncEnabled = <span class="hljs-literal">true</span>;
    sendVsyncHintOnLocked();
&#125;</code></pre></div>
<p>通过<code>setCallback()</code>建立<code>EventThread</code>与<code>DispSyncSource</code>之间的关联</p>
<h4 id="EventThread-onVsyncEvent"><a href="#EventThread-onVsyncEvent" class="headerlink" title="EventThread#onVsyncEvent"></a>EventThread#onVsyncEvent</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThread::onVSyncEvent</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> timestamp)</span> </span>&#123;
    Mutex::Autolock _l(mLock);
    mVSyncEvent[<span class="hljs-number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;
    mVSyncEvent[<span class="hljs-number">0</span>].header.id = <span class="hljs-number">0</span>;
    mVSyncEvent[<span class="hljs-number">0</span>].header.timestamp = timestamp;
    mVSyncEvent[<span class="hljs-number">0</span>].vsync.count++;
    mCondition.broadcast();<span class="hljs-comment">//唤醒EventThread</span>
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EventThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;
    DisplayEventReceiver::Event event;
    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;
  <span class="hljs-comment">//等待事件发生</span>
    signalConnections = waitForEvent(&amp;event);

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = signalConnections.size();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;
        <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; <span class="hljs-title">conn</span><span class="hljs-params">(signalConnections[i])</span></span>;
        <span class="hljs-comment">// 分发事件给所有的监听者</span>
        <span class="hljs-keyword">status_t</span> err = conn-&gt;postEvent(event);
        <span class="hljs-keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;
          
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;
            removeDisplayEventConnection(signalConnections[i]);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div>
<p><code>EventThread#threadLoop</code>在被唤醒后会执行<code>conn-&gt;postEvent()</code></p>
<h5 id="ET-Connection-postEvent"><a href="#ET-Connection-postEvent" class="headerlink" title="ET.Connection#postEvent"></a>ET.Connection#postEvent</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">status_t</span> EventThread::Connection::postEvent(
        <span class="hljs-keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;
    <span class="hljs-keyword">ssize_t</span> size = DisplayEventReceiver::sendEvents(mChannel, &amp;event, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> size &lt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">status_t</span>(size) : <span class="hljs-keyword">status_t</span>(NO_ERROR);
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/gui/DisplayEventReceiver.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">DisplayEventReceiver::sendEvents</span><span class="hljs-params">(gui::BitTube* dataChannel,
        Event <span class="hljs-keyword">const</span>* events, <span class="hljs-keyword">size_t</span> count)</span>
</span>&#123;
    <span class="hljs-keyword">return</span> gui::BitTube::sendObjects(dataChannel, events, count);
&#125;</code></pre></div>
<p>通过<code>BitTube</code>发送消息，此时就会触发到<code>MQ#cb_eventReceiver</code></p>
<h4 id="MessageQueue-cb-eventReceiver"><a href="#MessageQueue-cb-eventReceiver" class="headerlink" title="MessageQueue#cb_eventReceiver"></a>MessageQueue#cb_eventReceiver</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageQueue::cb_eventReceiver</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span>* data)</span> </span>&#123;
    MessageQueue* <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">reinterpret_cast</span>&lt;MessageQueue *&gt;(data);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>-&gt;eventReceiver(fd, events);
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageQueue::eventReceiver</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-comment">/*fd*/</span>, <span class="hljs-keyword">int</span> <span class="hljs-comment">/*events*/</span>)</span> </span>&#123;
    <span class="hljs-keyword">ssize_t</span> n;
    DisplayEventReceiver::Event buffer[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, <span class="hljs-number">8</span>)) &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;n ; i++) &#123;
            <span class="hljs-keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> INVALIDATE_ON_VSYNC</span>
                mHandler-&gt;dispatchInvalidate();
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
                mHandler-&gt;dispatchRefresh();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;

<span class="hljs-keyword">void</span> MessageQueue::Handler::dispatchRefresh() &#123;
    <span class="hljs-keyword">if</span> ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == <span class="hljs-number">0</span>) &#123;
        mQueue.mLooper-&gt;sendMessage(<span class="hljs-keyword">this</span>, Message(MessageQueue::REFRESH));
    &#125;
&#125;

<span class="hljs-keyword">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;
    <span class="hljs-keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="hljs-number">0</span>) &#123;
        mQueue.mLooper-&gt;sendMessage(<span class="hljs-keyword">this</span>, Message(MessageQueue::INVALIDATE));
    &#125;
&#125;</code></pre></div>
<p>回调到<code>MessageQueue.Handler</code>的<code>handleMessage()</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> MessageQueue::Handler::handleMessage(<span class="hljs-keyword">const</span> Message&amp; message) &#123;
    <span class="hljs-keyword">switch</span> (message.what) &#123;
        <span class="hljs-keyword">case</span> INVALIDATE:
            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);
            mQueue.mFlinger-&gt;onMessageReceived(message.what);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> REFRESH:
            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);
            mQueue.mFlinger-&gt;onMessageReceived(message.what);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TRANSACTION:
            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);
            mQueue.mFlinger-&gt;onMessageReceived(message.what);
            <span class="hljs-keyword">break</span>;
    &#125;
&#125;</code></pre></div>
<h4 id="Sf-onMessageReceived"><a href="#Sf-onMessageReceived" class="headerlink" title="Sf#onMessageReceived"></a>Sf#onMessageReceived</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> what)</span> </span>&#123;
    ATRACE_CALL();
    <span class="hljs-keyword">switch</span> (what) &#123;
        <span class="hljs-keyword">case</span> MessageQueue::TRANSACTION: &#123;
            handleMessageTransaction();
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;
            <span class="hljs-keyword">bool</span> refreshNeeded = handleMessageTransaction();
            refreshNeeded |= handleMessageInvalidate();
            refreshNeeded |= mRepaintEverything;
            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;
                signalRefresh();
            &#125;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;
            handleMessageRefresh();
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
&#125;</code></pre></div>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/15751538247774.jpg" srcset="/img/loading.gif" alt="img"></p>
<p>接收Vsync信号主要分为以下几步：</p>
<ol>
<li>HWC收到Vsync信号时，回调到<code>hook_vsync</code>，内部执行到<code>sf#onVsyncReceived()</code></li>
<li>继续执行到<code>DispSync#addResyncSample()</code>，然后到<code>DispSyncThread#updateModel()</code>调用<code>mCondition.broadcast()</code>唤醒<code>EventThread</code></li>
<li>唤醒之后执行到<code>DispSyncSource.onDispSyncEvent()</code>继续执行到<code>EventThread.onVsyncEvent()</code>，其中内部调用了<code>DisplayEventReceiver.sendEvents() -&gt; BitTube.sendObjects()</code>发送消息，<code>Looper</code>监听到<code>BitTube</code>有数据流动，就会回调<code>MessageQueue.cb_eventReceiver()</code></li>
<li>继续通过消息机制，回调到<code>MessageQueue.handleMessage()</code>，最后调用<code>Sf.handleMessageReceived()</code></li>
</ol>
<blockquote>
<p>简化版：</p>
<p><code>Vsync信号</code>由<code>HWC</code>产生，然后回调到<code>DispSyncthread</code>在继续回调到<code>DispSyncSource</code>，继续调用到了<code>EventThread</code>。最后<code>EventThread</code>通过<code>BitTube(Socket)</code>发送消息到<code>MessageQueue</code>，<code>MessageQueue</code>接收到消息后，在回调给<code>SurfaceFlinger</code>。</p>
</blockquote>
<h3 id="处理Vsync"><a href="#处理Vsync" class="headerlink" title="处理Vsync"></a>处理Vsync</h3><p>主要在<code>Sf#onMessageReceived()</code>处理<code>Vsync信号</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> what)</span> </span>&#123;
        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;
            <span class="hljs-keyword">bool</span> refreshNeeded = handleMessageTransaction();
            refreshNeeded |= handleMessageInvalidate();
            refreshNeeded |= mRepaintEverything;
            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;
                signalRefresh();
            &#125;
            <span class="hljs-keyword">break</span>;
        &#125;  
        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;
            handleMessageRefresh();
            <span class="hljs-keyword">break</span>;
        &#125;
&#125;</code></pre></div>
<p>在接受到<code>Vsync信号</code>后，就会回调到<code>MessageQueue::INVALIDATE</code>，继续向下执行到<code>signalRefresh()</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::signalRefresh</span><span class="hljs-params">()</span> </span>&#123;
    mEventQueue.refresh();
&#125;

<span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::refresh</span><span class="hljs-params">()</span> </span>&#123;
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> INVALIDATE_ON_VSYNC</span>
    mHandler-&gt;dispatchRefresh();
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    mEvents-&gt;requestNextVsync();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
&#125;

<span class="hljs-keyword">void</span> MessageQueue::Handler::dispatchRefresh() &#123;
    <span class="hljs-keyword">if</span> ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == <span class="hljs-number">0</span>) &#123;
        mQueue.mLooper-&gt;sendMessage(<span class="hljs-keyword">this</span>, Message(MessageQueue::REFRESH));
    &#125;
&#125;</code></pre></div>
<h4 id="Sf-handleMessageRefresh"><a href="#Sf-handleMessageRefresh" class="headerlink" title="Sf#handleMessageRefresh"></a>Sf#handleMessageRefresh</h4><p>最后还是执行到了<code>handleMessageRefresh()</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::handleMessageRefresh</span><span class="hljs-params">()</span> </span>&#123;
    ATRACE_CALL();
    preComposition();
    rebuildLayerStacks();
    setUpHWComposer();
    doDebugFlashRegions();
    doComposition();
    postComposition();
&#125;</code></pre></div>
<h5 id="preComposition-合成前预处理"><a href="#preComposition-合成前预处理" class="headerlink" title="preComposition-合成前预处理"></a>preComposition-合成前预处理</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::preComposition</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-comment">//是否需要刷新布局</span>
    <span class="hljs-keyword">bool</span> needExtraInvalidate = <span class="hljs-literal">false</span>;
    <span class="hljs-function"><span class="hljs-keyword">const</span> LayerVector&amp; <span class="hljs-title">layers</span><span class="hljs-params">(mDrawingState.layersSortedByZ)</span></span>;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = layers.size();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;
       <span class="hljs-comment">//当前Layer发生了变化</span>
        <span class="hljs-keyword">if</span> (layers[i]-&gt;onPreComposition()) &#123;
            needExtraInvalidate = <span class="hljs-literal">true</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">if</span> (needExtraInvalidate) &#123;
      <span class="hljs-comment">//申请下一个Vsync信号</span>
        signalLayerUpdate();
    &#125;
&#125;

<span class="hljs-comment">//frameworks/native/services/surfaceflinger/Layer.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Layer::onPreComposition</span><span class="hljs-params">()</span> </span>&#123;
    mRefreshPending = <span class="hljs-literal">false</span>;
   <span class="hljs-comment">//有待处理的Buffer帧，</span>
    <span class="hljs-keyword">return</span> mQueuedFrames &gt; <span class="hljs-number">0</span> || mSidebandStreamChanged;
&#125;</code></pre></div>
<p><code>preComposition()</code>需要先判断<code>Layer</code>是否发生了变化，没发生变化不需要申请下一次Vsync信号，否则执行<code>signalLayerUpdate()</code>申请下一次Vsync信号。</p>
<h6 id="signalLayerUpdate"><a href="#signalLayerUpdate" class="headerlink" title="signalLayerUpdate"></a>signalLayerUpdate</h6><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::signalLayerUpdate</span><span class="hljs-params">()</span> </span>&#123;
    mEventQueue.invalidate();
&#125;

<span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::invalidate</span><span class="hljs-params">()</span> </span>&#123;
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> INVALIDATE_ON_VSYNC</span>
    mEvents-&gt;requestNextVsync();
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    mHandler-&gt;dispatchInvalidate();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
&#125;

<span class="hljs-comment">//frameworks/native/services/surfaceflinger/EventThread.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThread::requestNextVsync</span><span class="hljs-params">(
        <span class="hljs-keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;
    Mutex::Autolock _l(mLock);
    <span class="hljs-keyword">if</span> (connection-&gt;count &lt; <span class="hljs-number">0</span>) &#123;
        connection-&gt;count = <span class="hljs-number">0</span>;
        mCondition.broadcast();
    &#125;
&#125;</code></pre></div>
<p>唤醒了<code>EventThread</code>，返回Vsync信号通知。</p>
<h5 id="rebuildLayerStacks-重建Layer"><a href="#rebuildLayerStacks-重建Layer" class="headerlink" title="rebuildLayerStacks-重建Layer"></a>rebuildLayerStacks-重建Layer</h5><blockquote>
<p>遍历<code>Lqayer</code>，计算和存储每个Layer的<code>dirtyRegion</code>，如果<code>dirtyRegion</code>显示在设备的显示区域内，就表示<code>Layer</code>需要重新绘制。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::rebuildLayerStacks</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// rebuild the visible layer list per screen</span>
    <span class="hljs-keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;
        ATRACE_CALL();
        mVisibleRegionsDirty = <span class="hljs-literal">false</span>;
        invalidateHwcGeometry();

        <span class="hljs-function"><span class="hljs-keyword">const</span> LayerVector&amp; <span class="hljs-title">layers</span><span class="hljs-params">(mDrawingState.layersSortedByZ)</span></span>;
      <span class="hljs-comment">//遍历所有显示设备，计算显示设备中dirtyRegion和 opaqueRegion</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;
            Region opaqueRegion;<span class="hljs-comment">//非透明区域</span>
            Region dirtyRegion;<span class="hljs-comment">//变化区域，需要刷新</span>
            Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;
            <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;
            <span class="hljs-function"><span class="hljs-keyword">const</span> Transform&amp; <span class="hljs-title">tr</span><span class="hljs-params">(hw-&gt;getTransform())</span></span>;
            <span class="hljs-function"><span class="hljs-keyword">const</span> Rect <span class="hljs-title">bounds</span><span class="hljs-params">(hw-&gt;getBounds())</span></span>;
            <span class="hljs-keyword">if</span> (hw-&gt;isDisplayOn()) &#123;
              <span class="hljs-comment">//计算Layer的 dirtyRegion和 opaqueRegion</span>
                SurfaceFlinger::computeVisibleRegions(layers,
                        hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion);

                <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = layers.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;
                    <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(layers[i])</span></span>;
                    <span class="hljs-function"><span class="hljs-keyword">const</span> Layer::State&amp; <span class="hljs-title">s</span><span class="hljs-params">(layer-&gt;getDrawingState())</span></span>;
                    <span class="hljs-keyword">if</span> (s.layerStack == hw-&gt;getLayerStack()) &#123;
                        <span class="hljs-function">Region <span class="hljs-title">drawRegion</span><span class="hljs-params">(tr.transform(
                                layer-&gt;visibleNonTransparentRegion))</span></span>;
                        drawRegion.andSelf(bounds);
                        <span class="hljs-keyword">if</span> (!drawRegion.isEmpty()) &#123;
                            layersSortedByZ.add(layer);
                        &#125;
                    &#125;
                &#125;
            &#125;
          <span class="hljs-comment">//按照Z轴由小到大排序</span>
            hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ);
            hw-&gt;undefinedRegion.<span class="hljs-built_in">set</span>(bounds);
            hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));
            hw-&gt;dirtyRegion.orSelf(dirtyRegion);
        &#125;
    &#125;
&#125;</code></pre></div>
<p>最重要的是<code>computeVisibleRegions</code>-对Layer的<code>dirtyRegion</code>和<code>opaqueRegion</code>的计算。</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::computeVisibleRegions</span><span class="hljs-params">(
        <span class="hljs-keyword">const</span> LayerVector&amp; currentLayers, <span class="hljs-keyword">uint32_t</span> layerStack,
        Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span>
</span>&#123;
 <span class="hljs-keyword">size_t</span> i = currentLayers.size();
    <span class="hljs-keyword">while</span> (i--) &#123;
        <span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; layer = currentLayers[i];

        <span class="hljs-comment">// start with the whole surface at its current location</span>
        <span class="hljs-function"><span class="hljs-keyword">const</span> Layer::State&amp; <span class="hljs-title">s</span><span class="hljs-params">(layer-&gt;getDrawingState())</span></span>;

        <span class="hljs-comment">// only consider the layers on the given layer stack</span>
        <span class="hljs-keyword">if</span> (s.layerStack != layerStack)
            <span class="hljs-keyword">continue</span>;
      <span class="hljs-comment">//非透明区域</span>
        Region opaqueRegion;
      <span class="hljs-comment">//可见区域</span>
        Region visibleRegion;
      <span class="hljs-comment">//被遮盖区域</span>
        Region coveredRegion;
      <span class="hljs-comment">//透明区域</span>
        Region transparentRegion;

        <span class="hljs-comment">// handle hidden surfaces by setting the visible region to empty</span>
        <span class="hljs-keyword">if</span> (CC_LIKELY(layer-&gt;isVisible())) &#123;
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> translucent = !layer-&gt;isOpaque(s);
            <span class="hljs-function">Rect <span class="hljs-title">bounds</span><span class="hljs-params">(s.transform.transform(layer-&gt;computeBounds()))</span></span>;
            visibleRegion.<span class="hljs-built_in">set</span>(bounds);
            <span class="hljs-keyword">if</span> (!visibleRegion.isEmpty()) &#123;
                <span class="hljs-comment">// Remove the transparent area from the visible region</span>
                <span class="hljs-keyword">if</span> (translucent) &#123;
                    <span class="hljs-function"><span class="hljs-keyword">const</span> Transform <span class="hljs-title">tr</span><span class="hljs-params">(s.transform)</span></span>;
                    <span class="hljs-keyword">if</span> (tr.transformed()) &#123;
                        <span class="hljs-keyword">if</span> (tr.preserveRects()) &#123;
                            <span class="hljs-comment">// transform the transparent region</span>
                            transparentRegion = tr.transform(s.activeTransparentRegion);
                        &#125; <span class="hljs-keyword">else</span> &#123;
                            <span class="hljs-comment">// transformation too complex, can't do the</span>
                            <span class="hljs-comment">// transparent region optimization.</span>
                            transparentRegion.clear();
                        &#125;
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        transparentRegion = s.activeTransparentRegion;
                    &#125;
                &#125;

                <span class="hljs-comment">// compute the opaque region</span>
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> layerOrientation = s.transform.getOrientation();
                <span class="hljs-keyword">if</span> (s.alpha==<span class="hljs-number">255</span> &amp;&amp; !translucent &amp;&amp;
                        ((layerOrientation &amp; Transform::ROT_INVALID) == <span class="hljs-literal">false</span>)) &#123;
                    <span class="hljs-comment">// the opaque region is the layer's footprint</span>
                    opaqueRegion = visibleRegion;
                &#125;
            &#125;
        &#125;

        <span class="hljs-comment">// Clip the covered region to the visible region</span>
        coveredRegion = aboveCoveredLayers.intersect(visibleRegion);

        <span class="hljs-comment">// 累加当前Layer和上层Layer的可见区域</span>
        aboveCoveredLayers.orSelf(visibleRegion);

        <span class="hljs-comment">// 可见区域减去非透明区域</span>
        visibleRegion.subtractSelf(aboveOpaqueLayers);

        <span class="hljs-comment">// 计算脏区</span>
        <span class="hljs-keyword">if</span> (layer-&gt;contentDirty) &#123;
            <span class="hljs-comment">// we need to invalidate the whole region</span>
            dirty = visibleRegion;
            <span class="hljs-comment">// as well, as the old visible region</span>
            dirty.orSelf(layer-&gt;visibleRegion);
            layer-&gt;contentDirty = <span class="hljs-literal">false</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">const</span> Region newExposed = visibleRegion - coveredRegion;
            <span class="hljs-keyword">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;
            <span class="hljs-keyword">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;
            <span class="hljs-keyword">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;
            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);
        &#125;
        dirty.subtractSelf(aboveOpaqueLayers);
       <span class="hljs-comment">//累加脏区</span>
        outDirtyRegion.orSelf(dirty);
       <span class="hljs-comment">//添加非透明区域</span>
        aboveOpaqueLayers.orSelf(opaqueRegion);
       <span class="hljs-comment">//存储可见区域</span>
        layer-&gt;setVisibleRegion(visibleRegion);
        layer-&gt;setCoveredRegion(coveredRegion);
        layer-&gt;setVisibleNonTransparentRegion(
                visibleRegion.subtract(transparentRegion));
    &#125;

    outOpaqueRegion = aboveOpaqueLayers;
&#125;</code></pre></div>
<p>按照上述源码，界面显示区域分为如下几种：</p>
<ul>
<li><code>opaqueRegion</code>：非透明区域——表示不完全透明的区域</li>
<li><code>dirtyRegion</code>：需要重绘的区域</li>
<li><code>visibleRegion</code>：可见区域——表示完全不透明的区域</li>
<li><code>coveredRegion</code>：被覆盖区域——被完全不透明区域覆盖的区域</li>
<li><code>transparentRegion</code>：完全透明的区域——一般需要从合成列表中移除</li>
<li><code>aboveOpaqueLayers</code>：所有<code>非透明区域</code>的叠加</li>
<li><code>aboveCoveredLayers</code>：所有<code>可见区域</code>的叠加</li>
</ul>
<p>以平常的应用界面来举例。</p>
<p><code>opaqueRegion</code>：状态栏通常都是半透明的，可以看到时间等信息</p>
<p><code>visibleRegion</code>：当前显示的应用界面，就完全遮盖了后面的内容</p>
<p><code>coveredRegion</code>：桌面应用设置的壁纸。</p>
<blockquote>
<p><code>computeVisibleRegions</code>主要完成了以下几步：</p>
<ol>
<li>在<code>Layer的Z轴</code>从上向下遍历该显示设备中的<code>Layer</code></li>
<li>计算被覆盖区域：<code>aboveCoveredLayers</code>与<code>opaqueRegion</code>的交集</li>
<li>计算可见区域：去除<code>opaqueRegion</code>和<code>aboveOpaqueLayers</code>的交集</li>
<li>计算脏区域</li>
<li>保存到<code>Layer</code>中</li>
</ol>
</blockquote>
<h5 id="setUpHWComposer-构造硬件合成的任务"><a href="#setUpHWComposer-构造硬件合成的任务" class="headerlink" title="setUpHWComposer-构造硬件合成的任务"></a>setUpHWComposer-构造硬件合成的任务</h5><blockquote>
<p><code>Layer</code>交给<code>HWComposer</code>去做图层混合。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::setUpHWComposer</span><span class="hljs-params">()</span> </span>&#123;
  
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;
        <span class="hljs-keyword">bool</span> dirty = !mDisplays[dpy]-&gt;getDirtyRegion(<span class="hljs-literal">false</span>).isEmpty();
        <span class="hljs-keyword">bool</span> empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == <span class="hljs-number">0</span>;
        <span class="hljs-keyword">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;
       <span class="hljs-comment">//没有脏区域或者可见的Layer，就不需要进行合成</span>
        <span class="hljs-keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);
      
        mDisplays[dpy]-&gt;beginFrame(mustRecompose);

        <span class="hljs-keyword">if</span> (mustRecompose) &#123;
            mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;
        &#125;      
    &#125;
  
  <span class="hljs-comment">//构造HWComposer硬件任务</span>
    <span class="hljs-function">HWComposer&amp; <span class="hljs-title">hwc</span><span class="hljs-params">(getHwComposer())</span></span>;
    <span class="hljs-keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;
        <span class="hljs-comment">// build the h/w work list</span>
        <span class="hljs-keyword">if</span> (CC_UNLIKELY(mHwWorkListDirty)) &#123;
            mHwWorkListDirty = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;
                <span class="hljs-function">sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();
                <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-function"><span class="hljs-keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="hljs-title">currentLayers</span><span class="hljs-params">(
                        hw-&gt;getVisibleLayersSortedByZ())</span></span>;
                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = currentLayers.size();
                  <span class="hljs-comment">//在HWC创建任务列表</span>
                    <span class="hljs-keyword">if</span> (hwc.createWorkList(id, count) == NO_ERROR) &#123;
                        HWComposer::LayerListIterator cur = hwc.begin(id);
                        <span class="hljs-keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;
                            <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(currentLayers[i])</span></span>;
                            layer-&gt;setGeometry(hw, *cur);
                            <span class="hljs-keyword">if</span> (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123;
                                cur-&gt;setSkip(<span class="hljs-literal">true</span>);
                            &#125;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;

        <span class="hljs-comment">// 设置每帧的数据</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;
            <span class="hljs-function">sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();
            <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span>) &#123;
                <span class="hljs-function"><span class="hljs-keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="hljs-title">currentLayers</span><span class="hljs-params">(
                    hw-&gt;getVisibleLayersSortedByZ())</span></span>;
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = currentLayers.size();
                HWComposer::LayerListIterator cur = hwc.begin(id);
                <span class="hljs-keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;
                    <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(currentLayers[i])</span></span>;
                    layer-&gt;setPerFrameData(hw, *cur);
                &#125;
            &#125;
        &#125;

        <span class="hljs-keyword">status_t</span> err = hwc.prepare();
        ALOGE_IF(err, <span class="hljs-string">"HWComposer::prepare failed (%s)"</span>, strerror(-err));

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;
            <span class="hljs-function">sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;
            hw-&gt;prepareFrame(hwc);
        &#125;
    &#125;  
  
&#125;</code></pre></div>
<h5 id="doComposition-执行合成任务"><a href="#doComposition-执行合成任务" class="headerlink" title="doComposition-执行合成任务"></a>doComposition-执行合成任务</h5><blockquote>
<p>前面已经准备好了<code>合成Layer任务</code>和<code>需要合成的数据</code>，现在就需要做图像的混合工作。</p>
</blockquote>
<p><code>doComposition</code>  </p>
<ul>
<li><code>doDisplayComposition</code>：重绘<code>FrameBuffer</code></li>
<li><code>postFrameBuffer</code>：将数据写入到<code>FrameBuffer</code>然后完成物理屏幕的图像显示</li>
</ul>
<h5 id="postComposition-合成图形结束后的处理"><a href="#postComposition-合成图形结束后的处理" class="headerlink" title="postComposition-合成图形结束后的处理"></a>postComposition-合成图形结束后的处理</h5><blockquote>
<p>此时图层已经混合完成，图像数据也被送到了<code>帧缓冲(FrameBuffer)</code>，并且已经显示在屏幕上了，由<code>postComposition()</code>进行一些收尾工作的处理。</p>
</blockquote>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>TODO</p>
<h2 id="Android图形缓冲区"><a href="#Android图形缓冲区" class="headerlink" title="Android图形缓冲区"></a>Android图形缓冲区</h2><p>Android的图形缓冲区主要由以下几部分组成：</p>
<ul>
<li><code>Surface</code></li>
<li><code>Layer</code></li>
<li><code>GraphicBuffer</code></li>
<li><code>BufferQueue</code></li>
</ul>
<h3 id="Surface相关"><a href="#Surface相关" class="headerlink" title="Surface相关"></a>Surface相关</h3><blockquote>
<p><strong><code>Surface</code>是提供给<code>图形生产者</code>控制缓冲区的</strong></p>
<p>在<code>软件绘制</code>中，调用<code>drawSoftware(surface)</code>传入<code>Surface缓冲区</code>到<code>native</code>层的<code>SkiaCanvas</code></p>
<p>在<code>硬件绘制</code>中，调用<code>ThreadedRenderer.initalize(surface)</code>传入<code>Surface缓冲区</code>到OpenGL中进行渲染。</p>
<p>当得到<code>Surface缓冲区</code>后，就可以存入<strong>需要绘制的内容</strong>到<code>Surface</code>中。</p>
</blockquote>
<p><code>Surface</code>内部持有<code>BufferQueue中的GraphicBufferProducer</code>，主要负责<strong>创建或获取可用的<code>GraphicBuffer</code>以及提交绘制后的<code>GraphicBuffer</code></strong>。</p>
<h3 id="Layer相关"><a href="#Layer相关" class="headerlink" title="Layer相关"></a>Layer相关</h3><blockquote>
<p><strong><code>Layer</code>是提供给<code>图形消费者</code>获取缓冲区的</strong></p>
<p>在<code>SurfaceFlinger</code>需要消费图形数据，进行图层混合时，在<code>rebuildLayerStacks()</code>进行<code>Layer</code>遍历，取出<code>Layer</code>中的图形数据，进行数据合成处理。</p>
</blockquote>
<p><code>Layer</code>内部持有<code>BufferQueue中的GraphicBufferConsumer</code>，主要负责<strong>获取和释放<code>GraphicBuffer</code></strong></p>
<h3 id="GraphicBuffer"><a href="#GraphicBuffer" class="headerlink" title="GraphicBuffer"></a>GraphicBuffer</h3><blockquote>
<p>真正被分配内存，并能存储图形数据的缓冲区。</p>
</blockquote>
<h3 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h3><blockquote>
<p>存放<code>GraphicBuffer</code>的数组结构，最多可以存储<strong>64</strong>个<code>GraphicBuffer</code></p>
</blockquote>
<p><img src="/images/BufferQueue执行流程.jpg" srcset="/img/loading.gif" alt="BufferQueue执行流程"></p>
<blockquote>
<p>当绘制图像时，首先去创建<code>Surface</code>和<code>Layer</code>，</p>
<p>然后<code>图像生产者</code>通过<code>Surface</code>调用<code>dequeue()</code>申请一块<code>GraphicBuffer</code>，在其上绘制图像</p>
<p>绘制完毕后，通过<code>Surface</code>调用<code>queue()</code>把绘制好的<code>GraphicBuffer</code>返回到<code>BufferQueue</code>中。</p>
<p>收到<code>HWComposer</code>发出的<code>Vsync信号后</code>，<code>SurfaceFlinger</code>通过<code>Layer</code>调用<code>acquire()</code>获取绘制好的<code>GraphicBuffer</code>进行合成与处理</p>
<p>处理完毕后通过<code>Layer</code>调用<code>release()</code>释放<code>GraphicBuffer</code>并返回到<code>BufferQueue</code>中。</p>
</blockquote>
<h3 id="缓冲区创建流程"><a href="#缓冲区创建流程" class="headerlink" title="缓冲区创建流程"></a>缓冲区创建流程</h3><h4 id="Activity创建图形缓冲区"><a href="#Activity创建图形缓冲区" class="headerlink" title="Activity创建图形缓冲区"></a>Activity创建图形缓冲区</h4><p>其中最常见的场景在<code>ViewRootImpl</code>的创建过程中，在其中执行了<code>Surface</code>的创建。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewRootImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewParent</span>,
        <span class="hljs-title">View</span>.<span class="hljs-title">AttachInfo</span>.<span class="hljs-title">Callbacks</span>, <span class="hljs-title">ThreadedRenderer</span>.<span class="hljs-title">DrawCallbacks</span> </span>&#123;
          ...
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Surface mSurface = <span class="hljs-keyword">new</span> Surface();
          
        &#125;</code></pre></div>
<p>主要在<code>WindowManagerGlobal.addView()</code>构造的<code>ViewRootImpl</code>对象。</p>
<p>此时创建的只是Java层的<code>Surface</code>，还需要绑定Native层的<code>Surface</code>。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;
               <span class="hljs-comment">//执行绘制流程 测量-布局-绘制</span>
                requestLayout();
                <span class="hljs-keyword">if</span> ((mWindowAttributes.inputFeatures
                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="hljs-number">0</span>) &#123;
                  <span class="hljs-comment">//触摸事件回调</span>
                    mInputChannel = <span class="hljs-keyword">new</span> InputChannel();
                &#125;
                mForceDecorViewVisibility = (mWindowAttributes.privateFlags
                        &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != <span class="hljs-number">0</span>;
                <span class="hljs-keyword">try</span> &#123;
                    mOrigWindowType = mWindowAttributes.type;
                    mAttachInfo.mRecomputeGlobalAttributes = <span class="hljs-keyword">true</span>;
                    collectViewAttributes();
                   <span class="hljs-comment">//添加窗口</span>
                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);
                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
                   ...
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-keyword">if</span> (restore) &#123;
                        attrs.restore();
                    &#125;
                &#125;      
    &#125;</code></pre></div>
<p><code>setView()</code>主要做了两件事情：</p>
<ul>
<li><code>requestLayout</code>：主要是执行到<code>relayoutWindow</code>创建了<code>Surface</code>和<code>Layer</code></li>
<li><code>addToDisplay</code>：创建了<code>SurfaceComponentClient</code></li>
</ul>
<p><code>requestLayout</code>需要在<code>addToDisplay</code>执行完毕后才可以执行。</p>
<p><br></p>
<h5 id="WS-addToDisplay"><a href="#WS-addToDisplay" class="headerlink" title="WS#addToDisplay"></a>WS#addToDisplay</h5><p><code>WS#addToDisplay()</code>执行过程</p>
<p><code>WindowSession</code>表示<strong>Java层的Window和WMS通信的对象</strong>。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//com.android.server.wm.Session</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Session</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IWindowSession</span>.<span class="hljs-title">Stub</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBinder</span>.<span class="hljs-title">DeathRecipient</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addToDisplayWithoutInputChannel</span><span class="hljs-params">(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,
            <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets)</span> </span>&#123;
        <span class="hljs-keyword">return</span> mService.addWindow(<span class="hljs-keyword">this</span>, window, seq, attrs, viewVisibility, displayId,
                <span class="hljs-keyword">new</span> Rect() <span class="hljs-comment">/* outFrame */</span>, outContentInsets, outStableInsets, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* outOutsets */</span>,
                <span class="hljs-keyword">new</span> DisplayCutout.ParcelableWrapper() <span class="hljs-comment">/* cutout */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* outInputChannel */</span>);
    &#125;  
&#125;</code></pre></div>
<p><code>mService</code>表示的就是<code>WindowManagerService</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//WindowManagerService.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addWindow</span><span class="hljs-params">(Session session, IWindow client, <span class="hljs-keyword">int</span> seq,
            LayoutParams attrs, <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outFrame,
            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,
            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel)</span> </span>&#123;
      ...      
      <span class="hljs-keyword">synchronized</span>(mWindowMap) &#123;
            AppWindowToken atoken = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hasParent = parentWindow != <span class="hljs-keyword">null</span>;
          <span class="hljs-comment">//创建WindowToken</span>
            WindowToken token = displayContent.getWindowToken(
                    hasParent ? parentWindow.mAttrs.token : attrs.token);        
        ...
          <span class="hljs-comment">//创建WindowState对象</span>
            <span class="hljs-keyword">final</span> WindowState win = <span class="hljs-keyword">new</span> WindowState(<span class="hljs-keyword">this</span>, session, client, token, parentWindow,
                    appOp[<span class="hljs-number">0</span>], seq, attrs, viewVisibility, session.mUid,
                    session.mCanAddInternalSystemWindow); 
        ...
          <span class="hljs-comment">//附加窗口</span>
            win.attach();
            mWindowMap.put(client.asBinder(), win);          
      &#125;
    &#125;</code></pre></div>
<p>这里重点关注<code>WindowState#attach</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//WindowState.java</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">"Attaching "</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">" token="</span> + mToken);
        mSession.windowAddedLocked(mAttrs.packageName);
    &#125;

<span class="hljs-comment">//Session.java</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">windowAddedLocked</span><span class="hljs-params">(String packageName)</span> </span>&#123;
        mPackageName = packageName;
        mRelayoutTag = <span class="hljs-string">"relayoutWindow: "</span> + mPackageName;
        <span class="hljs-keyword">if</span> (mSurfaceSession == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (WindowManagerService.localLOGV) Slog.v(
                TAG_WM, <span class="hljs-string">"First window added to "</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">", creating SurfaceSession"</span>);
            mSurfaceSession = <span class="hljs-keyword">new</span> SurfaceSession();
          ...
        &#125;
        mNumWindow++;
    &#125;

<span class="hljs-comment">//SurfaceSession.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SurfaceSession</span><span class="hljs-params">()</span> </span>&#123;
        mNativeClient = nativeCreate();
    &#125;

<span class="hljs-comment">//android_view_SurfaceSession.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeCreate</span><span class="hljs-params">(JNIEnv* env, jclass clazz)</span> </span>&#123;
    SurfaceComposerClient* client = <span class="hljs-keyword">new</span> SurfaceComposerClient();
    client-&gt;incStrong((<span class="hljs-keyword">void</span>*)nativeCreate);
    <span class="hljs-keyword">return</span> reinterpret_cast&lt;jlong&gt;(client);
&#125;</code></pre></div>
<p>经过上述步骤最后创建了<code>SurfaceComponentClient</code></p>
<p><code>addToDisplay</code>执行完毕后，回调到<code>performTraversals()</code></p>
<h5 id="WS-relayoutWindow"><a href="#WS-relayoutWindow" class="headerlink" title="WS#relayoutWindow"></a>WS#relayoutWindow</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);
      ...
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> surfaceGenerationId = mSurface.getGenerationId();

        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isViewVisible = viewVisibility == View.VISIBLE;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> windowRelayoutWasForced = mForceNextWindowRelayout;
        <span class="hljs-keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||
                viewVisibilityChanged || params != <span class="hljs-keyword">null</span> || mForceNextWindowRelayout) &#123;
            mForceNextWindowRelayout = <span class="hljs-keyword">false</span>;
          ...
            <span class="hljs-keyword">try</span> &#123;            
             relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);
              ...
            &#125;<span class="hljs-keyword">catch</span>(RemoteException e)&#123;
              
            &#125;
            <span class="hljs-keyword">if</span> (!mStopped || mReportNextDraw) &#123;
                <span class="hljs-keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(
                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()
                        || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||
                        updatedConfiguration) &#123;
                    <span class="hljs-keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
                    <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
                  <span class="hljs-comment">//执行测量流程</span>
                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);  
                  ...
                &#125;
            &#125;
          
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);
        <span class="hljs-keyword">if</span> (didLayout) &#123;
          <span class="hljs-comment">//执行布局过程</span>
            performLayout(lp, mWidth, mHeight);
        &#125;
      &#125;
        <span class="hljs-keyword">boolean</span> cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
        <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;
            <span class="hljs-keyword">if</span> (mPendingTransitions != <span class="hljs-keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;
                    mPendingTransitions.get(i).startChangingAnimations();
                &#125;
                mPendingTransitions.clear();
            &#125;
           <span class="hljs-comment">//执行绘制流程</span>
            performDraw();
        &#125; 
      ...
    &#125;</code></pre></div>
<p><code>performTraversals()</code>主要做了以下几步：</p>
<ol>
<li><code>relayoutWindow</code>——创建<code>Surface</code>和<code>Layout</code></li>
<li><code>performMeasure</code>——测量过程</li>
<li><code>performLayout</code>——布局过程</li>
<li><code>performDraw</code>——绘制过程</li>
</ol>
<p>接下来主要分析<code>relayoutWindow</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">relayoutWindow</span><span class="hljs-params">(WindowManager.LayoutParams params, <span class="hljs-keyword">int</span> viewVisibility,
            <span class="hljs-keyword">boolean</span> insetsPending)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;
      ...
        <span class="hljs-keyword">int</span> relayoutResult = mWindowSession.relayout(mWindow, mSeq, params,
                (<span class="hljs-keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="hljs-number">0.5f</span>),
                (<span class="hljs-keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="hljs-number">0.5f</span>), viewVisibility,
                insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="hljs-number">0</span>, frameNumber,
                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingDisplayCutout,
                mPendingMergedConfiguration, mSurface);      
    &#125;

<span class="hljs-comment">//Session.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">relayout</span><span class="hljs-params">(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,
            <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">int</span> viewFlags, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">long</span> frameNumber,
            Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets,
            Rect outStableInsets, Rect outsets, Rect outBackdropFrame,
            DisplayCutout.ParcelableWrapper cutout, MergedConfiguration mergedConfiguration,
            Surface outSurface)</span> </span>&#123;
      ...
        <span class="hljs-keyword">int</span> res = mService.relayoutWindow(<span class="hljs-keyword">this</span>, window, seq, attrs,
                requestedWidth, requestedHeight, viewFlags, flags, frameNumber,
                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,
                outStableInsets, outsets, outBackdropFrame, cutout,
                mergedConfiguration, outSurface);
      ...
        <span class="hljs-keyword">return</span> res;
    &#125;

<span class="hljs-comment">//WindowManagerService.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">relayoutWindow</span><span class="hljs-params">(Session session, IWindow client, <span class="hljs-keyword">int</span> seq, LayoutParams attrs,
            <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> flags,
            <span class="hljs-keyword">long</span> frameNumber, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
            Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,
            DisplayCutout.ParcelableWrapper outCutout, MergedConfiguration mergedConfiguration,
            Surface outSurface)</span> </span>&#123;
      ...
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;
                    (win.mAppToken == <span class="hljs-keyword">null</span> || win.mAttrs.type == TYPE_APPLICATION_STARTING
                            || !win.mAppToken.isClientHidden());        
            <span class="hljs-keyword">if</span> (shouldRelayout) &#123;
                <span class="hljs-keyword">try</span> &#123;
                  <span class="hljs-comment">//创建SurfaceControl</span>
                    result = createSurfaceControl(outSurface, result, win, winAnimator);
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                  ...
                &#125;              
            &#125;
      
    &#125;</code></pre></div>
<p>接下来执行到<code>createSurfaceControl</code></p>
<h6 id="WMS-createSurfaceControl"><a href="#WMS-createSurfaceControl" class="headerlink" title="WMS#createSurfaceControl"></a>WMS#createSurfaceControl</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">createSurfaceControl</span><span class="hljs-params">(Surface outSurface, <span class="hljs-keyword">int</span> result, WindowState win,
        WindowStateAnimator winAnimator)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!win.mHasSurface) &#123;
        result |= RELAYOUT_RES_SURFACE_CHANGED;
    &#125;

    WindowSurfaceController surfaceController;
    <span class="hljs-keyword">try</span> &#123;
        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="hljs-string">"createSurfaceControl"</span>);
      <span class="hljs-comment">//创建SurfaceControl</span>
        surfaceController = winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);
    &#125; <span class="hljs-keyword">finally</span> &#123;
        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
    &#125;
    <span class="hljs-keyword">if</span> (surfaceController != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">//创建Surface</span>
        surfaceController.getSurface(outSurface);
        <span class="hljs-keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(TAG_WM, <span class="hljs-string">"  OUT SURFACE "</span> + outSurface + <span class="hljs-string">": copied"</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// For some reason there isn't a surface.  Clear the</span>
        <span class="hljs-comment">// caller's object so they see the same state.</span>
        Slog.w(TAG_WM, <span class="hljs-string">"Failed to create surface control for "</span> + win);
        outSurface.release();
    &#125;

    <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div>
<p><code>createSurfaceControl()</code>主要执行了两步：</p>
<ul>
<li><code>createSurfaceLocked</code>——创建Layer</li>
<li><code>SurfaceControl#getSurface</code>——创建Surface</li>
</ul>
<h6 id="WMS-createSurfaceLocked"><a href="#WMS-createSurfaceLocked" class="headerlink" title="WMS#createSurfaceLocked"></a>WMS#createSurfaceLocked</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//com/android/server/wm/WindowStateAnimator.java</span>
    <span class="hljs-function">WindowSurfaceController <span class="hljs-title">createSurfaceLocked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> windowType, <span class="hljs-keyword">int</span> ownerUid)</span> </span>&#123;
      ...
            mSurfaceController = <span class="hljs-keyword">new</span> WindowSurfaceController(mSession.mSurfaceSession,
                    attrs.getTitle().toString(), width, height, format, flags, <span class="hljs-keyword">this</span>,
                    windowType, ownerUid);      
      ...
    &#125;

<span class="hljs-comment">//WindowSurfaceController.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WindowSurfaceController</span><span class="hljs-params">(SurfaceSession s, String name, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> format,
            <span class="hljs-keyword">int</span> flags, WindowStateAnimator animator, <span class="hljs-keyword">int</span> windowType, <span class="hljs-keyword">int</span> ownerUid)</span> </span>&#123;
      ...
        <span class="hljs-keyword">final</span> SurfaceControl.Builder b = win.makeSurface()
                .setParent(win.getSurfaceControl())
                .setName(name)
                .setSize(w, h)
                .setFormat(format)
                .setFlags(flags)
                .setMetadata(windowType, ownerUid);
        mSurfaceControl = b.build();      
      ...
    &#125;

<span class="hljs-comment">//SurfaceControl.java</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;
      ...
        <span class="hljs-function"><span class="hljs-keyword">public</span> SurfaceControl <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">if</span> (mWidth &lt;= <span class="hljs-number">0</span> || mHeight &lt;= <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(
                        <span class="hljs-string">"width and height must be set"</span>);
            &#125;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SurfaceControl(mSession, mName, mWidth, mHeight, mFormat,
                    mFlags, mParent, mWindowType, mOwnerUid);
        &#125;      
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SurfaceControl</span><span class="hljs-params">(SurfaceSession session, String name, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> format, <span class="hljs-keyword">int</span> flags,
            SurfaceControl parent, <span class="hljs-keyword">int</span> windowType, <span class="hljs-keyword">int</span> ownerUid)</span>
                    <span class="hljs-keyword">throws</span> OutOfResourcesException, IllegalArgumentException </span>&#123;
      ...
        mNativeObject = nativeCreate(session, name, w, h, format, flags,
            parent != <span class="hljs-keyword">null</span> ? parent.mNativeObject : <span class="hljs-number">0</span>, windowType, ownerUid);
      ...
    &#125;</code></pre></div>
<p>执行<code>nativeCreate</code>切换到Native层执行</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//base/core/jni/android_view_SurfaceControl.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeCreate</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jobject sessionObj,
        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,
        jint windowType, jint ownerUid)</span> </span>&#123;
    <span class="hljs-function">ScopedUtfChars <span class="hljs-title">name</span><span class="hljs-params">(env, nameStr)</span></span>;
    <span class="hljs-function">sp&lt;SurfaceComposerClient&gt; <span class="hljs-title">client</span><span class="hljs-params">(android_view_SurfaceSession_getClient(env, sessionObj))</span></span>;
    SurfaceControl *parent = <span class="hljs-keyword">reinterpret_cast</span>&lt;SurfaceControl*&gt;(parentObject);
    sp&lt;SurfaceControl&gt; surface;
    <span class="hljs-keyword">status_t</span> err = client-&gt;createSurfaceChecked(
            String8(name.c_str()), w, h, format, &amp;surface, flags, parent, windowType, ownerUid);
  ...

    surface-&gt;incStrong((<span class="hljs-keyword">void</span> *)nativeCreate);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());
&#125;</code></pre></div>
<p>在<code>createSurfaceChecked()</code>后续的流程会创建<code>Layer</code></p>
<h6 id="SurfaceControl-getSurface"><a href="#SurfaceControl-getSurface" class="headerlink" title="SurfaceControl#getSurface"></a>SurfaceControl#getSurface</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//WindowSurfaceController.java</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getSurface</span><span class="hljs-params">(Surface outSurface)</span> </span>&#123;
        outSurface.copyFrom(mSurfaceControl);
    &#125;

<span class="hljs-comment">//Surface.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyFrom</span><span class="hljs-params">(SurfaceControl other)</span> </span>&#123;
      ...
        <span class="hljs-comment">//创建Surface</span>
        <span class="hljs-keyword">long</span> newNativeObject = nativeGetFromSurfaceControl(surfaceControlPtr);

    &#125;</code></pre></div>
<p>在<code>nativeGetFromSurfaceControl()</code>创建<code>Surface</code></p>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>先执行<code>ViewRootImpl#setView()</code>，其中会执行</p>
<ul>
<li><p><code>requestLayout</code></p>
<p>内部执行<code>ViewRootImpl#performTraversals()</code>，接下去执行<code>WMS#relayoutWindow()</code>，然后是<code>WMS#createSurfaceControl</code>，分为两步：</p>
<ul>
<li><code>createSurfaceLocked</code>：创建<code>SurfaceControl</code>，内部执行<code>android_view_surfaceControl#nativeCreate</code>，执行<code>SurfaceComponentClient#createSurface</code>，创建<code>Layer</code>对象。</li>
<li><code>WindowSurfaceController#getSurface</code>：执行到<code>Surface#copyFrom()</code>，调用到<code>nativeGetFromSurfaceControl()</code>，内部调用到<code>SurfaceControl#getSurface()</code>去创建<code>Surface</code></li>
</ul>
<p>创建<code>Surface</code>和<code>Layer</code>完毕后，继续执行View的绘制流程<code>measure-&gt;layout-&gt;draw</code></p>
</li>
<li><p><code>WindowSession#addToDisplay()</code></p>
<p>执行到<code>WMS#addWindow()</code>，继续到<code>Session#windowAddedLocked()</code>，切换到<code>Native</code>层执行<code>android_view_surfaceSession#native_create()</code>在其中创建了<code>SurfaceComponentClient</code>。</p>
</li>
</ul>
</blockquote>
<h4 id="Surface、Layer的创建"><a href="#Surface、Layer的创建" class="headerlink" title="Surface、Layer的创建"></a>Surface、Layer的创建</h4><p>根据上节源码分析可以知道，<code>Surface、Layer</code>的创建主要分为以下几步</p>
<h5 id="创建SurfaceComponentClient"><a href="#创建SurfaceComponentClient" class="headerlink" title="创建SurfaceComponentClient"></a>创建SurfaceComponentClient</h5><blockquote>
<p>App进程与<code>SurfaceFlinger</code>沟通的桥梁。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/SurfaceComposerClient.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceComposerClient::onFirstRef</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-function">sp&lt;ISurfaceComposer&gt; <span class="hljs-title">sf</span><span class="hljs-params">(ComposerService::getComposerService())</span></span>;
    <span class="hljs-keyword">if</span> (sf != <span class="hljs-number">0</span> &amp;&amp; mStatus == NO_INIT) &#123;
        <span class="hljs-keyword">auto</span> rootProducer = mParent.promote();
        sp&lt;ISurfaceComposerClient&gt; conn;
        conn = (rootProducer != <span class="hljs-literal">nullptr</span>) ? sf-&gt;createScopedConnection(rootProducer) :
                sf-&gt;createConnection();
      ...
    &#125;
&#125;</code></pre></div>
<p>其中<code>ComposerService</code>就是<code>SurfaceFlinger</code>的Binder代理对象，<code>SurfaceComponentClient</code>通过<code>ComposerService</code>与<code>SurfaceFlinger</code>进行通信。</p>
<h6 id="ComposerService"><a href="#ComposerService" class="headerlink" title="ComposerService"></a>ComposerService</h6><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/SurfaceComposerClient.cpp</span>
<span class="hljs-comment">/*static*/</span> <span class="hljs-function">sp&lt;ISurfaceComposer&gt; <span class="hljs-title">ComposerService::getComposerService</span><span class="hljs-params">()</span> </span>&#123;
    ComposerService&amp; instance = ComposerService::getInstance();
    <span class="hljs-keyword">if</span> (instance.mComposerService == <span class="hljs-literal">NULL</span>) &#123;
        ComposerService::getInstance().connectLocked();
    &#125;
    <span class="hljs-keyword">return</span> instance.mComposerService;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ComposerService::connectLocked</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">const</span> String16 <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">"SurfaceFlinger"</span>)</span></span>;
  <span class="hljs-comment">//获取SurfaceFlinger 服务</span>
    <span class="hljs-keyword">while</span> (getService(name, &amp;mComposerService) != NO_ERROR) &#123;
        usleep(<span class="hljs-number">250000</span>);
    &#125;
    assert(mComposerService != <span class="hljs-literal">NULL</span>);
&#125;

<span class="hljs-comment">//native/libs/binder/include/binder/IServiceManager.h</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">getService</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String16&amp; name, sp&lt;INTERFACE&gt;* outService)</span>
</span>&#123;
    <span class="hljs-keyword">const</span> sp&lt;IServiceManager&gt; sm = defaultServiceManager();
    <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">NULL</span>) &#123;
        *outService = interface_cast&lt;INTERFACE&gt;(sm-&gt;getService(name));
        <span class="hljs-keyword">if</span> ((*outService) != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> NO_ERROR;
    &#125;
    <span class="hljs-keyword">return</span> NAME_NOT_FOUND;
&#125;</code></pre></div>
<h6 id="SurfaceFlinger-createConnection"><a href="#SurfaceFlinger-createConnection" class="headerlink" title="SurfaceFlinger#createConnection"></a>SurfaceFlinger#createConnection</h6><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/SurfaceFlinger.cpp</span>
<span class="hljs-function">sp&lt;ISurfaceComposerClient&gt; <span class="hljs-title">SurfaceFlinger::createConnection</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> initClient(<span class="hljs-keyword">new</span> Client(<span class="hljs-keyword">this</span>));
&#125;

<span class="hljs-function"><span class="hljs-keyword">static</span> sp&lt;ISurfaceComposerClient&gt; <span class="hljs-title">initClient</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;Client&gt;&amp; client)</span> </span>&#123;
  <span class="hljs-comment">//检查Client是否合法</span>
    <span class="hljs-keyword">status_t</span> err = client-&gt;initCheck();
    <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;
        <span class="hljs-keyword">return</span> client;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
&#125;</code></pre></div>
<p>其中<code>Client</code>内部封装的是<strong>创建和销毁Layer和Surface的操作函数。</strong></p>
<blockquote>
<p><code>Client</code>实现了<code>ISurfaceComposerClient</code>接口，<code>SurfaceComposerClient</code>通过<code>Client</code>和<code>SurfaceFlinger</code>进行通讯。</p>
<p>除此之外还可以创建<code>Surface</code>以及维护<code>Layer</code>对象。</p>
</blockquote>
<h5 id="创建SurfaceControl并创建Layer"><a href="#创建SurfaceControl并创建Layer" class="headerlink" title="创建SurfaceControl并创建Layer"></a>创建SurfaceControl并创建Layer</h5><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">SurfaceComposerClient::createSurfaceChecked</span><span class="hljs-params">(
        <span class="hljs-keyword">const</span> String8&amp; name,
        <span class="hljs-keyword">uint32_t</span> w,
        <span class="hljs-keyword">uint32_t</span> h,
        PixelFormat format,
        sp&lt;SurfaceControl&gt;* outSurface,
        <span class="hljs-keyword">uint32_t</span> flags,
        SurfaceControl* parent,
        <span class="hljs-keyword">int32_t</span> windowType,
        <span class="hljs-keyword">int32_t</span> ownerUid)</span>
</span>&#123;
    sp&lt;SurfaceControl&gt; sur;
    <span class="hljs-keyword">status_t</span> err = mStatus;
      
        err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle,
                windowType, ownerUid, &amp;handle, &amp;gbp);
        <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;
            *outSurface = <span class="hljs-keyword">new</span> SurfaceControl(<span class="hljs-keyword">this</span>, handle, gbp, <span class="hljs-literal">true</span> <span class="hljs-comment">/* owned */</span>);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> err;
&#125;</code></pre></div>
<h6 id="Client-createSurface"><a href="#Client-createSurface" class="headerlink" title="Client#createSurface"></a>Client#createSurface</h6><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/Client.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Client::createSurface</span><span class="hljs-params">(
        <span class="hljs-keyword">const</span> String8&amp; name,
        <span class="hljs-keyword">uint32_t</span> w, <span class="hljs-keyword">uint32_t</span> h, PixelFormat format, <span class="hljs-keyword">uint32_t</span> flags,
        <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; parentHandle, <span class="hljs-keyword">int32_t</span> windowType, <span class="hljs-keyword">int32_t</span> ownerUid,
        sp&lt;IBinder&gt;* handle,
        sp&lt;IGraphicBufferProducer&gt;* gbp)</span>
</span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCreateLayer</span> :</span> <span class="hljs-keyword">public</span> MessageBase &#123;
        SurfaceFlinger* flinger;
        Client* client;
        sp&lt;IBinder&gt;* handle;
        sp&lt;IGraphicBufferProducer&gt;* gbp;
        <span class="hljs-keyword">status_t</span> result;
        <span class="hljs-keyword">const</span> String8&amp; name;
        <span class="hljs-keyword">uint32_t</span> w, h;
        PixelFormat format;
        <span class="hljs-keyword">uint32_t</span> flags;
        sp&lt;Layer&gt;* parent;
        <span class="hljs-keyword">int32_t</span> windowType;
        <span class="hljs-keyword">int32_t</span> ownerUid;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">handler</span><span class="hljs-params">()</span> </span>&#123;
            result = flinger-&gt;createLayer(name, client, w, h, format, flags,
                    windowType, ownerUid, handle, gbp, parent);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
    &#125;;
  
    sp&lt;MessageBase&gt; msg = <span class="hljs-keyword">new</span> MessageCreateLayer(mFlinger.get(),
            name, <span class="hljs-keyword">this</span>, w, h, format, flags, handle,
            windowType, ownerUid, gbp, &amp;parent);
    mFlinger-&gt;postMessageSync(msg);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();  
&#125;</code></pre></div>
<p>通过<code>postMessageSync()</code>发送消息，处理后回调到<code>handler()</code>，继续执行<code>createLayer()</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/SurfaceFlinger.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">SurfaceFlinger::createLayer</span><span class="hljs-params">(
        <span class="hljs-keyword">const</span> String8&amp; name,
        <span class="hljs-keyword">const</span> sp&lt;Client&gt;&amp; client,
        <span class="hljs-keyword">uint32_t</span> w, <span class="hljs-keyword">uint32_t</span> h, PixelFormat format, <span class="hljs-keyword">uint32_t</span> flags,
        <span class="hljs-keyword">int32_t</span> windowType, <span class="hljs-keyword">int32_t</span> ownerUid, sp&lt;IBinder&gt;* handle,
        sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* parent)</span>
</span>&#123;
  ...
    <span class="hljs-keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;
        <span class="hljs-keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:
            result = createBufferLayer(client,
                    uniqueName, w, h, flags, format,
                    handle, gbp, &amp;layer);

            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> ISurfaceComposerClient::eFXSurfaceColor:
            result = createColorLayer(client,
                    uniqueName, w, h, flags,
                    handle, &amp;layer);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            result = BAD_VALUE;
            <span class="hljs-keyword">break</span>;
    &#125;
  ...  
  
&#125;

<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">SurfaceFlinger::createBufferLayer</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;Client&gt;&amp; client,
        <span class="hljs-keyword">const</span> String8&amp; name, <span class="hljs-keyword">uint32_t</span> w, <span class="hljs-keyword">uint32_t</span> h, <span class="hljs-keyword">uint32_t</span> flags, PixelFormat&amp; format,
        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span>
</span>&#123;
 ...
   <span class="hljs-comment">//创建Layer对象</span>
    sp&lt;BufferLayer&gt; layer = <span class="hljs-keyword">new</span> BufferLayer(<span class="hljs-keyword">this</span>, client, name, w, h, flags);   
 ...
&#125;</code></pre></div>
<p><code>createSurface</code>执行到最后，构建出<code>Layer</code>对象。</p>
<h6 id="new-SurfaceControl"><a href="#new-SurfaceControl" class="headerlink" title="new SurfaceControl"></a>new SurfaceControl</h6><blockquote>
<p><code>SurfaceControl</code>主要作用就是<strong>维护Surface</strong>。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/SurfaceControl.cpp</span>
SurfaceControl::SurfaceControl(
        <span class="hljs-keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,
        <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; handle,
        <span class="hljs-keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbp,
        <span class="hljs-keyword">bool</span> owned)
    : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp), mOwned(owned)
&#123;
&#125;</code></pre></div>
<p>创建SurfaceControl之后，仅仅是设置了<code>mClient</code>以及创建了<code>GraphicBufferProducer</code>对象。</p>
<h5 id="通过SurfaceControl创建Surface"><a href="#通过SurfaceControl创建Surface" class="headerlink" title="通过SurfaceControl创建Surface"></a>通过SurfaceControl创建Surface</h5><p>此时已经创建完毕<code>Surfacecontrol</code>和<code>Layer</code>对象。</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//</span>
<span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">SurfaceControl::getSurface</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>&#123;
    Mutex::Autolock _l(mLock);
    <span class="hljs-keyword">if</span> (mSurfaceData == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">return</span> generateSurfaceLocked();
    &#125;
    <span class="hljs-keyword">return</span> mSurfaceData;
&#125;

<span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">SurfaceControl::generateSurfaceLocked</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>&#123;
  <span class="hljs-comment">//构造Surface对象</span>
    mSurfaceData = <span class="hljs-keyword">new</span> Surface(mGraphicBufferProducer, <span class="hljs-literal">false</span>);

    <span class="hljs-keyword">return</span> mSurfaceData;
&#125;</code></pre></div>
<p><code>Native</code>层的<code>Surface</code>创建完毕后，返回到<code>Java</code>层进行赋值。</p>
<h4 id="BufferQueue的创建"><a href="#BufferQueue的创建" class="headerlink" title="BufferQueue的创建"></a>BufferQueue的创建</h4><p>在创建<code>Layer</code>完成后，后续就会继续去创建<code>BufferQueue</code></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//BufferLayer.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BufferLayer::onFirstRef</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span>
    sp&lt;IGraphicBufferProducer&gt; producer;
    sp&lt;IGraphicBufferConsumer&gt; consumer;
  <span class="hljs-comment">//创建BufferQueue对象</span>
    BufferQueue::createBufferQueue(&amp;producer, &amp;consumer, <span class="hljs-literal">true</span>);
    mProducer = <span class="hljs-keyword">new</span> MonitoredProducer(producer, mFlinger, <span class="hljs-keyword">this</span>);
    mConsumer = <span class="hljs-keyword">new</span> BufferLayerConsumer(consumer,
            mFlinger-&gt;getRenderEngine(), mTextureName, <span class="hljs-keyword">this</span>);
    mConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="hljs-number">0</span>));
    mConsumer-&gt;setContentsChangedListener(<span class="hljs-keyword">this</span>);
    mConsumer-&gt;setName(mName);

    <span class="hljs-keyword">if</span> (mFlinger-&gt;isLayerTripleBufferingDisabled()) &#123;
        mProducer-&gt;setMaxDequeuedBufferCount(<span class="hljs-number">2</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mFlinger-&gt;getDefaultDisplayDevice())</span></span>;
    updateTransformHint(hw);
&#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueue.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BufferQueue::createBufferQueue</span><span class="hljs-params">(sp&lt;IGraphicBufferProducer&gt;* outProducer,
        sp&lt;IGraphicBufferConsumer&gt;* outConsumer,
        <span class="hljs-keyword">bool</span> consumerIsSurfaceFlinger)</span> </span>&#123;
  <span class="hljs-comment">//创建BufferQueueCore</span>
    <span class="hljs-function">sp&lt;BufferQueueCore&gt; <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BufferQueueCore())</span></span>;
  <span class="hljs-comment">//创建BufferQueueProducer</span>
    <span class="hljs-function">sp&lt;IGraphicBufferProducer&gt; <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BufferQueueProducer(core, consumerIsSurfaceFlinger))</span></span>;
  <span class="hljs-comment">//创建BufferQueueConsumer</span>
    <span class="hljs-function">sp&lt;IGraphicBufferConsumer&gt; <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BufferQueueConsumer(core))</span></span>;
  
    *outProducer = producer;
    *outConsumer = consumer;
&#125;</code></pre></div>
<p><code>createBufferQueue</code>主要创建以下三个对象：</p>
<ul>
<li><code>BufferQueueCore</code></li>
<li><code>BufferQueueProducer</code></li>
<li><code>BufferQueueConsumer</code></li>
</ul>
<h5 id="BufferQueueCore"><a href="#BufferQueueCore" class="headerlink" title="BufferQueueCore"></a>BufferQueueCore</h5><blockquote>
<p>主要用来存放<code>GraphicBuffer</code>，并且存放最多<strong>64</strong>个。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/include/gui/BufferQueueCore.h</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferQueueCore</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> RefBase &#123;

    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferQueueProducer</span>;</span>
    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferQueueConsumer</span>;</span>
<span class="hljs-keyword">public</span>:
  ...
<span class="hljs-keyword">private</span>:
  ...
    BufferQueueDefs::SlotsType mSlots;
    Fifo mQueue;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; mFreeSlots;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; mFreeBuffers;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; mUnusedSlots;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; mActiveBuffers;
  ...
&#125;</code></pre></div>
<p>主要有以下几个对象：</p>
<ul>
<li><code>mSlots</code>：大小为<code>NUM_BUFFER_SLOTS(64)</code>的数组，存储数据为<code>BufferSlot</code></li>
<li><code>mQueue</code>：以<code>先进先出对了</code>存放<code>生产者生产的数据</code>，保证按照顺序取出</li>
<li><code>mFreeSlots</code>：尚未绑定<code>GraphicBuffer</code>且<code>state = FREE</code>的<code>BufferSlot</code>集合</li>
<li><code>mFreeBuffers</code>：已经绑定了<code>GraphicBuffer</code>且<code>state = FREE</code>的<code>BufferSlot</code>集合</li>
<li><code>mActiveBuffers</code>：已经绑定了<code>GraphicBuffer</code>且<code>state!=FREE</code>的<code>BufferSlot</code>集合</li>
<li><code>mUnusedSlots</code>：没有绑定<code>GraphicBuffer</code>且没有状态的<code>BufferSlot</code>集合</li>
</ul>
<p>主要介绍<code>BufferSlot</code>，<code>BufferQueueCore</code>基本是<code>BufferSlot</code>的各种集合</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BufferSlot</span> &#123;</span>

    BufferSlot()
    : mGraphicBuffer(<span class="hljs-literal">nullptr</span>),
      mBufferState(),
  ...
   <span class="hljs-comment">//绑定的 GraphicBuffer</span>
    sp&lt;GraphicBuffer&gt; mGraphicBuffer;
   <span class="hljs-comment">//绑定的BufferSlot 状态</span>
    BufferState mBufferState;
&#125;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BufferState</span> &#123;</span>

    <span class="hljs-comment">// All slots are initially FREE (not dequeued, queued, acquired, or shared).</span>
    BufferState()
    : mDequeueCount(<span class="hljs-number">0</span>),
      mQueueCount(<span class="hljs-number">0</span>),
      mAcquireCount(<span class="hljs-number">0</span>),
      mShared(<span class="hljs-literal">false</span>) &#123;
    &#125;
  
    <span class="hljs-comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span>
    <span class="hljs-comment">// --------|---------|---------------|-------------|---------------|</span>
    <span class="hljs-comment">// FREE    |  false  |       0       |      0      |       0       |</span>
    <span class="hljs-comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span>
    <span class="hljs-comment">// QUEUED  |  false  |       0       |      1      |       0       |</span>
    <span class="hljs-comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span>
    <span class="hljs-comment">// SHARED  |  true   |      any      |     any     |      any      |      </span>
&#125;</code></pre></div>
<p>主要由两部分构成：</p>
<ul>
<li><code>mGraphicBuffer</code>：<code>BufferSlot</code>所绑定的<code>GraphicBuffer</code></li>
<li><code>mBufferState</code>：表示当前<code>BufferSlot</code>的状态，主要有以下几种状态：<ul>
<li><code>FREE</code>：空闲状态，存入<code>mFreeSlots</code></li>
<li><code>DEQUEUED</code>：被<code>生产者</code>获取，待绘制数据</li>
<li><code>QUEUED</code>：被<code>BufferQueue</code>获取，待<code>消费者</code>获取。</li>
<li><code>ACQUIRED</code>：被<code>消费者</code>获取，待获取绘制数据</li>
<li><code>SHARED</code>：处于共享状态。</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>BufferQueueCore</code>设置了这么多的<code>BufferSlot</code>集合，主要为了<strong>分类BufferSlot时更高效</strong>。</p>
</blockquote>
<h5 id="BufferQueueProducer"><a href="#BufferQueueProducer" class="headerlink" title="BufferQueueProducer"></a>BufferQueueProducer</h5><blockquote>
<p><code>Surface</code>中持有<code>BufferQueueProducer</code>的BP代理对象-<code>IGraphicBufferProducer</code>。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span>
BufferQueueProducer::BufferQueueProducer(<span class="hljs-keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core,
        <span class="hljs-keyword">bool</span> consumerIsSurfaceFlinger) :
    mCore(core),
    mSlots(core-&gt;mSlots),
...
&#125;

<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,
                                            <span class="hljs-keyword">uint32_t</span> width, <span class="hljs-keyword">uint32_t</span> height, PixelFormat format,
                                            <span class="hljs-keyword">uint64_t</span> usage, <span class="hljs-keyword">uint64_t</span>* outBufferAge,
                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;
 ... 
&#125;

<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::queueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> slot,
        <span class="hljs-keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;
  ...
&#125;</code></pre></div>
<p>初始化了<code>mCore</code>和<code>mSlots</code>对象</p>
<h6 id="dequeueBuffer"><a href="#dequeueBuffer" class="headerlink" title="dequeueBuffer"></a>dequeueBuffer</h6><blockquote>
<p>向<code>BufferQueue</code>申请一块<code>GraphicBuffer</code>。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>为<code>DEQUEUED</code>。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,
                                            <span class="hljs-keyword">uint32_t</span> width, <span class="hljs-keyword">uint32_t</span> height, PixelFormat format,
                                            <span class="hljs-keyword">uint64_t</span> usage, <span class="hljs-keyword">uint64_t</span>* outBufferAge,
                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;
        <span class="hljs-keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;
            <span class="hljs-keyword">status_t</span> status = waitForFreeSlotThenRelock(FreeSlotCaller::Dequeue,
                    &amp;found);
           ...     
        &#125;
  ...
        <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferSlot != found) &#123;
            mCore-&gt;mActiveBuffers.insert(found);
        &#125;
        *outSlot = found;  
  ...
        mSlots[found].mBufferState.dequeue();

        <span class="hljs-keyword">if</span> ((buffer == <span class="hljs-literal">NULL</span>) ||
                buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage))
        &#123;
            mSlots[found].mAcquireCalled = <span class="hljs-literal">false</span>;
            mSlots[found].mGraphicBuffer = <span class="hljs-literal">NULL</span>;
            mSlots[found].mRequestBufferCalled = <span class="hljs-literal">false</span>;
            mSlots[found].mEglDisplay = EGL_NO_DISPLAY;
            mSlots[found].mEglFence = EGL_NO_SYNC_KHR;
            mSlots[found].mFence = Fence::NO_FENCE;
            mCore-&gt;mBufferAge = <span class="hljs-number">0</span>;
            mCore-&gt;mIsAllocating = <span class="hljs-literal">true</span>;

            returnFlags |= BUFFER_NEEDS_REALLOCATION;
        &#125; 
      ...
    <span class="hljs-keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;
        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="hljs-keyword">new</span> GraphicBuffer(
                width, height, format, BQ_LAYER_COUNT, usage,
                &#123;mConsumerName.<span class="hljs-built_in">string</span>(), mConsumerName.size()&#125;);
      &#123;
            <span class="hljs-keyword">if</span> (error == NO_ERROR &amp;&amp; !mCore-&gt;mIsAbandoned) &#123;
                graphicBuffer-&gt;setGenerationNumber(mCore-&gt;mGenerationNumber);
                mSlots[*outSlot].mGraphicBuffer = graphicBuffer;
            &#125;      
      &#125;
    &#125;
  
&#125;

<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::waitForFreeSlotThenRelock</span><span class="hljs-params">(FreeSlotCaller caller,
        <span class="hljs-keyword">int</span>* found)</span> <span class="hljs-keyword">const</span> </span>&#123;
  ...
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxBufferCount = mCore-&gt;getMaxBufferCountLocked();
        <span class="hljs-keyword">bool</span> tooManyBuffers = mCore-&gt;mQueue.size()
                            &gt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(maxBufferCount);
        <span class="hljs-keyword">if</span> (tooManyBuffers) &#123;
            BQ_LOGV(<span class="hljs-string">"%s: queue size is %zu, waiting"</span>, callerString,
                    mCore-&gt;mQueue.size());
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// If in shared buffer mode and a shared buffer exists, always</span>
            <span class="hljs-comment">// return it.</span>
            <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot !=
                    BufferQueueCore::INVALID_BUFFER_SLOT) &#123;
                *found = mCore-&gt;mSharedBufferSlot;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">if</span> (caller == FreeSlotCaller::Dequeue) &#123;
                    <span class="hljs-comment">// If we're calling this from dequeue, prefer free buffers</span>
                    <span class="hljs-keyword">int</span> slot = getFreeBufferLocked();
                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;
                        *found = slot;
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCore-&gt;mAllowAllocation) &#123;
                        *found = getFreeSlotLocked();
                    &#125;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// If we're calling this from attach, prefer free slots</span>
                    <span class="hljs-keyword">int</span> slot = getFreeSlotLocked();
                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;
                        *found = slot;
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        *found = getFreeBufferLocked();
                    &#125;
                &#125;
            &#125;
        &#125;
  ...
  
&#125;</code></pre></div>
<h6 id="queueBuffer"><a href="#queueBuffer" class="headerlink" title="queueBuffer"></a>queueBuffer</h6><blockquote>
<p>在<code>生产者</code>填充数据到<code>GraphicBuffer</code>完毕后，通过<code>queueBuffer</code>把<code>GraphicBuffer</code>放回到<code>BufferQueue</code>。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>QUEUED</code>。</p>
</blockquote>
<h5 id="BufferQueueConsumer"><a href="#BufferQueueConsumer" class="headerlink" title="BufferQueueConsumer"></a>BufferQueueConsumer</h5><blockquote>
<p><code>SurfaceFlinger</code>通过<code>BufferQueueConsumer</code>来获取以及释放<code>GraphicBuffer</code></p>
</blockquote>
<h6 id="acquireBuffer"><a href="#acquireBuffer" class="headerlink" title="acquireBuffer"></a>acquireBuffer</h6><blockquote>
<p><code>消费者</code>向<code>BufferQueue</code>申请<code>已被填充数据的GraphicBuffer</code>进行消费。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>ACQUIRED</code>。</p>
</blockquote>
<h6 id="releaseBuffer"><a href="#releaseBuffer" class="headerlink" title="releaseBuffer"></a>releaseBuffer</h6><blockquote>
<p><code>消费者</code>消费完毕后，通知<code>BufferQueueCore</code>已消费完毕，并返回<code>空GraphicBuffer</code>到<code>BufferQueue</code></p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>FREE</code>。</p>
</blockquote>
<h4 id="GraphicBuffer的创建"><a href="#GraphicBuffer的创建" class="headerlink" title="GraphicBuffer的创建"></a>GraphicBuffer的创建</h4><h4 id="图像缓冲区的使用场景"><a href="#图像缓冲区的使用场景" class="headerlink" title="图像缓冲区的使用场景"></a>图像缓冲区的使用场景</h4><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">SurfaceFlinger 解读</a></p>
<p><a href="https://blog.csdn.net/tyuiof/article/details/108434845" target="_blank" rel="noopener">掌握Android图像显示原理-上</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/14/Android性能优化-自动内存分析/">
                        <span class="hidden-mobile">Android性能优化-自动内存分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>







  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
