

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <meta name="description" content="基于Android 6.0源码进行分析  SurfaceFlinger是Android系统中最重要的图像消费者，Activity绘制的界面图像，都会传递到SurfaceFlinger中。 主要作用：接收图像缓冲区数据，然后交给HWComposer或OpenGL合成，合成完毕后再返回。  SurfaceFlinger初始化init通过执行surfaceflinger.rc文件，然后就执行到了ma">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android-SurfaceFlinger解析">
<meta property="og:url" content="https://leo-wxy.github.io/2020/12/21/Android-SurfaceFlinger解析/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="基于Android 6.0源码进行分析  SurfaceFlinger是Android系统中最重要的图像消费者，Activity绘制的界面图像，都会传递到SurfaceFlinger中。 主要作用：接收图像缓冲区数据，然后交给HWComposer或OpenGL合成，合成完毕后再返回。  SurfaceFlinger初始化init通过执行surfaceflinger.rc文件，然后就执行到了ma">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://leo-wxy.github.io/images/SurfaceFlinger执行流程.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/Sf初始化.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/SF接收Vsync信号.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/SF处理Vsync信号.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/BufferQueue执行流程.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/SF-Surface和Layer创建准备.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/SF-Buffer、Layer创建过程.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/SF-BufferQueueCore.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/SF-BufferQueue-dequeueBuffer.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/BufferSlot状态转变过程.jpg">
<meta property="og:updated_time" content="2021-01-29T08:10:40.000Z">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Android-SurfaceFlinger解析">
<meta name="twitter:description" content="基于Android 6.0源码进行分析  SurfaceFlinger是Android系统中最重要的图像消费者，Activity绘制的界面图像，都会传递到SurfaceFlinger中。 主要作用：接收图像缓冲区数据，然后交给HWComposer或OpenGL合成，合成完毕后再返回。  SurfaceFlinger初始化init通过执行surfaceflinger.rc文件，然后就执行到了ma">
<meta name="twitter:image" content="https://leo-wxy.github.io/images/SurfaceFlinger执行流程.jpg">
  
  <title>Android-SurfaceFlinger解析 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.12","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android-SurfaceFlinger解析">
              
                Android-SurfaceFlinger解析
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-21 15:06" pubdate>
        2020年12月21日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      89k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      279 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android-SurfaceFlinger解析</h1>
            
            <div class="markdown-body">
              <blockquote>
<p> 基于<code>Android 6.0</code>源码进行分析</p>
</blockquote>
<p><code>SurfaceFlinger</code>是Android系统中最重要的<strong>图像消费者</strong>，Activity绘制的界面图像，都会传递到<code>SurfaceFlinger</code>中。</p>
<p>主要作用：<strong>接收图像缓冲区数据，然后交给HWComposer或OpenGL合成，合成完毕后再返回。</strong></p>
<p><img src="/images/SurfaceFlinger执行流程.jpg" srcset="/img/loading.gif" lazyload alt="SurfaceFlinger执行流程"></p>
<h2 id="SurfaceFlinger初始化"><a href="#SurfaceFlinger初始化" class="headerlink" title="SurfaceFlinger初始化"></a>SurfaceFlinger初始化</h2><p><code>init</code>通过执行<code>surfaceflinger.rc</code>文件，然后就执行到了<code>main_surfaceflinger.cpp</code>开始初始化流程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>**)</span> </span>&#123;<br>    signal(SIGPIPE, SIG_IGN);<br><br>    hardware::configureRpcThreadpool(<span class="hljs-number">1</span> <span class="hljs-comment">/* maxThreads */</span>,<br>            <span class="hljs-literal">false</span> <span class="hljs-comment">/* callerWillJoin */</span>);<br><br>    startGraphicsAllocatorService();<br><br>   <span class="hljs-comment">//设置支持最多 4个 binder线程执行</span><br>    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// start the thread pool</span><br>    <span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ps</span><span class="hljs-params">(ProcessState::self())</span></span>;<br>    ps-&gt;startThreadPool();<br><br>    <span class="hljs-comment">//构建 Surfaceflinger实例</span><br>    sp&lt;SurfaceFlinger&gt; flinger = <span class="hljs-keyword">new</span> SurfaceFlinger();<br><br>    <span class="hljs-comment">// 执行初始化流程</span><br>    flinger-&gt;init();<br><br>    <span class="hljs-comment">// 通过ServiceManager注册 SurfaceFlinger服务</span><br>    <span class="hljs-function">sp&lt;IServiceManager&gt; <span class="hljs-title">sm</span><span class="hljs-params">(defaultServiceManager())</span></span>;<br>    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="hljs-literal">false</span>,<br>                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);<br><br>    startDisplayService(); <span class="hljs-comment">// dependency on SF getting registered above</span><br><br>    <span class="hljs-comment">// 开始运行</span><br>    flinger-&gt;run();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="new-SurfaceFlinger"><a href="#new-SurfaceFlinger" class="headerlink" title="new SurfaceFlinger"></a>new SurfaceFlinger</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onFirstRef</span><span class="hljs-params">()</span><br></span>&#123;<br>    mEventQueue-&gt;init(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>mEventQueue</code>执行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::init</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span> </span>&#123;<br>    mFlinger = flinger;<br>    mLooper = <span class="hljs-keyword">new</span> Looper(<span class="hljs-literal">true</span>);<br>    mHandler = <span class="hljs-keyword">new</span> Handler(*<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>初始化<code>Handler</code></p>
<h3 id="SurfaceFlinger-init"><a href="#SurfaceFlinger-init" class="headerlink" title="SurfaceFlinger#init"></a>SurfaceFlinger#init</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;<br>    ALOGI(  <span class="hljs-string">"SurfaceFlinger's main thread ready to run. "</span><br>            <span class="hljs-string">"Initializing graphics H/W..."</span>);<br><br>    ALOGI(<span class="hljs-string">"Phase offest NS: %"</span> PRId64 <span class="hljs-string">""</span>, vsyncPhaseOffsetNs);<br><br>    Mutex::Autolock _l(mStateLock);<br><br>    <span class="hljs-comment">// start the EventThread</span><br>    mEventThreadSource =<br>            <span class="hljs-built_in">std</span>::make_unique&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs,<br>                                             <span class="hljs-literal">true</span>, <span class="hljs-string">"app"</span>);<br>    mEventThread = <span class="hljs-built_in">std</span>::make_unique&lt;impl::EventThread&gt;(mEventThreadSource.get(),<br>                                                       [<span class="hljs-keyword">this</span>]() &#123; resyncWithRateLimit(); &#125;,<br>                                                       impl::EventThread::InterceptVSyncsCallback(),<br>                                                       <span class="hljs-string">"appEventThread"</span>);<br>    mSfEventThreadSource =<br>            <span class="hljs-built_in">std</span>::make_unique&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync,<br>                                             SurfaceFlinger::sfVsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">"sf"</span>);<br><br>    mSFEventThread =<br>            <span class="hljs-built_in">std</span>::make_unique&lt;impl::EventThread&gt;(mSfEventThreadSource.get(),<br>                                                [<span class="hljs-keyword">this</span>]() &#123; resyncWithRateLimit(); &#125;,<br>                                                [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">nsecs_t</span> timestamp) &#123;<br>                                                    mInterceptor-&gt;saveVSyncEvent(timestamp);<br>                                                &#125;,<br>                                                <span class="hljs-string">"sfEventThread"</span>);<br>    mEventQueue-&gt;setEventThread(mSFEventThread.get());<br>    mVsyncModulator.setEventThread(mSFEventThread.get());<br><br>    <span class="hljs-comment">// Get a RenderEngine for the given display / config (can't fail)</span><br>    getBE().mRenderEngine =<br>            RE::impl::RenderEngine::create(HAL_PIXEL_FORMAT_RGBA_8888,<br>                                           hasWideColorDisplay<br>                                                   ? RE::RenderEngine::WIDE_COLOR_SUPPORT<br>                                                   : <span class="hljs-number">0</span>);<br>  <br>    getBE().mHwc.reset(<br>            <span class="hljs-keyword">new</span> HWComposer(<span class="hljs-built_in">std</span>::make_unique&lt;Hwc2::impl::Composer&gt;(getBE().mHwcServiceName)));<br>    getBE().mHwc-&gt;registerCallback(<span class="hljs-keyword">this</span>, getBE().mComposerSequenceId);<br>    <span class="hljs-comment">// Process any initial hotplug and resulting display changes.</span><br>    processDisplayHotplugEventsLocked();<br>    LOG_ALWAYS_FATAL_IF(!getBE().mHwc-&gt;isConnected(HWC_DISPLAY_PRIMARY),<br>            <span class="hljs-string">"Registered composer callback but didn't create the default primary display"</span>);<br><br>    <span class="hljs-comment">// make the default display GLContext current so that we can create textures</span><br>    <span class="hljs-comment">// when creating Layers (which may happens before we render something)</span><br>    getDefaultDisplayDeviceLocked()-&gt;makeCurrent();<br><br>    mEventControlThread = <span class="hljs-built_in">std</span>::make_unique&lt;impl::EventControlThread&gt;(<br>            [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">bool</span> enabled) &#123; setVsyncEnabled(HWC_DISPLAY_PRIMARY, enabled); &#125;);<br><br>    <span class="hljs-comment">// initialize our drawing state</span><br>    mDrawingState = mCurrentState;<br><br>    <span class="hljs-comment">// set initial conditions (e.g. unblank default device)</span><br>    initializeDisplays();<br><br>    getBE().mRenderEngine-&gt;primeCache();<br><br>    <span class="hljs-comment">// Inform native graphics APIs whether the present timestamp is supported:</span><br>    <span class="hljs-keyword">if</span> (getHwComposer().hasCapability(<br>            HWC2::Capability::PresentFenceIsNotReliable)) &#123;<br>        mStartPropertySetThread = <span class="hljs-keyword">new</span> StartPropertySetThread(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mStartPropertySetThread = <span class="hljs-keyword">new</span> StartPropertySetThread(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mStartPropertySetThread-&gt;Start() != NO_ERROR) &#123;<br>        ALOGE(<span class="hljs-string">"Run StartPropertySetThread failed!"</span>);<br>    &#125;<br><br>    mLegacySrgbSaturationMatrix = getBE().mHwc-&gt;getDataspaceSaturationMatrix(HWC_DISPLAY_PRIMARY,<br>            Dataspace::SRGB_LINEAR);<br><br>    ALOGV(<span class="hljs-string">"Done initializing"</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="创建HWComposer"><a href="#创建HWComposer" class="headerlink" title="创建HWComposer"></a>创建HWComposer</h4><blockquote>
<p><code>HWComposer</code>代表着硬件显示设备。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span><br>HWComposer::HWComposer(<br>        <span class="hljs-keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,<br>        EventHandler&amp; handler)<br>    : mFlinger(flinger),<br>      mFbDev(<span class="hljs-number">0</span>), mHwc(<span class="hljs-number">0</span>), mNumDisplays(<span class="hljs-number">1</span>),<br>      mCBContext(<span class="hljs-keyword">new</span> cb_context),<br>      mEventHandler(handler),<br>      mDebugForceFakeVSync(<span class="hljs-literal">false</span>)<br>&#123;<br>    ...     <br>    <span class="hljs-keyword">bool</span> needVSyncThread = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// Note: some devices may insist that the FB HAL be opened before HWC.</span><br>    <span class="hljs-keyword">int</span> fberr = loadFbHalModule();<br>    loadHwcModule();<span class="hljs-comment">//加载HWComposer模块</span><br><br>    <span class="hljs-comment">// these display IDs are always reserved</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;<br>        mAllocatedDisplayIDs.markBit(i);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mHwc) &#123;<br>        ALOGI(<span class="hljs-string">"Using %s version %u.%u"</span>, HWC_HARDWARE_COMPOSER,<br>              (hwcApiVersion(mHwc) &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>,<br>              (hwcApiVersion(mHwc) &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>);<br>        <span class="hljs-keyword">if</span> (mHwc-&gt;registerProcs) &#123;<br>            mCBContext-&gt;hwc = <span class="hljs-keyword">this</span>;<br>            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;<br>          <span class="hljs-comment">//vsync信号回调方法</span><br>            mCBContext-&gt;procs.vsync = &amp;hook_vsync;<br>            <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))<br>                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;<br>            <span class="hljs-keyword">else</span><br>                mCBContext-&gt;procs.hotplug = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mCBContext-&gt;procs.zero));<br>          <span class="hljs-comment">//注册回调函数</span><br>            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);<br>        &#125;<br><br>        <span class="hljs-comment">// don't need a vsync thread if we have a hardware composer</span><br>        needVSyncThread = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// always turn vsync off when we start</span><br>        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// the number of displays we actually have depends on the</span><br>        <span class="hljs-comment">// hw composer version</span><br>        <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) &#123;<br>            <span class="hljs-comment">// 1.3 adds support for virtual displays</span><br>            mNumDisplays = MAX_HWC_DISPLAYS;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;<br>            <span class="hljs-comment">// 1.1 adds support for multiple displays</span><br>            mNumDisplays = NUM_BUILTIN_DISPLAYS;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mNumDisplays = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (needVSyncThread) &#123;<br>        <span class="hljs-comment">// 不支持硬件Vsync的设备，则使用`VsyncThread`模拟发出Vsync信号</span><br>        mVSyncThread = <span class="hljs-keyword">new</span> VSyncThread(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Vsync信号</code>本身由显示驱动发出，如果不支持硬件<code>Vsync</code>，则使用<code>VsyncThread</code>模拟发出信号。</p>
<h4 id="初始化显示设备"><a href="#初始化显示设备" class="headerlink" title="初始化显示设备"></a>初始化显示设备</h4><h4 id="运行EventThread线程"><a href="#运行EventThread线程" class="headerlink" title="运行EventThread线程"></a>运行EventThread线程</h4><blockquote>
<p><code>EventThread</code>主要用来接收<code>Vsync信号</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>        <span class="hljs-comment">// start the EventThread</span><br>    sp&lt;VSyncSource&gt; vsyncSrc = <span class="hljs-keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,<br>            vsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">"app"</span>);<br>  <span class="hljs-comment">//创建App的Vsync信号接收线程</span><br>    mEventThread = <span class="hljs-keyword">new</span> EventThread(vsyncSrc);<br>    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="hljs-keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,<br>            sfVsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">"sf"</span>);<br>   <span class="hljs-comment">//创建Sf的Vsync信号接收线程</span><br>    mSFEventThread = <span class="hljs-keyword">new</span> EventThread(sfVsyncSrc);<br>    mEventQueue.setEventThread(mSFEventThread);<br>...<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="DispSyncSource"><a href="#DispSyncSource" class="headerlink" title="DispSyncSource"></a>DispSyncSource</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DispSyncSource(DispSync* dispSync, <span class="hljs-keyword">nsecs_t</span> phaseOffset, <span class="hljs-keyword">bool</span> traceVsync,<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* label) :<br>        mValue(<span class="hljs-number">0</span>),<br>        mTraceVsync(traceVsync),<br>        mVsyncOnLabel(String8::format(<span class="hljs-string">"VsyncOn-%s"</span>, label)),<br>        mVsyncEventLabel(String8::format(<span class="hljs-string">"VSYNC-%s"</span>, label)),<br>        mDispSync(dispSync),<br>        mCallbackMutex(),<br>        mCallback(),<br>        mVsyncMutex(),<br>        mPhaseOffset(phaseOffset),<br>        mEnabled(<span class="hljs-literal">false</span>) &#123;&#125;<br></code></pre></td></tr></table></figure>
<h5 id="EventThread"><a href="#EventThread" class="headerlink" title="EventThread"></a>EventThread</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">EventThread::EventThread(<span class="hljs-keyword">const</span> sp&lt;VSyncSource&gt;&amp; src)<br>    : mVSyncSource(src),<br>      mUseSoftwareVSync(<span class="hljs-literal">false</span>),<br>      mVsyncEnabled(<span class="hljs-literal">false</span>),<br>      mDebugVsyncEnabled(<span class="hljs-literal">false</span>),<br>      mVsyncHintSent(<span class="hljs-literal">false</span>) &#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i=<span class="hljs-number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;<br>        mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<br>        mVSyncEvent[i].header.id = <span class="hljs-number">0</span>;<br>        mVSyncEvent[i].header.timestamp = <span class="hljs-number">0</span>;<br>        mVSyncEvent[i].vsync.count =  <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigevent</span> <span class="hljs-title">se</span>;</span><br>    se.sigev_notify = SIGEV_THREAD;<br>    se.sigev_value.sival_ptr = <span class="hljs-keyword">this</span>;<br>    se.sigev_notify_function = vsyncOffCallback;<br>    se.sigev_notify_attributes = <span class="hljs-literal">NULL</span>;<br>    timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThread::onFirstRef</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//运行EventThread线程</span><br>    run(<span class="hljs-string">"EventThread"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EventThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    DisplayEventReceiver::Event event;<br>    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;<br>  <span class="hljs-comment">//等待事件发生</span><br>    signalConnections = waitForEvent(&amp;event);<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = signalConnections.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; <span class="hljs-title">conn</span><span class="hljs-params">(signalConnections[i])</span></span>;<br>        <span class="hljs-comment">// 分发事件给所有的监听者</span><br>        <span class="hljs-keyword">status_t</span> err = conn-&gt;postEvent(event);<br>        <span class="hljs-keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;<br>          <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br>            removeDisplayEventConnection(signalConnections[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; <span class="hljs-title">EventThread::waitForEvent</span><span class="hljs-params">(<br>        DisplayEventReceiver::Event* event)</span><br></span>&#123;<br>    Mutex::Autolock _l(mLock);<br>    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// Here we figure out if we need to enable or disable vsyncs</span><br>        <span class="hljs-keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;<br>            disableVSyncLocked();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;<br>            enableVSyncLocked();<br>        &#125;<br><br>        <span class="hljs-comment">// note: !timestamp implies signalConnections.isEmpty(), because we</span><br>        <span class="hljs-comment">// don't populate signalConnections if there's no vsync pending</span><br>        <span class="hljs-keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;<br>            <span class="hljs-comment">// wait for something to happen</span><br>            <span class="hljs-keyword">if</span> (waitForVSync) &#123;<br>                <span class="hljs-keyword">bool</span> softwareSync = mUseSoftwareVSync;<br>                <span class="hljs-keyword">nsecs_t</span> timeout = softwareSync ? ms2ns(<span class="hljs-number">16</span>) : ms2ns(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">if</span> (mCondition.waitRelative(mLock, timeout) == TIMED_OUT) &#123;<br>                    <span class="hljs-keyword">if</span> (!softwareSync) &#123;<br>                        ALOGW(<span class="hljs-string">"Timed out waiting for hw vsync; faking it"</span>);<br>                    &#125;<br>                    mVSyncEvent[<span class="hljs-number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<br>                    mVSyncEvent[<span class="hljs-number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;<br>                    mVSyncEvent[<span class="hljs-number">0</span>].header.timestamp = systemTime(SYSTEM_TIME_MONOTONIC);<br>                    mVSyncEvent[<span class="hljs-number">0</span>].vsync.count++;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mCondition.wait(mLock);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (signalConnections.isEmpty());<br><br>    <span class="hljs-keyword">return</span> signalConnections;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建<code>EventThread</code>线程完毕后，执行<code>threadLoop</code>，通过<code>waitForEvent()</code>等待事件通知。</p>
<p>等待通过<code>mCondition.wait()</code>实现</p>
<h5 id="MessaqeQueue-setEventThread"><a href="#MessaqeQueue-setEventThread" class="headerlink" title="MessaqeQueue#setEventThread"></a>MessaqeQueue#setEventThread</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::setEventThread</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br></span>&#123;<br>    mEventThread = eventThread;<br>    mEvents = eventThread-&gt;createEventConnection();<br>    mEventTube = mEvents-&gt;getDataChannel();<br>    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="hljs-number">0</span>, Looper::EVENT_INPUT,<br>            MessageQueue::cb_eventReceiver, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要执行了以下几步：</p>
<h6 id="EventThread-createEventConnection"><a href="#EventThread-createEventConnection" class="headerlink" title="EventThread#createEventConnection"></a>EventThread#createEventConnection</h6><blockquote>
<p>新建<code>BitTube</code>对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/EventThread.cpp</span><br><span class="hljs-function">sp&lt;EventThread::Connection&gt; <span class="hljs-title">EventThread::createEventConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Connection(<span class="hljs-keyword">const_cast</span>&lt;EventThread*&gt;(<span class="hljs-keyword">this</span>));<br>&#125;<br><br>EventThread::Connection::Connection(<br>        <span class="hljs-keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)<br>    : count(<span class="hljs-number">-1</span>), mEventThread(eventThread), mChannel(<span class="hljs-keyword">new</span> BitTube())<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>构建完成<code>Connection</code>对象，执行如下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> EventThread::Connection::onFirstRef() &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> mEventThread doesn't hold a strong reference on us</span><br>    mEventThread-&gt;registerDisplayEventConnection(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">EventThread::registerDisplayEventConnection</span><span class="hljs-params">(<br>        <span class="hljs-keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;<br>    Mutex::Autolock _l(mLock);<br>    mDisplayEventConnections.add(connection);<br>    mCondition.broadcast();<br>    <span class="hljs-keyword">return</span> NO_ERROR;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>初始化<code>Connection</code>之后，将<code>Connection</code>对象添加到<code>mDisplayEventConnections</code>中。</p>
<p><code>mDisplayEventConnections</code>主要负责<strong>保存接收Vsync信号的Connection的容器</strong>. 主要存储的是<code>SurfaceFlinger</code>与<code>App</code>的用来接收<code>Vsync信号</code>。</p>
<h6 id="Connection-getDataChannel"><a href="#Connection-getDataChannel" class="headerlink" title="Connection#getDataChannel"></a>Connection#getDataChannel</h6><blockquote>
<p>获取<code>BitTube</code>对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sp&lt;BitTube&gt; EventThread::Connection::getDataChannel() <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> mChannel;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/gui/BitTube.cpp</span><br>BitTube::BitTube(<span class="hljs-keyword">size_t</span> bufsize) &#123;<br>    <span class="hljs-comment">// 创建socket pair，用于发送事件</span><br>    init(bufsize, bufsize);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BitTube::init</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> rcvbuf, <span class="hljs-keyword">size_t</span> sndbuf)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sockets[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="hljs-number">0</span>, sockets) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">size_t</span> size = DEFAULT_SOCKET_BUFFER_SIZE;<br>        <span class="hljs-comment">// 设置socket buffer</span><br>        setsockopt(sockets[<span class="hljs-number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, <span class="hljs-keyword">sizeof</span>(rcvbuf));<br>        setsockopt(sockets[<span class="hljs-number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, <span class="hljs-keyword">sizeof</span>(sndbuf));<br>        <span class="hljs-comment">// since we don't use the "return channel", we keep it small...</span><br>        setsockopt(sockets[<span class="hljs-number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;size, <span class="hljs-keyword">sizeof</span>(size));<br>        setsockopt(sockets[<span class="hljs-number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;size, <span class="hljs-keyword">sizeof</span>(size));<br>        fcntl(sockets[<span class="hljs-number">0</span>], F_SETFL, O_NONBLOCK);<br>        fcntl(sockets[<span class="hljs-number">1</span>], F_SETFL, O_NONBLOCK);<br>        <span class="hljs-comment">// socket[0]用于接收端，最终通过Binder IPC返回给客户端应用</span><br>        mReceiveFd.reset(sockets[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// socket[1]用于发送端</span><br>        mSendFd.reset(sockets[<span class="hljs-number">1</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mReceiveFd.reset();<br>        ALOGE(<span class="hljs-string">"BitTube: pipe creation failed (%s)"</span>, strerror(errno));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>BitTube</code>实际是一个<code>Socket</code>，所以<code>EventThread</code>实际通过<code>Socket</code>和<code>MessageQueue</code>通信。</p>
<h6 id="Looper-addFd"><a href="#Looper-addFd" class="headerlink" title="Looper#addFd"></a>Looper#addFd</h6><blockquote>
<p>监听<code>BitTube</code>，一旦收到数据调用<code>cb_eventReceiver()</code></p>
</blockquote>
<p>通过<code>Looper</code>监听<code>BitTube</code>的fd。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这一步主要用于接收<code>Vsync信号</code>的初始化操作</p>
<ol>
<li><code>init()</code>中，创建了<code>EventThread</code>用来接收<code>Vsync信号</code></li>
<li>通过<code>MessageQueue.setEventThread()</code>将<code>EventThread</code>与<code>MessageQueue</code>建立关联。实际内部通过<code>BitTube(Socket)</code>建立两者间的通信。</li>
<li>再通过<code>addFd()</code>监听<code>BitTube</code>的套接字fd，这样就可以监听到数据的变化。</li>
</ol>
<h3 id="SurfaceFlinger-run"><a href="#SurfaceFlinger-run" class="headerlink" title="SurfaceFlinger#run"></a>SurfaceFlinger#run</h3><p>最后执行<code>SurfaceFlinger#run</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        waitForEvent();<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::waitForEvent</span><span class="hljs-params">()</span> </span>&#123;<br>    mEventQueue.waitMessage();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::waitMessage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        IPCThreadState::self()-&gt;flushCommands();<br>        <span class="hljs-keyword">int32_t</span> ret = mLooper-&gt;pollOnce(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">switch</span> (ret) &#123;<br>            <span class="hljs-keyword">case</span> Looper::POLL_WAKE:<br>            <span class="hljs-keyword">case</span> Looper::POLL_CALLBACK:<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> Looper::POLL_ERROR:<br>                ALOGE(<span class="hljs-string">"Looper::POLL_ERROR"</span>);<br>            <span class="hljs-keyword">case</span> Looper::POLL_TIMEOUT:<br>                <span class="hljs-comment">// timeout (should not happen)</span><br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-comment">// should not happen</span><br>                ALOGE(<span class="hljs-string">"Looper::pollOnce() returned unknown status %d"</span>, ret);<br>                <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>waitMessage()</code>等待消息的到来</p>
<p><img src="/images/Sf初始化.png" srcset="/img/loading.gif" lazyload alt="Sf初始化"></p>
<h2 id="Vsync信号相关"><a href="#Vsync信号相关" class="headerlink" title="Vsync信号相关"></a>Vsync信号相关</h2><h3 id="接收Vsync"><a href="#接收Vsync" class="headerlink" title="接收Vsync"></a>接收Vsync</h3><h4 id="HWC-hook-vsync"><a href="#HWC-hook-vsync" class="headerlink" title="HWC#hook_vsync"></a>HWC#hook_vsync</h4><p><code>Vsync信号</code>都是由<code>HWComposer</code>发出的，需要从<code>HWC</code>进行分析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span><br>HWComposer::HWComposer(<br>        <span class="hljs-keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,<br>        EventHandler&amp; handler)<br>    : mFlinger(flinger),<br>      mFbDev(<span class="hljs-number">0</span>), mHwc(<span class="hljs-number">0</span>), mNumDisplays(<span class="hljs-number">1</span>),<br>      mCBContext(<span class="hljs-keyword">new</span> cb_context),<br>      mEventHandler(handler),<br>      mDebugForceFakeVSync(<span class="hljs-literal">false</span>)<br>&#123;<br>        ...<br>    <span class="hljs-keyword">if</span> (mHwc) &#123;<br>        <span class="hljs-keyword">if</span> (mHwc-&gt;registerProcs) &#123;<br>            mCBContext-&gt;hwc = <span class="hljs-keyword">this</span>;<br>            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate; <span class="hljs-comment">//invalidate事件回调</span><br>            mCBContext-&gt;procs.vsync = &amp;hook_vsync;<span class="hljs-comment">//Vsync回调</span><br>            <span class="hljs-keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))<br>                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;<br>            <span class="hljs-keyword">else</span><br>                mCBContext-&gt;procs.hotplug = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mCBContext-&gt;procs.zero));<br>            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);<br>        &#125;          <br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>hook_vsync</code>处理<code>Vsync信号</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HWComposer::hook_vsync</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct hwc_procs* procs, <span class="hljs-keyword">int</span> disp,<br>        <span class="hljs-keyword">int64_t</span> timestamp)</span> </span>&#123;<br>    cb_context* ctx = <span class="hljs-keyword">reinterpret_cast</span>&lt;cb_context*&gt;(<br>            <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">hwc_procs_t</span>*&gt;(procs));<br>    ctx-&gt;hwc-&gt;vsync(disp, timestamp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HWComposer::vsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> disp, <span class="hljs-keyword">int64_t</span> timestamp)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">uint32_t</span>(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;<br>        &#123;<br>            Mutex::Autolock _l(mLock);<br><br>            mLastHwVSync[disp] = timestamp;<br>        &#125;<br><br>        <span class="hljs-keyword">char</span> tag[<span class="hljs-number">16</span>];<br>        <span class="hljs-built_in">snprintf</span>(tag, <span class="hljs-keyword">sizeof</span>(tag), <span class="hljs-string">"HW_VSYNC_%1u"</span>, disp);<br>        mEventHandler.onVSyncReceived(disp, timestamp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当<code>hook_vsync</code>收到<code>Vsync信号</code>时，回调到<code>vsync()</code>，继续调用到<code>mEventHandler.onVsyncReceived()</code></p>
<p><code>mEventHandler</code>是在<code>HWC</code>初始化时赋值的，实际就是<code>SurfaceFlinger</code></p>
<h4 id="Sf-onVSyncReceived"><a href="#Sf-onVSyncReceived" class="headerlink" title="Sf#onVSyncReceived"></a>Sf#onVSyncReceived</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onVSyncReceived</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">nsecs_t</span> timestamp)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> needsHwVsync = <span class="hljs-literal">false</span>;<br><br>    &#123; <span class="hljs-comment">// Scope for the lock</span><br>        Mutex::Autolock _l(mHWVsyncLock);<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">0</span> &amp;&amp; mPrimaryHWVsyncEnabled) &#123;<br>            needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (needsHwVsync) &#123;<br>        enableHardwareVsync();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        disableHardwareVsync(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::init</span><span class="hljs-params">()</span> </span>&#123;<br>    sp&lt;VSyncSource&gt; vsyncSrc = <span class="hljs-keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,<br>            vsyncPhaseOffsetNs, <span class="hljs-literal">true</span>, <span class="hljs-string">"app"</span>);<br>    mEventThread = <span class="hljs-keyword">new</span> EventThread(vsyncSrc);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::enableHardwareVsync</span><span class="hljs-params">()</span> </span>&#123;<br>    Mutex::Autolock _l(mHWVsyncLock);<br>    <span class="hljs-keyword">if</span> (!mPrimaryHWVsyncEnabled &amp;&amp; mHWVsyncAvailable) &#123;<br>        mPrimaryDispSync.beginResync();<br>        <span class="hljs-comment">//申请Vsync信号</span><br>        mEventControlThread-&gt;setVsyncEnabled(<span class="hljs-literal">true</span>);<br>        mPrimaryHWVsyncEnabled = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="DispSync-addResyncSample"><a href="#DispSync-addResyncSample" class="headerlink" title="DispSync#addResyncSample"></a>DispSync#addResyncSample</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DispSync.cpp</span><br>DispSync::DispSync() :<br>        mRefreshSkipCount(<span class="hljs-number">0</span>),<br>        mThread(<span class="hljs-keyword">new</span> DispSyncThread()) &#123;<br>    <span class="hljs-comment">//启动DispSyncThread</span><br>    mThread-&gt;run(<span class="hljs-string">"DispSync"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);<br><br>    reset();<br>    beginResync();<br><br>    <span class="hljs-keyword">if</span> (kTraceDetailedInfo) &#123;<br>        <span class="hljs-keyword">if</span> (!kIgnorePresentFences) &#123;<br>            addEventListener(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ZeroPhaseTracer());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="DispSyncThread-threadLoop"><a href="#DispSyncThread-threadLoop" class="headerlink" title="DispSyncThread#threadLoop"></a>DispSyncThread#threadLoop</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/DispSync.cpp   </span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>         ...<br>                <span class="hljs-keyword">if</span> (mPeriod == <span class="hljs-number">0</span>) &#123;<br>                    err = mCond.wait(mMutex);<br>                    <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;<br>                        ALOGE(<span class="hljs-string">"error waiting for new events: %s (%d)"</span>,<br>                                strerror(-err), err);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;        <br>               <span class="hljs-comment">//收集Vsync信号回调的方法</span><br>                callbackInvocations = gatherCallbackInvocationsLocked(now);         <br>       &#125;<br><br>            <span class="hljs-keyword">if</span> (callbackInvocations.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                fireCallbackInvocations(callbackInvocations);<br>            &#125;  <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fireCallbackInvocations</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; callbacks.size(); i++) &#123;<br>          <span class="hljs-comment">//回调callback的 onDispSyncEvent</span><br>            callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>DispSyncThread</code>通过<code>mCond.wait()</code>等待被唤醒，被唤醒之后回调到<code>onDispSynvEvent()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DispSync::addResyncSample</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> timestamp)</span> </span>&#123;<br>    <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;<br>    <span class="hljs-keyword">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;<br>    mResyncSamples[idx] = timestamp;<br><br>    <span class="hljs-keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;<br>        mNumResyncSamples++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mFirstResyncSample = (mFirstResyncSample + <span class="hljs-number">1</span>) % MAX_RESYNC_SAMPLES;<br>    &#125;<br>    updateModelLocked();<br><br>    <span class="hljs-keyword">return</span> mPeriod == <span class="hljs-number">0</span> || mError &gt; kErrorThreshold;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;<br>        ...<br>        mPeriod = durationSum / (mNumResyncSamples - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// Artificially inflate the period if requested.</span><br>        mPeriod += mPeriod * mRefreshSkipCount;<br><br>        mThread-&gt;updateModel(mPeriod, mPhase);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="DispsyncThread-updateModel"><a href="#DispsyncThread-updateModel" class="headerlink" title="DispsyncThread#updateModel"></a>DispsyncThread#updateModel</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateModel</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> period, <span class="hljs-keyword">nsecs_t</span> phase)</span> </span>&#123;<br>    <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;<br>    mPeriod = period;<br>    mPhase = phase;<br>    mCond.signal();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行<code>updateModel()</code>后，唤醒了<code>DispSyncThread</code></p>
<p>在<code>SurfaceFlinger.init()</code>之后初始化设置的<code>DispSyncSource</code>就是<code>callback</code>，然后回调到<code>onDispSyncEvent</code></p>
<h4 id="Sf-DispSyncSource-onDispSyncEvent"><a href="#Sf-DispSyncSource-onDispSyncEvent" class="headerlink" title="Sf.DispSyncSource#onDispSyncEvent"></a>Sf.DispSyncSource#onDispSyncEvent</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDispSyncEvent</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> when)</span> </span>&#123;<br>    sp&lt;VSyncSource::Callback&gt; callback;<br>    &#123;<br>        <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mCallbackMutex)</span></span>;<br>        callback = mCallback;<br><br>        <span class="hljs-keyword">if</span> (mTraceVsync) &#123;<br>            mValue = (mValue + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;<br>            ATRACE_INT(mVsyncEventLabel.<span class="hljs-built_in">string</span>(), mValue);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">NULL</span>) &#123;<br>        callback-&gt;onVSyncEvent(when);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个<code>callback</code>是在<code>EventThread</code>初始化的时候设置的，所以<code>mCallback</code>就是<code>EventThread</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThread::enableVSyncLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mUseSoftwareVSync) &#123;<br>        <span class="hljs-comment">// never enable h/w VSYNC when screen is off</span><br>        <span class="hljs-keyword">if</span> (!mVsyncEnabled) &#123;<br>            mVsyncEnabled = <span class="hljs-literal">true</span>;<br>            mVSyncSource-&gt;setCallback(<span class="hljs-keyword">static_cast</span>&lt;VSyncSource::Callback*&gt;(<span class="hljs-keyword">this</span>));<br>            mVSyncSource-&gt;setVSyncEnabled(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>    mDebugVsyncEnabled = <span class="hljs-literal">true</span>;<br>    sendVsyncHintOnLocked();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>setCallback()</code>建立<code>EventThread</code>与<code>DispSyncSource</code>之间的关联</p>
<h4 id="EventThread-onVsyncEvent"><a href="#EventThread-onVsyncEvent" class="headerlink" title="EventThread#onVsyncEvent"></a>EventThread#onVsyncEvent</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThread::onVSyncEvent</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> timestamp)</span> </span>&#123;<br>    Mutex::Autolock _l(mLock);<br>    mVSyncEvent[<span class="hljs-number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;<br>    mVSyncEvent[<span class="hljs-number">0</span>].header.id = <span class="hljs-number">0</span>;<br>    mVSyncEvent[<span class="hljs-number">0</span>].header.timestamp = timestamp;<br>    mVSyncEvent[<span class="hljs-number">0</span>].vsync.count++;<br>    mCondition.broadcast();<span class="hljs-comment">//唤醒EventThread</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EventThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    DisplayEventReceiver::Event event;<br>    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;<br>  <span class="hljs-comment">//等待事件发生</span><br>    signalConnections = waitForEvent(&amp;event);<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = signalConnections.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; <span class="hljs-title">conn</span><span class="hljs-params">(signalConnections[i])</span></span>;<br>        <span class="hljs-comment">// 分发事件给所有的监听者</span><br>        <span class="hljs-keyword">status_t</span> err = conn-&gt;postEvent(event);<br>        <span class="hljs-keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;<br>          <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br>            removeDisplayEventConnection(signalConnections[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>EventThread#threadLoop</code>在被唤醒后会执行<code>conn-&gt;postEvent()</code></p>
<h5 id="ET-Connection-postEvent"><a href="#ET-Connection-postEvent" class="headerlink" title="ET.Connection#postEvent"></a>ET.Connection#postEvent</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">status_t</span> EventThread::Connection::postEvent(<br>        <span class="hljs-keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;<br>    <span class="hljs-keyword">ssize_t</span> size = DisplayEventReceiver::sendEvents(mChannel, &amp;event, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> size &lt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">status_t</span>(size) : <span class="hljs-keyword">status_t</span>(NO_ERROR);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/gui/DisplayEventReceiver.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">DisplayEventReceiver::sendEvents</span><span class="hljs-params">(gui::BitTube* dataChannel,<br>        Event <span class="hljs-keyword">const</span>* events, <span class="hljs-keyword">size_t</span> count)</span><br></span>&#123;<br>    <span class="hljs-keyword">return</span> gui::BitTube::sendObjects(dataChannel, events, count);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>BitTube</code>发送消息，此时就会触发到<code>MQ#cb_eventReceiver</code></p>
<h4 id="MessageQueue-cb-eventReceiver"><a href="#MessageQueue-cb-eventReceiver" class="headerlink" title="MessageQueue#cb_eventReceiver"></a>MessageQueue#cb_eventReceiver</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageQueue::cb_eventReceiver</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span>* data)</span> </span>&#123;<br>    MessageQueue* <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">reinterpret_cast</span>&lt;MessageQueue *&gt;(data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>-&gt;eventReceiver(fd, events);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageQueue::eventReceiver</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-comment">/*fd*/</span>, <span class="hljs-keyword">int</span> <span class="hljs-comment">/*events*/</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">ssize_t</span> n;<br>    DisplayEventReceiver::Event buffer[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, <span class="hljs-number">8</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;n ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> INVALIDATE_ON_VSYNC</span><br>                mHandler-&gt;dispatchInvalidate();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>                mHandler-&gt;dispatchRefresh();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> MessageQueue::Handler::dispatchRefresh() &#123;<br>    <span class="hljs-keyword">if</span> ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == <span class="hljs-number">0</span>) &#123;<br>        mQueue.mLooper-&gt;sendMessage(<span class="hljs-keyword">this</span>, Message(MessageQueue::REFRESH));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;<br>    <span class="hljs-keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="hljs-number">0</span>) &#123;<br>        mQueue.mLooper-&gt;sendMessage(<span class="hljs-keyword">this</span>, Message(MessageQueue::INVALIDATE));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>回调到<code>MessageQueue.Handler</code>的<code>handleMessage()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> MessageQueue::Handler::handleMessage(<span class="hljs-keyword">const</span> Message&amp; message) &#123;<br>    <span class="hljs-keyword">switch</span> (message.what) &#123;<br>        <span class="hljs-keyword">case</span> INVALIDATE:<br>            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;onMessageReceived(message.what);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REFRESH:<br>            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;onMessageReceived(message.what);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> TRANSACTION:<br>            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;onMessageReceived(message.what);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Sf-onMessageReceived"><a href="#Sf-onMessageReceived" class="headerlink" title="Sf#onMessageReceived"></a>Sf#onMessageReceived</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> what)</span> </span>&#123;<br>    ATRACE_CALL();<br>    <span class="hljs-keyword">switch</span> (what) &#123;<br>        <span class="hljs-keyword">case</span> MessageQueue::TRANSACTION: &#123;<br>            handleMessageTransaction();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;<br>            <span class="hljs-keyword">bool</span> refreshNeeded = handleMessageTransaction();<br>            refreshNeeded |= handleMessageInvalidate();<br>            refreshNeeded |= mRepaintEverything;<br>            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;<br>                signalRefresh();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;<br>            handleMessageRefresh();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/SF接收Vsync信号.jpg" srcset="/img/loading.gif" lazyload alt="SF接收Vsync信号"></p>
<p>接收Vsync信号主要分为以下几步：</p>
<ol>
<li>HWC收到Vsync信号时，回调到<code>hook_vsync</code>，内部执行到<code>sf#onVsyncReceived()</code></li>
<li>继续执行到<code>DispSync#addResyncSample()</code>，然后到<code>DispSyncThread#updateModel()</code>调用<code>mCondition.broadcast()</code>唤醒<code>EventThread</code></li>
<li>唤醒之后执行到<code>DispSyncSource.onDispSyncEvent()</code>继续执行到<code>EventThread.onVsyncEvent()</code>，其中内部调用了<code>DisplayEventReceiver.sendEvents() -&gt; BitTube.sendObjects()</code>发送消息，<code>Looper</code>监听到<code>BitTube</code>有数据流动，就会回调<code>MessageQueue.cb_eventReceiver()</code></li>
<li>继续通过消息机制，回调到<code>MessageQueue.handleMessage()</code>，最后调用<code>Sf.handleMessageReceived()</code></li>
</ol>
<blockquote>
<p>简化版：</p>
<p><code>Vsync信号</code>由<code>HWC</code>产生，然后回调到<code>DispSyncthread</code>在继续回调到<code>DispSyncSource</code>，继续调用到了<code>EventThread</code>。最后<code>EventThread</code>通过<code>BitTube(Socket)</code>发送消息到<code>MessageQueue</code>，<code>MessageQueue</code>接收到消息后，在回调给<code>SurfaceFlinger</code>。</p>
</blockquote>
<h3 id="处理Vsync"><a href="#处理Vsync" class="headerlink" title="处理Vsync"></a>处理Vsync</h3><p>主要在<code>Sf#onMessageReceived()</code>处理<code>Vsync信号</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> what)</span> </span>&#123;<br>        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;<br>            <span class="hljs-keyword">bool</span> refreshNeeded = handleMessageTransaction();<br>            refreshNeeded |= handleMessageInvalidate();<br>            refreshNeeded |= mRepaintEverything;<br>            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;<br>                signalRefresh();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;  <br>        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;<br>            handleMessageRefresh();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在接受到<code>Vsync信号</code>后，就会回调到<code>MessageQueue::INVALIDATE</code>，继续向下执行到<code>signalRefresh()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::signalRefresh</span><span class="hljs-params">()</span> </span>&#123;<br>    mEventQueue.refresh();<br>&#125;<br><br><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::refresh</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> INVALIDATE_ON_VSYNC</span><br>    mHandler-&gt;dispatchRefresh();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    mEvents-&gt;requestNextVsync();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;	<br><br><span class="hljs-keyword">void</span> MessageQueue::Handler::dispatchRefresh() &#123;<br>    <span class="hljs-keyword">if</span> ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == <span class="hljs-number">0</span>) &#123;<br>        mQueue.mLooper-&gt;sendMessage(<span class="hljs-keyword">this</span>, Message(MessageQueue::REFRESH));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Sf-handleMessageRefresh"><a href="#Sf-handleMessageRefresh" class="headerlink" title="Sf#handleMessageRefresh"></a>Sf#handleMessageRefresh</h4><p>最后还是执行到了<code>handleMessageRefresh()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::handleMessageRefresh</span><span class="hljs-params">()</span> </span>&#123;<br>    ATRACE_CALL();<br>    preComposition();<br>    rebuildLayerStacks();<br>    setUpHWComposer();<br>    doDebugFlashRegions();<br>    doComposition();<br>    postComposition();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="preComposition-合成前预处理"><a href="#preComposition-合成前预处理" class="headerlink" title="preComposition-合成前预处理"></a>preComposition-合成前预处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::preComposition</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-comment">//是否需要刷新布局</span><br>    <span class="hljs-keyword">bool</span> needExtraInvalidate = <span class="hljs-literal">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> LayerVector&amp; <span class="hljs-title">layers</span><span class="hljs-params">(mDrawingState.layersSortedByZ)</span></span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = layers.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;<br>       <span class="hljs-comment">//当前Layer发生了变化</span><br>        <span class="hljs-keyword">if</span> (layers[i]-&gt;onPreComposition()) &#123;<br>            needExtraInvalidate = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (needExtraInvalidate) &#123;<br>      <span class="hljs-comment">//申请下一个Vsync信号</span><br>        signalLayerUpdate();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//frameworks/native/services/surfaceflinger/Layer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Layer::onPreComposition</span><span class="hljs-params">()</span> </span>&#123;<br>    mRefreshPending = <span class="hljs-literal">false</span>;<br>   <span class="hljs-comment">//有待处理的Buffer帧，</span><br>    <span class="hljs-keyword">return</span> mQueuedFrames &gt; <span class="hljs-number">0</span> || mSidebandStreamChanged;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>preComposition()</code>需要先判断<code>Layer</code>是否发生了变化，没发生变化不需要申请下一次Vsync信号，否则执行<code>signalLayerUpdate()</code>申请下一次Vsync信号。</p>
<h6 id="signalLayerUpdate"><a href="#signalLayerUpdate" class="headerlink" title="signalLayerUpdate"></a>signalLayerUpdate</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::signalLayerUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>    mEventQueue.invalidate();<br>&#125;<br><br><span class="hljs-comment">//frameworks/native/services/surfaceflinger/MessageQueue.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::invalidate</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> INVALIDATE_ON_VSYNC</span><br>    mEvents-&gt;requestNextVsync();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    mHandler-&gt;dispatchInvalidate();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-comment">//frameworks/native/services/surfaceflinger/EventThread.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThread::requestNextVsync</span><span class="hljs-params">(<br>        <span class="hljs-keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;<br>    Mutex::Autolock _l(mLock);<br>    <span class="hljs-keyword">if</span> (connection-&gt;count &lt; <span class="hljs-number">0</span>) &#123;<br>        connection-&gt;count = <span class="hljs-number">0</span>;<br>        mCondition.broadcast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>唤醒了<code>EventThread</code>，返回Vsync信号通知。</p>
<h5 id="rebuildLayerStacks-重建Layer"><a href="#rebuildLayerStacks-重建Layer" class="headerlink" title="rebuildLayerStacks-重建Layer"></a>rebuildLayerStacks-重建Layer</h5><blockquote>
<p>遍历<code>Layer</code>，计算和存储每个Layer的<code>dirtyRegion</code>，如果<code>dirtyRegion</code>显示在设备的显示区域内，就表示<code>Layer</code>需要重新绘制。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::rebuildLayerStacks</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// rebuild the visible layer list per screen</span><br>    <span class="hljs-keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;<br>        ATRACE_CALL();<br>        mVisibleRegionsDirty = <span class="hljs-literal">false</span>;<br>        invalidateHwcGeometry();<br><br>        <span class="hljs-function"><span class="hljs-keyword">const</span> LayerVector&amp; <span class="hljs-title">layers</span><span class="hljs-params">(mDrawingState.layersSortedByZ)</span></span>;<br>      <span class="hljs-comment">//遍历所有显示设备，计算显示设备中dirtyRegion和 opaqueRegion</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>            Region opaqueRegion;<span class="hljs-comment">//非透明区域</span><br>            Region dirtyRegion;<span class="hljs-comment">//变化区域，需要刷新</span><br>            Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;<br>            <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>            <span class="hljs-function"><span class="hljs-keyword">const</span> Transform&amp; <span class="hljs-title">tr</span><span class="hljs-params">(hw-&gt;getTransform())</span></span>;<br>            <span class="hljs-function"><span class="hljs-keyword">const</span> Rect <span class="hljs-title">bounds</span><span class="hljs-params">(hw-&gt;getBounds())</span></span>;<br>            <span class="hljs-keyword">if</span> (hw-&gt;isDisplayOn()) &#123;<br>              <span class="hljs-comment">//计算Layer的 dirtyRegion和 opaqueRegion</span><br>                SurfaceFlinger::computeVisibleRegions(layers,<br>                        hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion);<br><br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = layers.size();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(layers[i])</span></span>;<br>                    <span class="hljs-function"><span class="hljs-keyword">const</span> Layer::State&amp; <span class="hljs-title">s</span><span class="hljs-params">(layer-&gt;getDrawingState())</span></span>;<br>                    <span class="hljs-keyword">if</span> (s.layerStack == hw-&gt;getLayerStack()) &#123;<br>                        <span class="hljs-function">Region <span class="hljs-title">drawRegion</span><span class="hljs-params">(tr.transform(<br>                                layer-&gt;visibleNonTransparentRegion))</span></span>;<br>                        drawRegion.andSelf(bounds);<br>                        <span class="hljs-keyword">if</span> (!drawRegion.isEmpty()) &#123;<br>                            layersSortedByZ.add(layer);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>          <span class="hljs-comment">//按照Z轴由小到大排序</span><br>            hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ);<br>            hw-&gt;undefinedRegion.<span class="hljs-built_in">set</span>(bounds);<br>            hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));<br>            hw-&gt;dirtyRegion.orSelf(dirtyRegion);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最重要的是<code>computeVisibleRegions</code>-对Layer的<code>dirtyRegion</code>和<code>opaqueRegion</code>的计算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::computeVisibleRegions</span><span class="hljs-params">(<br>        <span class="hljs-keyword">const</span> LayerVector&amp; currentLayers, <span class="hljs-keyword">uint32_t</span> layerStack,<br>        Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span><br></span>&#123;<br> <span class="hljs-keyword">size_t</span> i = currentLayers.size();<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        <span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; layer = currentLayers[i];<br><br>        <span class="hljs-comment">// start with the whole surface at its current location</span><br>        <span class="hljs-function"><span class="hljs-keyword">const</span> Layer::State&amp; <span class="hljs-title">s</span><span class="hljs-params">(layer-&gt;getDrawingState())</span></span>;<br><br>        <span class="hljs-comment">// only consider the layers on the given layer stack</span><br>        <span class="hljs-keyword">if</span> (s.layerStack != layerStack)<br>            <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-comment">//非透明区域</span><br>        Region opaqueRegion;<br>      <span class="hljs-comment">//可见区域</span><br>        Region visibleRegion;<br>      <span class="hljs-comment">//被遮盖区域</span><br>        Region coveredRegion;<br>      <span class="hljs-comment">//透明区域</span><br>        Region transparentRegion;<br><br>        <span class="hljs-comment">// handle hidden surfaces by setting the visible region to empty</span><br>        <span class="hljs-keyword">if</span> (CC_LIKELY(layer-&gt;isVisible())) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> translucent = !layer-&gt;isOpaque(s);<br>            <span class="hljs-function">Rect <span class="hljs-title">bounds</span><span class="hljs-params">(s.transform.transform(layer-&gt;computeBounds()))</span></span>;<br>            visibleRegion.<span class="hljs-built_in">set</span>(bounds);<br>            <span class="hljs-keyword">if</span> (!visibleRegion.isEmpty()) &#123;<br>                <span class="hljs-comment">// Remove the transparent area from the visible region</span><br>                <span class="hljs-keyword">if</span> (translucent) &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">const</span> Transform <span class="hljs-title">tr</span><span class="hljs-params">(s.transform)</span></span>;<br>                    <span class="hljs-keyword">if</span> (tr.transformed()) &#123;<br>                        <span class="hljs-keyword">if</span> (tr.preserveRects()) &#123;<br>                            <span class="hljs-comment">// transform the transparent region</span><br>                            transparentRegion = tr.transform(s.activeTransparentRegion);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// transformation too complex, can't do the</span><br>                            <span class="hljs-comment">// transparent region optimization.</span><br>                            transparentRegion.clear();<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        transparentRegion = s.activeTransparentRegion;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// compute the opaque region</span><br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> layerOrientation = s.transform.getOrientation();<br>                <span class="hljs-keyword">if</span> (s.alpha==<span class="hljs-number">255</span> &amp;&amp; !translucent &amp;&amp;<br>                        ((layerOrientation &amp; Transform::ROT_INVALID) == <span class="hljs-literal">false</span>)) &#123;<br>                    <span class="hljs-comment">// the opaque region is the layer's footprint</span><br>                    opaqueRegion = visibleRegion;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Clip the covered region to the visible region</span><br>        coveredRegion = aboveCoveredLayers.intersect(visibleRegion);<br><br>        <span class="hljs-comment">// 累加当前Layer和上层Layer的可见区域</span><br>        aboveCoveredLayers.orSelf(visibleRegion);<br><br>        <span class="hljs-comment">// 可见区域减去非透明区域</span><br>        visibleRegion.subtractSelf(aboveOpaqueLayers);<br><br>        <span class="hljs-comment">// 计算脏区</span><br>        <span class="hljs-keyword">if</span> (layer-&gt;contentDirty) &#123;<br>            <span class="hljs-comment">// we need to invalidate the whole region</span><br>            dirty = visibleRegion;<br>            <span class="hljs-comment">// as well, as the old visible region</span><br>            dirty.orSelf(layer-&gt;visibleRegion);<br>            layer-&gt;contentDirty = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> Region newExposed = visibleRegion - coveredRegion;<br>            <span class="hljs-keyword">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;<br>            <span class="hljs-keyword">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;<br>            <span class="hljs-keyword">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;<br>            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);<br>        &#125;<br>        dirty.subtractSelf(aboveOpaqueLayers);<br>       <span class="hljs-comment">//累加脏区</span><br>        outDirtyRegion.orSelf(dirty);<br>       <span class="hljs-comment">//添加非透明区域</span><br>        aboveOpaqueLayers.orSelf(opaqueRegion);<br>       <span class="hljs-comment">//存储可见区域</span><br>        layer-&gt;setVisibleRegion(visibleRegion);<br>        layer-&gt;setCoveredRegion(coveredRegion);<br>        layer-&gt;setVisibleNonTransparentRegion(<br>                visibleRegion.subtract(transparentRegion));<br>    &#125;<br><br>    outOpaqueRegion = aboveOpaqueLayers;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>按照上述源码，界面显示区域分为如下几种：</p>
<ul>
<li><code>opaqueRegion</code>：非透明区域——表示不完全透明的区域</li>
<li><code>dirtyRegion</code>：需要重绘的区域</li>
<li><code>visibleRegion</code>：可见区域——表示完全不透明的区域</li>
<li><code>coveredRegion</code>：被覆盖区域——被完全不透明区域覆盖的区域</li>
<li><code>transparentRegion</code>：完全透明的区域——一般需要从合成列表中移除</li>
<li><code>aboveOpaqueLayers</code>：所有<code>非透明区域</code>的叠加</li>
<li><code>aboveCoveredLayers</code>：所有<code>可见区域</code>的叠加</li>
</ul>
<p>以平常的应用界面来举例。</p>
<p><code>opaqueRegion</code>：状态栏通常都是半透明的，可以看到时间等信息</p>
<p><code>visibleRegion</code>：当前显示的应用界面，就完全遮盖了后面的内容</p>
<p><code>coveredRegion</code>：桌面应用设置的壁纸。</p>
<blockquote>
<p><code>computeVisibleRegions</code>主要完成了以下几步：</p>
<ol>
<li>在<code>Layer的Z轴</code>从上向下遍历该显示设备中的<code>Layer</code></li>
<li>计算被覆盖区域：<code>aboveCoveredLayers</code>与<code>opaqueRegion</code>的交集</li>
<li>计算可见区域：去除<code>opaqueRegion</code>和<code>aboveOpaqueLayers</code>的交集</li>
<li>计算脏区域</li>
<li>保存到<code>Layer</code>中</li>
</ol>
</blockquote>
<h5 id="setUpHWComposer-构造硬件合成的任务"><a href="#setUpHWComposer-构造硬件合成的任务" class="headerlink" title="setUpHWComposer-构造硬件合成的任务"></a>setUpHWComposer-构造硬件合成的任务</h5><blockquote>
<p><code>Layer</code>交给<code>HWComposer</code>去做图层混合。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::setUpHWComposer</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>        <span class="hljs-keyword">bool</span> dirty = !mDisplays[dpy]-&gt;getDirtyRegion(<span class="hljs-literal">false</span>).isEmpty();<br>        <span class="hljs-keyword">bool</span> empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;<br>       <span class="hljs-comment">//没有脏区域或者可见的Layer，就不需要进行合成</span><br>        <span class="hljs-keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);<br>      <br>        mDisplays[dpy]-&gt;beginFrame(mustRecompose);<br><br>        <span class="hljs-keyword">if</span> (mustRecompose) &#123;<br>            mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;<br>        &#125;      <br>    &#125;<br>  <br>  <span class="hljs-comment">//构造HWComposer硬件任务</span><br>    <span class="hljs-function">HWComposer&amp; <span class="hljs-title">hwc</span><span class="hljs-params">(getHwComposer())</span></span>;<br>    <span class="hljs-keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;<br>        <span class="hljs-comment">// build the h/w work list</span><br>        <span class="hljs-keyword">if</span> (CC_UNLIKELY(mHwWorkListDirty)) &#123;<br>            mHwWorkListDirty = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>                <span class="hljs-function">sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();<br>                <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="hljs-title">currentLayers</span><span class="hljs-params">(<br>                        hw-&gt;getVisibleLayersSortedByZ())</span></span>;<br>                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = currentLayers.size();<br>                  <span class="hljs-comment">//在HWC创建任务列表</span><br>                    <span class="hljs-keyword">if</span> (hwc.createWorkList(id, count) == NO_ERROR) &#123;<br>                        HWComposer::LayerListIterator cur = hwc.begin(id);<br>                        <span class="hljs-keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;<br>                            <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(currentLayers[i])</span></span>;<br>                            layer-&gt;setGeometry(hw, *cur);<br>                            <span class="hljs-keyword">if</span> (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123;<br>                                cur-&gt;setSkip(<span class="hljs-literal">true</span>);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置每帧的数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>            <span class="hljs-function">sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();<br>            <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="hljs-title">currentLayers</span><span class="hljs-params">(<br>                    hw-&gt;getVisibleLayersSortedByZ())</span></span>;<br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = currentLayers.size();<br>                HWComposer::LayerListIterator cur = hwc.begin(id);<br>                <span class="hljs-keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(currentLayers[i])</span></span>;<br>                    layer-&gt;setPerFrameData(hw, *cur);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">status_t</span> err = hwc.prepare();<br>        ALOGE_IF(err, <span class="hljs-string">"HWComposer::prepare failed (%s)"</span>, strerror(-err));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>            <span class="hljs-function">sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>            hw-&gt;prepareFrame(hwc);<br>        &#125;<br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="doComposition-执行合成任务"><a href="#doComposition-执行合成任务" class="headerlink" title="doComposition-执行合成任务"></a>doComposition-执行合成任务</h5><blockquote>
<p>前面已经准备好了<code>合成Layer任务</code>和<code>需要合成的数据</code>，现在就需要做图像的混合工作。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::doComposition</span><span class="hljs-params">()</span> </span>&#123;<br>    ATRACE_CALL();<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> repaintEverything = android_atomic_and(<span class="hljs-number">0</span>, &amp;mRepaintEverything);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>        <span class="hljs-keyword">if</span> (hw-&gt;isDisplayOn()) &#123;<br>            <span class="hljs-comment">// transform the dirty region into this screen's coordinate space</span><br>            <span class="hljs-function"><span class="hljs-keyword">const</span> Region <span class="hljs-title">dirtyRegion</span><span class="hljs-params">(hw-&gt;getDirtyRegion(repaintEverything))</span></span>;<br><br>            <span class="hljs-comment">// repaint the framebuffer (if needed)</span><br>            doDisplayComposition(hw, dirtyRegion);<br>        &#125;<br>    &#125;<br>    postFramebuffer();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>doComposition()</code>主要执行以下两步</p>
<h6 id="doDisplayComposition"><a href="#doDisplayComposition" class="headerlink" title="doDisplayComposition"></a>doDisplayComposition</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::doDisplayComposition</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt;&amp; hw,<br>        <span class="hljs-keyword">const</span> Region&amp; inDirtyRegion)</span><br></span>&#123;<br>  <span class="hljs-comment">//是否硬件绘制</span><br>    <span class="hljs-keyword">bool</span> isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>  <br>  ...<br>    <span class="hljs-comment">//进行合成</span><br>       <span class="hljs-keyword">if</span> (!doComposeSurfaces(hw, dirtyRegion)) <span class="hljs-keyword">return</span>;  <br>  ...<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SurfaceFlinger::doComposeSurfaces</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt;&amp; hw, <span class="hljs-keyword">const</span> Region&amp; dirty)</span><br></span>&#123;<br>  ...<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="hljs-title">layers</span><span class="hljs-params">(hw-&gt;getVisibleLayersSortedByZ())</span></span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = layers.size();<br>    <span class="hljs-keyword">const</span> Transform&amp; tr = hw-&gt;getTransform();<br>    <span class="hljs-keyword">if</span> (cur != end) &#123;<br>        <span class="hljs-comment">// 使用硬件合成</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count &amp;&amp; cur!=end ; ++i, ++cur) &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; <span class="hljs-title">layer</span><span class="hljs-params">(layers[i])</span></span>;<br>            <span class="hljs-function"><span class="hljs-keyword">const</span> Region <span class="hljs-title">clip</span><span class="hljs-params">(dirty.intersect(tr.transform(layer-&gt;visibleRegion)))</span></span>;<br>            <span class="hljs-keyword">if</span> (!clip.isEmpty()) &#123;<br>                <span class="hljs-keyword">switch</span> (cur-&gt;getCompositionType()) &#123;<br>                    <span class="hljs-keyword">case</span> HWC_CURSOR_OVERLAY:<br>                    <span class="hljs-keyword">case</span> HWC_OVERLAY: &#123;<br>                        <span class="hljs-function"><span class="hljs-keyword">const</span> Layer::State&amp; <span class="hljs-title">state</span><span class="hljs-params">(layer-&gt;getDrawingState())</span></span>;<br>                        <span class="hljs-keyword">if</span> ((cur-&gt;getHints() &amp; HWC_HINT_CLEAR_FB)<br>                                &amp;&amp; i<br>                                &amp;&amp; layer-&gt;isOpaque(state) &amp;&amp; (state.alpha == <span class="hljs-number">0xFF</span>)<br>                                &amp;&amp; hasGlesComposition) &#123;<br>                            <span class="hljs-comment">// never clear the very first layer since we're</span><br>                            <span class="hljs-comment">// guaranteed the FB is already cleared</span><br>                            layer-&gt;clearWithOpenGL(hw, clip);<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> HWC_FRAMEBUFFER: &#123;<br>                        layer-&gt;draw(hw, clip);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> HWC_FRAMEBUFFER_TARGET: &#123;<br>                        <span class="hljs-comment">// this should not happen as the iterator shouldn't</span><br>                        <span class="hljs-comment">// let us get there.</span><br>                        ALOGW(<span class="hljs-string">"HWC_FRAMEBUFFER_TARGET found in hwc list (index=%zu)"</span>, i);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            layer-&gt;setAcquireFence(hw, *cur);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 不使用硬件合成</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; ++i) &#123;<br>            <span class="hljs-keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);<br>            <span class="hljs-function"><span class="hljs-keyword">const</span> Region <span class="hljs-title">clip</span><span class="hljs-params">(dirty.intersect(<br>                    tr.transform(layer-&gt;visibleRegion)))</span></span>;<br>            <span class="hljs-keyword">if</span> (!clip.isEmpty()) &#123;<br>                layer-&gt;draw(hw, clip);<br>            &#125;<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="postFrameBuffer"><a href="#postFrameBuffer" class="headerlink" title="postFrameBuffer"></a>postFrameBuffer</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::postFramebuffer</span><span class="hljs-params">()</span><br></span>&#123;<br>    ATRACE_CALL();<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">nsecs_t</span> now = systemTime();<br>    mDebugInSwapBuffers = now;<br><br>    <span class="hljs-function">HWComposer&amp; <span class="hljs-title">hwc</span><span class="hljs-params">(getHwComposer())</span></span>;<br>    <span class="hljs-keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;<br>        <span class="hljs-keyword">if</span> (!hwc.supportsFramebufferTarget()) &#123;<br>            <span class="hljs-comment">// EGL spec says:</span><br>            <span class="hljs-comment">//   "surface must be bound to the calling thread's current context,</span><br>            <span class="hljs-comment">//    for the current rendering API."</span><br>            getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);<br>        &#125;<br>        hwc.commit();<br>    &#125;<br><br>    getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> dpy=<span class="hljs-number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;<br>        <span class="hljs-function">sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mDisplays[dpy])</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="hljs-title">currentLayers</span><span class="hljs-params">(hw-&gt;getVisibleLayersSortedByZ())</span></span>;<br>        hw-&gt;onSwapBuffersCompleted(hwc);<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = currentLayers.size();<br>        <span class="hljs-keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();<br>        <span class="hljs-keyword">if</span> (id &gt;=<span class="hljs-number">0</span> &amp;&amp; hwc.initCheck() == NO_ERROR) &#123;<br>            HWComposer::LayerListIterator cur = hwc.begin(id);<br>            <span class="hljs-keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123;<br>                currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                currentLayers[i]-&gt;onLayerDisplayed(hw, <span class="hljs-literal">NULL</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    mLastSwapBufferTime = systemTime() - now;<br>    mDebugInSwapBuffers = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">uint32_t</span> flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();<br>    <span class="hljs-keyword">if</span> (flipCount % LOG_FRAME_STATS_PERIOD == <span class="hljs-number">0</span>) &#123;<br>        logFrameStats();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>doComposition</code>  </p>
<ul>
<li><code>doDisplayComposition</code>：重绘<code>FrameBuffer</code>，并进行合成</li>
<li><code>postFrameBuffer</code>：将数据写入到<code>FrameBuffer</code>然后完成物理屏幕的图像显示</li>
</ul>
<h5 id="postComposition-合成图形结束后的处理"><a href="#postComposition-合成图形结束后的处理" class="headerlink" title="postComposition-合成图形结束后的处理"></a>postComposition-合成图形结束后的处理</h5><blockquote>
<p>此时图层已经混合完成，图像数据也被送到了<code>帧缓冲(FrameBuffer)</code>，并且已经显示在屏幕上了，由<code>postComposition()</code>进行一些收尾工作的处理。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::postComposition</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> LayerVector&amp; <span class="hljs-title">layers</span><span class="hljs-params">(mDrawingState.layersSortedByZ)</span></span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> count = layers.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span> ; i&lt;count ; i++) &#123;<br>        layers[i]-&gt;onPostComposition();<br>    &#125;<br>  ...<br>    <span class="hljs-comment">//更新 swapBuffer 记录时间</span><br>    <span class="hljs-keyword">nsecs_t</span> currentTime = systemTime();<br>    <span class="hljs-keyword">if</span> (mHasPoweredOff) &#123;<br>        mHasPoweredOff = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">nsecs_t</span> period = mPrimaryDispSync.getPeriod();<br>        <span class="hljs-keyword">nsecs_t</span> elapsedTime = currentTime - mLastSwapTime;<br>        <span class="hljs-keyword">size_t</span> numPeriods = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(elapsedTime / period);<br>        <span class="hljs-keyword">if</span> (numPeriods &lt; NUM_BUCKETS - <span class="hljs-number">1</span>) &#123;<br>            mFrameBuckets[numPeriods] += elapsedTime;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mFrameBuckets[NUM_BUCKETS - <span class="hljs-number">1</span>] += elapsedTime;<br>        &#125;<br>        mTotalTime += elapsedTime;<br>    &#125;<br>    mLastSwapTime = currentTime;    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/SF处理Vsync信号.jpg" srcset="/img/loading.gif" lazyload alt="SF处理Vsync信号"></p>
<h2 id="Android图形缓冲区"><a href="#Android图形缓冲区" class="headerlink" title="Android图形缓冲区"></a>Android图形缓冲区</h2><p>Android的图形缓冲区主要由以下几部分组成：</p>
<ul>
<li><code>Surface</code></li>
<li><code>Layer</code></li>
<li><code>GraphicBuffer</code></li>
<li><code>BufferQueue</code></li>
</ul>
<h3 id="Surface相关"><a href="#Surface相关" class="headerlink" title="Surface相关"></a>Surface相关</h3><blockquote>
<p><strong><code>Surface</code>是提供给<code>图形生产者</code>控制缓冲区的</strong></p>
<p>在<code>软件绘制</code>中，调用<code>drawSoftware(surface)</code>传入<code>Surface缓冲区</code>到<code>native</code>层的<code>SkiaCanvas</code></p>
<p>在<code>硬件绘制</code>中，调用<code>ThreadedRenderer.initalize(surface)</code>传入<code>Surface缓冲区</code>到OpenGL中进行渲染。</p>
<p>当得到<code>Surface缓冲区</code>后，就可以存入<strong>需要绘制的内容</strong>到<code>Surface</code>中。</p>
</blockquote>
<p><code>Surface</code>内部持有<code>BufferQueue中的GraphicBufferProducer</code>，主要负责<strong>创建或获取可用的<code>GraphicBuffer</code>以及提交绘制后的<code>GraphicBuffer</code></strong>。</p>
<h3 id="Layer相关"><a href="#Layer相关" class="headerlink" title="Layer相关"></a>Layer相关</h3><blockquote>
<p><strong><code>Layer</code>是提供给<code>图形消费者</code>获取缓冲区的</strong></p>
<p>在<code>SurfaceFlinger</code>需要消费图形数据，进行图层混合时，在<code>rebuildLayerStacks()</code>进行<code>Layer</code>遍历，取出<code>Layer</code>中的图形数据，进行数据合成处理。</p>
</blockquote>
<p><code>Layer</code>内部持有<code>BufferQueue中的GraphicBufferConsumer</code>，主要负责<strong>获取和释放<code>GraphicBuffer</code></strong></p>
<h3 id="GraphicBuffer"><a href="#GraphicBuffer" class="headerlink" title="GraphicBuffer"></a>GraphicBuffer</h3><blockquote>
<p>真正被分配内存，并能存储图形数据的缓冲区。</p>
</blockquote>
<h3 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h3><blockquote>
<p>存放<code>GraphicBuffer</code>的数组结构，最多可以存储<strong>64</strong>个<code>GraphicBuffer</code></p>
</blockquote>
<p><img src="/images/BufferQueue执行流程.jpg" srcset="/img/loading.gif" lazyload alt="BufferQueue执行流程"></p>
<blockquote>
<p>当绘制图像时，首先去创建<code>Surface</code>和<code>Layer</code>，</p>
<p>然后<code>图像生产者</code>通过<code>Surface</code>调用<code>dequeue()</code>申请一块<code>GraphicBuffer</code>，在其上绘制图像</p>
<p>绘制完毕后，通过<code>Surface</code>调用<code>queue()</code>把绘制好的<code>GraphicBuffer</code>返回到<code>BufferQueue</code>中。</p>
<p>收到<code>HWComposer</code>发出的<code>Vsync信号后</code>，<code>SurfaceFlinger</code>通过<code>Layer</code>调用<code>acquire()</code>获取绘制好的<code>GraphicBuffer</code>进行合成与处理</p>
<p>处理完毕后通过<code>Layer</code>调用<code>release()</code>释放<code>GraphicBuffer</code>并返回到<code>BufferQueue</code>中。</p>
</blockquote>
<h3 id="缓冲区创建流程"><a href="#缓冲区创建流程" class="headerlink" title="缓冲区创建流程"></a>缓冲区创建流程</h3><h4 id="Activity创建图形缓冲区"><a href="#Activity创建图形缓冲区" class="headerlink" title="Activity创建图形缓冲区"></a>Activity创建图形缓冲区</h4><p>其中最常见的场景在<code>ViewRootImpl</code>的创建过程中，在其中执行了<code>Surface</code>的创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewRootImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewParent</span>,<br>        <span class="hljs-title">View</span>.<span class="hljs-title">AttachInfo</span>.<span class="hljs-title">Callbacks</span>, <span class="hljs-title">ThreadedRenderer</span>.<span class="hljs-title">DrawCallbacks</span> </span>&#123;<br>          ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Surface mSurface = <span class="hljs-keyword">new</span> Surface();<br>          <br>        &#125;<br></code></pre></td></tr></table></figure>
<p>主要在<code>WindowManagerGlobal.addView()</code>构造的<code>ViewRootImpl</code>对象。</p>
<p>此时创建的只是Java层的<code>Surface</code>，还需要绑定Native层的<code>Surface</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;<br>               <span class="hljs-comment">//执行绘制流程 测量-布局-绘制</span><br>                requestLayout();<br>                <span class="hljs-keyword">if</span> ((mWindowAttributes.inputFeatures<br>                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="hljs-number">0</span>) &#123;<br>                  <span class="hljs-comment">//触摸事件回调</span><br>                    mInputChannel = <span class="hljs-keyword">new</span> InputChannel();<br>                &#125;<br>                mForceDecorViewVisibility = (mWindowAttributes.privateFlags<br>                        &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    mOrigWindowType = mWindowAttributes.type;<br>                    mAttachInfo.mRecomputeGlobalAttributes = <span class="hljs-keyword">true</span>;<br>                    collectViewAttributes();<br>                   <span class="hljs-comment">//添加窗口</span><br>                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,<br>                            getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,<br>                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,<br>                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);<br>                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                   ...<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (restore) &#123;<br>                        attrs.restore();<br>                    &#125;<br>                &#125;      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>setView()</code>主要做了两件事情：</p>
<ul>
<li><code>requestLayout</code>：主要是执行到<code>relayoutWindow</code>创建了<code>Surface</code>和<code>Layer</code></li>
<li><code>addToDisplay</code>：创建了<code>SurfaceComponentClient</code></li>
</ul>
<p><code>requestLayout</code>需要在<code>addToDisplay</code>执行完毕后才可以执行。</p>
<p><br></p>
<h5 id="WS-addToDisplay"><a href="#WS-addToDisplay" class="headerlink" title="WS#addToDisplay"></a>WS#addToDisplay</h5><p><code>WS#addToDisplay()</code>执行过程</p>
<p><code>WindowSession</code>表示<strong>Java层的Window和WMS通信的对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//com.android.server.wm.Session</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Session</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IWindowSession</span>.<span class="hljs-title">Stub</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBinder</span>.<span class="hljs-title">DeathRecipient</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addToDisplayWithoutInputChannel</span><span class="hljs-params">(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,<br>            <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mService.addWindow(<span class="hljs-keyword">this</span>, window, seq, attrs, viewVisibility, displayId,<br>                <span class="hljs-keyword">new</span> Rect() <span class="hljs-comment">/* outFrame */</span>, outContentInsets, outStableInsets, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* outOutsets */</span>,<br>                <span class="hljs-keyword">new</span> DisplayCutout.ParcelableWrapper() <span class="hljs-comment">/* cutout */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* outInputChannel */</span>);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>mService</code>表示的就是<code>WindowManagerService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//WindowManagerService.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addWindow</span><span class="hljs-params">(Session session, IWindow client, <span class="hljs-keyword">int</span> seq,<br>            LayoutParams attrs, <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outFrame,<br>            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,<br>            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel)</span> </span>&#123;<br>      ...      <br>      <span class="hljs-keyword">synchronized</span>(mWindowMap) &#123;<br>            AppWindowToken atoken = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hasParent = parentWindow != <span class="hljs-keyword">null</span>;<br>          <span class="hljs-comment">//创建WindowToken</span><br>            WindowToken token = displayContent.getWindowToken(<br>                    hasParent ? parentWindow.mAttrs.token : attrs.token);        <br>        ...<br>          <span class="hljs-comment">//创建WindowState对象</span><br>            <span class="hljs-keyword">final</span> WindowState win = <span class="hljs-keyword">new</span> WindowState(<span class="hljs-keyword">this</span>, session, client, token, parentWindow,<br>                    appOp[<span class="hljs-number">0</span>], seq, attrs, viewVisibility, session.mUid,<br>                    session.mCanAddInternalSystemWindow); <br>        ...<br>          <span class="hljs-comment">//附加窗口</span><br>            win.attach();<br>            mWindowMap.put(client.asBinder(), win);          <br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里重点关注<code>WindowState#attach</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//WindowState.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">"Attaching "</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">" token="</span> + mToken);<br>        mSession.windowAddedLocked(mAttrs.packageName);<br>    &#125;<br><br><span class="hljs-comment">//Session.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">windowAddedLocked</span><span class="hljs-params">(String packageName)</span> </span>&#123;<br>        mPackageName = packageName;<br>        mRelayoutTag = <span class="hljs-string">"relayoutWindow: "</span> + mPackageName;<br>        <span class="hljs-keyword">if</span> (mSurfaceSession == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (WindowManagerService.localLOGV) Slog.v(<br>                TAG_WM, <span class="hljs-string">"First window added to "</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">", creating SurfaceSession"</span>);<br>            mSurfaceSession = <span class="hljs-keyword">new</span> SurfaceSession();<br>          ...<br>        &#125;<br>        mNumWindow++;<br>    &#125;<br><br><span class="hljs-comment">//SurfaceSession.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SurfaceSession</span><span class="hljs-params">()</span> </span>&#123;<br>        mNativeClient = nativeCreate();<br>    &#125;<br><br><span class="hljs-comment">//android_view_SurfaceSession.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeCreate</span><span class="hljs-params">(JNIEnv* env, jclass clazz)</span> </span>&#123;<br>    SurfaceComposerClient* client = <span class="hljs-keyword">new</span> SurfaceComposerClient();<br>    client-&gt;incStrong((<span class="hljs-keyword">void</span>*)nativeCreate);<br>    <span class="hljs-keyword">return</span> reinterpret_cast&lt;jlong&gt;(client);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>经过上述步骤最后创建了<code>SurfaceComponentClient</code></p>
<p><code>addToDisplay</code>执行完毕后，回调到<code>performTraversals()</code></p>
<h5 id="WS-relayoutWindow"><a href="#WS-relayoutWindow" class="headerlink" title="WS#relayoutWindow"></a>WS#relayoutWindow</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>      ...<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> surfaceGenerationId = mSurface.getGenerationId();<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isViewVisible = viewVisibility == View.VISIBLE;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> windowRelayoutWasForced = mForceNextWindowRelayout;<br>        <span class="hljs-keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||<br>                viewVisibilityChanged || params != <span class="hljs-keyword">null</span> || mForceNextWindowRelayout) &#123;<br>            mForceNextWindowRelayout = <span class="hljs-keyword">false</span>;<br>          ...<br>            <span class="hljs-keyword">try</span> &#123;            <br>             relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);<br>              ...<br>            &#125;<span class="hljs-keyword">catch</span>(RemoteException e)&#123;<br>              <br>            &#125;<br>            <span class="hljs-keyword">if</span> (!mStopped || mReportNextDraw) &#123;<br>                <span class="hljs-keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(<br>                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()<br>                        || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||<br>                        updatedConfiguration) &#123;<br>                    <span class="hljs-keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);<br>                    <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);<br>                  <span class="hljs-comment">//执行测量流程</span><br>                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);  <br>                  ...<br>                &#125;<br>            &#125;<br>          <br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>        <span class="hljs-keyword">if</span> (didLayout) &#123;<br>          <span class="hljs-comment">//执行布局过程</span><br>            performLayout(lp, mWidth, mHeight);<br>        &#125;<br>      &#125;<br>        <span class="hljs-keyword">boolean</span> cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;<br>        <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;<br>            <span class="hljs-keyword">if</span> (mPendingTransitions != <span class="hljs-keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;<br>                    mPendingTransitions.get(i).startChangingAnimations();<br>                &#125;<br>                mPendingTransitions.clear();<br>            &#125;<br>           <span class="hljs-comment">//执行绘制流程</span><br>            performDraw();<br>        &#125; <br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>performTraversals()</code>主要做了以下几步：</p>
<ol>
<li><code>relayoutWindow</code>——创建<code>Surface</code>和<code>Layout</code></li>
<li><code>performMeasure</code>——测量过程</li>
<li><code>performLayout</code>——布局过程</li>
<li><code>performDraw</code>——绘制过程</li>
</ol>
<p>接下来主要分析<code>relayoutWindow</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">relayoutWindow</span><span class="hljs-params">(WindowManager.LayoutParams params, <span class="hljs-keyword">int</span> viewVisibility,<br>            <span class="hljs-keyword">boolean</span> insetsPending)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>      ...<br>        <span class="hljs-keyword">int</span> relayoutResult = mWindowSession.relayout(mWindow, mSeq, params,<br>                (<span class="hljs-keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="hljs-number">0.5f</span>),<br>                (<span class="hljs-keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="hljs-number">0.5f</span>), viewVisibility,<br>                insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="hljs-number">0</span>, frameNumber,<br>                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,<br>                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingDisplayCutout,<br>                mPendingMergedConfiguration, mSurface);      <br>    &#125;<br><br><span class="hljs-comment">//Session.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">relayout</span><span class="hljs-params">(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,<br>            <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">int</span> viewFlags, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">long</span> frameNumber,<br>            Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets,<br>            Rect outStableInsets, Rect outsets, Rect outBackdropFrame,<br>            DisplayCutout.ParcelableWrapper cutout, MergedConfiguration mergedConfiguration,<br>            Surface outSurface)</span> </span>&#123;<br>      ...<br>        <span class="hljs-keyword">int</span> res = mService.relayoutWindow(<span class="hljs-keyword">this</span>, window, seq, attrs,<br>                requestedWidth, requestedHeight, viewFlags, flags, frameNumber,<br>                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,<br>                outStableInsets, outsets, outBackdropFrame, cutout,<br>                mergedConfiguration, outSurface);<br>      ...<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-comment">//WindowManagerService.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">relayoutWindow</span><span class="hljs-params">(Session session, IWindow client, <span class="hljs-keyword">int</span> seq, LayoutParams attrs,<br>            <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> flags,<br>            <span class="hljs-keyword">long</span> frameNumber, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,<br>            Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,<br>            DisplayCutout.ParcelableWrapper outCutout, MergedConfiguration mergedConfiguration,<br>            Surface outSurface)</span> </span>&#123;<br>      ...<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> shouldRelayout = viewVisibility == View.VISIBLE &amp;&amp;<br>                    (win.mAppToken == <span class="hljs-keyword">null</span> || win.mAttrs.type == TYPE_APPLICATION_STARTING<br>                            || !win.mAppToken.isClientHidden());        <br>            <span class="hljs-keyword">if</span> (shouldRelayout) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-comment">//创建SurfaceControl</span><br>                    result = createSurfaceControl(outSurface, result, win, winAnimator);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                  ...<br>                &#125;              <br>            &#125;<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p>接下来执行到<code>createSurfaceControl</code></p>
<h6 id="WMS-createSurfaceControl"><a href="#WMS-createSurfaceControl" class="headerlink" title="WMS#createSurfaceControl"></a>WMS#createSurfaceControl</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">createSurfaceControl</span><span class="hljs-params">(Surface outSurface, <span class="hljs-keyword">int</span> result, WindowState win,<br>        WindowStateAnimator winAnimator)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!win.mHasSurface) &#123;<br>        result |= RELAYOUT_RES_SURFACE_CHANGED;<br>    &#125;<br><br>    WindowSurfaceController surfaceController;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="hljs-string">"createSurfaceControl"</span>);<br>      <span class="hljs-comment">//创建SurfaceControl</span><br>        surfaceController = winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (surfaceController != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">//创建Surface</span><br>        surfaceController.getSurface(outSurface);<br>        <span class="hljs-keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(TAG_WM, <span class="hljs-string">"  OUT SURFACE "</span> + outSurface + <span class="hljs-string">": copied"</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// For some reason there isn't a surface.  Clear the</span><br>        <span class="hljs-comment">// caller's object so they see the same state.</span><br>        Slog.w(TAG_WM, <span class="hljs-string">"Failed to create surface control for "</span> + win);<br>        outSurface.release();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>createSurfaceControl()</code>主要执行了两步：</p>
<ul>
<li><code>createSurfaceLocked</code>——创建Layer</li>
<li><code>SurfaceControl#getSurface</code>——创建Surface</li>
</ul>
<h6 id="WMS-createSurfaceLocked"><a href="#WMS-createSurfaceLocked" class="headerlink" title="WMS#createSurfaceLocked"></a>WMS#createSurfaceLocked</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//com/android/server/wm/WindowStateAnimator.java</span><br>    <span class="hljs-function">WindowSurfaceController <span class="hljs-title">createSurfaceLocked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> windowType, <span class="hljs-keyword">int</span> ownerUid)</span> </span>&#123;<br>      ...<br>            mSurfaceController = <span class="hljs-keyword">new</span> WindowSurfaceController(mSession.mSurfaceSession,<br>                    attrs.getTitle().toString(), width, height, format, flags, <span class="hljs-keyword">this</span>,<br>                    windowType, ownerUid);      <br>      ...<br>    &#125;<br><br><span class="hljs-comment">//WindowSurfaceController.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WindowSurfaceController</span><span class="hljs-params">(SurfaceSession s, String name, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> format,<br>            <span class="hljs-keyword">int</span> flags, WindowStateAnimator animator, <span class="hljs-keyword">int</span> windowType, <span class="hljs-keyword">int</span> ownerUid)</span> </span>&#123;<br>      ...<br>        <span class="hljs-keyword">final</span> SurfaceControl.Builder b = win.makeSurface()<br>                .setParent(win.getSurfaceControl())<br>                .setName(name)<br>                .setSize(w, h)<br>                .setFormat(format)<br>                .setFlags(flags)<br>                .setMetadata(windowType, ownerUid);<br>        mSurfaceControl = b.build();      <br>      ...<br>    &#125;<br><br><span class="hljs-comment">//SurfaceControl.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>      ...<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> SurfaceControl <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (mWidth &lt;= <span class="hljs-number">0</span> || mHeight &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                        <span class="hljs-string">"width and height must be set"</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SurfaceControl(mSession, mName, mWidth, mHeight, mFormat,<br>                    mFlags, mParent, mWindowType, mOwnerUid);<br>        &#125;      <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SurfaceControl</span><span class="hljs-params">(SurfaceSession session, String name, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> format, <span class="hljs-keyword">int</span> flags,<br>            SurfaceControl parent, <span class="hljs-keyword">int</span> windowType, <span class="hljs-keyword">int</span> ownerUid)</span><br>                    <span class="hljs-keyword">throws</span> OutOfResourcesException, IllegalArgumentException </span>&#123;<br>      ...<br>        mNativeObject = nativeCreate(session, name, w, h, format, flags,<br>            parent != <span class="hljs-keyword">null</span> ? parent.mNativeObject : <span class="hljs-number">0</span>, windowType, ownerUid);<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>执行<code>nativeCreate</code>切换到Native层执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/core/jni/android_view_SurfaceControl.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeCreate</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jobject sessionObj,<br>        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,<br>        jint windowType, jint ownerUid)</span> </span>&#123;<br>    <span class="hljs-function">ScopedUtfChars <span class="hljs-title">name</span><span class="hljs-params">(env, nameStr)</span></span>;<br>    <span class="hljs-function">sp&lt;SurfaceComposerClient&gt; <span class="hljs-title">client</span><span class="hljs-params">(android_view_SurfaceSession_getClient(env, sessionObj))</span></span>;<br>    SurfaceControl *parent = <span class="hljs-keyword">reinterpret_cast</span>&lt;SurfaceControl*&gt;(parentObject);<br>    sp&lt;SurfaceControl&gt; surface;<br>    <span class="hljs-keyword">status_t</span> err = client-&gt;createSurfaceChecked(<br>            String8(name.c_str()), w, h, format, &amp;surface, flags, parent, windowType, ownerUid);<br>  ...<br><br>    surface-&gt;incStrong((<span class="hljs-keyword">void</span> *)nativeCreate);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>createSurfaceChecked()</code>后续的流程会创建<code>Layer</code></p>
<h6 id="SurfaceControl-getSurface"><a href="#SurfaceControl-getSurface" class="headerlink" title="SurfaceControl#getSurface"></a>SurfaceControl#getSurface</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//WindowSurfaceController.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getSurface</span><span class="hljs-params">(Surface outSurface)</span> </span>&#123;<br>        outSurface.copyFrom(mSurfaceControl);<br>    &#125;<br><br><span class="hljs-comment">//Surface.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copyFrom</span><span class="hljs-params">(SurfaceControl other)</span> </span>&#123;<br>      ...<br>        <span class="hljs-comment">//创建Surface</span><br>        <span class="hljs-keyword">long</span> newNativeObject = nativeGetFromSurfaceControl(surfaceControlPtr);<br><br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>nativeGetFromSurfaceControl()</code>创建<code>Surface</code></p>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>先执行<code>ViewRootImpl#setView()</code>，其中会执行</p>
<ul>
<li><p><code>requestLayout</code></p>
<p>内部执行<code>ViewRootImpl#performTraversals()</code>，接下去执行<code>WMS#relayoutWindow()</code>，然后是<code>WMS#createSurfaceControl</code>，分为两步：</p>
<ul>
<li><code>createSurfaceLocked</code>：创建<code>SurfaceControl</code>，内部执行<code>android_view_surfaceControl#nativeCreate</code>，执行<code>SurfaceComponentClient#createSurface</code>，创建<code>Layer</code>对象。</li>
<li><code>WindowSurfaceController#getSurface</code>：执行到<code>Surface#copyFrom()</code>，调用到<code>nativeGetFromSurfaceControl()</code>，内部调用到<code>SurfaceControl#getSurface()</code>去创建<code>Surface</code></li>
</ul>
<p>创建<code>Surface</code>和<code>Layer</code>完毕后，继续执行View的绘制流程<code>measure-&gt;layout-&gt;draw</code></p>
</li>
<li><p><code>WindowSession#addToDisplay()</code></p>
<p>执行到<code>WMS#addWindow()</code>，继续到<code>Session#windowAddedLocked()</code>，切换到<code>Native</code>层执行<code>android_view_surfaceSession#native_create()</code>在其中创建了<code>SurfaceComponentClient</code>。</p>
</li>
</ul>
</blockquote>
<p><img src="/images/SF-Surface和Layer创建准备.jpg" srcset="/img/loading.gif" lazyload alt="SF-Surface/Layer创建准备"></p>
<h4 id="Surface、Layer的创建"><a href="#Surface、Layer的创建" class="headerlink" title="Surface、Layer的创建"></a>Surface、Layer的创建</h4><p>根据上节源码分析可以知道，<code>Surface、Layer</code>的创建主要分为以下几步</p>
<h5 id="创建SurfaceComponentClient"><a href="#创建SurfaceComponentClient" class="headerlink" title="创建SurfaceComponentClient"></a>创建SurfaceComponentClient</h5><blockquote>
<p>App进程与<code>SurfaceFlinger</code>沟通的桥梁。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceComposerClient::onFirstRef</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">sp&lt;ISurfaceComposer&gt; <span class="hljs-title">sf</span><span class="hljs-params">(ComposerService::getComposerService())</span></span>;<br>    <span class="hljs-keyword">if</span> (sf != <span class="hljs-number">0</span> &amp;&amp; mStatus == NO_INIT) &#123;<br>        <span class="hljs-keyword">auto</span> rootProducer = mParent.promote();<br>        sp&lt;ISurfaceComposerClient&gt; conn;<br>        conn = (rootProducer != <span class="hljs-literal">nullptr</span>) ? sf-&gt;createScopedConnection(rootProducer) :<br>                sf-&gt;createConnection();<br>      ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>ComposerService</code>就是<code>SurfaceFlinger</code>的Binder代理对象，<code>SurfaceComponentClient</code>通过<code>ComposerService</code>与<code>SurfaceFlinger</code>进行通信。</p>
<h6 id="ComposerService"><a href="#ComposerService" class="headerlink" title="ComposerService"></a>ComposerService</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/SurfaceComposerClient.cpp</span><br><span class="hljs-comment">/*static*/</span> <span class="hljs-function">sp&lt;ISurfaceComposer&gt; <span class="hljs-title">ComposerService::getComposerService</span><span class="hljs-params">()</span> </span>&#123;<br>    ComposerService&amp; instance = ComposerService::getInstance();<br>    <span class="hljs-keyword">if</span> (instance.mComposerService == <span class="hljs-literal">NULL</span>) &#123;<br>        ComposerService::getInstance().connectLocked();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance.mComposerService;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ComposerService::connectLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> String16 <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">"SurfaceFlinger"</span>)</span></span>;<br>  <span class="hljs-comment">//获取SurfaceFlinger 服务</span><br>    <span class="hljs-keyword">while</span> (getService(name, &amp;mComposerService) != NO_ERROR) &#123;<br>        usleep(<span class="hljs-number">250000</span>);<br>    &#125;<br>    assert(mComposerService != <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//native/libs/binder/include/binder/IServiceManager.h</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">getService</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String16&amp; name, sp&lt;INTERFACE&gt;* outService)</span><br></span>&#123;<br>    <span class="hljs-keyword">const</span> sp&lt;IServiceManager&gt; sm = defaultServiceManager();<br>    <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">NULL</span>) &#123;<br>        *outService = interface_cast&lt;INTERFACE&gt;(sm-&gt;getService(name));<br>        <span class="hljs-keyword">if</span> ((*outService) != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> NO_ERROR;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NAME_NOT_FOUND;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="SurfaceFlinger-createConnection"><a href="#SurfaceFlinger-createConnection" class="headerlink" title="SurfaceFlinger#createConnection"></a>SurfaceFlinger#createConnection</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function">sp&lt;ISurfaceComposerClient&gt; <span class="hljs-title">SurfaceFlinger::createConnection</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> initClient(<span class="hljs-keyword">new</span> Client(<span class="hljs-keyword">this</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> sp&lt;ISurfaceComposerClient&gt; <span class="hljs-title">initClient</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;Client&gt;&amp; client)</span> </span>&#123;<br>  <span class="hljs-comment">//检查Client是否合法</span><br>    <span class="hljs-keyword">status_t</span> err = client-&gt;initCheck();<br>    <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>        <span class="hljs-keyword">return</span> client;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>Client</code>内部封装的是<strong>创建和销毁Layer和Surface的操作函数。</strong></p>
<blockquote>
<p><code>Client</code>实现了<code>ISurfaceComposerClient</code>接口，<code>SurfaceComposerClient</code>通过<code>Client</code>和<code>SurfaceFlinger</code>进行通讯。</p>
<p>除此之外还可以创建<code>Surface</code>以及维护<code>Layer</code>对象。</p>
</blockquote>
<h5 id="创建SurfaceControl并创建Layer"><a href="#创建SurfaceControl并创建Layer" class="headerlink" title="创建SurfaceControl并创建Layer"></a>创建SurfaceControl并创建Layer</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">SurfaceComposerClient::createSurfaceChecked</span><span class="hljs-params">(<br>        <span class="hljs-keyword">const</span> String8&amp; name,<br>        <span class="hljs-keyword">uint32_t</span> w,<br>        <span class="hljs-keyword">uint32_t</span> h,<br>        PixelFormat format,<br>        sp&lt;SurfaceControl&gt;* outSurface,<br>        <span class="hljs-keyword">uint32_t</span> flags,<br>        SurfaceControl* parent,<br>        <span class="hljs-keyword">int32_t</span> windowType,<br>        <span class="hljs-keyword">int32_t</span> ownerUid)</span><br></span>&#123;<br>    sp&lt;SurfaceControl&gt; sur;<br>    <span class="hljs-keyword">status_t</span> err = mStatus;<br>      <br>        err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle,<br>                windowType, ownerUid, &amp;handle, &amp;gbp);<br>        <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>            *outSurface = <span class="hljs-keyword">new</span> SurfaceControl(<span class="hljs-keyword">this</span>, handle, gbp, <span class="hljs-literal">true</span> <span class="hljs-comment">/* owned */</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="Client-createSurface"><a href="#Client-createSurface" class="headerlink" title="Client#createSurface"></a>Client#createSurface</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/Client.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Client::createSurface</span><span class="hljs-params">(<br>        <span class="hljs-keyword">const</span> String8&amp; name,<br>        <span class="hljs-keyword">uint32_t</span> w, <span class="hljs-keyword">uint32_t</span> h, PixelFormat format, <span class="hljs-keyword">uint32_t</span> flags,<br>        <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; parentHandle, <span class="hljs-keyword">int32_t</span> windowType, <span class="hljs-keyword">int32_t</span> ownerUid,<br>        sp&lt;IBinder&gt;* handle,<br>        sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCreateLayer</span> :</span> <span class="hljs-keyword">public</span> MessageBase &#123;<br>        SurfaceFlinger* flinger;<br>        Client* client;<br>        sp&lt;IBinder&gt;* handle;<br>        sp&lt;IGraphicBufferProducer&gt;* gbp;<br>        <span class="hljs-keyword">status_t</span> result;<br>        <span class="hljs-keyword">const</span> String8&amp; name;<br>        <span class="hljs-keyword">uint32_t</span> w, h;<br>        PixelFormat format;<br>        <span class="hljs-keyword">uint32_t</span> flags;<br>        sp&lt;Layer&gt;* parent;<br>        <span class="hljs-keyword">int32_t</span> windowType;<br>        <span class="hljs-keyword">int32_t</span> ownerUid;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">handler</span><span class="hljs-params">()</span> </span>&#123;<br>            result = flinger-&gt;createLayer(name, client, w, h, format, flags,<br>                    windowType, ownerUid, handle, gbp, parent);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br>  <br>    sp&lt;MessageBase&gt; msg = <span class="hljs-keyword">new</span> MessageCreateLayer(mFlinger.get(),<br>            name, <span class="hljs-keyword">this</span>, w, h, format, flags, handle,<br>            windowType, ownerUid, gbp, &amp;parent);<br>    mFlinger-&gt;postMessageSync(msg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>postMessageSync()</code>发送消息，处理后回调到<code>handler()</code>，继续执行<code>createLayer()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">SurfaceFlinger::createLayer</span><span class="hljs-params">(<br>        <span class="hljs-keyword">const</span> String8&amp; name,<br>        <span class="hljs-keyword">const</span> sp&lt;Client&gt;&amp; client,<br>        <span class="hljs-keyword">uint32_t</span> w, <span class="hljs-keyword">uint32_t</span> h, PixelFormat format, <span class="hljs-keyword">uint32_t</span> flags,<br>        <span class="hljs-keyword">int32_t</span> windowType, <span class="hljs-keyword">int32_t</span> ownerUid, sp&lt;IBinder&gt;* handle,<br>        sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* parent)</span><br></span>&#123;<br>  ...<br>    <span class="hljs-keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;<br>        <span class="hljs-keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:<br>            result = createBufferLayer(client,<br>                    uniqueName, w, h, flags, format,<br>                    handle, gbp, &amp;layer);<br><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> ISurfaceComposerClient::eFXSurfaceColor:<br>            result = createColorLayer(client,<br>                    uniqueName, w, h, flags,<br>                    handle, &amp;layer);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            result = BAD_VALUE;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>  ...  <br>  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">SurfaceFlinger::createBufferLayer</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;Client&gt;&amp; client,<br>        <span class="hljs-keyword">const</span> String8&amp; name, <span class="hljs-keyword">uint32_t</span> w, <span class="hljs-keyword">uint32_t</span> h, <span class="hljs-keyword">uint32_t</span> flags, PixelFormat&amp; format,<br>        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span><br></span>&#123;<br> ...<br>   <span class="hljs-comment">//创建Layer对象</span><br>    sp&lt;BufferLayer&gt; layer = <span class="hljs-keyword">new</span> BufferLayer(<span class="hljs-keyword">this</span>, client, name, w, h, flags);   <br> ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>createSurface</code>执行到最后，构建出<code>Layer</code>对象。</p>
<h6 id="new-SurfaceControl"><a href="#new-SurfaceControl" class="headerlink" title="new SurfaceControl"></a>new SurfaceControl</h6><blockquote>
<p><code>SurfaceControl</code>主要作用就是<strong>维护Surface</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/SurfaceControl.cpp</span><br>SurfaceControl::SurfaceControl(<br>        <span class="hljs-keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,<br>        <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; handle,<br>        <span class="hljs-keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbp,<br>        <span class="hljs-keyword">bool</span> owned)<br>    : mClient(client), mHandle(handle), mGraphicBufferProducer(gbp), mOwned(owned)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建SurfaceControl之后，仅仅是设置了<code>mClient</code>以及创建了<code>GraphicBufferProducer</code>对象。</p>
<h5 id="通过SurfaceControl创建Surface"><a href="#通过SurfaceControl创建Surface" class="headerlink" title="通过SurfaceControl创建Surface"></a>通过SurfaceControl创建Surface</h5><p>此时已经创建完毕<code>Surfacecontrol</code>和<code>Layer</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">SurfaceControl::getSurface</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span><br></span>&#123;<br>    Mutex::Autolock _l(mLock);<br>    <span class="hljs-keyword">if</span> (mSurfaceData == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> generateSurfaceLocked();<br>    &#125;<br>    <span class="hljs-keyword">return</span> mSurfaceData;<br>&#125;<br><br><span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">SurfaceControl::generateSurfaceLocked</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span><br></span>&#123;<br>  <span class="hljs-comment">//构造Surface对象</span><br>    mSurfaceData = <span class="hljs-keyword">new</span> Surface(mGraphicBufferProducer, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">return</span> mSurfaceData;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Native</code>层的<code>Surface</code>创建完毕后，返回到<code>Java</code>层进行赋值。</p>
<p><img src="/images/SF-Buffer、Layer创建过程.jpg" srcset="/img/loading.gif" lazyload alt="SF-Buffer、Layer创建过程"></p>
<h4 id="BufferQueue的创建"><a href="#BufferQueue的创建" class="headerlink" title="BufferQueue的创建"></a>BufferQueue的创建</h4><p>在创建<code>Layer</code>完成后，后续就会继续去创建<code>BufferQueue</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//BufferLayer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BufferLayer::onFirstRef</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span><br>    sp&lt;IGraphicBufferProducer&gt; producer;<br>    sp&lt;IGraphicBufferConsumer&gt; consumer;<br>  <span class="hljs-comment">//创建BufferQueue对象</span><br>    BufferQueue::createBufferQueue(&amp;producer, &amp;consumer, <span class="hljs-literal">true</span>);<br>    mProducer = <span class="hljs-keyword">new</span> MonitoredProducer(producer, mFlinger, <span class="hljs-keyword">this</span>);<br>    mConsumer = <span class="hljs-keyword">new</span> BufferLayerConsumer(consumer,<br>            mFlinger-&gt;getRenderEngine(), mTextureName, <span class="hljs-keyword">this</span>);<br>    mConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="hljs-number">0</span>));<br>    mConsumer-&gt;setContentsChangedListener(<span class="hljs-keyword">this</span>);<br>    mConsumer-&gt;setName(mName);<br><br>    <span class="hljs-keyword">if</span> (mFlinger-&gt;isLayerTripleBufferingDisabled()) &#123;<br>        mProducer-&gt;setMaxDequeuedBufferCount(<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;<span class="hljs-keyword">const</span> DisplayDevice&gt; <span class="hljs-title">hw</span><span class="hljs-params">(mFlinger-&gt;getDefaultDisplayDevice())</span></span>;<br>    updateTransformHint(hw);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueue.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BufferQueue::createBufferQueue</span><span class="hljs-params">(sp&lt;IGraphicBufferProducer&gt;* outProducer,<br>        sp&lt;IGraphicBufferConsumer&gt;* outConsumer,<br>        <span class="hljs-keyword">bool</span> consumerIsSurfaceFlinger)</span> </span>&#123;<br>  <span class="hljs-comment">//创建BufferQueueCore</span><br>    <span class="hljs-function">sp&lt;BufferQueueCore&gt; <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BufferQueueCore())</span></span>;<br>  <span class="hljs-comment">//创建BufferQueueProducer</span><br>    <span class="hljs-function">sp&lt;IGraphicBufferProducer&gt; <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BufferQueueProducer(core, consumerIsSurfaceFlinger))</span></span>;<br>  <span class="hljs-comment">//创建BufferQueueConsumer</span><br>    <span class="hljs-function">sp&lt;IGraphicBufferConsumer&gt; <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">new</span> BufferQueueConsumer(core))</span></span>;<br>  <br>    *outProducer = producer;<br>    *outConsumer = consumer;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>createBufferQueue</code>主要创建以下三个对象：</p>
<ul>
<li><code>BufferQueueCore</code></li>
<li><code>BufferQueueProducer</code></li>
<li><code>BufferQueueConsumer</code></li>
</ul>
<h5 id="BufferQueueCore"><a href="#BufferQueueCore" class="headerlink" title="BufferQueueCore"></a>BufferQueueCore</h5><blockquote>
<p>主要用来存放<code>GraphicBuffer</code>，并且存放最多<strong>64</strong>个。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/include/gui/BufferQueueCore.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferQueueCore</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> RefBase &#123;<br><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferQueueProducer</span>;</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferQueueConsumer</span>;</span><br><span class="hljs-keyword">public</span>:<br>  ...<br><span class="hljs-keyword">private</span>:<br>  ...<br>    BufferQueueDefs::SlotsType mSlots;<br>    Fifo mQueue;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; mFreeSlots;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; mFreeBuffers;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; mUnusedSlots;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; mActiveBuffers;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要有以下几个对象：</p>
<ul>
<li><code>mSlots</code>：大小为<code>NUM_BUFFER_SLOTS(64)</code>的数组，存储数据为<code>BufferSlot</code></li>
<li><code>mQueue</code>：以<code>先进先出对了</code>存放<code>生产者生产的数据-BufferItem</code>，保证按照顺序取出</li>
<li><code>mFreeSlots</code>：尚未绑定<code>GraphicBuffer</code>且<code>state = FREE</code>的<code>BufferSlot</code>的<code>index</code>集合</li>
<li><code>mFreeBuffers</code>：已经绑定了<code>GraphicBuffer</code>且<code>state = FREE</code>的<code>BufferSlot</code>的<code>index</code>集合</li>
<li><code>mActiveBuffers</code>：已经绑定了<code>GraphicBuffer</code>且<code>state!=FREE</code>的<code>BufferSlot</code>的<code>index</code>集合</li>
<li><code>mUnusedSlots</code>：没有绑定<code>GraphicBuffer</code>且没有状态的<code>BufferSlot</code>的<code>index</code>集合</li>
</ul>
<p>主要介绍<code>BufferSlot</code>，<code>BufferQueueCore</code>基本是<code>BufferSlot</code>的各种集合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BufferSlot</span> &#123;</span><br><br>    BufferSlot()<br>    : mGraphicBuffer(<span class="hljs-literal">nullptr</span>),<br>      mBufferState(),<br>  ...<br>   <span class="hljs-comment">//绑定的 GraphicBuffer</span><br>    sp&lt;GraphicBuffer&gt; mGraphicBuffer;<br>   <span class="hljs-comment">//绑定的BufferSlot 状态</span><br>    BufferState mBufferState;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BufferState</span> &#123;</span><br><br>    <span class="hljs-comment">// All slots are initially FREE (not dequeued, queued, acquired, or shared).</span><br>    BufferState()<br>    : mDequeueCount(<span class="hljs-number">0</span>),<br>      mQueueCount(<span class="hljs-number">0</span>),<br>      mAcquireCount(<span class="hljs-number">0</span>),<br>      mShared(<span class="hljs-literal">false</span>) &#123;<br>    &#125;<br>  <br>    <span class="hljs-comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span><br>    <span class="hljs-comment">// --------|---------|---------------|-------------|---------------|</span><br>    <span class="hljs-comment">// FREE    |  false  |       0       |      0      |       0       |</span><br>    <span class="hljs-comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span><br>    <span class="hljs-comment">// QUEUED  |  false  |       0       |      1      |       0       |</span><br>    <span class="hljs-comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span><br>    <span class="hljs-comment">// SHARED  |  true   |      any      |     any     |      any      |      </span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要由两部分构成：</p>
<ul>
<li><code>mGraphicBuffer</code>：<code>BufferSlot</code>所绑定的<code>GraphicBuffer</code></li>
<li><code>mBufferState</code>：表示当前<code>BufferSlot</code>的状态，主要有以下几种状态：<ul>
<li><code>FREE</code>：空闲状态，存入<code>mFreeSlots</code></li>
<li><code>DEQUEUED</code>：被<code>生产者</code>获取，待绘制数据</li>
<li><code>QUEUED</code>：被<code>BufferQueue</code>获取，待<code>消费者</code>获取。</li>
<li><code>ACQUIRED</code>：被<code>消费者</code>获取，待获取绘制数据</li>
<li><code>SHARED</code>：处于共享状态。</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>BufferQueueCore</code>设置了这么多的<code>BufferSlot</code>集合，主要为了<strong>分类BufferSlot时更高效</strong>。</p>
</blockquote>
<p><img src="/images/SF-BufferQueueCore.jpg" srcset="/img/loading.gif" lazyload alt="SF-BufferQueueCore"></p>
<h5 id="BufferQueueProducer"><a href="#BufferQueueProducer" class="headerlink" title="BufferQueueProducer"></a>BufferQueueProducer</h5><blockquote>
<p><code>Surface</code>中持有<code>BufferQueueProducer</code>的BP代理对象-<code>IGraphicBufferProducer</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span><br>BufferQueueProducer::BufferQueueProducer(<span class="hljs-keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core,<br>        <span class="hljs-keyword">bool</span> consumerIsSurfaceFlinger) :<br>    mCore(core),<br>    mSlots(core-&gt;mSlots),<br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,<br>                                            <span class="hljs-keyword">uint32_t</span> width, <span class="hljs-keyword">uint32_t</span> height, PixelFormat format,<br>                                            <span class="hljs-keyword">uint64_t</span> usage, <span class="hljs-keyword">uint64_t</span>* outBufferAge,<br>                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;<br> ... <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::queueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> slot,<br>        <span class="hljs-keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>初始化了<code>mCore</code>和<code>mSlots</code>对象</p>
<pre><code class=" mermaid">graph TD
A(new &lt;br&gt;BufferQueueProducer)
B(赋值BufferQueueCore到mCore)
C(赋值mSlots)
A---&gt;B
A---&gt;C
</code></pre>
<h6 id="dequeueBuffer"><a href="#dequeueBuffer" class="headerlink" title="dequeueBuffer"></a>dequeueBuffer</h6><blockquote>
<p>向<code>BufferQueue</code>申请一块<code>GraphicBuffer</code>。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>为<code>DEQUEUED</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,<br>                                            <span class="hljs-keyword">uint32_t</span> width, <span class="hljs-keyword">uint32_t</span> height, PixelFormat format,<br>                                            <span class="hljs-keyword">uint64_t</span> usage, <span class="hljs-keyword">uint64_t</span>* outBufferAge,<br>                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;<br>            <span class="hljs-keyword">status_t</span> status = waitForFreeSlotThenRelock(FreeSlotCaller::Dequeue,<br>                    &amp;found);<br>           ...     <br>        &#125;<br>      <span class="hljs-comment">//判断寻找的 BufferSlot是否与 申请的宽高、格式一致</span><br>        <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="hljs-title">buffer</span><span class="hljs-params">(mSlots[found].mGraphicBuffer)</span></span>;<br>        <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferSlot == found &amp;&amp;<br>                buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage)) &#123;<br>            BQ_LOGE(<span class="hljs-string">"dequeueBuffer: cannot re-allocate a shared"</span><br>                    <span class="hljs-string">"buffer"</span>);<br><br>            <span class="hljs-keyword">return</span> BAD_VALUE;<br>        &#125;  <br>  ...<br>        <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferSlot != found) &#123;<br>          <span class="hljs-comment">//添加 GraphicBuffer 的index到 mActiveBuffers</span><br>            mCore-&gt;mActiveBuffers.insert(found);<br>        &#125;<br>        *outSlot = found;  <br>  ...<br>      <span class="hljs-comment">//标记 选中的BufferSlot状态为 DEQUEUED</span><br>        mSlots[found].mBufferState.dequeue();<br><br>      <span class="hljs-comment">//找到了空的 GraphicBuffer，就进行初始化。</span><br>        <span class="hljs-keyword">if</span> ((buffer == <span class="hljs-literal">NULL</span>) ||<br>                buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage))<br>        &#123;<br>            mSlots[found].mAcquireCalled = <span class="hljs-literal">false</span>;<br>            mSlots[found].mGraphicBuffer = <span class="hljs-literal">NULL</span>;<br>            mSlots[found].mRequestBufferCalled = <span class="hljs-literal">false</span>;<br>            mSlots[found].mEglDisplay = EGL_NO_DISPLAY;<br>            mSlots[found].mEglFence = EGL_NO_SYNC_KHR;<br>            mSlots[found].mFence = Fence::NO_FENCE;<br>            mCore-&gt;mBufferAge = <span class="hljs-number">0</span>;<br>            mCore-&gt;mIsAllocating = <span class="hljs-literal">true</span>;<br><br>            returnFlags |= BUFFER_NEEDS_REALLOCATION;<br>        &#125; <br>      ...<br>    <span class="hljs-keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;<br>        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="hljs-keyword">new</span> GraphicBuffer(<br>                width, height, format, BQ_LAYER_COUNT, usage,u<br>                &#123;mConsumerName.<span class="hljs-built_in">string</span>(), mConsumerName.size()&#125;);<br>      &#123;<br>            <span class="hljs-keyword">if</span> (error == NO_ERROR &amp;&amp; !mCore-&gt;mIsAbandoned) &#123;<br>                graphicBuffer-&gt;setGenerationNumber(mCore-&gt;mGenerationNumber);<br>              <span class="hljs-comment">//将新创建的GraphicBuffer放到 BufferSlot中</span><br>                mSlots[*outSlot].mGraphicBuffer = graphicBuffer;<br>            &#125;      <br>      &#125;<br>    &#125;<br>  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::waitForFreeSlotThenRelock</span><span class="hljs-params">(FreeSlotCaller caller,<br>        <span class="hljs-keyword">int</span>* found)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>  ...<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxBufferCount = mCore-&gt;getMaxBufferCountLocked();<br>       <span class="hljs-comment">//请求是否太多</span><br>        <span class="hljs-keyword">bool</span> tooManyBuffers = mCore-&gt;mQueue.size()<br>                            &gt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(maxBufferCount);<br>        <span class="hljs-keyword">if</span> (tooManyBuffers) &#123;<br>          <span class="hljs-comment">//请求过多时，就会进入阻塞状态</span><br>            BQ_LOGV(<span class="hljs-string">"r%s: queue size is %zu, waiting"</span>, callerString,<br>                    mCore-&gt;mQueue.size());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot !=<br>                    BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                *found = mCore-&gt;mSharedBufferSlot;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (caller == FreeSlotCaller::Dequeue) &#123;<br>                    <span class="hljs-comment">// 寻找已经绑定GraphicBuffer 但 State = FREE的 BufferSlot</span><br>                    <span class="hljs-keyword">int</span> slot = getFreeBufferLocked();<br>                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                        *found = slot;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCore-&gt;mAllowAllocation) &#123;<br>                        *found = getFreeSlotLocked();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// 寻找尚未绑定GraphicBuffer 但 State = FREE 的BufferSlot</span><br>                    <span class="hljs-keyword">int</span> slot = getFreeSlotLocked();<br>                    <span class="hljs-keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;<br>                        *found = slot;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        *found = getFreeBufferLocked();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>edequeueBuffer</code>主要做了以下几步：</p>
<ul>
<li><p>通过<code>waitForFreeSlotThenRelock</code>寻找空闲的<code>BufferSlot</code>，需要判断当前是否与申请<code>width、height、format</code>一致，不一致则需要重新请求</p>
<p><code>waitForFreeSlotThenRelock</code>主要实现了以下几步：</p>
<ul>
<li><code>getFreeBufferLocked</code>：直接使用已经绑定的<code>GraphicBuffer</code></li>
<li><code>getFreeSlotLocked</code>：需要新建一个<code>GraphicBuffer</code>与其绑定</li>
</ul>
</li>
<li><p>把找到的<code>BufferSlot</code>的<code>index</code>放到<code>mActiveSlots</code>中</p>
</li>
<li><p>如果找到的<code>BufferSlot</code>中的<code>GraphicBuffer</code>为null，需要初始化<code>BufferSlot</code></p>
</li>
<li><p>如果需要重新创建<code>GraphicBuffer</code>，并把新建的<code>GraphicBuffer</code>放在找到的<code>BufferSlot</code>中</p>
</li>
</ul>
<blockquote>
<p>尝试寻找一个<code>BufferSlot</code>，并且<code>width,height,format</code>都符合要求，如果没有绑定<code>GraphicBuffer</code>，就需要新建一个并且进行绑定，然后设置<code>BufferSlot</code>的<code>BufferState</code>为<code>DEQUEUED</code>，最后返回在<code>mSlots</code>的<code>index</code>回去。</p>
</blockquote>
<p><img src="/images/SF-BufferQueue-dequeueBuffer.jpg" srcset="/img/loading.gif" lazyload alt="SF-BufferQueue-dequeueBuffer"></p>
<h6 id="queueBuffer"><a href="#queueBuffer" class="headerlink" title="queueBuffer"></a>queueBuffer</h6><blockquote>
<p>在<code>生产者</code>填充数据到<code>GraphicBuffer</code>完毕后，通过<code>queueBuffer</code>把<code>GraphicBuffer</code>放回到<code>BufferQueue</code>。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>QUEUED</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::queueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> slot,<br>        <span class="hljs-keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//消费者回调</span><br>    sp&lt;IConsumerListener&gt; frameAvailableListener;<br>    sp&lt;IConsumerListener&gt; frameReplacedListener;<br>    <span class="hljs-keyword">int</span> callbackTicket = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">uint64_t</span> currentFrameNumber = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//需要插入mQueue的 数据结构</span><br>    BufferItem item;<br>  ...<br>  &#123;<br>    ...<br>        <span class="hljs-function"><span class="hljs-keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="hljs-title">graphicBuffer</span><span class="hljs-params">(mSlots[slot].mGraphicBuffer)</span></span>;    <br>        mSlots[slot].mBufferState.<span class="hljs-built_in">queue</span>();<br>       <span class="hljs-comment">//构造BufferItem对象</span><br>        item.mAcquireCalled = mSlots[slot].mAcquireCalled;<br>        item.mGraphicBuffer = mSlots[slot].mGraphicBuffer;<br>        item.mCrop = crop;<br>        item.mTransform = transform &amp;<br>                ~<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);<br>        item.mTransformToDisplayInverse =<br>                (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != <span class="hljs-number">0</span>;<br>        item.mScalingMode = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(scalingMode);<br>        item.mTimestamp = requestedPresentTimestamp;<br>        item.mIsAutoTimestamp = isAutoTimestamp;<br>        item.mDataSpace = dataSpace;<br>        item.mHdrMetadata = hdrMetadata;<br>        item.mFrameNumber = currentFrameNumber;<br>        item.mSlot = slot;<br>        item.mFence = acquireFence;<br>        item.mFenceTime = acquireFenceTime;<br>        item.mIsDroppable = mCore-&gt;mAsyncMode ||<br>                mCore-&gt;mDequeueBufferCannotBlock ||<br>                (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == slot);<br>        item.mSurfaceDamage = surfaceDamage;<br>        item.mQueuedBuffer = <span class="hljs-literal">true</span>;<br>        item.mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mAutoRefresh;<br>        item.mApi = mCore-&gt;mConnectedApi;    <br>    <br>        <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;<br>          <span class="hljs-comment">//添加BufferItem</span><br>            mCore-&gt;mQueue.push_back(item);<br>            frameAvailableListener = mCore-&gt;mConsumerListener;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> BufferItem&amp; last = mCore-&gt;mQueue.itemAt(<br>                    mCore-&gt;mQueue.size() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (last.mIsDroppable) &#123;<br>              <span class="hljs-comment">//替换mQueue最后一位 为新的BufferItem</span><br>                mCore-&gt;mQueue.editItemAt(mCore-&gt;mQueue.size() - <span class="hljs-number">1</span>) = item;<br>                frameReplacedListener = mCore-&gt;mConsumerListener;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//添加 BufferItem</span><br>                mCore-&gt;mQueue.push_back(item);<br>                frameAvailableListener = mCore-&gt;mConsumerListener;<br>            &#125;               <br>        &#125;<br>    ...<br>      <br>        <span class="hljs-keyword">if</span> (frameAvailableListener != <span class="hljs-literal">NULL</span>) &#123;<br>          <span class="hljs-comment">//回调 onFrameAvaliaable 通知消费者有新的数据入队</span><br>            frameAvailableListener-&gt;onFrameAvailable(item);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (frameReplacedListener != <span class="hljs-literal">NULL</span>) &#123;<br>            frameReplacedListener-&gt;onFrameReplaced(item);<br>        &#125;      <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>queueBuffer</code>主要执行了以下几步：</p>
<ul>
<li>根据传入的<code>slot</code>从<code>mSlots</code>获取对应的<code>BufferSlot</code>，并设置对应的<code>BufferState</code>为<code>QUEUED</code></li>
<li>根据获取的<code>BufferSlot</code>构造出<code>BufferItem</code>，并添加到<code>mQueues</code>中</li>
<li>最后回调到<code>frameAvaliableListener.onFrameAvaliable()</code>通知<code>消费者</code>有新数据入队，可以进行获取。</li>
</ul>
<pre><code class=" mermaid">graph TD
A(queueBuffer)
B(&quot;获取mSlots[slot].mGraphicBuffer&quot;)
C(&quot;mSlots[slot].mBufferState.queue()&quot;)
A--&gt;B
A---&gt;C
D(&quot;设置BufferState状态为QUEUED&quot;)
D---C
E(&quot;组装BufferItem&quot;)
B--&gt;E
F&#123;&quot;last&lt;br&gt;.mIsDroppable&quot;&#125;
E---&gt;F
G(&quot;mQueue.push_back(item)&quot;)
H(&quot;mQueue.editItemAt(last)==item&quot;)
F--&gt;|Y| H
F--&gt;|N| G
J(&quot;frameAvailableListener-&gt;onFrameAvailable(item)&quot;)
H--&gt;J
G--&gt;J
I(&quot;通知消费者有数据入队，消费者可以获取数据&quot;)
K(&quot;最后一条数据是否有效？&quot;)
K---F
I---J
</code></pre>
<h5 id="BufferQueueConsumer"><a href="#BufferQueueConsumer" class="headerlink" title="BufferQueueConsumer"></a>BufferQueueConsumer</h5><blockquote>
<p><code>SurfaceFlinger</code>通过<code>BufferQueueConsumer</code>来获取以及释放<code>GraphicBuffer</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueConsumer.cpp</span><br>BufferQueueConsumer::BufferQueueConsumer(<span class="hljs-keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :<br>    mCore(core),<br>    mSlots(core-&gt;mSlots),<br>    mConsumerName() &#123;&#125;<br></code></pre></td></tr></table></figure>
<p><code>BufferQueueConsumer</code>只是设置了<code>mCore</code>和<code>mSlots</code>的两个参数。</p>
<h6 id="acquireBuffer"><a href="#acquireBuffer" class="headerlink" title="acquireBuffer"></a>acquireBuffer</h6><blockquote>
<p><code>消费者</code>向<code>BufferQueue</code>申请<code>已被填充数据的GraphicBuffer</code>进行消费。</p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>ACQUIRED</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueConsumer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueConsumer::acquireBuffer</span><span class="hljs-params">(BufferItem* outBuffer,<br>        <span class="hljs-keyword">nsecs_t</span> expectedPresent, <span class="hljs-keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br> ... <br>      <span class="hljs-comment">//生产者注册回调</span><br>       sp&lt;IProducerListener&gt; listener;<br>   <span class="hljs-comment">//如果队列为空则返回空</span><br>        <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.empty() &amp;&amp; !sharedBufferAvailable) &#123;<br>            <span class="hljs-keyword">return</span> NO_BUFFER_AVAILABLE;<br>        &#125;<br>    <span class="hljs-comment">//获取队列的第一条数据</span><br>        BufferQueueCore::<span class="hljs-function">Fifo::iterator <span class="hljs-title">front</span><span class="hljs-params">(mCore-&gt;mQueue.begin())</span></span>; <br>        <span class="hljs-keyword">if</span> (sharedBufferAvailable &amp;&amp; mCore-&gt;mQueue.empty()) &#123;<br>            <span class="hljs-comment">//共享Buffer模式</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//从front获取对应的slot</span><br>            slot = front-&gt;mSlot;<br>            *outBuffer = *front;<br>        &#125;<br>  ...<br>                <span class="hljs-keyword">if</span> (!front-&gt;mIsStale) &#123;<br>                    <span class="hljs-comment">// Front buffer is still in mSlots, so mark the slot as free</span><br>                    mSlots[front-&gt;mSlot].mBufferState.freeQueued();<br>                  <span class="hljs-comment">//存在已经被消费的BufferSlot</span><br>                    listener = mCore-&gt;mConnectedProducerListener;                  <br>                &#125;<br>        <span class="hljs-keyword">if</span> (!outBuffer-&gt;mIsStale) &#123;<br>            mSlots[slot].mAcquireCalled = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// Don't decrease the queue count if the BufferItem wasn't</span><br>            <span class="hljs-comment">// previously in the queue. This happens in shared buffer mode when</span><br>            <span class="hljs-comment">// the queue is empty and the BufferItem is created above.</span><br>            <span class="hljs-keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;<br>                mSlots[slot].mBufferState.acquireNotInQueue();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//更新BufferState 为 ACQUIRED</span><br>                mSlots[slot].mBufferState.acquire();<br>            &#125;<br>            mSlots[slot].mFence = Fence::NO_FENCE;<br>        &#125;    <br>       <span class="hljs-comment">//从队列中移除</span><br>        mCore-&gt;mQueue.erase(front);   <br>  <br>      <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numDroppedBuffers; ++i) &#123;<br>          <span class="hljs-comment">//回调生产者 有数据被消费</span><br>            listener-&gt;onBufferReleased();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>acquireBuffer</code>主要有以下几步：</p>
<ul>
<li>从<code>mQueue</code>中获取第一个元素</li>
<li>改变第一个<code>BufferSlot</code>的<code>BufferState</code>为<code>ACQUIRED</code></li>
<li>再将该<code>BufferSlot</code>从<code>mQueue</code>中移除</li>
<li>如果存在已被消费的数据则回调<code>onBufferReleased</code></li>
</ul>
<pre><code class=" mermaid">graph TB
A(&quot;acquireBuffer()&quot;)
C&#123;&quot;mQueue.empty()&quot;&#125;
A--&gt;C
D(&quot;NO_BUFFER_AVALIABLE&quot;)
C---&gt;|Y| D
E(&quot;front = &lt;br&gt;mCore-&gt;mQueue.begin()&quot;)
F(&quot;获取第一条BufferSlot&quot;)
F---E
C---&gt;|N| E
G(&quot;mSlots[slot].mBufferState.acquire()&quot;)
H(&quot;slot = front-&gt;mSlot&quot;)
E--&gt;H
H---&gt;G
J(&quot;设置BufferSlot的BufferState状态为ACQUIRED&quot;)
J---G
K(&quot;mCore-&gt;mQueue.erase(front)&quot;)
L(&quot;从mQueue中移除front&quot;)
L---K
G--&gt;K
</code></pre>
<h6 id="releaseBuffer"><a href="#releaseBuffer" class="headerlink" title="releaseBuffer"></a>releaseBuffer</h6><blockquote>
<p><code>消费者</code>消费完毕后，通知<code>BufferQueueCore</code>已消费完毕，并返回<code>空GraphicBuffer</code>到<code>BufferQueue</code></p>
<p>标记<code>BufferSlot</code>的<code>BufferState</code>标记为<code>FREE</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueConsumer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueConsumer::releaseBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> slot, <span class="hljs-keyword">uint64_t</span> frameNumber,<br>        <span class="hljs-keyword">const</span> sp&lt;Fence&gt;&amp; releaseFence, EGLDisplay eglDisplay,<br>        EGLSyncKHR eglFence)</span> </span>&#123;<br>  ...<br>    sp&lt;IProducerListener&gt; listener;<br>    &#123; <span class="hljs-comment">// Autolock scope</span><br>      ...<br>        mSlots[slot].mEglDisplay = eglDisplay;<br>        mSlots[slot].mEglFence = eglFence;<br>        mSlots[slot].mFence = releaseFence;<br>      <span class="hljs-comment">//设置 BufferSlot状态为 FREE</span><br>        mSlots[slot].mBufferState.release();     <br>      ...<br>        <span class="hljs-keyword">if</span> (!mSlots[slot].mBufferState.isShared()) &#123;<br>            mCore-&gt;mActiveBuffers.erase(slot);<br>          <span class="hljs-comment">//将BufferSlot放入 mFreeBuffers</span><br>            mCore-&gt;mFreeBuffers.push_back(slot);<br>        &#125;<br><br>        listener = mCore-&gt;mConnectedProducerListener;        <br>    &#125;<br>    <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-comment">//通知生产者有数据被消费</span><br>        listener-&gt;onBufferReleased();<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>releaseBuffer</code>主要有以下几步：</p>
<ul>
<li>将使用完的<code>BufferSlot</code>的<code>BufferState</code>转换为<code>FREE</code></li>
<li>被消费完的<code>BufferSlot</code>的<code>index</code>放回到<code>mFreeBuffers</code>供后续的<code>生产者</code>继续获取</li>
<li>最后通知生产者有数据被消费，生产者可以准备生产数据。</li>
</ul>
<pre><code class=" mermaid">graph TD
A(&quot;releaseBuffer()&quot;)
B(&quot;mSlots[slot].mBufferState.release()&quot;)
C(&quot;mFreeBuffers.push_back(slot)&quot;)
D(&quot;listener-&gt;onBufferReleased&quot;)

A---&gt;B
B---&gt;C
C---&gt;D

E(&quot;设置BufferSlot状态为FREE&quot;)
F(&quot;存入mFreeBuffers待使用&quot;)
G(&quot;通知 生产者 数据被消费，可以准备生产数据&quot;)

E---B
F---C
G---D
</code></pre>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/BufferSlot状态转变过程.jpg" srcset="/img/loading.gif" lazyload alt="BufferSlot状态转变过程"></p>
<h4 id="GraphicBuffer的创建"><a href="#GraphicBuffer的创建" class="headerlink" title="GraphicBuffer的创建"></a>GraphicBuffer的创建</h4><blockquote>
<p><code>GraphicBuffer</code>是基本单元，所有的交互都是基于它进行的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/BufferQueueProducer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferQueueProducer::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,<br>                                            <span class="hljs-keyword">uint32_t</span> width, <span class="hljs-keyword">uint32_t</span> height, PixelFormat format,<br>                                            <span class="hljs-keyword">uint64_t</span> usage, <span class="hljs-keyword">uint64_t</span>* outBufferAge,<br>                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;<br>  ...<br>        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="hljs-keyword">new</span> GraphicBuffer(<br>                width, height, format, BQ_LAYER_COUNT, usage,<br>                &#123;mConsumerName.<span class="hljs-built_in">string</span>(), mConsumerName.size()&#125;);<br>  ...<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要在<code>dequeueBuffer</code>进行的创建过程。在<code>生产者</code>的使用场景下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/ui/GraphicBuffer.cpp</span><br>GraphicBuffer::GraphicBuffer(<span class="hljs-keyword">uint32_t</span> inWidth, <span class="hljs-keyword">uint32_t</span> inHeight,<br>        PixelFormat inFormat, <span class="hljs-keyword">uint32_t</span> inLayerCount, <span class="hljs-keyword">uint64_t</span> usage, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> requestorName)<br>    : GraphicBuffer()<br>&#123;<br>    mInitCheck = initWithSize(inWidth, inHeight, inFormat, inLayerCount,<br>            usage, <span class="hljs-built_in">std</span>::move(requestorName));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">GraphicBuffer::initWithSize</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> inWidth, <span class="hljs-keyword">uint32_t</span> inHeight,<br>        PixelFormat inFormat, <span class="hljs-keyword">uint32_t</span> inLayerCount, <span class="hljs-keyword">uint64_t</span> inUsage,<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> requestorName)</span><br></span>&#123;<br>  <span class="hljs-comment">//GraphicBuffer的内存分配器</span><br>    GraphicBufferAllocator&amp; allocator = GraphicBufferAllocator::get();<br>    <span class="hljs-keyword">uint32_t</span> outStride = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//为GraphicBuffer分配内存</span><br>    <span class="hljs-keyword">status_t</span> err = allocator.allocate(inWidth, inHeight, inFormat, inLayerCount,<br>            inUsage, &amp;handle, &amp;outStride, mId,<br>            <span class="hljs-built_in">std</span>::move(requestorName));<br>    <span class="hljs-keyword">if</span> (err == NO_ERROR) &#123;<br>        mBufferMapper.getTransportSize(handle, &amp;mTransportNumFds, &amp;mTransportNumInts);<br><br>        width = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(inWidth);<br>        height = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(inHeight);<br>        format = inFormat;<br>        layerCount = inLayerCount;<br>        usage = inUsage;<br>        usage_deprecated = <span class="hljs-keyword">int</span>(usage);<br>        stride = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(outStride);<br>    &#125;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>GraphicBuffer</code>创建过程主要执行了以下几步：</p>
<ul>
<li>获取<code>GraphicBufferAllocator</code>，这个是<code>GraphicBuffer</code>的内存分配器</li>
<li>再调用<code>allocate()</code>进行内存分配</li>
</ul>
<p>其中<code>GraphicBufferAllocator</code>的实现如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp">//native/libs/ui/GraphicBufferAllocator.cpp<br>GraphicBufferAllocator::GraphicBufferAllocator()<br>  : mMapper(GraphicBufferMapper::getInstance()),<br>    mAllocator(std::make_unique&lt;Gralloc2::Allocator&gt;(<br>                mMapper.getGrallocMapper()))<br>&#123;<br>&#125;<br><br>status_t GraphicBufferAllocator::allocate(uint32_t width, uint32_t height,<br>        PixelFormat format, uint32_t layerCount, uint64_t usage,<br>        buffer_handle_t* handle, uint32_t* stride,<br>        uint64_t /*graphicBufferId*/, std::string requestorName)<br>&#123;<br>    ATRACE_CALL();<br><br>    // make sure to not allocate a N x 0 or 0 x N buffer, since this is<br>    // allowed from an API stand-point allocate a 1x1 buffer instead.<br>    if (!width || !height)<br>        width = height = 1;<br><br>    // Ensure that layerCount is valid.<br>    if (layerCount &lt; 1)<br>        layerCount = 1;<br><br>    Gralloc2::IMapper::BufferDescriptorInfo info = &#123;&#125;;<br>    info.width = width;<br>    info.height = height;<br>    info.layerCount = layerCount;<br>    info.format = static_cast&lt;Gralloc2::PixelFormat&gt;(format);<br>    info.usage = usage;<br><br>    Gralloc2::Error error = mAllocator-&gt;allocate(info, stride, handle);<br>    if (error == Gralloc2::Error::NONE) &#123;<br>        Mutex::Autolock _l(sLock);<br>        KeyedVector&lt;buffer_handle_t, alloc_rec_t&gt;&amp; list(sAllocList);<br>        uint32_t bpp = bytesPerPixel(format);<br>        alloc_rec_t rec;<br>        rec.width = width;<br>        rec.height = height;<br>        rec.stride = *stride;<br>        rec.format = format;<br>        rec.layerCount = layerCount;<br>        rec.usage = usage;<br>        rec.size = static_cast&lt;size_t&gt;(height * (*stride) * bpp);<br>        rec.requestorName = std::move(requestorName);<br>        list.add(*handle, rec);<br><br>        return NO_ERROR;<br>    &#125; else &#123;<br>        ALOGE("Failed to allocate (%u x %u) layerCount %u format %d "<br>                "usage %" PRIx64 ": %d",<br>                width, height, layerCount, format, usage,<br>                error);<br>        return NO_MEMORY;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>//TODO 对<code>GraphicBufferAllocator</code>进行分析</p>
<h3 id="图形缓冲区在图像生产者的使用"><a href="#图形缓冲区在图像生产者的使用" class="headerlink" title="图形缓冲区在图像生产者的使用"></a>图形缓冲区在<code>图像生产者</code>的使用</h3><blockquote>
<p>Android中的<code>图像生产者</code>如<code>Skia、OpenGL、Vulkan</code>。负责<strong>将绘制的数据放在图形缓冲区中</strong></p>
</blockquote>
<p>Android中的图像绘制分为以下两种，主要区别在于<strong>是否开启硬件加速</strong>。</p>
<p>未开启就是<code>软件绘制</code>，若开启就执行<code>硬件绘制</code>流程。</p>
<h4 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h4><p><code>软件绘制</code>的入口函数位于<code>ViewRootImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">drawSoftware</span><span class="hljs-params">(Surface surface, AttachInfo attachInfo, <span class="hljs-keyword">int</span> xoff, <span class="hljs-keyword">int</span> yoff,<br>            <span class="hljs-keyword">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Canvas canvas;<br>           <span class="hljs-comment">//从surface获取Canvas</span><br>            canvas = mSurface.lockCanvas(dirty);<br>           <span class="hljs-comment">//在canvas上进行绘制</span><br>            mView.draw(canvas);<br>           <span class="hljs-comment">//将绘制内容提交给SF进行合成</span><br>            surface.unlockCanvasAndPost(canvas);      <br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>drawSoftware()</code>主要分为以下几步：</p>
<pre><code class=" mermaid">graph LR
classDef someclass fill:#f96;
A(&quot;drawSoftware()&lt;br&gt;软件绘制&quot;)
B(&quot;lockCanvas()&lt;br&gt;获取Canvas&quot;)
C(&quot;draw(canvas)&lt;br&gt;在Canvas进行绘制&quot;)
D(&quot;unlockCanvasAndPost()&lt;br&gt;提交绘制完成的GraphicBuffer&lt;br&gt;到SurfaceFlinger进行合成&quot;)
A--&gt;B:::someclass
A--&gt;C
A--&gt;D:::someclass
</code></pre>
<h5 id="lockCanvas"><a href="#lockCanvas" class="headerlink" title="lockCanvas"></a>lockCanvas</h5><blockquote>
<p>获取<code>Canvas</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Surface.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Canvas <span class="hljs-title">lockCanvas</span><span class="hljs-params">(Rect inOutDirty)</span><br>            <span class="hljs-keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            checkNotReleasedLocked();<br>            <span class="hljs-keyword">if</span> (mLockedObject != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Surface was already locked"</span>);<br>            &#125;<br>            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);<br>            <span class="hljs-keyword">return</span> mCanvas;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/core/jni/android_view_Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeLockCanvas</span><span class="hljs-params">(JNIEnv* env, jclass clazz,<br>        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;<br>    <span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">surface</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;<br>  ...<br>    <span class="hljs-function">Rect <span class="hljs-title">dirtyRect</span><span class="hljs-params">(Rect::EMPTY_RECT)</span></span>;<br>    Rect* dirtyRectPtr = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (dirtyRectObj) &#123;<br>        dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);<br>        dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);<br>        dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);<br>        dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);<br>        dirtyRectPtr = &amp;dirtyRect;<br>    &#125;<br><br>    ANativeWindow_Buffer outBuffer;<br>  <span class="hljs-comment">//获取绘制图形的GraphicBuffer</span><br>    <span class="hljs-keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);  <br>  ...<br>    SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,<br>                                         convertPixelFormat(outBuffer.format),<br>                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888<br>                                                 ? kOpaque_SkAlphaType : kPremul_SkAlphaType,<br>                                         GraphicsJNI::defaultColorSpace());<br><br>    SkBitmap bitmap;<br>    <span class="hljs-keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);<br>    bitmap.setInfo(info, bpr);<br>    <span class="hljs-keyword">if</span> (outBuffer.width &gt; <span class="hljs-number">0</span> &amp;&amp; outBuffer.height &gt; <span class="hljs-number">0</span>) &#123;<br>        bitmap.setPixels(outBuffer.bits);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// be safe with an empty bitmap.</span><br>        bitmap.setPixels(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>   <span class="hljs-comment">//新建Canvas对象</span><br>    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);<br>    nativeCanvas-&gt;setBitmap(bitmap);    <br>  <br>    <span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">lockedSurface</span><span class="hljs-params">(surface)</span></span>;<br>    lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);<br>   <span class="hljs-comment">//返回最后的Canvas对象</span><br>    <span class="hljs-keyword">return</span> (jlong) lockedSurface.get();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要通过<code>surface#lock</code>获取<code>GraphicBuffer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Surface::lock</span><span class="hljs-params">(<br>        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br></span>&#123;<br>  ...<br>    <span class="hljs-keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);<br>  ...<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后通过<code>dequeueBuffer</code>获取<code>GraphicBuffer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Surface::dequeueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">android_native_buffer_t</span>** buffer, <span class="hljs-keyword">int</span>* fenceFd)</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//申请一块GraphicBuffer</span><br>    <span class="hljs-keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight,<br>                                                            reqFormat, reqUsage, &amp;mBufferAge,<br>                                                            enableFrameTimestamps ? &amp;frameTimestamps<br>                                                                                  : <span class="hljs-literal">nullptr</span>);    <br>  ...<br>    <span class="hljs-keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mReportRemovedBuffers &amp;&amp; (gbuf != <span class="hljs-literal">nullptr</span>)) &#123;<br>            mRemovedBuffers.push_back(gbuf);<br>        &#125;<br>      <span class="hljs-comment">//映射 GraphicBuffer</span><br>        result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);<br>        <span class="hljs-keyword">if</span> (result != NO_ERROR) &#123;<br>            ALOGE(<span class="hljs-string">"dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d"</span>, result);<br>            mGraphicBufferProducer-&gt;cancelBuffer(buf, fence);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要执行了以下两步：</p>
<ol>
<li><code>dequeueBuffer</code>：申请<code>GraphicBuffer</code></li>
<li><code>requestBuffer</code>：使用<code>GraphicBuffer</code></li>
</ol>
<p>其中<code>requestBuffer</code>通过<strong>共享内存</strong>方式获取<code>GraphicBuffer</code>数据</p>
<pre><code class=" mermaid">graph TB

 E(&quot;nativeLockCanvas()&quot;)
 F(&quot;Surface-&gt;lock()&quot;)
 G(&quot;Surface::dequeueBuffer()&lt;br&gt;获取待绘制的GraphicBuffer&quot;)
 H(&quot;mGraphicProducer&lt;br&gt;.requestBuffer()&lt;br&gt;使用GraphicBuffer&quot;)
 E--&gt;F
 F--&gt;G
 G--&gt;J
 J--&gt;H
J(&quot;mGraphicProducer&lt;br&gt;.dequeueBuffer()&quot;)
</code></pre>
<h5 id="draw-Canvas"><a href="#draw-Canvas" class="headerlink" title="draw(Canvas)"></a>draw(Canvas)</h5><blockquote>
<p>在Canvas上绘制图形</p>
</blockquote>
<h5 id="unlockCanvasAndPost"><a href="#unlockCanvasAndPost" class="headerlink" title="unlockCanvasAndPost()"></a>unlockCanvasAndPost()</h5><blockquote>
<p>提交绘制完成的GraphicBuffer到SurfaceFlinger进行合成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Surface.java</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlockCanvasAndPost</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            checkNotReleasedLocked();<br><br>            <span class="hljs-keyword">if</span> (mHwuiContext != <span class="hljs-keyword">null</span>) &#123;<br>                mHwuiContext.unlockAndPost(canvas);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//软件绘制提交</span><br>                unlockSwCanvasAndPost(canvas);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlockSwCanvasAndPost</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            nativeUnlockCanvasAndPost(mLockedObject, canvas);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            nativeRelease(mLockedObject);<br>            mLockedObject = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/core/jni/android_view_Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nativeUnlockCanvasAndPost</span><span class="hljs-params">(JNIEnv* env, jclass clazz,<br>        jlong nativeObject, jobject canvasObj)</span> </span>&#123;<br>    <span class="hljs-function">sp&lt;Surface&gt; <span class="hljs-title">surface</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;<br>    <span class="hljs-keyword">if</span> (!isSurfaceValid(surface)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// detach the canvas from the surface</span><br>    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);<br>    nativeCanvas-&gt;setBitmap(SkBitmap());<br><br>    <span class="hljs-comment">// unlock surface</span><br>    <span class="hljs-keyword">status_t</span> err = surface-&gt;unlockAndPost();<br>    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;<br>        doThrowIAE(env);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>继续通过<code>Surface#unlockAndPost()</code>执行提交过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/libs/gui/Surface.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Surface::unlockAndPost</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span> (mLockedBuffer == <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">"Surface::unlockAndPost failed, no locked buffer"</span>);<br>        <span class="hljs-keyword">return</span> INVALID_OPERATION;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> fd = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">status_t</span> err = mLockedBuffer-&gt;unlockAsync(&amp;fd);<br><br>    err = queueBuffer(mLockedBuffer.get(), fd);<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Surface::queueBuffer</span><span class="hljs-params">(<span class="hljs-keyword">android_native_buffer_t</span>* buffer, <span class="hljs-keyword">int</span> fenceFd)</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//根据传入的GraphicBufer 获取对应的 BufferSlot位置</span><br>    <span class="hljs-keyword">int</span> i = getSlotFromBufferLocked(buffer);<br>  ...<br>    <span class="hljs-comment">//把获取到的数据 放回到BufferQueue中</span><br>    <span class="hljs-keyword">status_t</span> err = mGraphicerProducer-&gt;queueBuffer(i, input, &amp;output);    <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后通过<code>queueBuffer</code>提交<code>GraphicBuffer</code>。</p>
<pre><code class=" mermaid">graph TB
A(&quot;unlockCanvasAndPost()&quot;)
B(&quot;unlockSwCanvasAndPost()&quot;)
C(&quot;Surface::unlockAndPost&quot;)
A--&gt;B
B--&quot;nativeUnlockCanvasAndPost()&quot;--&gt;C
D(&quot;Surface::queueBuffer&quot;)
C--&gt;D
E(&quot;i = &lt;br&gt;getSlotFromBufferLocked()&quot;)
G(&quot;根据传入的Buffer获取对应mSlots中的index&quot;)
G---E
D---&gt;E
F(&quot;mGraphicProducer&lt;br&gt;.queueBuffer(i)&quot;)
H(&quot;通过queueBuffer放回数据&quot;)
E--&gt;F
H---F
</code></pre>
<h4 id="硬件绘制"><a href="#硬件绘制" class="headerlink" title="硬件绘制"></a>硬件绘制</h4><p>具体执行流程可以参考{% post_link Android-硬件加速%}</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/libs/hwui/renderthread/CanvasContext.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CanvasContext::draw</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//获取GraphicBuffer</span><br>    Frame frame = mRenderPipeline-&gt;getFrame();<br>  ...<br>    <span class="hljs-comment">//绘制图形到 GraphicBuffer上</span><br>    <span class="hljs-keyword">bool</span> drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,<br>                                      mContentDrawBounds, mOpaque, mWideColorGamut, mLightInfo,<br>                                      mRenderNodes, &amp;(profiler()));    <br>  ...<br>    <span class="hljs-comment">//提交绘制完成的GraphicBuffer到 SurfaceFlinger进行合成</span><br>    <span class="hljs-keyword">bool</span> requireSwap = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">bool</span> didSwap =<br>            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="OpenGLPipeline-getFrame"><a href="#OpenGLPipeline-getFrame" class="headerlink" title="OpenGLPipeline#getFrame"></a>OpenGLPipeline#getFrame</h5><blockquote>
<p>从<code>BufferQueue</code>获取<code>GraphicBuffer</code>准备绘制图形</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/libs/hwui/renderthread/OpenGLPipeline.cpp</span><br><span class="hljs-function">Frame <span class="hljs-title">OpenGLPipeline::getFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mEglManager.beginFrame(mEglSurface);<br>&#125;<br><br><span class="hljs-comment">//base/libs/hwui/renderthread/EglManager.cpp</span><br><span class="hljs-function">Frame <span class="hljs-title">EglManager::beginFrame</span><span class="hljs-params">(EGLSurface surface)</span> </span>&#123;<br>    makeCurrent(surface);  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EglManager::makeCurrent</span><span class="hljs-params">(EGLSurface surface, EGLint* errOut)</span> </span>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (!eglMakeCurrent(mEglDisplay, surface, surface, mEglContext)) &#123;<br>        <span class="hljs-keyword">if</span> (errOut) &#123;<br>            *errOut = eglGetError();<br>        &#125;<br>    &#125;<br>    mCurrentSurface = surface; <br>  ...<br>&#125;<br><br><span class="hljs-comment">//native/opengl/libagl/egl.cpp</span><br><span class="hljs-function">EGLBoolean <span class="hljs-title">eglMakeCurrent</span><span class="hljs-params">(  EGLDisplay dpy, EGLSurface draw,<br>                            EGLSurface read, EGLContext ctx)</span><br></span>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (ctx == EGL_NO_CONTEXT) &#123;<br>        <span class="hljs-comment">// if we're detaching, we need the current context</span><br>        current_ctx = (EGLContext)getGlThreadSpecific();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">egl_surface_t</span>* d = (<span class="hljs-keyword">egl_surface_t</span>*)draw;<br>        <span class="hljs-keyword">egl_surface_t</span>* r = (<span class="hljs-keyword">egl_surface_t</span>*)read;<br>    &#125;  <br>  ...<br>            <span class="hljs-keyword">if</span> (d) &#123;<br>              <span class="hljs-comment">//创建GraphicBuffer</span><br>                <span class="hljs-keyword">if</span> (d-&gt;connect() == EGL_FALSE) &#123;<br>                    <span class="hljs-keyword">return</span> EGL_FALSE;<br>                &#125;<br>                d-&gt;ctx = ctx;<br>                d-&gt;bindDrawSurface(gl);<br>            &#125;<br>  ...<br>&#125;<br><br><span class="hljs-function">EGLBoolean <span class="hljs-title">egl_window_surface_v2_t::connect</span><span class="hljs-params">()</span> <br></span>&#123;<br>      <span class="hljs-comment">// dequeue a buffer</span><br>    <span class="hljs-keyword">int</span> fenceFd = <span class="hljs-number">-1</span>;<br>   <span class="hljs-comment">//Surface是 ANativeWindow 的子类，实际调用的就是Surface#dequeueBuffer</span><br>    <span class="hljs-keyword">if</span> (nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer,<br>            &amp;fenceFd) != NO_ERROR) &#123;<br>        <span class="hljs-keyword">return</span> setError(EGL_BAD_ALLOC, EGL_FALSE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>OpenGLPipeline#getFrame()</code>最后通过<code>Surface#dequeueBuffer()</code>获取<code>GraphicBuffer</code></p>
<h5 id="OpenGLPipeline-draw"><a href="#OpenGLPipeline-draw" class="headerlink" title="OpenGLPipeline#draw"></a>OpenGLPipeline#draw</h5><blockquote>
<p>将图像绘制到获取的<code>GraphicBuffer</code>上</p>
</blockquote>
<h5 id="OpenGLPipeline-swapBuffers"><a href="#OpenGLPipeline-swapBuffers" class="headerlink" title="OpenGLPipeline#swapBuffers"></a>OpenGLPipeline#swapBuffers</h5><blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/libs/hwui/renderthread/OpenGLPipeline.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">OpenGLPipeline::swapBuffers</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Frame&amp; frame, <span class="hljs-keyword">bool</span> drew, <span class="hljs-keyword">const</span> SkRect&amp; screenDirty,<br>                                 FrameInfo* currentFrameInfo, <span class="hljs-keyword">bool</span>* requireSwap)</span> </span>&#123;<br><br>  ...<br>    <span class="hljs-keyword">if</span> (*requireSwap &amp;&amp; (CC_UNLIKELY(!mEglManager.swapBuffers(frame, screenDirty)))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> *requireSwap;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在向下执行到<code>EglManager#swapBuffers()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//base/libs/hwui/renderthread/EglManager.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EglManager::swapBuffers</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Frame&amp; frame, <span class="hljs-keyword">const</span> SkRect&amp; screenDirty)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (CC_UNLIKELY(Properties::waitForGpuCompletion)) &#123;<br>        ATRACE_NAME(<span class="hljs-string">"Finishing GPU work"</span>);<br>        fence();<br>    &#125;<br><br>    EGLint rects[<span class="hljs-number">4</span>];<br>    frame.<span class="hljs-built_in">map</span>(screenDirty, rects);<br>    eglSwapBuffersWithDamageKHR(mEglDisplay, frame.mSurface, rects, screenDirty.isEmpty() ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//native/opengl/libs/EGL/eglApi.cpp</span><br><span class="hljs-function">EGLBoolean <span class="hljs-title">eglSwapBuffersWithDamageKHR</span><span class="hljs-params">(EGLDisplay dpy, EGLSurface draw,<br>        EGLint *rects, EGLint n_rects)</span><br></span>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (n_rects == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> s-&gt;cnx-&gt;egl.eglSwapBuffers(dp-&gt;disp.dpy, s-&gt;surface);<br>    &#125;<br>  ...<br>    <span class="hljs-keyword">if</span> (s-&gt;cnx-&gt;egl.eglSwapBuffersWithDamageKHR) &#123;<br>      <span class="hljs-comment">//调用自身</span><br>        <span class="hljs-keyword">return</span> s-&gt;cnx-&gt;egl.eglSwapBuffersWithDamageKHR(dp-&gt;disp.dpy, s-&gt;surface,<br>                rects, n_rects);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> s-&gt;cnx-&gt;egl.eglSwapBuffers(dp-&gt;disp.dpy, s-&gt;surface);<br>    &#125;  <br> <br>&#125;<br><br><span class="hljs-comment">//native/opengl/libagl/egl.cpp</span><br><span class="hljs-function">EGLBoolean <span class="hljs-title">eglSwapBuffers</span><span class="hljs-params">(EGLDisplay dpy, EGLSurface draw)</span><br></span>&#123;<br>    <span class="hljs-comment">// post the surface</span><br>    d-&gt;swapBuffers();<br>   ...<br>    <span class="hljs-keyword">return</span> EGL_TRUE;<br>&#125;<br><br><span class="hljs-function">EGLBoolean <span class="hljs-title">egl_window_surface_v2_t::swapBuffers</span><span class="hljs-params">()</span><br></span>&#123;<br>  ...<br>    unlock(buffer);<br>    previousBuffer = buffer;<br>  <span class="hljs-comment">//提交GraphicBuffer</span><br>    nativeWindow-&gt;queueBuffer(nativeWindow, buffer, <span class="hljs-number">-1</span>);<br>    buffer = <span class="hljs-number">0</span>;<br>  ...<br>    <span class="hljs-comment">//重新申请 GraphicBuffer</span><br>    <span class="hljs-keyword">if</span> (nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer, &amp;fenceFd) == NO_ERROR) &#123;<br>        <span class="hljs-function">sp&lt;Fence&gt; <span class="hljs-title">fence</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Fence(fenceFd))</span></span>;<br>      ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>swapBuffers()</code>主要执行以下两步：</p>
<ul>
<li><code>Surface#queueBuffer</code>：提交<code>GraphicBuffer</code>到<code>BufferQueue</code>中</li>
<li><code>Surface#dequeueBuffer</code>：从<code>BufferQueue</code>中获取空闲的<code>BufferQueue</code>并获取其中的<code>GraphicBuffer</code>进行图像绘制</li>
</ul>
<p>//TODO 流程图</p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>图像缓冲区的使用场景主要有两种：<code>软件绘制</code>和<code>硬件绘制</code>。</p>
<p>主要执行以下几步：</p>
<ol>
<li><code>dequeueBuffer</code>获取<code>GraphicBuffer</code></li>
<li>进行<code>GraphicBuffer</code>内存绑定操作<ul>
<li>软件绘制：<code>GBQ#requestBuffer</code></li>
<li>硬件绘制：<code>egl#lock</code></li>
</ul>
</li>
<li>在<code>GraphicBuffer</code>进行图像绘制</li>
<li><code>queueBuffer</code>提交<code>GraphicBuffer</code>到<code>BufferQueue</code>中</li>
</ol>
<h3 id="图形缓冲区在图像消费者的使用"><a href="#图形缓冲区在图像消费者的使用" class="headerlink" title="图形缓冲区在图像消费者的使用"></a>图形缓冲区在<code>图像消费者</code>的使用</h3><blockquote>
<p><code>图像消费者</code>主要就是<code>SurfaceFlinger</code></p>
</blockquote>
<p>主要执行流程参考<a href="#Vsync信号相关">Vsync信号相关</a></p>
<p>收到<code>Vsync信号</code>会回调到<code>SurfaceFlinger</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> what)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (what) &#123;<br>        <span class="hljs-keyword">case</span> MessageQueue::INVALIDATE: &#123;<br>          <span class="hljs-comment">//判断是否有丢帧</span><br>            <span class="hljs-keyword">bool</span> frameMissed = !mHadClientComposition &amp;&amp;<br>                    mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;<br>                    (mPreviousPresentFence-&gt;getSignalTime() ==<br>                            Fence::SIGNAL_TIME_PENDING);<br>            <span class="hljs-keyword">if</span> (frameMissed) &#123;<br>                mTimeStats.incrementMissedFrames();<br>                <span class="hljs-keyword">if</span> (mPropagateBackpressure) &#123;<br>                  <span class="hljs-comment">//需要执行 申请Vsync信号过程</span><br>                    signalLayerUpdate();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>          <span class="hljs-comment">//需要重新刷新</span><br>            <span class="hljs-keyword">bool</span> refreshNeeded = handleMessageTransaction();<br>            refreshNeeded |= handleMessageInvalidate();<br>            refreshNeeded |= mRepaintEverything;<br>            <span class="hljs-keyword">if</span> (refreshNeeded) &#123;<br>              <span class="hljs-comment">//执行刷新过程</span><br>                signalRefresh();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MessageQueue::REFRESH: &#123;<br>            handleMessageRefresh();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>handleMessageRefresh</code>流程在上面的<a href="#处理Vsync">处理Vsync</a>已经介绍过，包括<code>signalLayerUpdate()</code>以及<code>signalRefresh()</code>都有相关的介绍。</p>
<p>在<code>SurfaceFlinger</code>与<code>BufferQueue</code>相关的操作都位于<code>handleMessageInvalidate()</code>中</p>
<h4 id="SF-handleMessageInvalidate"><a href="#SF-handleMessageInvalidate" class="headerlink" title="SF#handleMessageInvalidate"></a>SF#handleMessageInvalidate</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SurfaceFlinger::handleMessageInvalidate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> handlePageFlip();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SurfaceFlinger::handlePageFlip</span><span class="hljs-params">()</span><br></span>&#123;<br>  ...<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">const</span> Region <span class="hljs-title">dirty</span><span class="hljs-params">(layer-&gt;latchBuffer(visibleRegions, latchTime))</span></span>;<br>        layer-&gt;useSurfaceDamage();<br>        invalidateLayerStack(layer, dirty);<br>        <span class="hljs-keyword">if</span> (layer-&gt;isBufferLatched()) &#123;<br>            newDataLatched = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>layer</code>的实现为<code>BufferLayer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="hljs-function">Region <span class="hljs-title">BufferLayer::latchBuffer</span><span class="hljs-params">(<span class="hljs-keyword">bool</span>&amp; recomputeVisibleRegions, <span class="hljs-keyword">nsecs_t</span> latchTime)</span> </span>&#123;<br>  ...<br>    <span class="hljs-keyword">bool</span> queuedBuffer = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">status_t</span> updateResult =<br>            mConsumer-&gt;updateTexImage(&amp;r, mFlinger-&gt;mPrimaryDispSync,<br>                                                    &amp;mAutoRefresh, &amp;queuedBuffer,<br>                                                    mLastFrameNumberReceived);  <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>mConsumer</code>指的对象为<code>BufferLayerConsumer</code></p>
<h5 id="BufferLayerConsumer-updateTexImage"><a href="#BufferLayerConsumer-updateTexImage" class="headerlink" title="BufferLayerConsumer#updateTexImage"></a>BufferLayerConsumer#updateTexImage</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//native/services/surfaceflinger/BufferLayerConsumer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferLayerConsumer::updateTexImage</span><span class="hljs-params">(BufferRejecter* rejecter, <span class="hljs-keyword">const</span> DispSync&amp; dispSync,<br>                                             <span class="hljs-keyword">bool</span>* autoRefresh, <span class="hljs-keyword">bool</span>* queuedBuffer,<br>                                             <span class="hljs-keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br>  ...<br>    BufferItem item;<br><br>    <span class="hljs-comment">// Acquire the next buffer.</span><br>    <span class="hljs-comment">// In asynchronous mode the list is guaranteed to be one buffer</span><br>    <span class="hljs-comment">// deep, while in synchronous mode we use the oldest buffer.</span><br>    <span class="hljs-comment">// 从BufferQueue获取已绘制完成的 GraphicBuffer</span><br>    <span class="hljs-keyword">status_t</span> err = acquireBufferLocked(&amp;item, computeExpectedPresent(dispSync), maxFrameNumber);<br>  <br>    <span class="hljs-comment">// Release the previous buffer.</span><br>    <span class="hljs-comment">//释放已经使用完成的 GraphicBuffer并返回到BufferQueue</span><br>    err = updateAndReleaseLocked(item, &amp;mPendingRelease);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>updateTexImage</code>主要执行以下两步：</p>
<h6 id="acquireBufferLocked"><a href="#acquireBufferLocked" class="headerlink" title="acquireBufferLocked"></a>acquireBufferLocked</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferLayerConsumer::acquireBufferLocked</span><span class="hljs-params">(BufferItem* item, <span class="hljs-keyword">nsecs_t</span> presentWhen,<br>                                                  <span class="hljs-keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br>    <span class="hljs-keyword">status_t</span> err = ConsumerBase::acquireBufferLocked(item, presentWhen, maxFrameNumber);<br>    <span class="hljs-keyword">return</span> NO_ERROR;<br>&#125;<br><br><span class="hljs-comment">//native/libs/gui/ConsumerBase.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">ConsumerBase::acquireBufferLocked</span><span class="hljs-params">(BufferItem *item,<br>        <span class="hljs-keyword">nsecs_t</span> presentWhen, <span class="hljs-keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;<br>   <br>    <span class="hljs-keyword">status_t</span> err = mConsumer-&gt;acquireBuffer(item, presentWhen, maxFrameNumber);<br><br>    <span class="hljs-keyword">if</span> (item-&gt;mGraphicBuffer != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mSlots[item-&gt;mSlot].mGraphicBuffer != <span class="hljs-literal">NULL</span>) &#123;<br>            freeBufferLocked(item-&gt;mSlot);<br>        &#125;<br>        mSlots[item-&gt;mSlot].mGraphicBuffer = item-&gt;mGraphicBuffer;<br>    &#125;<br><br>    mSlots[item-&gt;mSlot].mFrameNumber = item-&gt;mFrameNumber;<br>    mSlots[item-&gt;mSlot].mFence = item-&gt;mFence;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后是通过<code>acquireBuffer</code>从<code>BufferQueue</code>获取<code>已绘制完成的GraphicBuffer</code></p>
<h6 id="updateAndReleaseLocked"><a href="#updateAndReleaseLocked" class="headerlink" title="updateAndReleaseLocked"></a>updateAndReleaseLocked</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BufferLayerConsumer::updateAndReleaseLocked</span><span class="hljs-params">(<span class="hljs-keyword">const</span> BufferItem&amp; item,<br>                                                     PendingRelease* pendingRelease)</span> </span>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) &#123;<br>        <span class="hljs-keyword">if</span> (pendingRelease == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">status_t</span> status =<br>                    releaseBufferLocked(mCurrentTexture, mCurrentTextureImage-&gt;graphicBuffer());<br>        &#125;<br>    &#125;<br>  ...<br>&#125;<br><br><span class="hljs-comment">//native/libs/gui/ConsumerBase.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">ConsumerBase::releaseBufferLocked</span><span class="hljs-params">(<br>        <span class="hljs-keyword">int</span> slot, <span class="hljs-keyword">const</span> sp&lt;GraphicBuffer&gt; graphicBuffer,<br>        EGLDisplay display, EGLSyncKHR eglFence)</span> </span>&#123;<br>  ...<br>    <span class="hljs-keyword">status_t</span> err = mConsumer-&gt;releaseBuffer(slot, mSlots[slot].mFrameNumber,<br>            display, eglFence, mSlots[slot].mFence);<br>    <span class="hljs-keyword">if</span> (err == IGraphicBufferConsumer::STALE_BUFFER_SLOT) &#123;<br>      <span class="hljs-comment">//重置BufferSlot数据</span><br>        freeBufferLocked(slot);<br>    &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后是通过<code>releaseBuffer()</code>把<code>使用完成的GraphicBuffer</code>返回到<code>BufferQueue</code>中</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/" target="_blank" rel="noopener">SurfaceFlinger 解读</a></p>
<p><a href="https://blog.csdn.net/tyuiof/article/details/108434845" target="_blank" rel="noopener">掌握Android图像显示原理-上</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/16/Ubuntu18-04-双系统安装笔记/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Ubuntu18.04 双系统安装笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/14/Android性能优化-自动内存分析/">
                        <span class="hidden-mobile">Android性能优化-自动内存分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>
  














  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
