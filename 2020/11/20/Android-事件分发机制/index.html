

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <title>Android-事件分发机制 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.5","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android-事件分发机制">
              
                Android-事件分发机制
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-20 10:29" pubdate>
        2020年11月20日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      152
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android-事件分发机制</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>当用户触摸屏幕或者按键操作。</p>
<ol>
<li>首先触发硬件驱动，驱动收到事件后，将相应事件写入到输入设备节点</li>
<li>输入系统取出内核事件，封装成为KeyEvent或MotionEvent</li>
<li>交付给对应的Window消费该事件。</li>
</ol>
</blockquote>
<p><img src="/images/真·事件分发" srcset="/img/loading.gif" alt="input"></p>
<h2 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h2><p>物理设备将数据发送给内核是通过<code>设备驱动</code>传输的，在<code>dev/input/</code>目录下有几个设备文件<code>eventX</code>。</p>
<p>其中<code>event0</code>对应的就是触摸屏，当触摸屏的驱动被挂载后，驱动程序就会进行初始化。</p>
<p>当触发对应的硬件中断后，就会调用对应的处理方法，把对应事件写到<code>设备节点(/dev/input/event0)</code>中.</p>
<p><img src="/images/硬件中断流程.png" srcset="/img/loading.gif" alt="img"></p>
<h2 id="IMS获取内核事件"><a href="#IMS获取内核事件" class="headerlink" title="IMS获取内核事件"></a>IMS获取内核事件</h2><h3 id="IMS启动过程"><a href="#IMS启动过程" class="headerlink" title="IMS启动过程"></a>IMS启动过程</h3><p>在<a href="/2020/11/12/Android-系统启动过程/" title="Android系统启动过程">Android系统启动过程</a>有介绍系统的启动流程，其中<code>IMS</code>属于<code>system_server</code>，随着<code>system_server</code>的启动而启动。</p>
<pre><code class="hljs java"><span class="hljs-comment">//SystemServer.java</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startOtherServices</span><span class="hljs-params">()</span> </span>&#123;
      ...
        InputManagerService inputManager = <span class="hljs-keyword">null</span>;
      ...
            traceBeginAndSlog(<span class="hljs-string">"StartInputManagerService"</span>);
      <span class="hljs-comment">//新建IMS对象</span>
            inputManager = <span class="hljs-keyword">new</span> InputManagerService(context);
            traceEnd();        
      
      <span class="hljs-comment">//启动IMS</span>
            traceBeginAndSlog(<span class="hljs-string">"StartInputManager"</span>);
            inputManager.setWindowManagerCallbacks(wm.getInputMonitor());<span class="hljs-comment">//与window进行绑定</span>
            inputManager.start();
            traceEnd();      
      
    &#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-comment">//InputManagerService.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputManagerService</span><span class="hljs-params">(Context context)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.mContext = context;
        <span class="hljs-keyword">this</span>.mHandler = <span class="hljs-keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());
      ...
        <span class="hljs-comment">//初始化Native对象</span>
        mPtr = nativeInit(<span class="hljs-keyword">this</span>, mContext, mHandler.getLooper().getQueue());

        LocalServices.addService(InputManagerInternal<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">new</span> <span class="hljs-title">LocalService</span>())</span>;
    &#125;</code></pre>
<p><code>nativeInit()</code>执行在Native层</p>
<pre><code class="hljs c++"><span class="hljs-comment">//services/core/jni/com_android_server_input_InputManagerService.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeInit</span><span class="hljs-params">(JNIEnv* env, jclass <span class="hljs-comment">/* clazz */</span>,
        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;
  <span class="hljs-comment">//获取Native的消息队列</span>
    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
  ...
    <span class="hljs-comment">//创建Native的 InputManager对象</span>
    NativeInputManager* im = <span class="hljs-keyword">new</span> NativeInputManager(contextObj, serviceObj,
            messageQueue-&gt;getLooper());
    <span class="hljs-comment">//增加强引用</span>
    im-&gt;incStrong(<span class="hljs-number">0</span>);
   <span class="hljs-comment">//返回 NativeInputManager的指针</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(im);
&#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-comment">//services/core/jni/com_android_server_input_InputManagerService.cpp</span>
NativeInputManager::NativeInputManager(jobject contextObj,
        jobject serviceObj, <span class="hljs-keyword">const</span> sp&lt;Looper&gt;&amp; looper) :
        mLooper(looper), mInteractive(<span class="hljs-keyword">true</span>) &#123;
    JNIEnv* env = jniEnv();

    mContextObj = env-&gt;NewGlobalRef(contextObj);
    mServiceObj = env-&gt;NewGlobalRef(serviceObj);<span class="hljs-comment">//IMS对象</span>

    &#123;
        <span class="hljs-function">AutoMutex <span class="hljs-title">_l</span><span class="hljs-params">(mLock)</span></span>;
        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;
        mLocked.pointerSpeed = <span class="hljs-number">0</span>;
        mLocked.pointerGesturesEnabled = <span class="hljs-keyword">true</span>;
        mLocked.showTouches = <span class="hljs-keyword">false</span>;
        mLocked.pointerCapture = <span class="hljs-keyword">false</span>;
    &#125;
    mInteractive = <span class="hljs-keyword">true</span>;
   <span class="hljs-comment">//初始EventHub对象</span>
    sp&lt;EventHub&gt; eventHub = <span class="hljs-keyword">new</span> EventHub();
   <span class="hljs-comment">//初始InputManager对象</span>
    mInputManager = <span class="hljs-keyword">new</span> InputManager(eventHub, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);
&#125;</code></pre>
<h4 id="初始EventHub"><a href="#初始EventHub" class="headerlink" title="初始EventHub"></a>初始EventHub</h4><p><code>EventHub</code>主要用于<strong>监控设备节点是否更新</strong></p>
<pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/EventHub.cpp</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *WAKE_LOCK_ID = <span class="hljs-string">"KeyEvents"</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *DEVICE_PATH = <span class="hljs-string">"/dev/input"</span>;<span class="hljs-comment">//设备文件</span>

EventHub::EventHub(<span class="hljs-keyword">void</span>) :
        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(<span class="hljs-number">1</span>), mControllerNumbers(),
        mOpeningDevices(<span class="hljs-number">0</span>), mClosingDevices(<span class="hljs-number">0</span>),
        mNeedToSendFinishedDeviceScan(<span class="hljs-literal">false</span>),
        mNeedToReopenDevices(<span class="hljs-literal">false</span>), mNeedToScanDevices(<span class="hljs-literal">true</span>),
        mPendingEventCount(<span class="hljs-number">0</span>), mPendingEventIndex(<span class="hljs-number">0</span>), mPendingINotify(<span class="hljs-literal">false</span>) &#123;
    acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);
<span class="hljs-comment">//创建epoll实例</span>
    mEpollFd = epoll_create(EPOLL_SIZE_HINT);

<span class="hljs-comment">//创建iNotify实例</span>
    mINotifyFd = inotify_init();
<span class="hljs-comment">//iNotify实例 监听 DEVICE_PATH </span>
    <span class="hljs-keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);
          
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">eventItem</span>;</span>
    <span class="hljs-built_in">memset</span>(&amp;eventItem, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(eventItem));
    eventItem.events = EPOLLIN;
    eventItem.data.u32 = EPOLL_ID_INOTIFY;
<span class="hljs-comment">//epoll 监听 iNotify实例</span>
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);

    <span class="hljs-keyword">int</span> wakeFds[<span class="hljs-number">2</span>];
    result = pipe(wakeFds);<span class="hljs-comment">//创造管道</span>

    mWakeReadPipeFd = wakeFds[<span class="hljs-number">0</span>];
    mWakeWritePipeFd = wakeFds[<span class="hljs-number">1</span>];

<span class="hljs-comment">//切换非阻塞方式进行读写</span>
    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);

    eventItem.data.u32 = EPOLL_ID_WAKE;
<span class="hljs-comment">//epoll监听 管道实例</span>
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);

    <span class="hljs-keyword">int</span> major, minor;
    getLinuxRelease(&amp;major, &amp;minor);
    <span class="hljs-comment">// EPOLLWAKEUP was introduced in kernel 3.5</span>
    mUsingEpollWakeup = major &gt; <span class="hljs-number">3</span> || (major == <span class="hljs-number">3</span> &amp;&amp; minor &gt;= <span class="hljs-number">5</span>);
&#125;</code></pre>
<p><code>EventHub</code>主要执行了以下几步：</p>
<ol>
<li>初始化<code>epoll</code>实例</li>
<li>初始化<code>iNotify</code>实例，用于监控<code>/dev/input</code>目录的变化。若发生变化，意味设备发生变化，需要处理。<code>epoll</code>添加<code>iNotify实例</code>监听</li>
<li>创建非阻塞模式的管道(<code>pipe</code>)，epoll监听管道的内容</li>
</ol>
<h4 id="初始InputManager"><a href="#初始InputManager" class="headerlink" title="初始InputManager"></a>初始InputManager</h4><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputManager.cpp</span>
InputManager::InputManager(
        <span class="hljs-keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,
        <span class="hljs-keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,
        <span class="hljs-keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;
    mDispatcher = <span class="hljs-keyword">new</span> InputDispatcher(dispatcherPolicy);
    mReader = <span class="hljs-keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);
    initialize();
&#125;</code></pre>
<h5 id="InputDispatcher"><a href="#InputDispatcher" class="headerlink" title="InputDispatcher"></a>InputDispatcher</h5><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputDispatcher.cpp</span>
InputDispatcher::InputDispatcher(<span class="hljs-keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :
    mPolicy(policy),
    mPendingEvent(<span class="hljs-literal">NULL</span>), mLastDropReason(DROP_REASON_NOT_DROPPED),
    mAppSwitchSawKeyDown(<span class="hljs-literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),
    mNextUnblockedEvent(<span class="hljs-literal">NULL</span>),
    mDispatchEnabled(<span class="hljs-literal">false</span>), mDispatchFrozen(<span class="hljs-literal">false</span>), mInputFilterEnabled(<span class="hljs-literal">false</span>),
    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;
    <span class="hljs-comment">//新建Looper对象</span>
    mLooper = <span class="hljs-keyword">new</span> Looper(<span class="hljs-literal">false</span>);

    mKeyRepeatState.lastKeyEntry = <span class="hljs-literal">NULL</span>;

    policy-&gt;getDispatcherConfiguration(&amp;mConfig);
&#125;</code></pre>
<h5 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h5><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputReader.cpp</span>
InputReader::InputReader(<span class="hljs-keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,
        <span class="hljs-keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,
        <span class="hljs-keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :
        mContext(<span class="hljs-keyword">this</span>), mEventHub(eventHub), mPolicy(policy),
        mGlobalMetaState(<span class="hljs-number">0</span>), mGeneration(<span class="hljs-number">1</span>),
        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),
        mConfigurationChangesToRefresh(<span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">//listener 对象 就是 InputDispatcher</span>
    mQueuedListener = <span class="hljs-keyword">new</span> QueuedInputListener(listener);

    &#123; <span class="hljs-comment">// acquire lock</span>
        AutoMutex _l(mLock);

        refreshConfigurationLocked(<span class="hljs-number">0</span>);
        updateGlobalMetaStateLocked();
    &#125; <span class="hljs-comment">// release lock</span>
&#125;</code></pre>
<p>负责监听<code>InputDispatcher</code>对象</p>
<h5 id="initalize"><a href="#initalize" class="headerlink" title="initalize()"></a>initalize()</h5><pre><code class="hljs java"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputManager.cpp</span>
<span class="hljs-keyword">void</span> InputManager::initialize() &#123;
    mReaderThread = <span class="hljs-keyword">new</span> InputReaderThread(mReader);
    mDispatcherThread = <span class="hljs-keyword">new</span> InputDispatcherThread(mDispatcher);
&#125;

<span class="hljs-comment">//frameworks/native/services/inputflinger/InputDispatcher.cpp</span>
InputDispatcherThread::InputDispatcherThread(<span class="hljs-keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) :
        Thread(<span class="hljs-comment">/*canCallJava*/</span> <span class="hljs-keyword">true</span>), mDispatcher(dispatcher) &#123;
&#125;

<span class="hljs-comment">//frameworks/native/services/inputflinger/InputReader.cpp</span>
InputReaderThread::InputReaderThread(<span class="hljs-keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader) :
        Thread(<span class="hljs-comment">/*canCallJava*/</span> <span class="hljs-keyword">true</span>), mReader(reader) &#123;
&#125;</code></pre>
<p><code>initalize()</code>主要是创建两个能访问Java代码的native线程。</p>
<blockquote>
<p>1.The InputReaderThread (called “InputReader”) reads and preprocesses raw input events,applies policy, and posts messages to a queue managed by the DispatcherThread.</p>
<p>2.The InputDispatcherThread (called “InputDispatcher”) thread waits for new events on the queue and asynchronously dispatches them to applications.</p>
</blockquote>
<h4 id="IMS启动——start"><a href="#IMS启动——start" class="headerlink" title="IMS启动——start()"></a>IMS启动——start()</h4><p><code>IMS</code>初始化完毕就准备启动</p>
<pre><code class="hljs java"><span class="hljs-comment">//InputManagerService.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;
        Slog.i(TAG, <span class="hljs-string">"Starting input manager"</span>);
        nativeStart(mPtr);
      ...
    &#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//services/core/jni/com_android_server_input_InputManagerService.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nativeStart</span><span class="hljs-params">(JNIEnv* env, jclass <span class="hljs-comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;
    NativeInputManager* im = <span class="hljs-keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);

    <span class="hljs-keyword">status_t</span> result = im-&gt;getInputManager()-&gt;start();
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputManager.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">InputManager::start</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-comment">//启动InputDispatcherThread</span>
    <span class="hljs-keyword">status_t</span> result = mDispatcherThread-&gt;<span class="hljs-built_in">run</span>(<span class="hljs-string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY)
  <span class="hljs-comment">//启动InputReaderThread</span>
    result = mReaderThread-&gt;<span class="hljs-built_in">run</span>(<span class="hljs-string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);

    <span class="hljs-keyword">return</span> OK;
&#125;</code></pre>
<p><code>IMS</code>启动，会带着<code>InputDispatcherThread</code>和<code>InputReaderThread</code>一起启动。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>IMS启动过程重点在于Native的初始化，分别创建以下对象：</p>
<ul>
<li><p><strong>EventHub</strong></p>
<p>监听并记录<code>/dev/input</code>的变化</p>
</li>
<li><p><strong>InputManager</strong></p>
<p>创建<code>InputReader</code>和<code>InputDispatcher</code>对象</p>
</li>
</ul>
<p>初始化完毕上述对象后，然后启动以下线程：</p>
<ul>
<li><strong>InputReaderThread</strong>：从<code>EventHub</code>取出事件并处理，再转发给<code>InputDispatcher</code></li>
<li><strong>InputDispatcherThread</strong>：接收来自<code>InputReader</code>的事件，并派发事件到合适的窗口(window)去处理</li>
</ul>
<p><img src="/images/event1_4.png" srcset="/img/loading.gif" alt="img"></p>
<h3 id="内核事件转发APP进程过程"><a href="#内核事件转发APP进程过程" class="headerlink" title="内核事件转发APP进程过程"></a>内核事件转发APP进程过程</h3><p><code>IMS</code>启动之后，<code>InputDispatcherThread</code>与<code>InputReaderThread</code>随之启动。</p>
<h4 id="InputReaderThread"><a href="#InputReaderThread" class="headerlink" title="InputReaderThread"></a>InputReaderThread</h4><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputReader.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InputReaderThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;
    mReader-&gt;loopOnce();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputReader::loopOnce</span><span class="hljs-params">()</span> </span>&#123;
  ...
    <span class="hljs-comment">//从EventHub获取事件</span>
    <span class="hljs-keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);

    &#123; <span class="hljs-comment">// acquire lock</span>
        AutoMutex _l(mLock);
        mReaderIsAliveCondition.broadcast();

        <span class="hljs-keyword">if</span> (count) &#123;
          <span class="hljs-comment">//处理获取的事件</span>
            processEventsLocked(mEventBuffer, count);
        &#125;

    &#125; <span class="hljs-comment">// release lock</span>
    ...
   <span class="hljs-comment">//处理完毕后发送到 InputDispatcher</span>
    mQueuedListener-&gt;<span class="hljs-built_in">flush</span>();
&#125;</code></pre>
<h5 id="EventHub-gt-getEvents-获取事件"><a href="#EventHub-gt-getEvents-获取事件" class="headerlink" title="EventHub-&gt;getEvents() 获取事件"></a>EventHub-&gt;getEvents() 获取事件</h5><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/EventHub.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">EventHub::getEvents</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeoutMillis, RawEvent* <span class="hljs-built_in">buffer</span>, <span class="hljs-keyword">size_t</span> bufferSize)</span> </span>&#123;
  <span class="hljs-comment">//原始事件构造</span>
    RawEvent* event = <span class="hljs-built_in">buffer</span>;
    <span class="hljs-keyword">size_t</span> capacity = bufferSize;  
  <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//开启循环</span>
    ...
        <span class="hljs-keyword">if</span> (mNeedToScanDevices) &#123;
            mNeedToScanDevices = <span class="hljs-literal">false</span>;
            scanDevicesLocked();<span class="hljs-comment">//开始扫描设备</span>
            mNeedToSendFinishedDeviceScan = <span class="hljs-literal">true</span>;
        &#125;    
    ...
        <span class="hljs-keyword">while</span> (mOpeningDevices != <span class="hljs-literal">NULL</span>) &#123;
            Device* device = mOpeningDevices;
            ALOGV(<span class="hljs-string">"Reporting device opened: id=%d, name=%s\n"</span>,
                 device-&gt;id, device-&gt;path.<span class="hljs-built_in">string</span>());
            mOpeningDevices = device-&gt;next;
            event-&gt;when = now;
            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="hljs-number">0</span> : device-&gt;id;
            event-&gt;type = DEVICE_ADDED;<span class="hljs-comment">//添加设备</span>
            event += <span class="hljs-number">1</span>;
            mNeedToSendFinishedDeviceScan = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (--capacity == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;      
    ...
        <span class="hljs-keyword">while</span> (mPendingEventIndex &lt; mPendingEventCount) &#123;
          ...
            <span class="hljs-keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(eventItem.data.u32);          
          ...
            Device* device = mDevices.valueAt(deviceIndex);
            <span class="hljs-keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;
             ...
                    <span class="hljs-keyword">int32_t</span> deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="hljs-number">0</span> : device-&gt;id;

                    <span class="hljs-keyword">size_t</span> count = <span class="hljs-keyword">size_t</span>(readSize) / <span class="hljs-keyword">sizeof</span>(struct input_event);
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;
                      <span class="hljs-comment">//获取readBuffer的数据</span>
                        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_event</span>&amp; <span class="hljs-title">iev</span> = <span class="hljs-title">readBuffer</span>[<span class="hljs-title">i</span>];</span>
                      <span class="hljs-comment">//封装成RawEvent对象</span>
                        event-&gt;deviceId = deviceId;
                        event-&gt;type = iev.type;
                        event-&gt;code = iev.code;
                        event-&gt;value = iev.value;
                        event += <span class="hljs-number">1</span>;
                        capacity -= <span class="hljs-number">1</span>;                      
                      
                    &#125;
            &#125;
        &#125;
          ...
            <span class="hljs-comment">//等待input事件</span>
           <span class="hljs-keyword">int</span> pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);
    
  &#125;
  ...
      <span class="hljs-comment">// 返回读取的事件个数</span>
    <span class="hljs-keyword">return</span> event - <span class="hljs-built_in">buffer</span>;
&#125;</code></pre>
<p><code>getEvents()</code>采用<code>INotify + epoll</code>监听<code>/dev/input/</code>目录下的设备节点，再转换<code>deviceId + input_event</code>为<code>RawEvent</code></p>
<pre><code class="hljs c++"><span class="hljs-comment">// frameworks/native/services/inputflinger/EventHub.h</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RawEvent</span> &#123;</span>
    <span class="hljs-keyword">nsecs_t</span> when;<span class="hljs-comment">//事件发生的时间点</span>
    <span class="hljs-keyword">int32_t</span> deviceId;<span class="hljs-comment">//设备id</span>
    <span class="hljs-keyword">int32_t</span> type;<span class="hljs-comment">//事件类型</span>
    <span class="hljs-keyword">int32_t</span> code;
    <span class="hljs-keyword">int32_t</span> value;
&#125;;</code></pre>
<p><code>type</code>可以为以下几种</p>
<ul>
<li><code>DEVICE_ADDED</code>：添加设备</li>
<li><code>DEVICE_REMOVED</code>：移除设备</li>
<li><code>FINISHED_DEVICE_SCAN</code>：扫描完成</li>
<li><code>type &lt; FIRST_SYNTHETIC_EVENT</code>：其他事件</li>
</ul>
<blockquote>
<p>此时，EventHub从设备节点获取到了事件，并转化为<code>RawEvent</code>向下处理。</p>
</blockquote>
<h5 id="processEventsLocked-处理事件"><a href="#processEventsLocked-处理事件" class="headerlink" title="processEventsLocked() 处理事件"></a>processEventsLocked() 处理事件</h5><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputReader::processEventsLocked</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RawEvent* rawEvents, <span class="hljs-keyword">size_t</span> count)</span> </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> RawEvent* rawEvent = rawEvents; count;) &#123;
        <span class="hljs-keyword">int32_t</span> type = rawEvent-&gt;type;
        <span class="hljs-keyword">size_t</span> batchSize = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;
            <span class="hljs-keyword">int32_t</span> deviceId = rawEvent-&gt;deviceId;
            <span class="hljs-keyword">while</span> (batchSize &lt; count) &#123;
                <span class="hljs-keyword">if</span> (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT
                        || rawEvent[batchSize].deviceId != deviceId) &#123;
                    <span class="hljs-keyword">break</span>;
                &#125;
                batchSize += <span class="hljs-number">1</span>;
            &#125;
          <span class="hljs-comment">//处理其他事件的数据</span>
            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">switch</span> (rawEvent-&gt;type) &#123;
            <span class="hljs-keyword">case</span> EventHubInterface::DEVICE_ADDED:
                <span class="hljs-comment">//设备增加</span>
                addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> EventHubInterface::DEVICE_REMOVED:
                <span class="hljs-comment">//设备移除</span>
                removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> EventHubInterface::FINISHED_DEVICE_SCAN:
                <span class="hljs-comment">//设备扫描完成</span>
                handleConfigurationChangedLocked(rawEvent-&gt;when);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                ALOG_ASSERT(<span class="hljs-literal">false</span>); <span class="hljs-comment">// can't happen</span>
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        count -= batchSize;
        rawEvent += batchSize;
    &#125;
&#125;</code></pre>
<h6 id="addDeviceLocked-添加设备"><a href="#addDeviceLocked-添加设备" class="headerlink" title="addDeviceLocked() 添加设备"></a>addDeviceLocked() 添加设备</h6><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputReader::addDeviceLocked</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> when, <span class="hljs-keyword">int32_t</span> deviceId)</span> </span>&#123;
    <span class="hljs-keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);

  <span class="hljs-comment">//根据deviceId 创建设备</span>
    InputDevice* device = createDeviceLocked(deviceId, controllerNumber, identifier, classes);
    device-&gt;configure(when, &amp;mConfig, <span class="hljs-number">0</span>);
    device-&gt;reset(when);

  <span class="hljs-comment">//添加设备</span>
    mDevices.add(deviceId, device);
    bumpGenerationLocked();

&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-function">InputDevice* <span class="hljs-title">InputReader::createDeviceLocked</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> deviceId, <span class="hljs-keyword">int32_t</span> controllerNumber,
        <span class="hljs-keyword">const</span> InputDeviceIdentifier&amp; identifier, <span class="hljs-keyword">uint32_t</span> classes)</span> </span>&#123;
    InputDevice* device = <span class="hljs-keyword">new</span> InputDevice(&amp;mContext, deviceId, bumpGenerationLocked(),
            controllerNumber, identifier, classes);
...
    <span class="hljs-comment">// Keyboard-like devices.  </span>
    <span class="hljs-keyword">if</span> (keyboardSource != <span class="hljs-number">0</span>) &#123;
        device-&gt;addMapper(<span class="hljs-keyword">new</span> KeyboardInputMapper(device, keyboardSource, keyboardType));
    &#125;

    <span class="hljs-comment">// Cursor-like devices.</span>
    <span class="hljs-keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_CURSOR) &#123;
        device-&gt;addMapper(<span class="hljs-keyword">new</span> CursorInputMapper(device));
    &#125;

    <span class="hljs-comment">// Touchscreens and touchpad devices.</span>
    <span class="hljs-keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_TOUCH_MT) &#123;
        device-&gt;addMapper(<span class="hljs-keyword">new</span> MultiTouchInputMapper(device));
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_TOUCH) &#123;
        device-&gt;addMapper(<span class="hljs-keyword">new</span> SingleTouchInputMapper(device));
    &#125;
...

    <span class="hljs-keyword">return</span> device;
&#125;</code></pre>
<p><code>addDeviceLocked()</code>主要创建<code>InputDevice</code>，并且根据不同的设备类型来创建相应的<code>InputMapper</code>。</p>
<p>根据上述代码列举对应关系：</p>
<ul>
<li><code>Keyboard-like</code>：键盘类设备 –&gt; KeyboardInputMapper</li>
<li><code>Cursor-like</code>：鼠标类设备 –&gt; CursorInputMapper</li>
<li><code>TouchScreens</code>：触摸屏设备 –&gt; MultiTouchInputMapper(多点触控) / SingleTouchInputMapper(单点触控)</li>
</ul>
<h6 id="processEventsForDeviceLocked-处理设备事件"><a href="#processEventsForDeviceLocked-处理设备事件" class="headerlink" title="processEventsForDeviceLocked() 处理设备事件"></a>processEventsForDeviceLocked() 处理设备事件</h6><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputReader::processEventsForDeviceLocked</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> deviceId,
        <span class="hljs-keyword">const</span> RawEvent* rawEvents, <span class="hljs-keyword">size_t</span> count)</span> </span>&#123;
    <span class="hljs-keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);
<span class="hljs-comment">//获取输入设备</span>
    InputDevice* device = mDevices.valueAt(deviceIndex);

    device-&gt;<span class="hljs-built_in">process</span>(rawEvents, count);
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputReader.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputDevice::process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RawEvent* rawEvents, <span class="hljs-keyword">size_t</span> count)</span> </span>&#123;

    <span class="hljs-keyword">size_t</span> numMappers = mMappers.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> RawEvent* rawEvent = rawEvents; count != <span class="hljs-number">0</span>; rawEvent++) &#123;

        <span class="hljs-keyword">if</span> (mDropUntilNextSync) &#123;

        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;

        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numMappers; i++) &#123;
                InputMapper* mapper = mMappers[i];
              <span class="hljs-comment">//获取mapper继续执行process任务</span>
                mapper-&gt;<span class="hljs-built_in">process</span>(rawEvent);
            &#125;
        &#125;
        --count;
    &#125;
&#125;</code></pre>
<p>以触摸屏为例，<code>mapper</code>指向<code>MultiTouchInputMapper</code></p>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MultiTouchInputMapper::process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RawEvent* rawEvent)</span> </span>&#123;
    TouchInputMapper::<span class="hljs-built_in">process</span>(rawEvent);

    mMultiTouchMotionAccumulator.<span class="hljs-built_in">process</span>(rawEvent);
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TouchInputMapper::process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RawEvent* rawEvent)</span> </span>&#123;
    mCursorButtonAccumulator.<span class="hljs-built_in">process</span>(rawEvent);
    mCursorScrollAccumulator.<span class="hljs-built_in">process</span>(rawEvent);
    mTouchButtonAccumulator.<span class="hljs-built_in">process</span>(rawEvent);

    <span class="hljs-keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;
        sync(rawEvent-&gt;when);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TouchInputMapper::dispatchPointerSimple</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> when, <span class="hljs-keyword">uint32_t</span> policyFlags,
        <span class="hljs-keyword">bool</span> down, <span class="hljs-keyword">bool</span> hovering)</span> </span>&#123;
  ...
    <span class="hljs-keyword">if</span> (mPointerSimple.down &amp;&amp; !down) &#123;
        mPointerSimple.down = <span class="hljs-literal">false</span>;

        <span class="hljs-comment">// Send up.</span>
        <span class="hljs-function">NotifyMotionArgs <span class="hljs-title">args</span><span class="hljs-params">(when, getDeviceId(), mSource, policyFlags,
                 AMOTION_EVENT_ACTION_UP, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, metaState, mLastRawState.buttonState, <span class="hljs-number">0</span>,
                 mViewport.displayId, <span class="hljs-comment">/* deviceTimestamp */</span> <span class="hljs-number">0</span>,
                 <span class="hljs-number">1</span>, &amp;mPointerSimple.lastProperties, &amp;mPointerSimple.lastCoords,
                 mOrientedXPrecision, mOrientedYPrecision,
                 mPointerSimple.downTime)</span></span>;
        getListener()-&gt;notifyMotion(&amp;args);
    &#125;
  
    <span class="hljs-keyword">if</span> (down) &#123;
        <span class="hljs-keyword">if</span> (!mPointerSimple.down) &#123;
            mPointerSimple.down = <span class="hljs-literal">true</span>;
            mPointerSimple.downTime = when;

            <span class="hljs-comment">// Send down.</span>
            <span class="hljs-function">NotifyMotionArgs <span class="hljs-title">args</span><span class="hljs-params">(when, getDeviceId(), mSource, policyFlags,
                    AMOTION_EVENT_ACTION_DOWN, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, metaState, mCurrentRawState.buttonState, <span class="hljs-number">0</span>,
                    mViewport.displayId, <span class="hljs-comment">/* deviceTimestamp */</span> <span class="hljs-number">0</span>,
                    <span class="hljs-number">1</span>, &amp;mPointerSimple.currentProperties, &amp;mPointerSimple.currentCoords,
                    mOrientedXPrecision, mOrientedYPrecision,
                    mPointerSimple.downTime)</span></span>;
            getListener()-&gt;notifyMotion(&amp;args);
        &#125;

        <span class="hljs-comment">// Send move.</span>
        <span class="hljs-function">NotifyMotionArgs <span class="hljs-title">args</span><span class="hljs-params">(when, getDeviceId(), mSource, policyFlags,
                AMOTION_EVENT_ACTION_MOVE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, metaState, mCurrentRawState.buttonState, <span class="hljs-number">0</span>,
                mViewport.displayId, <span class="hljs-comment">/* deviceTimestamp */</span> <span class="hljs-number">0</span>,
                <span class="hljs-number">1</span>, &amp;mPointerSimple.currentProperties, &amp;mPointerSimple.currentCoords,
                mOrientedXPrecision, mOrientedYPrecision,
                mPointerSimple.downTime)</span></span>;
        getListener()-&gt;notifyMotion(&amp;args);
    &#125;  
  
&#125;</code></pre>
<p><code>getListener()</code>指的就是<code>mQueuedListener</code></p>
<pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputListener.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QueuedInputListener::notifyMotion</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NotifyMotionArgs* args)</span> </span>&#123;
    mArgsQueue.push(<span class="hljs-keyword">new</span> NotifyMotionArgs(*args));
&#125;</code></pre>
<p>将触摸事件放入<code>mArgsQueue</code>，此时事件加工完成。</p>
<h5 id="QueuedInputListener-flush-发送事件"><a href="#QueuedInputListener-flush-发送事件" class="headerlink" title="QueuedInputListener.flush() 发送事件"></a>QueuedInputListener.flush() 发送事件</h5><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputListener.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QueuedInputListener::flush</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">size_t</span> count = mArgsQueue.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;
        NotifyArgs* args = mArgsQueue[i];
        args-&gt;notify(mInnerListener);
        <span class="hljs-keyword">delete</span> args;
    &#125;
    mArgsQueue.<span class="hljs-built_in">clear</span>();
&#125;</code></pre>
<p><code>NotifyArgs</code>主要有以下几类：</p>
<ul>
<li>NotifyConfigurationChangedArgs：配置变化</li>
<li>NotifyKeyArgs：键盘事件</li>
<li>NotifyMotionArgs：触摸事件</li>
<li>NotifySwitchArgs：切换事件</li>
<li>NotifyDeviceResetArgs：设备重置事件</li>
</ul>
<p>根据上节可知<code>args</code>为<code>NotifyMotionArgs</code></p>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NotifyMotionArgs::notify</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener)</span> <span class="hljs-keyword">const</span> </span>&#123;
    listener-&gt;notifyMotion(<span class="hljs-keyword">this</span>);
&#125;</code></pre>
<p><code>listener</code>指的就是<code>InputDispatcher</code></p>
<pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputDispatcher.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputDispatcher::notifyMotion</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NotifyMotionArgs* args)</span> </span>&#123;
...
    <span class="hljs-keyword">if</span> (!validateMotionEvent(args-&gt;action, args-&gt;actionButton,
                args-&gt;pointerCount, args-&gt;pointerProperties)) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">uint32_t</span> policyFlags = args-&gt;policyFlags;
    policyFlags |= POLICY_FLAG_TRUSTED;

    android::base::Timer t;
    mPolicy-&gt;interceptMotionBeforeQueueing(args-&gt;eventTime, <span class="hljs-comment">/*byref*/</span> policyFlags);

    <span class="hljs-keyword">bool</span> needWake;
    &#123; <span class="hljs-comment">// acquire lock</span>
        mLock.lock();

      <span class="hljs-comment">//拦截事件分发</span>
        <span class="hljs-keyword">if</span> (shouldSendMotionToInputFilterLocked(args)) &#123;
            mLock.unlock();

            MotionEvent event;<span class="hljs-comment">//初始化MotionEvent对象</span>
            event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action, args-&gt;actionButton,
                    args-&gt;flags, args-&gt;edgeFlags, args-&gt;metaState, args-&gt;buttonState,
                    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, args-&gt;xPrecision, args-&gt;yPrecision,
                    args-&gt;downTime, args-&gt;eventTime,
                    args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords);

            policyFlags |= POLICY_FLAG_FILTERED;
            <span class="hljs-keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;
                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// event was consumed by the filter</span>
            &#125;

            mLock.lock();
        &#125;

        <span class="hljs-comment">// Just enqueue a new motion event.</span>
        MotionEntry* newEntry = <span class="hljs-keyword">new</span> MotionEntry(args-&gt;eventTime,
                args-&gt;deviceId, args-&gt;source, policyFlags,
                args-&gt;action, args-&gt;actionButton, args-&gt;flags,
                args-&gt;metaState, args-&gt;buttonState,
                args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime,
                args-&gt;displayId,
                args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

        needWake = enqueueInboundEventLocked(newEntry);
        mLock.unlock();
    &#125; <span class="hljs-comment">// release lock</span>

    <span class="hljs-keyword">if</span> (needWake) &#123;
      <span class="hljs-comment">//唤醒消息队列</span>
        mLooper-&gt;wake();
    &#125;
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InputDispatcher::enqueueInboundEventLocked</span><span class="hljs-params">(EventEntry* entry)</span> </span>&#123;
    <span class="hljs-keyword">bool</span> needWake = mInboundQueue.isEmpty();
    mInboundQueue.enqueueAtTail(entry);<span class="hljs-comment">//将事件放入`mInBoundQueue`的尾部，等待处理</span>
    traceInboundQueueLengthLocked();

    <span class="hljs-keyword">switch</span> (entry-&gt;type) &#123;

    <span class="hljs-keyword">case</span> EventEntry::TYPE_MOTION: &#123;

        MotionEntry* motionEntry = <span class="hljs-keyword">static_cast</span>&lt;MotionEntry*&gt;(entry);
        <span class="hljs-keyword">if</span> (motionEntry-&gt;action == AMOTION_EVENT_ACTION_DOWN
                &amp;&amp; (motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)
                &amp;&amp; mInputTargetWaitCause == INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY
                &amp;&amp; mInputTargetWaitApplicationHandle != <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-keyword">int32_t</span> displayId = motionEntry-&gt;displayId;
            <span class="hljs-keyword">int32_t</span> x = <span class="hljs-keyword">int32_t</span>(motionEntry-&gt;pointerCoords[<span class="hljs-number">0</span>].
                    getAxisValue(AMOTION_EVENT_AXIS_X));
            <span class="hljs-keyword">int32_t</span> y = <span class="hljs-keyword">int32_t</span>(motionEntry-&gt;pointerCoords[<span class="hljs-number">0</span>].
                    getAxisValue(AMOTION_EVENT_AXIS_Y));
            sp&lt;InputWindowHandle&gt; touchedWindowHandle = findTouchedWindowAtLocked(displayId, x, y);
            <span class="hljs-keyword">if</span> (touchedWindowHandle != <span class="hljs-literal">NULL</span>
                    &amp;&amp; touchedWindowHandle-&gt;inputApplicationHandle
                            != mInputTargetWaitApplicationHandle) &#123;
                <span class="hljs-comment">// User touched a different application than the one we are waiting on.</span>
                <span class="hljs-comment">// Flag the event, and start pruning the input queue.</span>
                mNextUnblockedEvent = motionEntry;
                needWake = <span class="hljs-literal">true</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">break</span>;
    &#125;
    &#125;

    <span class="hljs-keyword">return</span> needWake;
&#125;</code></pre>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/v2-196591e61a6bed7189d68d7a72a07f4a_1440w.jpg" srcset="/img/loading.gif" alt="img"></p>
<p><code>InputReaderThread</code>主要负责<strong>事件封装转换</strong></p>
<ul>
<li><code>EventHub.getEvents()</code>：通过<code>epoll</code>监听<code>iNotify实例(监听 /dev/input/ 目录)</code>读取事件放入<code>mEventBuffer</code>，然后转换成<code>RawEvent</code></li>
<li><code>processEventsLocked()</code>：对<code>RawEvent</code>进行加工，转换成<code>NotifyMotionArgs</code></li>
<li><code>flush()</code>：将事件<code>NotifyMotionArgs</code>发送到<code>InputDispatcher</code>进行处理，最后转换成<code>MotionEntry</code>并写入到<code>InputDispatcher.mInBoundQueue</code></li>
</ul>
<p><img src="/images/InputReaderThread.jpg" srcset="/img/loading.gif" alt="InputReaderThread"></p>
<h4 id="InputDispatcherThread"><a href="#InputDispatcherThread" class="headerlink" title="InputDispatcherThread"></a>InputDispatcherThread</h4><pre><code class="hljs c++"><span class="hljs-comment">// frameworks/native/services/inputflinger/InputDispatcher.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InputDispatcherThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;
    mDispatcher-&gt;dispatchOnce();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputDispatcher::dispatchOnce</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;
    &#123; <span class="hljs-comment">// acquire lock</span>
        AutoMutex _l(mLock);
      <span class="hljs-comment">//唤醒等待线程，监听当前是否发生死锁</span>
        mDispatcherIsAliveCondition.broadcast();

        <span class="hljs-comment">// Run a dispatch loop if there are no pending commands.</span>
        <span class="hljs-comment">// The dispatch loop might enqueue commands to run afterwards.</span>
        <span class="hljs-keyword">if</span> (!haveCommandsLocked()) &#123;
            dispatchOnceInnerLocked(&amp;nextWakeupTime);
        &#125;

        <span class="hljs-comment">// Run all pending commands if there are any.</span>
        <span class="hljs-comment">// If any commands were run then force the next poll to wake up immediately.</span>
        <span class="hljs-keyword">if</span> (runCommandsLockedInterruptible()) &#123;
            nextWakeupTime = LONG_LONG_MIN;
        &#125;
    &#125; <span class="hljs-comment">// release lock</span>

    <span class="hljs-comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span>
    <span class="hljs-keyword">nsecs_t</span> currentTime = now();
    <span class="hljs-keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);
    mLooper-&gt;pollOnce(timeoutMillis);
&#125;</code></pre>
<h5 id="dispatchOnceInnerLocked-获取事件"><a href="#dispatchOnceInnerLocked-获取事件" class="headerlink" title="dispatchOnceInnerLocked() 获取事件"></a>dispatchOnceInnerLocked() 获取事件</h5><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputDispatcher::dispatchOnceInnerLocked</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;
    <span class="hljs-keyword">nsecs_t</span> currentTime = now();

    <span class="hljs-comment">// Ready to start a new event.</span>
    <span class="hljs-comment">// If we don't already have a pending event, go grab one.</span>
    <span class="hljs-keyword">if</span> (! mPendingEvent) &#123;
        <span class="hljs-keyword">if</span> (mInboundQueue.isEmpty()) &#123;
          ...
            <span class="hljs-comment">// Nothing to do if there is no pending event.</span>
            <span class="hljs-keyword">if</span> (!mPendingEvent) &#123;
                <span class="hljs-keyword">return</span>;
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 从 mInBoundQueue获取事件 实质就是上一步的 MotionEntry</span>
            mPendingEvent = mInboundQueue.dequeueAtHead();
            traceInboundQueueLengthLocked();
        &#125;
      ...
        <span class="hljs-comment">// 重置ANR时间</span>
        resetANRTimeoutsLocked();
    &#125;

    <span class="hljs-comment">// Now we have an event to dispatch.</span>
    <span class="hljs-comment">// All events are eventually dequeued and processed this way, even if we intend to drop them.</span>
    ALOG_ASSERT(mPendingEvent != <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">bool</span> done = <span class="hljs-literal">false</span>;
    DropReason dropReason = DROP_REASON_NOT_DROPPED;
    <span class="hljs-keyword">if</span> (!(mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER)) &#123;
        dropReason = DROP_REASON_POLICY;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mDispatchEnabled) &#123;
        dropReason = DROP_REASON_DISABLED;
    &#125;

    <span class="hljs-keyword">switch</span> (mPendingEvent-&gt;type) &#123;
    <span class="hljs-keyword">case</span> EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;
       ...
        <span class="hljs-keyword">break</span>;
    &#125;

    <span class="hljs-keyword">case</span> EventEntry::TYPE_DEVICE_RESET: &#123;
       ...
        <span class="hljs-keyword">break</span>;
    &#125;

    <span class="hljs-keyword">case</span> EventEntry::TYPE_KEY: &#123;
       ...
        <span class="hljs-keyword">break</span>;
    &#125;

    <span class="hljs-keyword">case</span> EventEntry::TYPE_MOTION: &#123;
        MotionEntry* typedEntry = <span class="hljs-keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);
        <span class="hljs-keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;
            dropReason = DROP_REASON_APP_SWITCH;
        &#125;
        <span class="hljs-keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED
                &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123;
            dropReason = DROP_REASON_STALE;
        &#125;
        <span class="hljs-keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;
            dropReason = DROP_REASON_BLOCKED;
        &#125;
      <span class="hljs-comment">//分发触摸事件</span>
        done = dispatchMotionLocked(currentTime, typedEntry,
                &amp;dropReason, nextWakeupTime);
        <span class="hljs-keyword">break</span>;
    &#125;


    <span class="hljs-keyword">if</span> (done) &#123;
        <span class="hljs-keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;
            dropInboundEventLocked(mPendingEvent, dropReason);
        &#125;
        mLastDropReason = dropReason;

        releasePendingEventLocked();
        *nextWakeupTime = LONG_LONG_MIN;  <span class="hljs-comment">// force next poll to wake up immediately</span>
    &#125;
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InputDispatcher::dispatchMotionLocked</span><span class="hljs-params">(
        <span class="hljs-keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="hljs-keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;

    <span class="hljs-keyword">bool</span> isPointerEvent = entry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER;

    <span class="hljs-comment">// Identify targets.</span>
    Vector&lt;InputTarget&gt; inputTargets;

    <span class="hljs-keyword">bool</span> conflictingPointerActions = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">int32_t</span> injectionResult;
    <span class="hljs-keyword">if</span> (isPointerEvent) &#123;
        <span class="hljs-comment">// 寻找有 焦点的 window。并记录在inputTargets中</span>
        injectionResult = findTouchedWindowTargetsLocked(currentTime,
                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// Non touch event.  (eg. trackball)</span>
        injectionResult = findFocusedWindowTargetsLocked(currentTime,
                entry, inputTargets, nextWakeupTime);
    &#125;

    addMonitoringTargetsLocked(inputTargets);
   <span class="hljs-comment">//将 entry 分发到 对应window上</span>
    dispatchEventLocked(currentTime, entry, inputTargets);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputDispatcher::dispatchEventLocked</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> currentTime,
        EventEntry* eventEntry, <span class="hljs-keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;

    pokeUserActivityLocked(eventEntry);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; inputTargets.<span class="hljs-built_in">size</span>(); i++) &#123;
        <span class="hljs-keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);

        <span class="hljs-keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);
        <span class="hljs-keyword">if</span> (connectionIndex &gt;= <span class="hljs-number">0</span>) &#123;
            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);
          <span class="hljs-comment">//准备分发消息</span>
            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);

        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputDispatcher::prepareDispatchCycleLocked</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> currentTime,
        <span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="hljs-keyword">const</span> InputTarget* inputTarget)</span> </span>&#123;
     ...

    <span class="hljs-comment">// Not splitting.  Enqueue dispatch entries for the event as is.</span>
    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);
&#125;


<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputDispatcher::enqueueDispatchEntriesLocked</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> currentTime,
        <span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="hljs-keyword">const</span> InputTarget* inputTarget)</span> </span>&#123;
    <span class="hljs-keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();
  ...

    <span class="hljs-comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span>
    <span class="hljs-keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;
        startDispatchCycleLocked(currentTime, connection);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InputDispatcher::startDispatchCycleLocked</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> currentTime,
        <span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; connection)</span> </span>&#123;
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span>
    ALOGD(<span class="hljs-string">"channel '%s' ~ startDispatchCycle"</span>,
            connection-&gt;getInputChannelName().c_str());
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

    <span class="hljs-keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL
            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;
        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;
        dispatchEntry-&gt;deliveryTime = currentTime;

        <span class="hljs-comment">// Publish the event.</span>
        <span class="hljs-keyword">status_t</span> status;
        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;
        <span class="hljs-keyword">switch</span> (eventEntry-&gt;type) &#123;


        <span class="hljs-keyword">case</span> EventEntry::TYPE_MOTION: &#123;
            MotionEntry* motionEntry = <span class="hljs-keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);

            PointerCoords scaledCoords[MAX_POINTERS];
            <span class="hljs-keyword">const</span> PointerCoords* usingCoords = motionEntry-&gt;pointerCoords;

            <span class="hljs-comment">// Set the X and Y offset depending on the input source.</span>
            <span class="hljs-keyword">float</span> xOffset, yOffset;
            <span class="hljs-keyword">if</span> ((motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)
                    &amp;&amp; !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123;
                <span class="hljs-keyword">float</span> scaleFactor = dispatchEntry-&gt;scaleFactor;
                xOffset = dispatchEntry-&gt;xOffset * scaleFactor;
                yOffset = dispatchEntry-&gt;yOffset * scaleFactor;
                <span class="hljs-keyword">if</span> (scaleFactor != <span class="hljs-number">1.0f</span>) &#123;
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;
                        scaledCoords[i] = motionEntry-&gt;pointerCoords[i];
                        scaledCoords[i].scale(scaleFactor);
                    &#125;
                    usingCoords = scaledCoords;
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                xOffset = <span class="hljs-number">0.0f</span>;
                yOffset = <span class="hljs-number">0.0f</span>;

                <span class="hljs-comment">// We don't want the dispatch target to know.</span>
                <span class="hljs-keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS) &#123;
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;
                        scaledCoords[i].<span class="hljs-built_in">clear</span>();
                    &#125;
                    usingCoords = scaledCoords;
                &#125;
            &#125;

            <span class="hljs-comment">// Publish the motion event.</span>
            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,
                    motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId,
                    dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,
                    dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,
                    motionEntry-&gt;metaState, motionEntry-&gt;buttonState,
                    xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,
                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,
                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,
                    usingCoords);
            <span class="hljs-keyword">break</span>;
        &#125;

        <span class="hljs-comment">// Re-enqueue the event on the wait queue.</span>
        connection-&gt;outboundQueue.dequeue(dispatchEntry);
        traceOutboundQueueLengthLocked(connection);
        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);
        traceWaitQueueLengthLocked(connection);
    &#125;
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/libs/input/InputTransport.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">InputPublisher::publishMotionEvent</span><span class="hljs-params">(
        <span class="hljs-keyword">uint32_t</span> seq,
        <span class="hljs-keyword">int32_t</span> deviceId,
        <span class="hljs-keyword">int32_t</span> source,
        <span class="hljs-keyword">int32_t</span> displayId,
        <span class="hljs-keyword">int32_t</span> action,
        <span class="hljs-keyword">int32_t</span> actionButton,
        <span class="hljs-keyword">int32_t</span> flags,
        <span class="hljs-keyword">int32_t</span> edgeFlags,
        <span class="hljs-keyword">int32_t</span> metaState,
        <span class="hljs-keyword">int32_t</span> buttonState,
        <span class="hljs-keyword">float</span> xOffset,
        <span class="hljs-keyword">float</span> yOffset,
        <span class="hljs-keyword">float</span> xPrecision,
        <span class="hljs-keyword">float</span> yPrecision,
        <span class="hljs-keyword">nsecs_t</span> downTime,
        <span class="hljs-keyword">nsecs_t</span> eventTime,
        <span class="hljs-keyword">uint32_t</span> pointerCount,
        <span class="hljs-keyword">const</span> PointerProperties* pointerProperties,
        <span class="hljs-keyword">const</span> PointerCoords* pointerCoords)</span> </span>&#123;


    InputMessage msg;
    msg.header.type = InputMessage::TYPE_MOTION;
    msg.body.motion.seq = seq;
    msg.body.motion.deviceId = deviceId;
    msg.body.motion.source = source;
    msg.body.motion.displayId = displayId;
    msg.body.motion.action = action;
    msg.body.motion.actionButton = actionButton;
    msg.body.motion.flags = flags;
    msg.body.motion.edgeFlags = edgeFlags;
    msg.body.motion.metaState = metaState;
    msg.body.motion.buttonState = buttonState;
    msg.body.motion.xOffset = xOffset;
    msg.body.motion.yOffset = yOffset;
    msg.body.motion.xPrecision = xPrecision;
    msg.body.motion.yPrecision = yPrecision;
    msg.body.motion.downTime = downTime;
    msg.body.motion.eventTime = eventTime;
    msg.body.motion.pointerCount = pointerCount;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; pointerCount; i++) &#123;
        msg.body.motion.pointers[i].properties.copyFrom(pointerProperties[i]);
        msg.body.motion.pointers[i].coords.copyFrom(pointerCoords[i]);
    &#125;
    <span class="hljs-keyword">return</span> mChannel-&gt;sendMessage(&amp;msg);
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/libs/input/InputTransport.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">InputChannel::sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">const</span> InputMessage* msg)</span> </span>&#123;
 ...
&#125;</code></pre>
<p>最终通过<code>InputChannel</code>发送包装好的触摸事件</p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/event1_5.png" srcset="/img/loading.gif" alt="img"></p>
<p><code>InputReader</code>发送触摸事件到<code>InputDispatcher</code>，通过<code>findFocusedWindowTargetsLocked()</code>寻找触摸事件对应的窗口，如果没有找到就使用第一个<code>Window</code>。把结果写入<code>inputTargets</code>中，然后通过<code>publishMotionEvent</code>分发触摸事件，再通过<code>InputChannel</code>发送消息到UI线程。</p>
<p><img src="/images/InputDispatcherThread.jpg" srcset="/img/loading.gif" alt="InputDispatche"></p>
<h3 id="触摸事件发送至Activity"><a href="#触摸事件发送至Activity" class="headerlink" title="触摸事件发送至Activity"></a>触摸事件发送至Activity</h3><p><code>InputDispatcher</code>负责分发触摸事件，最后通过<code>InputChannel-&gt;sendMessage()</code>发出消息</p>
<pre><code class="hljs c++"><span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">InputChannel::sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">const</span> InputMessage* msg)</span> </span>&#123;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> msgLength = msg-&gt;<span class="hljs-built_in">size</span>();
    InputMessage cleanMsg;
    msg-&gt;getSanitizedCopy(&amp;cleanMsg);
    <span class="hljs-keyword">ssize_t</span> nWrite;
    <span class="hljs-keyword">do</span> &#123;
        nWrite = ::send(mFd, &amp;cleanMsg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);
    &#125; <span class="hljs-keyword">while</span> (nWrite == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR);

    <span class="hljs-keyword">return</span> OK;
&#125;</code></pre>
<p><code>InputChannel</code>通过<code>socket</code>发送消息。</p>
<p>既然存在<code>sendMessage()</code>就需要找到相对的<code>receiveMessage()</code>调用的地方。</p>
<p>最后屏幕的触摸事件都需要反映到一个Activity上，然后再一步步传递到对应的View上。所以需要先从Activity开始分析触摸事件的传递流程。</p>
<h4 id="InputChannel注册"><a href="#InputChannel注册" class="headerlink" title="InputChannel注册"></a>InputChannel注册</h4><pre><code class="hljs java"><span class="hljs-comment">//ActivityThread.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest, <span class="hljs-keyword">boolean</span> isForward,
            String reason)</span> </span>&#123;
      ...
        wm.addView(decor, l);
      ...
    &#125;

<span class="hljs-comment">// ==&gt; WindowManagerGlobal.java</span>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow)</span> </span>&#123;
        <span class="hljs-comment">//新建ViewRootImpl</span>
            root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);        
        
        root.setView(view, wparams, panelParentView);
      &#125;
  
<span class="hljs-comment">// ==&gt; ViewRootImpl.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;
      <span class="hljs-comment">//创建InputChannel对象</span>
        <span class="hljs-keyword">if</span> ((mWindowAttributes.inputFeatures
                 &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="hljs-number">0</span>) &#123;
            mInputChannel = <span class="hljs-keyword">new</span> InputChannel();
        &#125; 
      <span class="hljs-comment">//创建Socket的服务端</span>
       res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
             getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,
             mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
             mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);      
      
      <span class="hljs-comment">//创建Socket的客户端</span>
        <span class="hljs-keyword">if</span> (mInputChannel != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (mInputQueueCallback != <span class="hljs-keyword">null</span>) &#123;
                mInputQueue = <span class="hljs-keyword">new</span> InputQueue();
                mInputQueueCallback.onInputQueueCreated(mInputQueue);
            &#125;
          <span class="hljs-comment">//创建WindowEventReceiver对象</span>
            mInputEventReceiver = <span class="hljs-keyword">new</span> WindowInputEventReceiver(mInputChannel,
                    Looper.myLooper());
        &#125;
    &#125;</code></pre>
<h5 id="addToDisplay"><a href="#addToDisplay" class="headerlink" title="addToDisplay()"></a>addToDisplay()</h5><pre><code class="hljs java"><span class="hljs-comment">//Session.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addToDisplay</span><span class="hljs-params">(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,
            <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outFrame, Rect outContentInsets,
            Rect outStableInsets, Rect outOutsets,
            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel)</span> </span>&#123;
        <span class="hljs-keyword">return</span> mService.addWindow(<span class="hljs-keyword">this</span>, window, seq, attrs, viewVisibility, displayId, outFrame,
                outContentInsets, outStableInsets, outOutsets, outDisplayCutout, outInputChannel);
    &#125;</code></pre>
<p>其中<code>mService</code>指的就是<code>WindowManagerService</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addWindow</span><span class="hljs-params">(Session session, IWindow client, <span class="hljs-keyword">int</span> seq,
            LayoutParams attrs, <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outFrame,
            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,
            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel)</span> </span>&#123;
      ...
            <span class="hljs-keyword">final</span> WindowState win = <span class="hljs-keyword">new</span> WindowState(<span class="hljs-keyword">this</span>, session, client, token, parentWindow,
                    appOp[<span class="hljs-number">0</span>], seq, attrs, viewVisibility, session.mUid,
                    session.mCanAddInternalSystemWindow);
      ...
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> openInputChannels = (outInputChannel != <span class="hljs-keyword">null</span>
                    &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span>  (openInputChannels) &#123;
                win.openInputChannel(outInputChannel);
            &#125;      
      
    &#125;</code></pre>
<p><code>addWindow()</code>主要创建了<code>WindowState</code>对象，然后继续调用到<code>openInputChannels()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//frameworks/base/services/core/java/com/android/server/wm/WindowState.java</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">openInputChannel</span><span class="hljs-params">(InputChannel outInputChannel)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mInputChannel != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Window already has an input channel."</span>);
        &#125;
        String name = getName();
        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);
        mInputChannel = inputChannels[<span class="hljs-number">0</span>];
        mClientChannel = inputChannels[<span class="hljs-number">1</span>];
        mInputWindowHandle.inputChannel = inputChannels[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span> (outInputChannel != <span class="hljs-keyword">null</span>) &#123;
            mClientChannel.transferTo(outInputChannel);
            mClientChannel.dispose();
            mClientChannel = <span class="hljs-keyword">null</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// If the window died visible, we setup a dummy input channel, so that taps</span>
            <span class="hljs-comment">// can still detected by input monitor channel, and we can relaunch the app.</span>
            <span class="hljs-comment">// Create dummy event receiver that simply reports all events as handled.</span>
            mDeadWindowEventReceiver = <span class="hljs-keyword">new</span> DeadWindowEventReceiver(mClientChannel);
        &#125;
        mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);
    &#125;</code></pre>
<p><strong>点到为止</strong></p>
<p><img src="/images/v2-1e1273f15cfdd7b81aa7a2cb819d8890_1440w.jpg" srcset="/img/loading.gif" alt="InputChannel对应关系"></p>
<p><code>addToDisplay()</code>主要处理两部分内容</p>
<ul>
<li><p>创建Socket pair，作为<code>InputChannel</code></p>
<p><code>socket服务端</code>保存在<code>WidnowState</code>中的<code>mInputChannel</code>中</p>
<p><code>socket客户端</code>通过<code>binder</code>传到<code>ViewRootImpl</code>中的<code>mInputChannel</code></p>
</li>
<li><p>通过<code>IMS.registerInputChannel()</code>注册<code>InputChannel</code>，监听socket服务端，收到消息后回调<code>InputDispatcher::handleReceiveCallback()</code></p>
</li>
</ul>
<h5 id="WindowInputEventReceiver"><a href="#WindowInputEventReceiver" class="headerlink" title="WindowInputEventReceiver"></a>WindowInputEventReceiver</h5><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>
    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowInputEventReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputEventReceiver</span> </span>&#123;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WindowInputEventReceiver</span><span class="hljs-params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;
            <span class="hljs-keyword">super</span>(inputChannel, looper);
        &#125;
      ...
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInputEvent</span><span class="hljs-params">(InputEvent event, <span class="hljs-keyword">int</span> displayId)</span> </span>&#123;
            enqueueInputEvent(event, <span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">true</span>);
        &#125;        
    &#125;

<span class="hljs-comment">//InputeventReceiver.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputEventReceiver</span><span class="hljs-params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;

        mInputChannel = inputChannel;
        mMessageQueue = looper.getQueue();
        mReceiverPtr = nativeInit(<span class="hljs-keyword">new</span> WeakReference&lt;InputEventReceiver&gt;(<span class="hljs-keyword">this</span>),
                inputChannel, mMessageQueue);

        mCloseGuard.open(<span class="hljs-string">"dispose"</span>);
    &#125;

<span class="hljs-comment">//Native层调用该方法</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchInputEvent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> seq, InputEvent event, <span class="hljs-keyword">int</span> displayId)</span> </span>&#123;
        mSeqMap.put(event.getSequenceNumber(), seq);
        onInputEvent(event, displayId);
    &#125;</code></pre>
<p>初始化 InputEventReceiver</p>
<pre><code class="hljs c++"><span class="hljs-comment">//frameworks/base/core/jni/android_view_InputEventReceiver.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeInit</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jobject receiverWeak,
        jobject inputChannelObj, jobject messageQueueObj)</span> </span>&#123;
    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,
            inputChannelObj);
    <span class="hljs-keyword">if</span> (inputChannel == <span class="hljs-literal">NULL</span>) &#123;
        jniThrowRuntimeException(env, <span class="hljs-string">"InputChannel is not initialized."</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;

  <span class="hljs-comment">//获取消息队列</span>
    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
    <span class="hljs-keyword">if</span> (messageQueue == <span class="hljs-literal">NULL</span>) &#123;
        jniThrowRuntimeException(env, <span class="hljs-string">"MessageQueue is not initialized."</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;

  <span class="hljs-comment">//创建NativeInputEventReceiver对象</span>
    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="hljs-keyword">new</span> NativeInputEventReceiver(env,
            receiverWeak, inputChannel, messageQueue);
    <span class="hljs-keyword">status_t</span> status = receiver-&gt;initialize();

    receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); <span class="hljs-comment">// retain a reference for the object</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="hljs-built_in">get</span>());
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">NativeInputEventReceiver::initialize</span><span class="hljs-params">()</span> </span>&#123;
    setFdEvents(ALOOPER_EVENT_INPUT);
    <span class="hljs-keyword">return</span> OK;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NativeInputEventReceiver::setFdEvents</span><span class="hljs-params">(<span class="hljs-keyword">int</span> events)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (mFdEvents != events) &#123;
        mFdEvents = events;
        <span class="hljs-keyword">int</span> fd = mInputConsumer.getChannel()-&gt;getFd();
        <span class="hljs-keyword">if</span> (events) &#123;
            mMessageQueue-&gt;getLooper()-&gt;addFd(fd, <span class="hljs-number">0</span>, events, <span class="hljs-keyword">this</span>, <span class="hljs-literal">NULL</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            mMessageQueue-&gt;getLooper()-&gt;removeFd(fd);
        &#125;
    &#125;
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//system/core/libutils/Looper.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Looper::addFd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> ident, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="hljs-keyword">void</span>* data)</span> </span>&#123;
  <span class="hljs-comment">//构造native Request消息</span>
          Request request;
        request.fd = fd;
        request.ident = ident;
        request.events = events;
        request.seq = mNextRequestSeq++;
        request.callback = callback; <span class="hljs-comment">//NativeInputReceiver</span>
        request.data = data;
        <span class="hljs-keyword">if</span> (mNextRequestSeq == <span class="hljs-number">-1</span>) mNextRequestSeq = <span class="hljs-number">0</span>; <span class="hljs-comment">// reserve sequence number -1</span>
  
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">eventItem</span>;</span>
        request.initEventItem(&amp;eventItem);
       ...
         <span class="hljs-comment">//在epoll实例 添加native request监听</span>
        <span class="hljs-keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);         
  
       <span class="hljs-comment">//唤醒线程</span>
        scheduleEpollRebuildLocked();  
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Looper::scheduleEpollRebuildLocked</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!mEpollRebuildRequired) &#123;
        mEpollRebuildRequired = <span class="hljs-literal">true</span>;
        wake();
    &#125;
&#125;</code></pre>
<p>这一部分涉及<code>looper</code>在<code>Handler</code>就有详细介绍，<code>wake</code>之后，<code>native request</code>相关消息触发后会回调到<code>callback-&gt;handleEvent()</code></p>
<pre><code class="hljs c++"><span class="hljs-comment">//frameworks/base/core/jni/android_view_InputEventReceiver.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">NativeInputEventReceiver::handleEvent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> receiveFd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span>* data)</span> </span>&#123;
  ...
    <span class="hljs-keyword">if</span> (events &amp; ALOOPER_EVENT_INPUT) &#123; <span class="hljs-comment">//events 就是 ALOOPER_EVENT_INPUT</span>
        JNIEnv* env = AndroidRuntime::getJNIEnv();
        <span class="hljs-keyword">status_t</span> status = consumeEvents(env, <span class="hljs-literal">false</span> <span class="hljs-comment">/*consumeBatches*/</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>);
        mMessageQueue-&gt;raiseAndClearException(env, <span class="hljs-string">"handleReceiveCallback"</span>);
        <span class="hljs-keyword">return</span> status == OK || status == NO_MEMORY ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
    &#125;
  ...
&#125;

<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">NativeInputEventReceiver::consumeEvents</span><span class="hljs-params">(JNIEnv* env,
        <span class="hljs-keyword">bool</span> consumeBatches, <span class="hljs-keyword">nsecs_t</span> frameTime, <span class="hljs-keyword">bool</span>* outConsumedBatch)</span> </span>&#123;
  <span class="hljs-keyword">for</span> (;;) &#123;
        <span class="hljs-keyword">status_t</span> status = mInputConsumer.consume(&amp;mInputEventFactory,
                consumeBatches, frameTime, &amp;seq, &amp;inputEvent, &amp;displayId);
    ...
        <span class="hljs-keyword">if</span> (!skipCallbacks) &#123;

            jobject inputEventObj;
            <span class="hljs-keyword">switch</span> (inputEvent-&gt;getType()) &#123;

            <span class="hljs-keyword">case</span> AINPUT_EVENT_TYPE_MOTION: &#123;
                <span class="hljs-keyword">if</span> (kDebugDispatchCycle) &#123;
                    ALOGD(<span class="hljs-string">"channel '%s' ~ Received motion event."</span>, getInputChannelName().c_str());
                &#125;
              <span class="hljs-comment">//封装MotionEvent对象</span>
                MotionEvent* motionEvent = <span class="hljs-keyword">static_cast</span>&lt;MotionEvent*&gt;(inputEvent);
                <span class="hljs-keyword">if</span> ((motionEvent-&gt;getAction() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123;
                    *outConsumedBatch = <span class="hljs-literal">true</span>;
                &#125;
                inputEventObj = android_view_MotionEvent_obtainAsCopy(env, motionEvent);
                <span class="hljs-keyword">break</span>;
            &#125;

            <span class="hljs-keyword">default</span>:
                assert(<span class="hljs-literal">false</span>); <span class="hljs-comment">// InputConsumer should prevent this from ever happening</span>
                inputEventObj = <span class="hljs-literal">NULL</span>;
            &#125;

            <span class="hljs-keyword">if</span> (inputEventObj) &#123;
                <span class="hljs-keyword">if</span> (kDebugDispatchCycle) &#123;
                    ALOGD(<span class="hljs-string">"channel '%s' ~ Dispatching input event."</span>, getInputChannelName().c_str());
                &#125;
              <span class="hljs-comment">//回调到Java层的 dispatchInputEvent() </span>
                env-&gt;CallVoidMethod(receiverObj.<span class="hljs-built_in">get</span>(),
                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj,
                        displayId);
                <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) &#123;
                    ALOGE(<span class="hljs-string">"Exception dispatching input event."</span>);
                    skipCallbacks = <span class="hljs-literal">true</span>;
                &#125;
                env-&gt;DeleteLocalRef(inputEventObj);
            &#125; <span class="hljs-keyword">else</span> &#123;
                ALOGW(<span class="hljs-string">"channel '%s' ~ Failed to obtain event object."</span>,
                        getInputChannelName().c_str());
                skipCallbacks = <span class="hljs-literal">true</span>;
            &#125;
        &#125;    
    
  &#125;
  
&#125;</code></pre>
<pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/libs/input/InputTransport.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">InputConsumer::consume</span><span class="hljs-params">(InputEventFactoryInterface* factory,
        <span class="hljs-keyword">bool</span> consumeBatches, <span class="hljs-keyword">nsecs_t</span> frameTime, <span class="hljs-keyword">uint32_t</span>* outSeq, InputEvent** outEvent,
        <span class="hljs-keyword">int32_t</span>* displayId)</span> </span>&#123;
    <span class="hljs-keyword">while</span> (!*outEvent) &#123;
            mMsgDeferred = <span class="hljs-literal">false</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 收到新消息</span>
            <span class="hljs-keyword">status_t</span> result = mChannel-&gt;receiveMessage(&amp;mMsg);
            <span class="hljs-keyword">if</span> (result) &#123;
                <span class="hljs-keyword">if</span> (consumeBatches || result != WOULD_BLOCK) &#123;
                    result = consumeBatch(factory, frameTime, outSeq, outEvent, displayId);
                    <span class="hljs-keyword">if</span> (*outEvent) &#123;
                        <span class="hljs-keyword">break</span>;
                    &#125;
                &#125;
                <span class="hljs-keyword">return</span> result;
            &#125;
        &#125;  
  
&#125;</code></pre>
<p><code>WindowInputEventReceiver</code>主要执行了以下几步：</p>
<ul>
<li>初始化了<code>NativeInputReceiver</code>，调用了<code>sendFdEvents()</code>发出了消息</li>
<li>往主线程Looper添加了一条<code>Native Request</code>，且<code>callback</code>为<code>NativeInputReceiver</code></li>
<li>向Looper的<code>mEpollFd</code>添加了监听，只要收到触摸事件的消息就会调用到<code>callback-&gt;handleEvent()</code></li>
<li><code>NativeInputReceiver::handleEvent()</code>主要回调到Java层的<code>dispatchInputEvent()</code>且携带<code>InputEvent</code>回去(在触摸场景下，实际为<code>MotionEvent</code>)。</li>
</ul>
<p>//TODO 流程图</p>
<h4 id="回调到Activity"><a href="#回调到Activity" class="headerlink" title="回调到Activity"></a>回调到Activity</h4><pre><code class="hljs java"><span class="hljs-comment">//InputEventReceiver.java</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchInputEvent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> seq, InputEvent event, <span class="hljs-keyword">int</span> displayId)</span> </span>&#123;
        mSeqMap.put(event.getSequenceNumber(), seq);
        onInputEvent(event, displayId);
    &#125;


<span class="hljs-comment">//ViewRootImpl.java</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInputEvent</span><span class="hljs-params">(InputEvent event, <span class="hljs-keyword">int</span> displayId)</span> </span>&#123;
            enqueueInputEvent(event, <span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">true</span>);
        &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueueInputEvent</span><span class="hljs-params">(InputEvent event,
            InputEventReceiver receiver, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">boolean</span> processImmediately)</span> </span>&#123;
        adjustInputEventForCompatibility(event);
        QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);

        <span class="hljs-keyword">if</span> (processImmediately) &#123;
            doProcessInputEvents();
        &#125; <span class="hljs-keyword">else</span> &#123;
            scheduleProcessInputEvents();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doProcessInputEvents</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// Deliver all pending input events in the queue.</span>
        <span class="hljs-keyword">while</span> (mPendingInputEventHead != <span class="hljs-keyword">null</span>) &#123;
            QueuedInputEvent q = mPendingInputEventHead;
            mPendingInputEventHead = q.mNext;
            <span class="hljs-keyword">if</span> (mPendingInputEventHead == <span class="hljs-keyword">null</span>) &#123;
                mPendingInputEventTail = <span class="hljs-keyword">null</span>;
            &#125;
            q.mNext = <span class="hljs-keyword">null</span>;

            <span class="hljs-keyword">if</span> (q.mEvent <span class="hljs-keyword">instanceof</span> MotionEvent) &#123;
                MotionEvent me = (MotionEvent)q.mEvent;
                <span class="hljs-keyword">if</span> (me.getHistorySize() &gt; <span class="hljs-number">0</span>) &#123;
                    oldestEventTime = me.getHistoricalEventTimeNano(<span class="hljs-number">0</span>);
                &#125;
            &#125;
            mChoreographer.mFrameInfo.updateInputEventTime(eventTime, oldestEventTime);

            deliverInputEvent(q);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deliverInputEvent</span><span class="hljs-params">(QueuedInputEvent q)</span> </span>&#123;

        InputStage stage;
        <span class="hljs-keyword">if</span> (q.shouldSendToSynthesizer()) &#123;
            stage = mSyntheticInputStage;
        &#125; <span class="hljs-keyword">else</span> &#123;
            stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;
        &#125;

        <span class="hljs-keyword">if</span> (stage != <span class="hljs-keyword">null</span>) &#123;
            handleWindowFocusChanged();
            stage.deliver(q);
        &#125; <span class="hljs-keyword">else</span> &#123;
          <span class="hljs-comment">//事件分发完成后 执行</span>
            finishInputEvent(q);
        &#125;
    &#125;

    <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputStage</span> </span>&#123;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deliver</span><span class="hljs-params">(QueuedInputEvent q)</span> </span>&#123;
            <span class="hljs-keyword">if</span> ((q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED) != <span class="hljs-number">0</span>) &#123;
                forward(q);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shouldDropInputEvent(q)) &#123;
                finish(q, <span class="hljs-keyword">false</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                apply(q, onProcess(q));
            &#125;
        &#125;      
    &#125;</code></pre>
<p>此处<code>stage</code>是<code>ViewPostImeInputStage</code>，向下继续调用到<code>onProcess()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//viewRootImpl.java</span>
    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewPostImeInputStage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputStage</span> </span>&#123;
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">onProcess</span><span class="hljs-params">(QueuedInputEvent q)</span> </span>&#123;
            <span class="hljs-keyword">if</span> (q.mEvent <span class="hljs-keyword">instanceof</span> KeyEvent) &#123;
                <span class="hljs-keyword">return</span> processKeyEvent(q);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> source = q.mEvent.getSource();
                <span class="hljs-keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-keyword">return</span> processPointerEvent(q);
                &#125;
            &#125;
        &#125;
      
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">processPointerEvent</span><span class="hljs-params">(QueuedInputEvent q)</span> </span>&#123;
            <span class="hljs-keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;

            mAttachInfo.mUnbufferedDispatchRequested = <span class="hljs-keyword">false</span>;
            mAttachInfo.mHandlingPointerEvent = <span class="hljs-keyword">true</span>;
          <span class="hljs-comment">//向下分发到View</span>
            <span class="hljs-keyword">boolean</span> handled = mView.dispatchPointerEvent(event);
  
            <span class="hljs-keyword">return</span> handled ? FINISH_HANDLED : FORWARD;
        &#125;      
      
    &#125;</code></pre>
<p>此时<code>mView</code>表示的就是<code>DecorView</code>，本质就是View</p>
<pre><code class="hljs java"><span class="hljs-comment">//view.java    </span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchPointerEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (event.isTouchEvent()) &#123;
            <span class="hljs-keyword">return</span> dispatchTouchEvent(event);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> dispatchGenericMotionEvent(event);
        &#125;
    &#125;

<span class="hljs-comment">//DecorView.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;
        <span class="hljs-keyword">final</span> Window.Callback cb = mWindow.getCallback();
        <span class="hljs-keyword">return</span> cb != <span class="hljs-keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="hljs-number">0</span>
                ? cb.dispatchTouchEvent(ev) : <span class="hljs-keyword">super</span>.dispatchTouchEvent(ev);
    &#125;</code></pre>
<p><code>mWindow.getCallback()</code>就是与Window绑定的Activity</p>
<pre><code class="hljs java"><span class="hljs-comment">//Activity.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;
            onUserInteraction();
        &#125;
        <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        &#125;
        <span class="hljs-keyword">return</span> onTouchEvent(ev);
    &#125;</code></pre>
<p>所以经过一系列操作 让用户的屏幕触摸操作，最终走到了<code>Activity.dispatchTouchEvent()</code></p>
<p><img src="/images/触发Activity触摸事件" srcset="/img/loading.gif" alt="img"></p>
<h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><h3 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h3><blockquote>
<p>当用户点击View或ViewGroup的时候，将会产生一个事件对象，就是<code>MotionEvent</code>。</p>
</blockquote>
<p><code>MotionEvent</code>记录了<code>事件的类型(action)、触摸的位置(x,y)以及触摸的时间等</code>。</p>
<p>事件的类型主要分为以下几种：</p>
<ul>
<li><code>ACTION_DOWN</code>：监听用户手指按下的操作，一次按下标志触摸事件的开始。</li>
<li><code>ACTION_MOVE</code>：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。</li>
<li><code>ACTION_UP</code>：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。</li>
<li><code>ACTION_CANCEL</code>：当用户保持按下操作，并把手指移动到了控件外部区域时且父View处理事件触发。</li>
</ul>
<p>用户手指触摸到屏幕到离开屏幕可能产生的事件序列如下：</p>
<p><code>ACTION_DOWN</code> -&gt; <code>ACTION_MOVE</code> -&gt; <code>ACTION_MOVE</code> -&gt; … <code>ACTION_MOVE</code> -&gt; <code>ACTION_UP</code></p>
<p><img src="/images/事件分发顺序.jpg" srcset="/img/loading.gif" alt="事件分发顺序"></p>
<h3 id="MotionEvent产生时机"><a href="#MotionEvent产生时机" class="headerlink" title="MotionEvent产生时机"></a>MotionEvent产生时机</h3><p>在<code>ViewRootImpl,setView()</code>时，创建了<code>WindowInputReceiver</code>，当IMS写入事件(通过EventHub监听到<code>/dev/input/</code>)，通过一系列的操作回调到<code>dispatchInputEvent()</code>，最后走到了<code>processPointerEvent()</code>，此时把从Native层传递过来的<code>InputEvent</code>强转成<code>MotionEvent</code>，然后继续向下传递。</p>
<h3 id="MotionEvent传递顺序-事件分发顺序"><a href="#MotionEvent传递顺序-事件分发顺序" class="headerlink" title="MotionEvent传递顺序-事件分发顺序"></a>MotionEvent传递顺序-事件分发顺序</h3><p>事件分发本质就是<code>MotionEvent</code>的传递过程。</p>
<pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">processPointerEvent</span><span class="hljs-params">(QueuedInputEvent q)</span> </span>&#123;
            <span class="hljs-keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;

            mAttachInfo.mUnbufferedDispatchRequested = <span class="hljs-keyword">false</span>;
            mAttachInfo.mHandlingPointerEvent = <span class="hljs-keyword">true</span>;
          <span class="hljs-comment">//向下分发到View</span>
            <span class="hljs-keyword">boolean</span> handled = mView.dispatchPointerEvent(event);
  
            <span class="hljs-keyword">return</span> handled ? FINISH_HANDLED : FORWARD;
        &#125;</code></pre>
<p><code>mView</code>就是<code>DecorView</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//DecorView.java</span>
没有实现对应方法。。。
向上寻找父类
  
<span class="hljs-comment">//View.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchPointerEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (event.isTouchEvent()) &#123;
            <span class="hljs-keyword">return</span> dispatchTouchEvent(event);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> dispatchGenericMotionEvent(event);
        &#125;
    &#125;
  

<span class="hljs-comment">//DecorView.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;
        <span class="hljs-keyword">final</span> Window.Callback cb = mWindow.getCallback();
        <span class="hljs-keyword">return</span> cb != <span class="hljs-keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="hljs-number">0</span>
                ? cb.dispatchTouchEvent(ev) : <span class="hljs-keyword">super</span>.dispatchTouchEvent(ev);
    &#125;</code></pre>
<p>此时<code>mWindow.getCallback()</code>指的就是<code>Activity</code></p>
<h4 id="Activity事件分发"><a href="#Activity事件分发" class="headerlink" title="Activity事件分发"></a>Activity事件分发</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;
      <span class="hljs-comment">//在此处可以监听到 用户触摸屏幕的操作</span>
        onUserInteraction();
    &#125;
   <span class="hljs-comment">//若dispatchTouchEvent返回true，事件到此结束，返回false，继续向下传递</span>
  <span class="hljs-comment">//对应PhoneWindow</span>
    <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
  <span class="hljs-comment">//没有任何View去处理，交给Activity自身的onTouchEvent处理</span>
    <span class="hljs-keyword">return</span> onTouchEvent(ev);
&#125;</code></pre>
<p><code>getWindow()</code>对应唯一实现类<code>PhoneWindow</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//PhoneWindow.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;
      <span class="hljs-comment">//mDecor 是DecorView的一个实例，DecoeView就是顶层View中的实例对象</span>
        <span class="hljs-keyword">return</span> mDecor.superDispatchTouchEvent(event);
    &#125;</code></pre>
<p><code>mDecor</code>指的就是<code>DecorView</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//DecorView.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;
      <span class="hljs-comment">//调用父类的方法即FrameLayout.dispatchTouchEvent = ViewGroup.dispatchTouchEvent()，由父类去处理事件分发</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);<span class="hljs-comment">//指向了 ViewGroup</span>
    &#125;</code></pre>
<p><img src="/images/Activity-Dispatch.png" srcset="/img/loading.gif" alt="Activity事件分发"></p>
<p>总结一下：按照上述流程图，当一个点击事件进来时，Activity上的事件流程如下：</p>
<ul>
<li>调用<code>Activity.dispatchTouchEvent()</code>，然后调用<code>onUserInteraction()</code></li>
<li>调用<code>getWindow()即PhoneWindow.superDispatchTouchEvent()</code></li>
<li>调用<code>mDecor即DecorView.superDispatchTouchEvent()</code></li>
<li>调用DecorView父类即<strong><code>ViewGroup.dispatchTouchEvent()</code></strong> 在这里实现了事件从Activity传递至ViewGroup</li>
</ul>
<h4 id="ViewGroup事件分发"><a href="#ViewGroup事件分发" class="headerlink" title="ViewGroup事件分发"></a>ViewGroup事件分发</h4><p>上述Activity分发后，执行到<code>ViewGroup.dispatchTouchEvent()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//ViewGroup.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;
      ...
        
            <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;
              <span class="hljs-comment">//发生ACTION_DOWN事件，取消并清除之前的触摸</span>
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            &#125;        
      ...
          <span class="hljs-comment">//判定当前事件是否需要拦截</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intercepted;
            <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//只有ACTION_DOWN才可以触发拦截</span>
                <span class="hljs-comment">//FLAG_DISALLOW_INTERCEPT：禁止ViewGroup拦截除了DOWN以外的事件</span>
                <span class="hljs-comment">//可由View调用requestDisallowInterceptTouchEvent设置标记</span>
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;
                  <span class="hljs-comment">//调用拦截方法</span>
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span>
                &#125; <span class="hljs-keyword">else</span> &#123;
                    intercepted = <span class="hljs-keyword">false</span>;
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
               <span class="hljs-comment">//没有触摸targets 且 非ACTION_DOWN 需要拦截</span>
                intercepted = <span class="hljs-keyword">true</span>;
            &#125;   
      ...
           <span class="hljs-comment">//非取消事件 且 没被拦截</span>
            <span class="hljs-keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;
                <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;<span class="hljs-comment">//当前为 DOWN 事件</span>
                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> actionIndex = ev.getActionIndex(); <span class="hljs-comment">// always 0 for down</span>
                   <span class="hljs-comment">//存在子View</span>
                    <span class="hljs-keyword">if</span> (newTouchTarget == <span class="hljs-keyword">null</span> &amp;&amp; childrenCount != <span class="hljs-number">0</span>) &#123;
                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> x = ev.getX(actionIndex);
                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> y = ev.getY(actionIndex);
                      <span class="hljs-comment">//从上往下 寻找能处理触摸事件的子View</span>
                        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();
                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = preorderedList == <span class="hljs-keyword">null</span>
                                &amp;&amp; isChildrenDrawingOrderEnabled();
                        <span class="hljs-keyword">final</span> View[] children = mChildren;
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
                            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(
                                    childrenCount, i, customOrder);
                            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(
                                    preorderedList, children, childIndex);
                           <span class="hljs-comment">//无法获取焦点，跳过循环</span>
                            <span class="hljs-keyword">if</span> (childWithAccessibilityFocus != <span class="hljs-keyword">null</span>) &#123;
                                <span class="hljs-keyword">if</span> (childWithAccessibilityFocus != child) &#123;
                                    <span class="hljs-keyword">continue</span>;
                                &#125;
                                childWithAccessibilityFocus = <span class="hljs-keyword">null</span>;
                                i = childrenCount - <span class="hljs-number">1</span>;
                            &#125;
                          <span class="hljs-comment">//View不可见 或者 触摸的坐标点不在View的范围内，跳过循环</span>
                            <span class="hljs-keyword">if</span> (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, <span class="hljs-keyword">null</span>)) &#123;
                                ev.setTargetAccessibilityFocus(<span class="hljs-keyword">false</span>);
                                <span class="hljs-keyword">continue</span>;
                            &#125;

                            newTouchTarget = getTouchTarget(child);
                          <span class="hljs-comment">//当前正在循环 ，退出当前循环</span>
                            <span class="hljs-keyword">if</span> (newTouchTarget != <span class="hljs-keyword">null</span>) &#123;
                                <span class="hljs-comment">// Child is already receiving touch within its bounds.</span>
                                <span class="hljs-comment">// Give it the new pointer in addition to the ones it is handling.</span>
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                <span class="hljs-keyword">break</span>;
                            &#125;

                            resetCancelNextUpFlag(child);
                          <span class="hljs-comment">////事件传递下来后，调用dispatchTransformedTouchEvent，事件就会传递到View/ViewGroup中       </span>
                            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-keyword">false</span>, child, idBitsToAssign)) &#123;
                                <span class="hljs-comment">// Child wants to receive touch within its bounds.</span>
                                mLastTouchDownTime = ev.getDownTime();
                                <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-keyword">null</span>) &#123;
                                    <span class="hljs-comment">// childIndex points into presorted list, find original index</span>
                                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; childrenCount; j++) &#123;
                                        <span class="hljs-keyword">if</span> (children[childIndex] == mChildren[j]) &#123;
                                            mLastTouchDownIndex = j;
                                            <span class="hljs-keyword">break</span>;
                                        &#125;
                                    &#125;
                                &#125; <span class="hljs-keyword">else</span> &#123;
                                    mLastTouchDownIndex = childIndex;
                                &#125;
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                              <span class="hljs-comment">//添加新的 touchtarget</span>
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = <span class="hljs-keyword">true</span>;
                                <span class="hljs-keyword">break</span>;
                            &#125;
                            ev.setTargetAccessibilityFocus(<span class="hljs-keyword">false</span>);
                        &#125;
                        <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-keyword">null</span>) preorderedList.clear();
                    &#125;

                    <span class="hljs-keyword">if</span> (newTouchTarget == <span class="hljs-keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;
                        newTouchTarget = mFirstTouchTarget;
                        <span class="hljs-keyword">while</span> (newTouchTarget.next != <span class="hljs-keyword">null</span>) &#123;
                            newTouchTarget = newTouchTarget.next;
                        &#125;
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                    &#125;                  
                &#125;
            &#125;
      
            <span class="hljs-comment">// mFirstTouchTarget赋值是在通过addTouchTarget方法获取的；</span>
            <span class="hljs-comment">// 只有处理ACTION_DOWN事件，才会进入addTouchTarget方法。</span>
            <span class="hljs-comment">// 这也正是当View没有消费ACTION_DOWN事件，则不会接收其他MOVE,UP等事件的原因</span>
            <span class="hljs-keyword">if</span> (mFirstTouchTarget == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">// ViewGroup处理事件 当无人可以响应触摸事件</span>
                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-keyword">null</span>,
                        TouchTarget.ALL_POINTER_IDS);
            &#125; <span class="hljs-keyword">else</span> &#123;
               <span class="hljs-comment">//如果View消费ACTION_DOWN事件，那么MOVE,UP等事件相继开始执行</span>
                TouchTarget predecessor = <span class="hljs-keyword">null</span>;
                TouchTarget target = mFirstTouchTarget;
                <span class="hljs-keyword">while</span> (target != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-keyword">final</span> TouchTarget next = target.next;
                    <span class="hljs-keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;
                        handled = <span class="hljs-keyword">true</span>;
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                      <span class="hljs-comment">//子View/ViewGroup 处理触摸事件</span>
                        <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) &#123;
                            handled = <span class="hljs-keyword">true</span>;
                        &#125;
                        <span class="hljs-keyword">if</span> (cancelChild) &#123;
                            <span class="hljs-keyword">if</span> (predecessor == <span class="hljs-keyword">null</span>) &#123;
                                mFirstTouchTarget = next;
                            &#125; <span class="hljs-keyword">else</span> &#123;
                                predecessor.next = next;
                            &#125;
                            target.recycle();
                            target = next;
                            <span class="hljs-keyword">continue</span>;
                        &#125;
                    &#125;
                    predecessor = target;
                    target = next;
                &#125;
            &#125;    
              ...
        &#125;
        <span class="hljs-keyword">return</span> handled;
      
    &#125;</code></pre>
<h5 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent()"></a>onInterceptTouchEvent()</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)
            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN
            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;</code></pre>
<p>可以通过重写该方法，进行事件分发的拦截。</p>
<ul>
<li>返回true，事件被拦截，执行当前View的<code>onTouchEvent()</code></li>
<li>返回false，事件继续向下分发</li>
</ul>
<h5 id="buildTouchDispatchChildList"><a href="#buildTouchDispatchChildList" class="headerlink" title="buildTouchDispatchChildList()"></a>buildTouchDispatchChildList()</h5><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;View&gt; <span class="hljs-title">buildTouchDispatchChildList</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> buildOrderedChildList();
    &#125;

    <span class="hljs-function">ArrayList&lt;View&gt; <span class="hljs-title">buildOrderedChildList</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childrenCount = mChildrenCount;
        <span class="hljs-keyword">if</span> (childrenCount &lt;= <span class="hljs-number">1</span> || !hasChildWithZ()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

      <span class="hljs-comment">//z</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = isChildrenDrawingOrderEnabled();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;
            <span class="hljs-comment">// add next child (in child order) to end of list</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            <span class="hljs-keyword">final</span> View nextChild = mChildren[childIndex];
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> currentZ = nextChild.getZ();

            <span class="hljs-comment">// 按z轴，从小到大排序所有的子视图，即z轴大的View先响应事件</span>
            <span class="hljs-keyword">int</span> insertIndex = i;
            <span class="hljs-keyword">while</span> (insertIndex &gt; <span class="hljs-number">0</span> &amp;&amp; mPreSortedChildren.get(insertIndex - <span class="hljs-number">1</span>).getZ() &gt; currentZ) &#123;
                insertIndex--;
            &#125;
            mPreSortedChildren.add(insertIndex, nextChild);
        &#125;
        <span class="hljs-keyword">return</span> mPreSortedChildren;
    &#125;

<span class="hljs-comment">//View.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getZ</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> getElevation() + getTranslationZ();
    &#125;</code></pre>
<p>默认的事件分发顺序与绘制顺序一致，按照<code>view.getZ()</code>从大到小排序，Z值大的先绘制且先响应事件。</p>
<p>当然，这个事件分发的顺序也可以修改，只需要实现两个方法：</p>
<ul>
<li><code>isChildDrawingOrder()</code>：允许自定义顺序</li>
<li><code>getChildDrawingOrder()</code>：自定义当前View的顺序</li>
</ul>
<p>也可以通过<code>setElevation()</code>、<code>setTranslationZ()</code>或者<code>setZ()</code>去修改Z轴的坐标值。</p>
<h5 id="dispatchTransformedTouchEvent"><a href="#dispatchTransformedTouchEvent" class="headerlink" title="dispatchTransformedTouchEvent()"></a>dispatchTransformedTouchEvent()</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTransformedTouchEvent</span><span class="hljs-params">(MotionEvent event, <span class="hljs-keyword">boolean</span> cancel,
        View child, <span class="hljs-keyword">int</span> desiredPointerIdBits)</span> </span>&#123;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> handled;

   <span class="hljs-comment">//发生取消事件后，不再执行后续的任何操作</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldAction = event.getAction();
    <span class="hljs-keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;
        event.setAction(MotionEvent.ACTION_CANCEL);
        <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;
            handled = <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);
        &#125; <span class="hljs-keyword">else</span> &#123;
            handled = child.dispatchTouchEvent(event);
        &#125;
        event.setAction(oldAction);
        <span class="hljs-keyword">return</span> handled;
    &#125;

    <span class="hljs-keyword">final</span> MotionEvent transformedEvent;
    <span class="hljs-keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;
        <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span> || child.hasIdentityMatrix()) &#123;
            <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;
              <span class="hljs-comment">//不存在子视图，调用View.dispatchTouchEvent()</span>
                handled = <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> offsetX = mScrollX - child.mLeft;
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> offsetY = mScrollY - child.mTop;
                event.offsetLocation(offsetX, offsetY);
               <span class="hljs-comment">//调用子View/ViewGroup的 dispatchTouchEvent()</span>
                handled = child.dispatchTouchEvent(event);

                event.offsetLocation(-offsetX, -offsetY);
            &#125;
            <span class="hljs-keyword">return</span> handled;
        &#125;
        transformedEvent = MotionEvent.obtain(event);
    &#125; <span class="hljs-keyword">else</span> &#123;
        transformedEvent = event.split(newPointerIdBits);
    &#125;

    <span class="hljs-comment">// Done.</span>
    transformedEvent.recycle();
    <span class="hljs-keyword">return</span> handled;
&#125;</code></pre>
<p><code>dispatchTransformedTouchEvent()</code>分为两套处理方式：</p>
<ul>
<li><code>child==null</code>：发生的情况：<code>事件被拦截</code>或<code>真的没有可执行触摸事件的子View</code>。执行<code>View.dispatchTouchEvent()</code></li>
<li><code>child!=null</code>：向下执行子View/ViewGroup的<code>dispatchTouchEvent()</code></li>
</ul>
<p><img src="/images/ViewGroup-Dispatch.png" srcset="/img/loading.gif" alt="ViewGroup事件分发"></p>
<p>根据上述流程图，总结一下：</p>
<ul>
<li>点击事件从上层传递到ViewGroup，先调用<code>ViewGroup.dispatchTouchEvent()</code></li>
<li>判断<code>ViewGroup.onInterceptTouchEvent()</code>是否拦截点击事件<ul>
<li>默认不拦截，则将事件继续向子View传递，然后调用<code>View.dispatchTouchEvent()</code></li>
<li>被拦截返回<code>true</code>，调用<code>super.dispatchTouchEvent()</code>返给父布局处理，并且ViewGroup自身也处理事件，比如<code>onTouch(),onClick(),onTouchEvent()</code>等事件</li>
</ul>
</li>
</ul>
<blockquote>
<p>通常情况下ViewGroup的<code>onInterceptTouchEvent()</code>返回false，不会拦截用户操作。</p>
<p>不过要注意的是 拦截的是 一个用户的操作序列：<em>从用户手指按下到手指抬起为止。</em></p>
<ul>
<li>拦截了Down事件，后续的事件都会交由<code>ViewGroup.onTouchEvent()</code>处理</li>
<li>拦截了其他事件，会给之前序列头部的<code>ACTION_DOWN</code>事件发送一个<code>ACTION_CANCEL</code>类型事件，通知子View无法执行后续事件，回归初始状态。(<strong>例如点击ListView中的一个Item的Button，再滑动ListView，Button就会恢复初始状态。</strong>)</li>
</ul>
</blockquote>
<h4 id="View事件分发"><a href="#View事件分发" class="headerlink" title="View事件分发"></a>View事件分发</h4><p>ViewGroup事件分发完毕后，由子View继续执行事件分发</p>
<pre><code class="hljs java"><span class="hljs-comment">//View.java    </span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;

        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;

        <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;
            <span class="hljs-keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;
                result = <span class="hljs-keyword">true</span>;
            &#125;
            <span class="hljs-comment">//noinspection SimplifiableIfStatement</span>
            ListenerInfo li = mListenerInfo;
            <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-keyword">null</span> <span class="hljs-comment">//View设置了touch事件</span>
                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED <span class="hljs-comment">//View是可以操作的</span>
                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, event)) &#123; <span class="hljs-comment">//View.onTouch返回true</span>
                result = <span class="hljs-keyword">true</span>;
            &#125;

          <span class="hljs-comment">//上述任一条件不满足，就会执行 onTouchEvent()</span>
            <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;
                result = <span class="hljs-keyword">true</span>;
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> result;
    &#125;</code></pre>
<p><code>dispatchTouchEvent()</code>按照如下顺序执行：</p>
<ol>
<li><code>onTouchListener.ouTouch()</code>开始执行，返回<code>true</code>表示当前事件已被消费，不需要向上执行。否则继续向下执行</li>
<li><code>onTouchEvent()</code>返回<code>true</code>表示消费事件。</li>
</ol>
<pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE <span class="hljs-comment">//有点击事件 调用setOnClickListener()</span>
                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) <span class="hljs-comment">//有长按事件 调用setOnLongClickListener()</span>
                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
      
        <span class="hljs-keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;
            <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="hljs-number">0</span>) &#123;
                setPressed(<span class="hljs-keyword">false</span>);
            &#125;
            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
          <span class="hljs-comment">//当View不可用时 直接消费事件</span>
            <span class="hljs-keyword">return</span> clickable;
        &#125;
      
      <span class="hljs-keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;
            <span class="hljs-keyword">switch</span> (action) &#123;
                <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:
                        <span class="hljs-keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;
                            <span class="hljs-comment">// This is a tap, so remove the longpress check</span>
                            removeLongPressCallback();

                            <span class="hljs-keyword">if</span> (!focusTaken) &#123;
                                <span class="hljs-keyword">if</span> (mPerformClick == <span class="hljs-keyword">null</span>) &#123;
                                    mPerformClick = <span class="hljs-keyword">new</span> PerformClick();
                                &#125;
                                <span class="hljs-keyword">if</span> (!post(mPerformClick)) &#123;
                                  <span class="hljs-comment">//调用View.onClckListener</span>
                                    performClickInternal();
                                &#125;
                            &#125;
                        &#125;                
            &#125;
      &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">performClickInternal</span><span class="hljs-params">()</span> </span>&#123;

        <span class="hljs-keyword">return</span> performClick();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">performClick</span><span class="hljs-params">()</span> </span>&#123;

        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> result;
        <span class="hljs-keyword">final</span> ListenerInfo li = mListenerInfo;
        <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="hljs-keyword">null</span>) &#123;
            playSoundEffect(SoundEffectConstants.CLICK);
            li.mOnClickListener.onClick(<span class="hljs-keyword">this</span>);
            result = <span class="hljs-keyword">true</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            result = <span class="hljs-keyword">false</span>;
        &#125;

        <span class="hljs-keyword">return</span> result;
    &#125;</code></pre>
<p><img src="/images/View-Dispatch.png" srcset="/img/loading.gif" alt="View事件分发"></p>
<p>根据上述流程图，总结一下：</p>
<ul>
<li>点击事件从ViewGroup传递到View，调用<code>View.dispatchTouchEvent()</code></li>
<li>判断当前View是否设置<code>OnTouchListener</code>，并且设置了<code>onTouch()</code>返回值，默认返回false<ul>
<li>返回<code>true</code>，代表事件被<code>onTouch()</code>消费，不会继续往下传递</li>
<li>返回<code>false</code>，事件继续向下传递，调用<code>View.onTouchEvent()</code>，后续若设置点击事件，则继续调用<code>performClick()</code>，最后执行<code>onClick()</code>事件</li>
</ul>
</li>
</ul>
<p>拓展：</p>
<blockquote>
<ol>
<li>如果有一个控件是<code>DISABLED</code>，注册的<code>onTouch()</code>事件不会被执行。若要监听点击事件，只能实现它的<code>onTouchEvent()</code></li>
<li>点击事件优先级： <code>onTouch()</code> &gt; <code>onTouchEvent()</code> &gt; <code>performClick()</code> &gt; <code>onClick()</code> </li>
</ol>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>根据前几节分析得出完整的事件分发顺序：</p>
<p><strong>IMS -&gt; WindowInputREceiver(ViewRootImpl) -&gt; DecorView -&gt; Activity -&gt; DecorView -&gt; viewGroup -&gt; View</strong></p>
<h4 id="事件分发核心方法"><a href="#事件分发核心方法" class="headerlink" title="事件分发核心方法"></a>事件分发核心方法</h4><p><code>boolean dispatchTouchEvent()</code></p>
<p>用来进行事件的分发。</p>
<ul>
<li>返回<code>true</code>：事件被当前View所消费，不会向下传递</li>
<li>返回<code>false</code>：交由上一层的View的<code>onTouchEvent()</code>处理</li>
<li>返回<code>super.dispatchTouchEvent()</code>：继续向下分发事件</li>
</ul>
<p><code>boolean onInterceptTouchEvent()</code></p>
<p>用来进行事件的拦截，在<code>dispatchOnTouchEvent()</code>中调用。<strong>只有ViewGroup才可以调用</strong></p>
<ul>
<li><p>返回<code>true</code>：拦截当前事件，并交由<code>onTouchEvent()</code>去处理</p>
</li>
<li><p>返回<code>false</code>：不拦截当前事件，继续向下传递</p>
</li>
<li><p>返回<code>super.onInterceptTouchEvent()</code>：调用父类的<code>onInterceptTouchEvent()</code>，大部分情况下是<code>false</code>。</p>
<p>如果点击了子View区域，可以继续分发到<code>child.dispatchTouchEvent()</code></p>
<p>没有子View可以响应事件，执行<code>onTouchEvent()</code></p>
</li>
</ul>
<p><code>boolean onTouchEvent()</code></p>
<p>用来处理点击事件，在<code>dispatchOnTouchEvent()</code>中调用。</p>
<ul>
<li><p>返回<code>true</code>：当前View处理当前事件</p>
</li>
<li><p>返回<code>false</code>：当前View无法处理事件，交由上一层View的<code>onTouchEvent()</code>处理</p>
</li>
<li><p>返回<code>super.onTouchEvent()</code></p>
<p>当前View设置了<code>clickable/longclickable</code>，等价于返回true，当前View处理事件</p>
<p>当前View未设置<code>clickable/longclickable</code>，等价于返回false,交由上一层的<code>onTouchEvent()</code>处理。</p>
</li>
</ul>
<p>上述三个核心方法，可以用如下伪代码代替</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">boolean</span> res = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// 是否不允许拦截事件</span>
    <span class="hljs-comment">// 如果设置了 FLAG_DISALLOW_INTERCEPT，不会拦截事件，所以在 child 里可以通过 requestDisallowInterceptTouchEvent 控制父 View 是否来拦截事件</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent()) &#123; <span class="hljs-comment">// View 不调用这里，直接执行下面的 touchlistener 判断</span>
        <span class="hljs-keyword">if</span> (touchlistener &amp;&amp; touchlistener.onTouch()) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        &#125;
        res = onTouchEvent(); <span class="hljs-comment">// 里面会处理点击事件 -&gt; performClick() -&gt; clicklistener.onClick()</span>
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DOWN) &#123; <span class="hljs-comment">// 如果是 DOWN 事件，则遍历子 View 进行事件分发</span>
        <span class="hljs-comment">// 循环子 View 处理事件</span>
        <span class="hljs-keyword">for</span> (childs) &#123;
            res = child.dispatchTouchEvent();
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// 事件分发给 target 去处理，这里的 target 就是上一步处理 DOWN 事件的 View</span>
        target.child.dispatchTouchEvent();
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre>
<p><img src="/images/TouchEvent-Transmit.png" srcset="/img/loading.gif" alt="事件分发"></p>
<ol>
<li>点击事件传递从<code>dispatchTouchEvent()</code>开始，在不修改默认返回值时，事件会按照嵌套层次由外向内传递，到达最内层View时，由最内层View<code>onTouchEvent()</code>处理</li>
<li>View的点击事件触发顺序为  <code>onTouch()</code> &gt; <code>onTouchEvent()</code> &gt; <code>performClick()</code> &gt; <code>onClick()</code> </li>
<li><em>Touch事件的后续(例如<code>ACTION_MOVE</code>,<code>ACTION_UP</code>)层级传递</em><ul>
<li>若<code>dispatchTouchEvent()</code>返回true，那么能收到<code>ACTION_DOWN</code>的函数也可以收到后续事件</li>
<li>若<code>onTouchEvent()</code>返回true，那么其他事件不再往下传递，而是直接传给自己的<code>onTouchEvent()</code>并结束本次事件传递</li>
</ul>
</li>
</ol>
<h4 id="事件分发特殊情况"><a href="#事件分发特殊情况" class="headerlink" title="事件分发特殊情况"></a>事件分发特殊情况</h4><h5 id="ACTIOIN-CANCEL产生场景"><a href="#ACTIOIN-CANCEL产生场景" class="headerlink" title="ACTIOIN_CANCEL产生场景"></a><code>ACTIOIN_CANCEL</code>产生场景</h5><ol>
<li><p>子View处理了Down事件，按照设定Move与Up的事件也会交给他处理。若此时，父View拦截了事件，此时子View就会收到一个Cancel事件，并且无法接收到后续的Move与Up事件。</p>
<p>常见场景：ListView有一个Item带有Button，此时点击按钮(触发ACTION_DOWN)，再进行上下滑动，ListView就会拦截掉后续的Move事件，此时Button就会收到ACTION_CANCEL</p>
</li>
<li><p>子View收到ACTION_DOWN，但是上一个事件还没有结束(因为APP切换、ANR导致后续事件丢失)，此时也会执行ACTION_CANCEL</p>
</li>
</ol>
<h2 id="事件分发完成"><a href="#事件分发完成" class="headerlink" title="事件分发完成"></a>事件分发完成</h2><p>//android_view_InputEventReceiver finishInputEvent</p>
<p>//InputTransport.cpp sendFinishedSignal() sendUnchainedFinishedSignal() channel-&gt;sendMessage</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://gityuan.com/2016/12/11/input-reader/" target="_blank" rel="noopener">InputReaderThread</a></p>
<p><a href="https://cs.android.com" target="_blank" rel="noopener">Android相关源码</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/31210271" target="_blank" rel="noopener">一次触摸，Android 到底干了啥</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/20/Android-性能监控/">
                        <span class="hidden-mobile">Android-性能监控</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>







  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
