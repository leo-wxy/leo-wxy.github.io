

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Android-事件分发机制 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android-事件分发机制">
              
                Android-事件分发机制
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-20 10:29" pubdate>
        2020年11月20日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      181
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android-事件分发机制</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>当用户触摸屏幕或者按键操作。</p>
<ol>
<li>首先触发硬件驱动，驱动收到事件后，将相应事件写入到输入设备节点</li>
<li>输入系统取出内核事件，封装成为KeyEvent或MotionEvent</li>
<li>交付给对应的Window消费该事件。</li>
</ol>
</blockquote>
<p><img src="/images/Android事件分发机制xmind.png" srcset="/img/loading.gif" alt="事件分发机制xmind"></p>
<p><img src="/images/真·事件分发" srcset="/img/loading.gif" alt="input"></p>
<h2 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h2><p><img src="/images/事件分发-硬件中断.png" srcset="/img/loading.gif" alt="硬件中断"></p>
<p>物理设备将数据发送给内核是通过<code>设备驱动</code>传输的，在<code>dev/input/</code>目录下有几个设备文件<code>eventX</code>。</p>
<p>其中<code>event0</code>对应的就是触摸屏，当触摸屏的驱动被挂载后，驱动程序就会进行初始化。</p>
<p>当触发对应的硬件中断后，就会调用对应的处理方法，把对应事件写到<code>设备节点(/dev/input/event0)</code>中.</p>
<p><img src="/images/硬件中断流程.png" srcset="/img/loading.gif" alt="img"></p>
<h2 id="IMS获取内核事件"><a href="#IMS获取内核事件" class="headerlink" title="IMS获取内核事件"></a>IMS获取内核事件</h2><h3 id="IMS启动过程"><a href="#IMS启动过程" class="headerlink" title="IMS启动过程"></a>IMS启动过程</h3><p><img src="/images/事件分发-启动IMS.png" srcset="/img/loading.gif" alt="启动IMS"></p>
<p>在<a href="/2020/11/12/Android-系统启动过程/" title="Android系统启动过程">Android系统启动过程</a>有介绍系统的启动流程，其中<code>IMS</code>属于<code>system_server</code>，随着<code>system_server</code>的启动而启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">//SystemServer.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> startOtherServices() &#123;<br>      ...<br>        InputManagerService inputManager = <span class="hljs-keyword">null</span>;<br>      ...<br>            traceBeginAndSlog("StartInputManagerService");<br>      //新建IMS对象<br>            inputManager = new InputManagerService(context);<br>            traceEnd();        <br>      <br>      //启动IMS<br>            traceBeginAndSlog("StartInputManager");<br>            inputManager.setWindowManagerCallbacks(wm.getInputMonitor());//与window进行绑定<br>            inputManager.start();<br>            traceEnd();      <br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">//InputManagerService.java<br>    <span class="hljs-keyword">public</span> InputManagerService(Context context) &#123;<br>        <span class="hljs-keyword">this</span>.mContext = context;<br>        <span class="hljs-keyword">this</span>.mHandler = new InputManagerHandler(DisplayThread.get().getLooper());<br>      ...<br>        //初始化Native对象<br>        mPtr = nativeInit(<span class="hljs-keyword">this</span>, mContext, mHandler.getLooper().getQueue());<br><br>        LocalServices.addService(InputManagerInternal.class, new LocalService());<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>nativeInit()</code>执行在Native层</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">//services/core/jni/com_android_server_input_InputManagerService.cpp<br><span class="hljs-keyword">static</span> jlong nativeInit(JNIEnv* env, jclass /* clazz */,<br>        jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123;<br>  //获取Native的消息队列<br>    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);<br>  ...<br>    //创建Native的 InputManager对象<br>    NativeInputManager* im = <span class="hljs-keyword">new</span> NativeInputManager(contextObj, serviceObj,<br>            messageQueue-&gt;getLooper());<br>    //增加强引用<br>    im-&gt;incStrong(0);<br>   //返回 NativeInputManager的指针<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(im);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">//services/core/jni/com_android_server_input_InputManagerService.cpp<br>NativeInputManager::NativeInputManager(jobject contextObj,<br>        jobject serviceObj, <span class="hljs-keyword">const</span> sp&lt;Looper&gt;&amp; looper) :<br>        mLooper(looper), mInteractive(<span class="hljs-keyword">true</span>) &#123;<br>    JNIEnv* env = jniEnv();<br><br>    mContextObj = env-&gt;NewGlobalRef(contextObj);<br>    mServiceObj = env-&gt;NewGlobalRef(serviceObj);//IMS对象<br><br>    &#123;<br>        AutoMutex _l(mLock);<br>        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;<br>        mLocked.pointerSpeed = 0;<br>        mLocked.pointerGesturesEnabled = <span class="hljs-keyword">true</span>;<br>        mLocked.showTouches = <span class="hljs-keyword">false</span>;<br>        mLocked.pointerCapture = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    mInteractive = <span class="hljs-keyword">true</span>;<br>   //初始EventHub对象<br>    sp&lt;EventHub&gt; eventHub = new EventHub();<br>   //初始InputManager对象<br>    mInputManager = new InputManager(eventHub, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="初始EventHub"><a href="#初始EventHub" class="headerlink" title="初始EventHub"></a>初始EventHub</h4><p><img src="/images/IMS-EventHub.png" srcset="/img/loading.gif" alt="EventHub"></p>
<p><code>EventHub</code>主要用于<strong>监控设备节点是否更新</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/EventHub.cpp<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *WAKE_LOCK_ID = "KeyEvents";<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *DEVICE_PATH = "/dev/input";//设备文件<br><br>EventHub::EventHub(<span class="hljs-keyword">void</span>) :<br>        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(1), mControllerNumbers(),<br>        mOpeningDevices(0), mClosingDevices(0),<br>        mNeedToSendFinishedDeviceScan(<span class="hljs-literal">false</span>),<br>        mNeedToReopenDevices(<span class="hljs-literal">false</span>), mNeedToScanDevices(<span class="hljs-literal">true</span>),<br>        mPendingEventCount(0), mPendingEventIndex(0), mPendingINotify(<span class="hljs-literal">false</span>) &#123;<br>    acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);<br>//创建epoll实例<br>    mEpollFd = epoll_create(EPOLL_SIZE_HINT);<br><br>//创建iNotify实例<br>    mINotifyFd = inotify_init();<br>//iNotify实例 监听 DEVICE_PATH <br>    <span class="hljs-keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);<br>          <br>    struct epoll_event eventItem;<br>    <span class="hljs-built_in">memset</span>(&amp;eventItem, 0, <span class="hljs-keyword">sizeof</span>(eventItem));<br>    eventItem.events = EPOLLIN;<br>    eventItem.data.u32 = EPOLL_ID_INOTIFY;<br>//epoll 监听 iNotify实例<br>    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);<br><br>    <span class="hljs-keyword">int</span> wakeFds[2];<br>    result = pipe(wakeFds);//创造管道<br><br>    mWakeReadPipeFd = wakeFds[0];<br>    mWakeWritePipeFd = wakeFds[1];<br><br>//切换非阻塞方式进行读写<br>    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);<br>    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);<br><br>    eventItem.data.u32 = EPOLL_ID_WAKE;<br>//epoll监听 管道实例<br>    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);<br><br>    <span class="hljs-keyword">int</span> major, minor;<br>    getLinuxRelease(&amp;major, &amp;minor);<br>    // EPOLLWAKEUP was introduced in kernel 3.5<br>    mUsingEpollWakeup = major &gt; 3 || (major == 3 &amp;&amp; minor &gt;= 5);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>EventHub</code>主要执行了以下几步：</p>
<ol>
<li>初始化<code>epoll</code>实例</li>
<li>初始化<code>iNotify</code>实例，用于监控<code>/dev/input</code>目录的变化。若发生变化，意味设备发生变化，需要处理。<code>epoll</code>添加<code>iNotify实例</code>监听</li>
<li>创建非阻塞模式的管道(<code>pipe</code>)，epoll监听管道的内容。(主要用于 唤醒InputReader线程)</li>
</ol>
<h4 id="初始InputManager"><a href="#初始InputManager" class="headerlink" title="初始InputManager"></a>初始InputManager</h4><p><img src="/images/IMS-InputManager.png" srcset="/img/loading.gif" alt="InputManager"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputManager.cpp<br>InputManager::InputManager(<br>        <span class="hljs-keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,<br>        <span class="hljs-keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,<br>        <span class="hljs-keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;<br>    mDispatcher = <span class="hljs-keyword">new</span> InputDispatcher(dispatcherPolicy);<br>    mReader = <span class="hljs-keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);<br>    initialize();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="InputDispatcher"><a href="#InputDispatcher" class="headerlink" title="InputDispatcher"></a>InputDispatcher</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputDispatcher.cpp<br>InputDispatcher::InputDispatcher(<span class="hljs-keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :<br>    mPolicy(policy),<br>    mPendingEvent(<span class="hljs-literal">NULL</span>), mLastDropReason(DROP_REASON_NOT_DROPPED),<br>    mAppSwitchSawKeyDown(<span class="hljs-literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),<br>    mNextUnblockedEvent(<span class="hljs-literal">NULL</span>),<br>    mDispatchEnabled(<span class="hljs-literal">false</span>), mDispatchFrozen(<span class="hljs-literal">false</span>), mInputFilterEnabled(<span class="hljs-literal">false</span>),<br>    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;<br>    //新建Looper对象<br>    mLooper = <span class="hljs-keyword">new</span> Looper(<span class="hljs-literal">false</span>);<br><br>    mKeyRepeatState.lastKeyEntry = <span class="hljs-literal">NULL</span>;<br><br>    policy-&gt;getDispatcherConfiguration(&amp;mConfig);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputReader.cpp<br>InputReader::InputReader(<span class="hljs-keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,<br>        <span class="hljs-keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,<br>        <span class="hljs-keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :<br>        mContext(<span class="hljs-keyword">this</span>), mEventHub(eventHub), mPolicy(policy),<br>        mGlobalMetaState(0), mGeneration(1),<br>        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),<br>        mConfigurationChangesToRefresh(0) &#123;<br>    //listener 对象 就是 InputDispatcher<br>    mQueuedListener = <span class="hljs-keyword">new</span> QueuedInputListener(listener);<br><br>    &#123; // acquire lock<br>        AutoMutex _l(mLock);<br><br>        refreshConfigurationLocked(0);<br>        updateGlobalMetaStateLocked();<br>    &#125; // release lock<br>&#125;<br></code></pre></td></tr></table></figure>
<p>负责监听<code>InputDispatcher</code>对象</p>
<h5 id="initalize"><a href="#initalize" class="headerlink" title="initalize()"></a>initalize()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">//frameworks/<span class="hljs-keyword">native</span>/services/inputflinger/InputManager.cpp<br><span class="hljs-keyword">void</span> InputManager::initialize() &#123;<br>    mReaderThread = new InputReaderThread(mReader);<br>    mDispatcherThread = new InputDispatcherThread(mDispatcher);<br>&#125;<br><br>//frameworks/<span class="hljs-keyword">native</span>/services/inputflinger/InputDispatcher.cpp<br>InputDispatcherThread::InputDispatcherThread(<span class="hljs-keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) :<br>        Thread(/*canCallJava*/ <span class="hljs-keyword">true</span>), mDispatcher(dispatcher) &#123;<br>&#125;<br><br>//frameworks/<span class="hljs-keyword">native</span>/services/inputflinger/InputReader.cpp<br>InputReaderThread::InputReaderThread(<span class="hljs-keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader) :<br>        Thread(/*canCallJava*/ <span class="hljs-keyword">true</span>), mReader(reader) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>initalize()</code>主要是创建两个能访问Java代码的native线程。</p>
<blockquote>
<p>1.The InputReaderThread (called “InputReader”) reads and preprocesses raw input events,applies policy, and posts messages to a queue managed by the DispatcherThread.</p>
<p>2.The InputDispatcherThread (called “InputDispatcher”) thread waits for new events on the queue and asynchronously dispatches them to applications.</p>
</blockquote>
<h4 id="IMS启动——start"><a href="#IMS启动——start" class="headerlink" title="IMS启动——start()"></a>IMS启动——start()</h4><p><img src="/images/IMS-start.png" srcset="/img/loading.gif" alt="IMS启动"></p>
<p><code>IMS</code>初始化完毕就准备启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">//InputManagerService.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> start() &#123;<br>        Slog.i(TAG, "Starting input manager");<br>        nativeStart(mPtr);<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">//services/core/jni/com_android_server_input_InputManagerService.cpp<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> nativeStart(JNIEnv* env, jclass /* clazz */, jlong ptr) &#123;<br>    NativeInputManager* im = <span class="hljs-keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);<br><br>    status_t result = im-&gt;getInputManager()-&gt;start();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputManager.cpp<br>status_t InputManager::start() &#123;<br>  //启动InputDispatcherThread<br>    status_t result = mDispatcherThread-&gt;run("InputDispatcher", PRIORITY_URGENT_DISPLAY)<br>  //启动InputReaderThread<br>    result = mReaderThread-&gt;run("InputReader", PRIORITY_URGENT_DISPLAY);<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>IMS</code>启动，会带着<code>InputDispatcherThread</code>和<code>InputReaderThread</code>一起启动。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/IMS结构体系.png" srcset="/img/loading.gif" alt="IMS结构体系"></p>
<p>IMS启动过程重点在于Native的初始化，分别创建以下对象：</p>
<ul>
<li><p><strong>EventHub</strong></p>
<p>监听并记录<code>/dev/input</code>的变化</p>
</li>
<li><p><strong>InputManager</strong></p>
<p>创建<code>InputReader</code>和<code>InputDispatcher</code>对象</p>
</li>
</ul>
<p>初始化完毕上述对象后，然后启动以下线程：</p>
<ul>
<li><strong>InputReaderThread</strong>：从<code>EventHub</code>取出事件并处理，再转发给<code>InputDispatcher</code></li>
<li><strong>InputDispatcherThread</strong>：接收来自<code>InputReader</code>的事件，并派发事件到合适的窗口(window)去处理</li>
</ul>
<p><img src="/images/event1_4.png" srcset="/img/loading.gif" alt="img"></p>
<h3 id="内核事件转发APP进程过程"><a href="#内核事件转发APP进程过程" class="headerlink" title="内核事件转发APP进程过程"></a>内核事件转发APP进程过程</h3><p><code>IMS</code>启动之后，<code>InputDispatcherThread</code>与<code>InputReaderThread</code>随之启动。</p>
<h4 id="InputReaderThread"><a href="#InputReaderThread" class="headerlink" title="InputReaderThread"></a>InputReaderThread</h4><p><img src="/images/InputReaderThread.png" srcset="/img/loading.gif" alt="InputReaderThread"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputReader.cpp<br><span class="hljs-keyword">bool</span> InputReaderThread::threadLoop() &#123;<br>    mReader-&gt;loopOnce();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> InputReader::loopOnce() &#123;<br>  ...<br>    //从EventHub获取事件列表，返回的是 事件的个数。无事件时将阻塞 <br>    size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);<br><br>    &#123; // acquire lock<br>        AutoMutex _l(mLock);<br>        mReaderIsAliveCondition.broadcast();<br><br>        <span class="hljs-keyword">if</span> (count) &#123;<br>          //处理获取的事件<br>            processEventsLocked(mEventBuffer, count);<br>        &#125;<br><br>    &#125; // release lock<br>    ...<br>   //处理完毕后发送到 InputDispatcher<br>    mQueuedListener-&gt;flush();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="EventHub-gt-getEvents-获取事件"><a href="#EventHub-gt-getEvents-获取事件" class="headerlink" title="EventHub-&gt;getEvents() 获取事件"></a>EventHub-&gt;getEvents() 获取事件</h5><p><img src="/images/EventHub-getEvents.png" srcset="/img/loading.gif" alt="EventHub-getEvents"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/EventHub.cpp<br>size_t EventHub::getEvents(<span class="hljs-keyword">int</span> timeoutMillis, RawEvent* buffer, size_t bufferSize) &#123;<br>  //原始事件构造<br>    RawEvent* event = buffer;<br>    size_t capacity = bufferSize;  <br>  <span class="hljs-keyword">for</span> (;;) &#123;//开启循环<br>    ...<br>        <span class="hljs-keyword">if</span> (mNeedToScanDevices) &#123;<br>            mNeedToScanDevices = <span class="hljs-literal">false</span>;<br>            scanDevicesLocked();//开始扫描设备<br>            mNeedToSendFinishedDeviceScan = <span class="hljs-literal">true</span>;<br>        &#125;    <br>    ...<br>        <span class="hljs-keyword">while</span> (mOpeningDevices != <span class="hljs-literal">NULL</span>) &#123;<br>            Device* device = mOpeningDevices;<br>            ALOGV("Reporting device opened: id=%d, name=%s\n",<br>                 device-&gt;id, device-&gt;path.<span class="hljs-built_in">string</span>());<br>            mOpeningDevices = device-&gt;next;<br>            event-&gt;when = now;<br>            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? 0 : device-&gt;id;<br>            event-&gt;type = DEVICE_ADDED;//添加设备<br>            event += 1;<br>            mNeedToSendFinishedDeviceScan = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (--capacity == 0) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;      <br>    ...<br>        <span class="hljs-keyword">while</span> (mPendingEventIndex &lt; mPendingEventCount) &#123;<br>          ...<br>            ssize_t deviceIndex = mDevices.indexOfKey(eventItem.data.u32);          <br>          ...<br>            Device* device = mDevices.valueAt(deviceIndex);<br>            <span class="hljs-keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;<br>             ...<br>                    int32_t deviceId = device-&gt;id == mBuiltInKeyboardId ? 0 : device-&gt;id;<br><br>                    size_t count = size_t(readSize) / <span class="hljs-keyword">sizeof</span>(struct input_event);<br>                    <span class="hljs-keyword">for</span> (size_t i = 0; i &lt; count; i++) &#123;<br>                      //获取readBuffer的数据<br>                        struct input_event&amp; iev = readBuffer[i];<br>                      //封装成RawEvent对象<br>                        event-&gt;deviceId = deviceId;<br>                        event-&gt;type = iev.type;<br>                        event-&gt;code = iev.code;<br>                        event-&gt;value = iev.value;<br>                        event += 1;<br>                        capacity -= 1;                      <br>                      <br>                    &#125;<br>            &#125;<br>        &#125;<br>          ...<br>            //等待input事件<br>           <span class="hljs-keyword">int</span> pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);<br>    <br>    ...<br>        // readNotify() will modify the <span class="hljs-built_in">list</span> of devices so <span class="hljs-keyword">this</span> must be done after<br>        // processing all other events to ensure that we read all remaining events<br>        // before closing the devices.<br>        <span class="hljs-keyword">if</span> (mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123;<br>            mPendingINotify = <span class="hljs-literal">false</span>;<br>          //从INotify事件 读取发生的事件<br>            readNotifyLocked();<br>            deviceChanged = <span class="hljs-literal">true</span>;<br>        &#125;<br>  &#125;<br>  ...<br>      // 返回读取的事件个数<br>    <span class="hljs-keyword">return</span> event - buffer;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>getEvents()</code>采用<code>INotify + epoll</code>监听<code>/dev/input/</code>目录下的设备节点，再转换<code>deviceId + input_event</code>为<code>RawEvent</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">// frameworks/native/services/inputflinger/EventHub.h<br>struct RawEvent &#123;<br>    nsecs_t when;//事件发生的时间点<br>    int32_t deviceId;//设备id<br>    int32_t type;//事件类型<br>    int32_t code;<br>    int32_t value;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>type</code>可以为以下几种</p>
<ul>
<li><code>DEVICE_ADDED</code>：添加设备</li>
<li><code>DEVICE_REMOVED</code>：移除设备</li>
<li><code>FINISHED_DEVICE_SCAN</code>：扫描完成</li>
<li><code>type &lt; FIRST_SYNTHETIC_EVENT</code>：其他事件</li>
</ul>
<p><code>getEvents()</code>大概执行流程：</p>
<p>当<code>设备节点(/dev/input)</code>发生变化时，<code>epoll_wait()</code>会响应到对应的变化，然后<code>getEvents()</code>可以知道对应的变化。继续从<code>mINotifyFd</code>读取<code>iNotify事件</code>，进行输入设备的操作，最后生成相应的<code>RawEvent</code></p>
<blockquote>
<p>此时，EventHub从设备节点获取到了事件，并转化为<code>RawEvent</code>向下处理。</p>
</blockquote>
<h5 id="processEventsLocked-处理事件"><a href="#processEventsLocked-处理事件" class="headerlink" title="processEventsLocked() 处理事件"></a>processEventsLocked() 处理事件</h5><p><img src="/images/InputReaderThread-processEventsLocked.png" srcset="/img/loading.gif" alt="InputReaderThread-processEventsLocked"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> InputReader::processEventsLocked(<span class="hljs-keyword">const</span> RawEvent* rawEvents, size_t count) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> RawEvent* rawEvent = rawEvents; count;) &#123;<br>        int32_t type = rawEvent-&gt;type;<br>        size_t batchSize = 1;<br>        <span class="hljs-keyword">if</span> (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;<br>            int32_t deviceId = rawEvent-&gt;deviceId;<br>            <span class="hljs-keyword">while</span> (batchSize &lt; count) &#123;<br>                <span class="hljs-keyword">if</span> (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT<br>                        || rawEvent[batchSize].deviceId != deviceId) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                batchSize += 1;<br>            &#125;<br>          //处理其他事件的数据<br>            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">switch</span> (rawEvent-&gt;type) &#123;<br>            <span class="hljs-keyword">case</span> EventHubInterface::DEVICE_ADDED:<br>                //设备增加<br>                addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> EventHubInterface::DEVICE_REMOVED:<br>                //设备移除<br>                removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> EventHubInterface::FINISHED_DEVICE_SCAN:<br>                //设备扫描完成<br>                handleConfigurationChangedLocked(rawEvent-&gt;when);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                ALOG_ASSERT(<span class="hljs-literal">false</span>); // can't happen<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        count -= batchSize;<br>        rawEvent += batchSize;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="addDeviceLocked-添加设备"><a href="#addDeviceLocked-添加设备" class="headerlink" title="addDeviceLocked() 添加设备"></a>addDeviceLocked() 添加设备</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> InputReader::addDeviceLocked(nsecs_t when, int32_t deviceId) &#123;<br>    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);<br><br>  //根据deviceId 创建设备<br>    InputDevice* device = createDeviceLocked(deviceId, controllerNumber, identifier, classes);<br>    device-&gt;configure(when, &amp;mConfig, 0);<br>    device-&gt;reset(when);<br><br>  //添加设备<br>    mDevices.add(deviceId, device);<br>    bumpGenerationLocked();<br><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">InputDevice* InputReader::createDeviceLocked(int32_t deviceId, int32_t controllerNumber,<br>        <span class="hljs-keyword">const</span> InputDeviceIdentifier&amp; identifier, uint32_t classes) &#123;<br>    InputDevice* device = <span class="hljs-keyword">new</span> InputDevice(&amp;mContext, deviceId, bumpGenerationLocked(),<br>            controllerNumber, identifier, classes);<br>...<br>    // Keyboard-like devices.  <br>    <span class="hljs-keyword">if</span> (keyboardSource != 0) &#123;<br>        device-&gt;addMapper(<span class="hljs-keyword">new</span> KeyboardInputMapper(device, keyboardSource, keyboardType));<br>    &#125;<br><br>    // Cursor-like devices.<br>    <span class="hljs-keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_CURSOR) &#123;<br>        device-&gt;addMapper(<span class="hljs-keyword">new</span> CursorInputMapper(device));<br>    &#125;<br><br>    // Touchscreens <span class="hljs-keyword">and</span> touchpad devices.<br>    <span class="hljs-keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_TOUCH_MT) &#123;<br>        device-&gt;addMapper(<span class="hljs-keyword">new</span> MultiTouchInputMapper(device));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_TOUCH) &#123;<br>        device-&gt;addMapper(<span class="hljs-keyword">new</span> SingleTouchInputMapper(device));<br>    &#125;<br>...<br><br>    <span class="hljs-keyword">return</span> device;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>addDeviceLocked()</code>主要创建<code>InputDevice</code>，并且根据不同的设备类型来创建相应的<code>InputMapper</code>。</p>
<p>根据上述代码列举对应关系：</p>
<ul>
<li><code>Keyboard-like</code>：键盘类设备 –&gt; KeyboardInputMapper</li>
<li><code>Cursor-like</code>：鼠标类设备 –&gt; CursorInputMapper</li>
<li><code>TouchScreens</code>：触摸屏设备 –&gt; MultiTouchInputMapper(多点触控) / SingleTouchInputMapper(单点触控)</li>
</ul>
<p><img src="/images/InputMapper对应关系.png" srcset="/img/loading.gif" alt="InputMapper对应关系"></p>
<h6 id="processEventsForDeviceLocked-处理设备事件"><a href="#processEventsForDeviceLocked-处理设备事件" class="headerlink" title="processEventsForDeviceLocked() 处理设备事件"></a>processEventsForDeviceLocked() 处理设备事件</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> InputReader::processEventsForDeviceLocked(int32_t deviceId,<br>        <span class="hljs-keyword">const</span> RawEvent* rawEvents, size_t count) &#123;<br>    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);<br>//获取输入设备<br>    InputDevice* device = mDevices.valueAt(deviceIndex);<br><br>    device-&gt;process(rawEvents, count);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputReader.cpp<br><span class="hljs-keyword">void</span> InputDevice::process(<span class="hljs-keyword">const</span> RawEvent* rawEvents, size_t count) &#123;<br><br>    size_t numMappers = mMappers.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> RawEvent* rawEvent = rawEvents; count != 0; rawEvent++) &#123;<br><br>        <span class="hljs-keyword">if</span> (mDropUntilNextSync) &#123;<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (size_t i = 0; i &lt; numMappers; i++) &#123;<br>                InputMapper* mapper = mMappers[i];<br>              //获取mapper继续执行process任务<br>                mapper-&gt;process(rawEvent);<br>            &#125;<br>        &#125;<br>        --count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以触摸屏为例，<code>mapper</code>指向<code>MultiTouchInputMapper</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> MultiTouchInputMapper::process(<span class="hljs-keyword">const</span> RawEvent* rawEvent) &#123;<br>    TouchInputMapper::process(rawEvent);<br><br>    mMultiTouchMotionAccumulator.process(rawEvent);<br>&#125;<br><br><span class="hljs-keyword">void</span> TouchInputMapper::process(<span class="hljs-keyword">const</span> RawEvent* rawEvent) &#123;<br>    mCursorButtonAccumulator.process(rawEvent);<br>    mCursorScrollAccumulator.process(rawEvent);<br>    mTouchButtonAccumulator.process(rawEvent);<br><br>    <span class="hljs-keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;<br>        sync(rawEvent-&gt;when);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> TouchInputMapper::dispatchPointerSimple(nsecs_t when, uint32_t policyFlags,<br>        <span class="hljs-keyword">bool</span> down, <span class="hljs-keyword">bool</span> hovering) &#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (mPointerSimple.down &amp;&amp; !down) &#123;<br>        mPointerSimple.down = <span class="hljs-literal">false</span>;<br><br>        // Send up.<br>        NotifyMotionArgs args(when, getDeviceId(), mSource, policyFlags,<br>                 AMOTION_EVENT_ACTION_UP, 0, 0, metaState, mLastRawState.buttonState, 0,<br>                 mViewport.displayId, /* deviceTimestamp */ 0,<br>                 1, &amp;mPointerSimple.lastProperties, &amp;mPointerSimple.lastCoords,<br>                 mOrientedXPrecision, mOrientedYPrecision,<br>                 mPointerSimple.downTime);<br>        getListener()-&gt;notifyMotion(&amp;args);<br>    &#125;<br>  <br>    <span class="hljs-keyword">if</span> (down) &#123;<br>        <span class="hljs-keyword">if</span> (!mPointerSimple.down) &#123;<br>            mPointerSimple.down = <span class="hljs-literal">true</span>;<br>            mPointerSimple.downTime = when;<br><br>            // Send down.<br>            NotifyMotionArgs args(when, getDeviceId(), mSource, policyFlags,<br>                    AMOTION_EVENT_ACTION_DOWN, 0, 0, metaState, mCurrentRawState.buttonState, 0,<br>                    mViewport.displayId, /* deviceTimestamp */ 0,<br>                    1, &amp;mPointerSimple.currentProperties, &amp;mPointerSimple.currentCoords,<br>                    mOrientedXPrecision, mOrientedYPrecision,<br>                    mPointerSimple.downTime);<br>            getListener()-&gt;notifyMotion(&amp;args);<br>        &#125;<br><br>        // Send move.<br>        NotifyMotionArgs args(when, getDeviceId(), mSource, policyFlags,<br>                AMOTION_EVENT_ACTION_MOVE, 0, 0, metaState, mCurrentRawState.buttonState, 0,<br>                mViewport.displayId, /* deviceTimestamp */ 0,<br>                1, &amp;mPointerSimple.currentProperties, &amp;mPointerSimple.currentCoords,<br>                mOrientedXPrecision, mOrientedYPrecision,<br>                mPointerSimple.downTime);<br>        getListener()-&gt;notifyMotion(&amp;args);<br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>getListener()</code>指的就是<code>mQueuedListener</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputListener.cpp<br><span class="hljs-keyword">void</span> QueuedInputListener::notifyMotion(<span class="hljs-keyword">const</span> NotifyMotionArgs* args) &#123;<br>    mArgsQueue.push(<span class="hljs-keyword">new</span> NotifyMotionArgs(*args));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>将触摸事件放入<code>mArgsQueue</code>，此时事件加工完成。</p>
<h5 id="QueuedInputListener-flush-发送事件"><a href="#QueuedInputListener-flush-发送事件" class="headerlink" title="QueuedInputListener.flush() 发送事件"></a>QueuedInputListener.flush() 发送事件</h5><p><img src="/images/InputReaderThread-分发事件.png" srcset="/img/loading.gif" alt="InputReaderThread-分发事件"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputListener.cpp<br><span class="hljs-keyword">void</span> QueuedInputListener::flush() &#123;<br>    size_t count = mArgsQueue.size();<br>    <span class="hljs-keyword">for</span> (size_t i = 0; i &lt; count; i++) &#123;<br>        NotifyArgs* args = mArgsQueue[i];<br>        args-&gt;notify(mInnerListener);<br>        <span class="hljs-keyword">delete</span> args;<br>    &#125;<br>    mArgsQueue.clear();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>NotifyArgs</code>主要有以下几类：</p>
<ul>
<li>NotifyConfigurationChangedArgs：配置变化</li>
<li>NotifyKeyArgs：键盘事件</li>
<li>NotifyMotionArgs：触摸事件</li>
<li>NotifySwitchArgs：切换事件</li>
<li>NotifyDeviceResetArgs：设备重置事件</li>
</ul>
<p>根据上节可知<code>args</code>为<code>NotifyMotionArgs</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> NotifyMotionArgs::notify(<span class="hljs-keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class="hljs-keyword">const</span> &#123;<br>    listener-&gt;notifyMotion(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>listener</code>指的就是<code>InputDispatcher</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputDispatcher.cpp<br><span class="hljs-keyword">void</span> InputDispatcher::notifyMotion(<span class="hljs-keyword">const</span> NotifyMotionArgs* args) &#123;<br>...<br>    <span class="hljs-keyword">if</span> (!validateMotionEvent(args-&gt;action, args-&gt;actionButton,<br>                args-&gt;pointerCount, args-&gt;pointerProperties)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    uint32_t policyFlags = args-&gt;policyFlags;<br>    policyFlags |= POLICY_FLAG_TRUSTED;<br><br>    android::base::Timer t;<br>    mPolicy-&gt;interceptMotionBeforeQueueing(args-&gt;eventTime, /*byref*/ policyFlags);<br><br>    <span class="hljs-keyword">bool</span> needWake;<br>    &#123; // acquire lock<br>        mLock.lock();<br><br>      //拦截事件分发<br>        <span class="hljs-keyword">if</span> (shouldSendMotionToInputFilterLocked(args)) &#123;<br>            mLock.unlock();<br><br>            MotionEvent event;//初始化MotionEvent对象<br>            event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action, args-&gt;actionButton,<br>                    args-&gt;flags, args-&gt;edgeFlags, args-&gt;metaState, args-&gt;buttonState,<br>                    0, 0, args-&gt;xPrecision, args-&gt;yPrecision,<br>                    args-&gt;downTime, args-&gt;eventTime,<br>                    args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords);<br><br>            policyFlags |= POLICY_FLAG_FILTERED;<br>            <span class="hljs-keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;<br>                <span class="hljs-keyword">return</span>; // event was consumed by the filter<br>            &#125;<br><br>            mLock.lock();<br>        &#125;<br><br>        // Just enqueue a <span class="hljs-keyword">new</span> motion event.<br>        MotionEntry* newEntry = <span class="hljs-keyword">new</span> MotionEntry(args-&gt;eventTime,<br>                args-&gt;deviceId, args-&gt;source, policyFlags,<br>                args-&gt;action, args-&gt;actionButton, args-&gt;flags,<br>                args-&gt;metaState, args-&gt;buttonState,<br>                args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime,<br>                args-&gt;displayId,<br>                args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, 0, 0);<br><br>        needWake = enqueueInboundEventLocked(newEntry);<br>        mLock.unlock();<br>    &#125; // release lock<br><br>    <span class="hljs-keyword">if</span> (needWake) &#123;<br>      //唤醒消息队列<br>        mLooper-&gt;wake();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123;<br>    <span class="hljs-keyword">bool</span> needWake = mInboundQueue.isEmpty();<br>    mInboundQueue.enqueueAtTail(entry);//将事件放入`mInBoundQueue`的尾部，等待处理<br>    traceInboundQueueLengthLocked();<br><br>    <span class="hljs-keyword">switch</span> (entry-&gt;type) &#123;<br><br>    <span class="hljs-keyword">case</span> EventEntry::TYPE_MOTION: &#123;<br><br>        MotionEntry* motionEntry = <span class="hljs-keyword">static_cast</span>&lt;MotionEntry*&gt;(entry);<br>        <span class="hljs-keyword">if</span> (motionEntry-&gt;action == AMOTION_EVENT_ACTION_DOWN<br>                &amp;&amp; (motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)<br>                &amp;&amp; mInputTargetWaitCause == INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY<br>                &amp;&amp; mInputTargetWaitApplicationHandle != <span class="hljs-literal">NULL</span>) &#123;<br>            int32_t displayId = motionEntry-&gt;displayId;<br>            int32_t x = int32_t(motionEntry-&gt;pointerCoords[0].<br>                    getAxisValue(AMOTION_EVENT_AXIS_X));<br>            int32_t y = int32_t(motionEntry-&gt;pointerCoords[0].<br>                    getAxisValue(AMOTION_EVENT_AXIS_Y));<br>            sp&lt;InputWindowHandle&gt; touchedWindowHandle = findTouchedWindowAtLocked(displayId, x, y);<br>            <span class="hljs-keyword">if</span> (touchedWindowHandle != <span class="hljs-literal">NULL</span><br>                    &amp;&amp; touchedWindowHandle-&gt;inputApplicationHandle<br>                            != mInputTargetWaitApplicationHandle) &#123;<br>                // User touched a different application than the one we are waiting on.<br>                // Flag the event, <span class="hljs-keyword">and</span> start pruning the input <span class="hljs-built_in">queue</span>.<br>                mNextUnblockedEvent = motionEntry;<br>                needWake = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> needWake;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/v2-196591e61a6bed7189d68d7a72a07f4a_1440w.jpg" srcset="/img/loading.gif" alt="img"></p>
<p><code>InputReaderThread</code>主要负责<strong>事件封装转换</strong></p>
<ul>
<li><code>EventHub.getEvents()</code>：通过<code>epoll</code>监听<code>iNotify实例(监听 /dev/input/ 目录)</code>读取事件放入<code>mEventBuffer</code>，然后转换成<code>RawEvent</code></li>
<li><code>processEventsLocked()</code>：对<code>RawEvent</code>进行加工，转换成<code>NotifyMotionArgs</code></li>
<li><code>flush()</code>：将事件<code>NotifyMotionArgs</code>发送到<code>InputDispatcher</code>进行处理，最后转换成<code>MotionEntry</code>并写入到<code>InputDispatcher.mInBoundQueue</code></li>
</ul>
<p><img src="/images/InputReaderThread.jpg" srcset="/img/loading.gif" alt="InputReaderThread"></p>
<h4 id="InputDispatcherThread"><a href="#InputDispatcherThread" class="headerlink" title="InputDispatcherThread"></a>InputDispatcherThread</h4><p><img src="/images/InputDispatcherThread.png" srcset="/img/loading.gif" alt="InputDispatcherThread"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">// frameworks/native/services/inputflinger/InputDispatcher.cpp<br><span class="hljs-keyword">bool</span> InputDispatcherThread::threadLoop() &#123;<br>    mDispatcher-&gt;dispatchOnce();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> InputDispatcher::dispatchOnce() &#123;<br>    nsecs_t nextWakeupTime = LONG_LONG_MAX;<br>    &#123; // acquire lock<br>        AutoMutex _l(mLock);<br>      //唤醒等待线程，监听当前是否发生死锁<br>        mDispatcherIsAliveCondition.broadcast();<br><br>       //派发输入事件，`nextWakeUpTime`决定下次派发线程执行时间<br>        <span class="hljs-keyword">if</span> (!haveCommandsLocked()) &#123;<br>            dispatchOnceInnerLocked(&amp;nextWakeupTime);<br>        &#125;<br><br>        // Run all pending commands <span class="hljs-keyword">if</span> there are any.<br>        // If any commands were run then force the next poll to wake up immediately.<br>        <span class="hljs-keyword">if</span> (runCommandsLockedInterruptible()) &#123;<br>            nextWakeupTime = LONG_LONG_MIN;<br>        &#125;<br>    &#125; // release lock<br><br>   //派发线程进入休眠状态<br>    nsecs_t currentTime = now();<br>    <span class="hljs-keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);<br>    mLooper-&gt;pollOnce(timeoutMillis);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="dispatchOnceInnerLocked-获取事件"><a href="#dispatchOnceInnerLocked-获取事件" class="headerlink" title="dispatchOnceInnerLocked() 获取事件"></a>dispatchOnceInnerLocked() 获取事件</h5><p><img src="/images/InputDispatcher-dispatchOnceInnerLocked.png" srcset="/img/loading.gif" alt="InputDispatcher-dispatchOnceInnerLocked"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123;<br>    nsecs_t currentTime = now();<br><br>    // Ready to start a <span class="hljs-keyword">new</span> event.<br>    // If we don't already have a pending event, go grab one.<br>    <span class="hljs-keyword">if</span> (! mPendingEvent) &#123;<br>        <span class="hljs-keyword">if</span> (mInboundQueue.isEmpty()) &#123;<br>          //派发队列为空，进入线程休眠状态<br>          ...<br>            // Nothing to <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> there is no pending event.<br>            <span class="hljs-keyword">if</span> (!mPendingEvent) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            // 从 mInBoundQueue获取事件 实质就是上一步的 MotionEntry<br>            mPendingEvent = mInboundQueue.dequeueAtHead();<br>            traceInboundQueueLengthLocked();<br>        &#125;<br>      ...<br>        // 重置ANR时间<br>        resetANRTimeoutsLocked();<br>    &#125;<br><br>    // Now we have an event to dispatch.<br>    // All events are eventually dequeued <span class="hljs-keyword">and</span> processed <span class="hljs-keyword">this</span> way, even <span class="hljs-keyword">if</span> we intend to drop them.<br>    ALOG_ASSERT(mPendingEvent != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">bool</span> done = <span class="hljs-literal">false</span>;<br>    DropReason dropReason = DROP_REASON_NOT_DROPPED;<br>  //检查事件是否需要丢弃<br>    <span class="hljs-keyword">if</span> (!(mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER)) &#123;<br>        dropReason = DROP_REASON_POLICY;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mDispatchEnabled) &#123;<br>        dropReason = DROP_REASON_DISABLED;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (mPendingEvent-&gt;type) &#123;<br>    <span class="hljs-keyword">case</span> EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;<br>       ...<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> EventEntry::TYPE_DEVICE_RESET: &#123;<br>       ...<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> EventEntry::TYPE_KEY: &#123;<br>       ...<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> EventEntry::TYPE_MOTION: &#123;<br>        MotionEntry* typedEntry = <span class="hljs-keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);<br>        <span class="hljs-keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;<br>            dropReason = DROP_REASON_APP_SWITCH;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED<br>                &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123;<br>            dropReason = DROP_REASON_STALE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;<br>            dropReason = DROP_REASON_BLOCKED;<br>        &#125;<br>      //分发触摸事件<br>        done = dispatchMotionLocked(currentTime, typedEntry,<br>                &amp;dropReason, nextWakeupTime);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br><br>        //准备派发下一个事件<br>    <span class="hljs-keyword">if</span> (done) &#123;<br>        <span class="hljs-keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;<br>            dropInboundEventLocked(mPendingEvent, dropReason);<br>        &#125;<br>        mLastDropReason = dropReason;<br><br>        releasePendingEventLocked();<br>        *nextWakeupTime = LONG_LONG_MIN;  // force next poll to wake up immediately<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> InputDispatcher::dispatchMotionLocked(<br>        nsecs_t currentTime, MotionEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123;<br><br>    <span class="hljs-keyword">bool</span> isPointerEvent = entry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER;<br><br>    // 保存触摸事件的发送目标<br>    Vector&lt;InputTarget&gt; inputTargets;<br><br>    <span class="hljs-keyword">bool</span> conflictingPointerActions = <span class="hljs-literal">false</span>;<br>    int32_t injectionResult;<br>    <span class="hljs-keyword">if</span> (isPointerEvent) &#123;<br>        // 基于坐标点的形式，如触屏，根据坐标点获取目标窗口<br>        injectionResult = findTouchedWindowTargetsLocked(currentTime,<br>                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // 无坐标点的触摸事件，例如 轨迹球<br>        injectionResult = findFocusedWindowTargetsLocked(currentTime,<br>                entry, inputTargets, nextWakeupTime);<br>    &#125;<br><br>    addMonitoringTargetsLocked(inputTargets);<br>   //将 entry 分发到 对应window上<br>    dispatchEventLocked(currentTime, entry, inputTargets);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>InputTarget</code>的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputDispatcher.h<br>struct InputTarget &#123;<br>    // 连接InputDispatcher与Window的通信管道<br>    sp&lt;InputChannel&gt; inputChannel;<br><br>    // Flags <span class="hljs-keyword">for</span> the input target.<br>    int32_t flags;<br><br>    // The x <span class="hljs-keyword">and</span> y offset to add to a MotionEvent as it is delivered.<br>    // (ignored <span class="hljs-keyword">for</span> KeyEvents)<br>    <span class="hljs-keyword">float</span> xOffset, yOffset;<br><br>    // Scaling factor to apply to MotionEvent as it is delivered.<br>    // (ignored <span class="hljs-keyword">for</span> KeyEvents)<br>    <span class="hljs-keyword">float</span> scaleFactor;<br><br>    // The subset of pointer ids to include in motion events dispatched to <span class="hljs-keyword">this</span> input target<br>    // <span class="hljs-keyword">if</span> FLAG_SPLIT is <span class="hljs-built_in">set</span>.<br>    BitSet32 pointerIds;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="dispatchEventLocked-发送事件"><a href="#dispatchEventLocked-发送事件" class="headerlink" title="dispatchEventLocked() 发送事件"></a>dispatchEventLocked() 发送事件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">void</span> InputDispatcher::dispatchEventLocked(nsecs_t currentTime,<br>        EventEntry* eventEntry, <span class="hljs-keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;<br><br>    pokeUserActivityLocked(eventEntry);<br><br>    <span class="hljs-keyword">for</span> (size_t i = 0; i &lt; inputTargets.size(); i++) &#123;<br>        <span class="hljs-keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);<br>       //根据InputTarget的InputChannel 获取 connection<br>        ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);<br>        <span class="hljs-keyword">if</span> (connectionIndex &gt;= 0) &#123;<br>            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);<br>          //准备分发消息<br>            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);<br><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime,<br>        <span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="hljs-keyword">const</span> InputTarget* inputTarget) &#123;<br>     ...<br><br>    // 将事件添加到Connections的发送队列<br>    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);<br>&#125;<br><br><br><span class="hljs-keyword">void</span> InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime,<br>        <span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="hljs-keyword">const</span> InputTarget* inputTarget) &#123;<br>    <span class="hljs-keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();<br>  ...<br><br>    // If the outbound <span class="hljs-built_in">queue</span> was previously empty, start the dispatch cycle going.<br>    <span class="hljs-keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;<br>        startDispatchCycleLocked(currentTime, connection);<br>    &#125;<br>&#125;<br><br>//开始循环<br><span class="hljs-keyword">void</span> InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,<br>        <span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;<br><br>    <span class="hljs-keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL<br>            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;<br>        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;<br>        dispatchEntry-&gt;deliveryTime = currentTime;<br><br>        // Publish the event.<br>        status_t status;<br>        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;<br>        <span class="hljs-keyword">switch</span> (eventEntry-&gt;type) &#123;<br><br><br>        <span class="hljs-keyword">case</span> EventEntry::TYPE_MOTION: &#123;<br>            MotionEntry* motionEntry = <span class="hljs-keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);<br><br>            PointerCoords scaledCoords[MAX_POINTERS];<br>            <span class="hljs-keyword">const</span> PointerCoords* usingCoords = motionEntry-&gt;pointerCoords;<br><br>            // Set the X <span class="hljs-keyword">and</span> Y offset depending on the input source.<br>            <span class="hljs-keyword">float</span> xOffset, yOffset;<br>            <span class="hljs-keyword">if</span> ((motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)<br>                    &amp;&amp; !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123;<br>                <span class="hljs-keyword">float</span> scaleFactor = dispatchEntry-&gt;scaleFactor;<br>                xOffset = dispatchEntry-&gt;xOffset * scaleFactor;<br>                yOffset = dispatchEntry-&gt;yOffset * scaleFactor;<br>                <span class="hljs-keyword">if</span> (scaleFactor != 1.0f) &#123;<br>                    <span class="hljs-keyword">for</span> (uint32_t i = 0; i &lt; motionEntry-&gt;pointerCount; i++) &#123;<br>                        scaledCoords[i] = motionEntry-&gt;pointerCoords[i];<br>                        scaledCoords[i].scale(scaleFactor);<br>                    &#125;<br>                    usingCoords = scaledCoords;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                xOffset = 0.0f;<br>                yOffset = 0.0f;<br><br>                // We don't want the dispatch target to know.<br>                <span class="hljs-keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS) &#123;<br>                    <span class="hljs-keyword">for</span> (uint32_t i = 0; i &lt; motionEntry-&gt;pointerCount; i++) &#123;<br>                        scaledCoords[i].clear();<br>                    &#125;<br>                    usingCoords = scaledCoords;<br>                &#125;<br>            &#125;<br><br>            // Publish the motion event.<br>            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,<br>                    motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId,<br>                    dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,<br>                    dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,<br>                    motionEntry-&gt;metaState, motionEntry-&gt;buttonState,<br>                    xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,<br>                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,<br>                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,<br>                    usingCoords);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        // 回收队列<br>        connection-&gt;outboundQueue.dequeue(dispatchEntry);<br>        traceOutboundQueueLengthLocked(connection);<br>        // 等待执行队列<br>        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);<br>        traceWaitQueueLengthLocked(connection);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/libs/input/InputTransport.cpp<br>status_t InputPublisher::publishMotionEvent(<br>        uint32_t seq,<br>        int32_t deviceId,<br>        int32_t source,<br>        int32_t displayId,<br>        int32_t action,<br>        int32_t actionButton,<br>        int32_t flags,<br>        int32_t edgeFlags,<br>        int32_t metaState,<br>        int32_t buttonState,<br>        <span class="hljs-keyword">float</span> xOffset,<br>        <span class="hljs-keyword">float</span> yOffset,<br>        <span class="hljs-keyword">float</span> xPrecision,<br>        <span class="hljs-keyword">float</span> yPrecision,<br>        nsecs_t downTime,<br>        nsecs_t eventTime,<br>        uint32_t pointerCount,<br>        <span class="hljs-keyword">const</span> PointerProperties* pointerProperties,<br>        <span class="hljs-keyword">const</span> PointerCoords* pointerCoords) &#123;<br><br><br>    InputMessage msg;<br>    msg.header.type = InputMessage::TYPE_MOTION;<br>    msg.body.motion.seq = seq;<br>    msg.body.motion.deviceId = deviceId;<br>    msg.body.motion.source = source;<br>    msg.body.motion.displayId = displayId;<br>    msg.body.motion.action = action;<br>    msg.body.motion.actionButton = actionButton;<br>    msg.body.motion.flags = flags;<br>    msg.body.motion.edgeFlags = edgeFlags;<br>    msg.body.motion.metaState = metaState;<br>    msg.body.motion.buttonState = buttonState;<br>    msg.body.motion.xOffset = xOffset;<br>    msg.body.motion.yOffset = yOffset;<br>    msg.body.motion.xPrecision = xPrecision;<br>    msg.body.motion.yPrecision = yPrecision;<br>    msg.body.motion.downTime = downTime;<br>    msg.body.motion.eventTime = eventTime;<br>    msg.body.motion.pointerCount = pointerCount;<br>    <span class="hljs-keyword">for</span> (uint32_t i = 0; i &lt; pointerCount; i++) &#123;<br>        msg.body.motion.pointers[i].properties.copyFrom(pointerProperties[i]);<br>        msg.body.motion.pointers[i].coords.copyFrom(pointerCoords[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mChannel-&gt;sendMessage(&amp;msg);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/libs/input/InputTransport.cpp<br>status_t InputChannel::sendMessage(<span class="hljs-keyword">const</span> InputMessage* msg) &#123;<br> ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终通过<code>InputChannel.sendMessage()</code>发送包装好的触摸事件</p>
<blockquote>
<p>TODO</p>
</blockquote>
<h5 id="handleReceiveCallback-接收事件"><a href="#handleReceiveCallback-接收事件" class="headerlink" title="handleReceiveCallback 接收事件"></a>handleReceiveCallback 接收事件</h5><p>这一节的触发条件会在后面讲到，简单来说就是</p>
<p>后面Java层的事件分发结束，调用到<code>InputEventReceiver.finishInputEvent()</code>，会向UI进程持有的<code>InputChannel</code>写入数据，然后唤醒<code>InputDispatcher</code>线程被唤醒后执行<code>handleReceiveCallback()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputDispatcher.cpp<br><span class="hljs-keyword">int</span> InputDispatcher::handleReceiveCallback(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span>* data) &#123;<br>  ...<br>        sp&lt;Connection&gt; connection = d-&gt;mConnectionsByFd.valueAt(connectionIndex);<br>  ...<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                uint32_t seq;<br>                <span class="hljs-keyword">bool</span> handled;<br>              //从 connection 获取消息<br>                status = connection-&gt;inputPublisher.receiveFinishedSignal(&amp;seq, &amp;handled);<br>                <span class="hljs-keyword">if</span> (status) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>              <br>                d-&gt;finishDispatchCycleLocked(currentTime, connection, seq, handled);<br>                gotOne = <span class="hljs-literal">true</span>;<br>            &#125;    <br>&#125;<br><br><span class="hljs-keyword">void</span> InputDispatcher::finishDispatchCycleLocked(nsecs_t currentTime,<br>        <span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; connection, uint32_t seq, <span class="hljs-keyword">bool</span> handled) &#123;<br><br>    connection-&gt;inputPublisherBlocked = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (connection-&gt;status == Connection::STATUS_BROKEN<br>            || connection-&gt;status == Connection::STATUS_ZOMBIE) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    // Notify other system components <span class="hljs-keyword">and</span> prepare to start the next dispatch cycle.<br>    onDispatchCycleFinishedLocked(currentTime, connection, seq, handled);<br>&#125;<br><br><span class="hljs-keyword">void</span> InputDispatcher::onDispatchCycleFinishedLocked(<br>        nsecs_t currentTime, <span class="hljs-keyword">const</span> sp&lt;Connection&gt;&amp; connection, uint32_t seq, <span class="hljs-keyword">bool</span> handled) &#123;<br>  //发送命令到 doDispatchCycleFinishedLockedInterruptible<br>    CommandEntry* commandEntry = postCommandLocked(<br>            &amp; InputDispatcher::doDispatchCycleFinishedLockedInterruptible);<br>    commandEntry-&gt;connection = connection;<br>    commandEntry-&gt;eventTime = currentTime;<br>    commandEntry-&gt;seq = seq;<br>    commandEntry-&gt;handled = handled;<br>&#125;<br><br><span class="hljs-keyword">void</span> InputDispatcher::doDispatchCycleFinishedLockedInterruptible(<br>        CommandEntry* commandEntry) &#123;<br>  ...<br>        <span class="hljs-keyword">if</span> (dispatchEntry == connection-&gt;findWaitQueueEntry(seq)) &#123;<br>          //事件执行完毕后，从waitQueue移除事件<br>            connection-&gt;waitQueue.dequeue(dispatchEntry);<br>            traceWaitQueueLengthLocked(connection);<br>        &#125;<br><br>        // 开始下一次发送循环<br>        startDispatchCycleLocked(now(), connection);  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/event1_5.png" srcset="/img/loading.gif" alt="img"></p>
<p><code>InputReader</code>发送触摸事件到<code>InputDispatcher</code>，通过<code>findFocusedWindowTargetsLocked()</code>寻找触摸事件对应的窗口，如果没有找到就使用第一个<code>Window</code>。把结果写入<code>inputTargets</code>中，然后通过<code>publishMotionEvent</code>分发触摸事件，再通过<code>InputChannel</code>发送消息到UI线程。</p>
<p><img src="/images/InputDispatcherThread.jpg" srcset="/img/loading.gif" alt="InputDispatche"></p>
<h3 id="触摸事件发送至Activity"><a href="#触摸事件发送至Activity" class="headerlink" title="触摸事件发送至Activity"></a>触摸事件发送至Activity</h3><p><img src="/images/事件分发-触摸事件发送至Activity.png" srcset="/img/loading.gif" alt="事件分发-触摸事件发送至Activity"></p>
<p><code>InputDispatcher</code>负责分发触摸事件，最后通过<code>InputChannel-&gt;sendMessage()</code>发出消息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/libs/input/InputTransport.cpp<br>status_t InputChannel::sendMessage(<span class="hljs-keyword">const</span> InputMessage* msg) &#123;<br>    <span class="hljs-keyword">const</span> size_t msgLength = msg-&gt;size();<br>    InputMessage cleanMsg;<br>    msg-&gt;getSanitizedCopy(&amp;cleanMsg);<br>    ssize_t nWrite;<br>    <span class="hljs-keyword">do</span> &#123;<br>        nWrite = ::send(mFd, &amp;cleanMsg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);<br>    &#125; <span class="hljs-keyword">while</span> (nWrite == -1 &amp;&amp; errno == EINTR);<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>InputChannel</code>通过<code>socket</code>发送消息。</p>
<p>既然存在<code>sendMessage()</code>就需要找到相对的<code>receiveMessage()</code>调用的地方。</p>
<blockquote>
<p>当前是<code>InputDispatcher</code>调用的<code>sendMessage()</code>，对应就需要去<code>Window</code>找<code>receiveMessage()</code></p>
</blockquote>
<h4 id="InputChannel的理解"><a href="#InputChannel的理解" class="headerlink" title="InputChannel的理解"></a>InputChannel的理解</h4><p><img src="/images/事件分发-InputChannel.png" srcset="/img/loading.gif" alt="InputChannel"></p>
<p>本质是<code>SocketPair(非网络套接字)</code>。<code>SocketPair</code>用于实现本机内的进程间通信。</p>
<p><code>SocketPair</code>提供方法：</p>
<ul>
<li><code>socketPair()</code>：创建SocketPair，返回一对相互连接的fd</li>
<li><code>send()</code>：写入数据，可在另一个fd读取</li>
<li><code>recv()</code>：读取数据</li>
</ul>
<p><strong>非常适合用来进行进程间的交互式通讯。</strong></p>
<p><code>InputChannel</code>就是<code>SocketPair</code>的封装，分别分配给<code>InputDispatcher</code>与<code>Window</code>。</p>
<p><code>InputDispatcher</code>写入的事件，<code>Window</code>可以从自己持有的<code>InputChannel</code>获取；反向也是如此。</p>
<p><code>InputChannel</code>提供方法：位于<code>InputTransport.cpp</code>中</p>
<ul>
<li><code>openInputChannelPair()</code>：封装<code>socketPair()</code></li>
<li><code>sendMessage()</code>：封装<code>send()</code></li>
<li><code>receiveMessage()</code>：封装<code>recv()</code></li>
</ul>
<p><img src="/images/InputChannel原理.png" srcset="/img/loading.gif" alt="InputChannel原理"></p>
<p>最后屏幕的触摸事件都需要反映到一个Activity上，然后再一步步传递到对应的View上。所以需要先从Activity开始分析触摸事件的传递流程。</p>
<h4 id="InputChannel注册"><a href="#InputChannel注册" class="headerlink" title="InputChannel注册"></a>InputChannel注册</h4><p><img src="/images/事件分发-InputChannel注册.png" srcset="/img/loading.gif" alt="事件分发-InputChannel注册"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">//ActivityThread.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> handleResumeActivity(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest, <span class="hljs-keyword">boolean</span> isForward,<br>            String reason) &#123;<br>      ...<br>        wm.addView(decor, l);<br>      ...<br>    &#125;<br><br>// ==&gt; WindowManagerGlobal.java<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> addView(View view, ViewGroup.LayoutParams params,<br>            Display display, Window parentWindow) &#123;<br>        //新建ViewRootImpl<br>            root = new ViewRootImpl(view.getContext(), display);        <br>        <br>        root.setView(view, wparams, panelParentView);<br>      &#125;<br>  <br>// ==&gt; ViewRootImpl.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;<br>      //创建InputChannel对象<br>        <span class="hljs-keyword">if</span> ((mWindowAttributes.inputFeatures<br>                 &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123;<br>            mInputChannel = new InputChannel();<br>        &#125; <br>      //创建Socket的服务端<br>       res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,<br>             getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,<br>             mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,<br>             mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);      <br>      <br>      //创建Socket的客户端<br>        <span class="hljs-keyword">if</span> (mInputChannel != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mInputQueueCallback != <span class="hljs-keyword">null</span>) &#123;<br>                mInputQueue = new InputQueue();<br>                mInputQueueCallback.onInputQueueCreated(mInputQueue);<br>            &#125;<br>          //创建WindowEventReceiver对象<br>            mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,<br>                    Looper.myLooper());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="addToDisplay"><a href="#addToDisplay" class="headerlink" title="addToDisplay()"></a>addToDisplay()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">//Session.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> addToDisplay(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,<br>            <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outFrame, Rect outContentInsets,<br>            Rect outStableInsets, Rect outOutsets,<br>            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel) &#123;<br>        return mService.addWindow(<span class="hljs-keyword">this</span>, window, seq, attrs, viewVisibility, displayId, outFrame,<br>                outContentInsets, outStableInsets, outOutsets, outDisplayCutout, outInputChannel);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>mService</code>指的就是<code>WindowManagerService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">//frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> addWindow(Session session, IWindow client, <span class="hljs-keyword">int</span> seq,<br>            LayoutParams attrs, <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outFrame,<br>            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,<br>            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel) &#123;<br>      ...<br>            <span class="hljs-keyword">final</span> WindowState win = new WindowState(<span class="hljs-keyword">this</span>, session, client, token, parentWindow,<br>                    appOp[0], seq, attrs, viewVisibility, session.mUid,<br>                    session.mCanAddInternalSystemWindow);<br>      ...<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> openInputChannels = (outInputChannel != <span class="hljs-keyword">null</span><br>                    &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);<br>            <span class="hljs-keyword">if</span>  (openInputChannels) &#123;<br>                win.openInputChannel(outInputChannel);<br>            &#125;      <br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>addWindow()</code>主要创建了<code>WindowState</code>对象，然后继续调用到<code>openInputChannels()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">//frameworks/base/services/core/java/com/android/server/wm/WindowState.java<br>    <span class="hljs-keyword">void</span> openInputChannel(InputChannel outInputChannel) &#123;<br>        <span class="hljs-keyword">if</span> (mInputChannel != <span class="hljs-keyword">null</span>) &#123;<br>            throw new IllegalStateException("Window already has an input channel.");<br>        &#125;<br>        String name = getName();<br>        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);<br>        mInputChannel = inputChannels[0];<br>        mClientChannel = inputChannels[1];<br>        mInputWindowHandle.inputChannel = inputChannels[0];<br>        <span class="hljs-keyword">if</span> (outInputChannel != <span class="hljs-keyword">null</span>) &#123;<br>            mClientChannel.transferTo(outInputChannel);<br>            mClientChannel.dispose();<br>            mClientChannel = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            // If the window died visible, we setup a dummy input channel, so that taps<br>            // can still detected by input monitor channel, and we can relaunch the app.<br>            // Create dummy event receiver that simply reports all events as handled.<br>            mDeadWindowEventReceiver = new DeadWindowEventReceiver(mClientChannel);<br>        &#125;<br>        mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="registerInputChannel"><a href="#registerInputChannel" class="headerlink" title="registerInputChannel()"></a>registerInputChannel()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">//InputManagerService.java <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> registerInputChannel(InputChannel inputChannel,<br>            InputWindowHandle inputWindowHandle) &#123;<br>       //通过Native层完成注册<br>        nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, <span class="hljs-keyword">false</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">status_t NativeInputManager::registerInputChannel(JNIEnv* /* env */,<br>        <span class="hljs-keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,<br>        <span class="hljs-keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="hljs-keyword">bool</span> monitor) &#123;<br>    ATRACE_CALL();<br>  //再通过 InputDispatcher 继续注册<br>    <span class="hljs-keyword">return</span> mInputManager-&gt;getDispatcher()-&gt;registerInputChannel(<br>            inputChannel, inputWindowHandle, monitor);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/services/inputflinger/InputDispatcher.cpp<br>status_t InputDispatcher::registerInputChannel(<span class="hljs-keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,<br>        <span class="hljs-keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="hljs-keyword">bool</span> monitor) &#123;<br><br><br>    &#123; // acquire lock<br>        AutoMutex _l(mLock);<br><br>      //为传入的 InputChannel 创建Connection对象<br>        sp&lt;Connection&gt; connection = <span class="hljs-keyword">new</span> Connection(inputChannel, inputWindowHandle, monitor);<br><br>        <span class="hljs-keyword">int</span> fd = inputChannel-&gt;getFd();<br>      //监听connection的变化<br>        mConnectionsByFd.add(fd, connection);<br><br>        <span class="hljs-keyword">if</span> (monitor) &#123;<br>            mMonitoringChannels.push(inputChannel);<br>        &#125;<br><br>      //如果发生变化，回调handleReceiveCallback方法<br>        mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="hljs-keyword">this</span>);<br>    &#125; // release lock<br><br>    // Wake the looper because some connections have changed.<br>    mLooper-&gt;wake();<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/InputChannel执行过程.png" srcset="/img/loading.gif" alt="InputChannel执行过程"></p>
<p><img src="/images/v2-1e1273f15cfdd7b81aa7a2cb819d8890_1440w.jpg" srcset="/img/loading.gif" alt="InputChannel对应关系"></p>
<p><code>addToDisplay()</code>主要处理两部分内容</p>
<ul>
<li><p>创建Socket pair，作为<code>InputChannel</code></p>
<p><code>socket服务端</code>保存在<code>WidnowState</code>中的<code>mInputChannel</code>中</p>
<p><code>socket客户端</code>通过<code>binder</code>传到<code>ViewRootImpl</code>中的<code>mInputChannel</code></p>
</li>
<li><p>通过<code>IMS.registerInputChannel()</code>注册<code>InputChannel</code>，监听socket服务端，收到消息后回调<code>InputDispatcher::handleReceiveCallback()</code></p>
</li>
</ul>
<h5 id="WindowInputEventReceiver"><a href="#WindowInputEventReceiver" class="headerlink" title="WindowInputEventReceiver"></a>WindowInputEventReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">final</span> class WindowInputEventReceiver extends InputEventReceiver &#123;<br>        <span class="hljs-keyword">public</span> WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123;<br>            <span class="hljs-keyword">super</span>(inputChannel, looper);<br>        &#125;<br>      ...<br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onInputEvent(InputEvent event, <span class="hljs-keyword">int</span> displayId) &#123;<br>            enqueueInputEvent(event, <span class="hljs-keyword">this</span>, 0, <span class="hljs-keyword">true</span>);<br>        &#125;        <br>    &#125;<br><br>//InputeventReceiver.java<br>    <span class="hljs-keyword">public</span> InputEventReceiver(InputChannel inputChannel, Looper looper) &#123;<br><br>        mInputChannel = inputChannel;<br>        mMessageQueue = looper.getQueue();<br>        mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(<span class="hljs-keyword">this</span>),<br>                inputChannel, mMessageQueue);<br><br>        mCloseGuard.open("dispose");<br>    &#125;<br><br>//Native层调用该方法<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> dispatchInputEvent(<span class="hljs-keyword">int</span> seq, InputEvent event, <span class="hljs-keyword">int</span> displayId) &#123;<br>        mSeqMap.put(event.getSequenceNumber(), seq);<br>        onInputEvent(event, displayId);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>初始化 InputEventReceiver</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/base/core/jni/android_view_InputEventReceiver.cpp<br><span class="hljs-keyword">static</span> jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak,<br>        jobject inputChannelObj, jobject messageQueueObj) &#123;<br>    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,<br>            inputChannelObj);<br>    <span class="hljs-keyword">if</span> (inputChannel == <span class="hljs-literal">NULL</span>) &#123;<br>        jniThrowRuntimeException(env, "InputChannel is <span class="hljs-keyword">not</span> initialized.");<br>        <span class="hljs-keyword">return</span> 0;<br>    &#125;<br><br>  //获取消息队列<br>    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);<br>    <span class="hljs-keyword">if</span> (messageQueue == <span class="hljs-literal">NULL</span>) &#123;<br>        jniThrowRuntimeException(env, "MessageQueue is <span class="hljs-keyword">not</span> initialized.");<br>        <span class="hljs-keyword">return</span> 0;<br>    &#125;<br><br>  //创建NativeInputEventReceiver对象<br>    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="hljs-keyword">new</span> NativeInputEventReceiver(env,<br>            receiverWeak, inputChannel, messageQueue);<br>    status_t status = receiver-&gt;initialize();<br><br>    receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference <span class="hljs-keyword">for</span> the object<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(receiver.get());<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">status_t NativeInputEventReceiver::initialize() &#123;<br>    setFdEvents(ALOOPER_EVENT_INPUT);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-keyword">void</span> NativeInputEventReceiver::setFdEvents(<span class="hljs-keyword">int</span> events) &#123;<br>    <span class="hljs-keyword">if</span> (mFdEvents != events) &#123;<br>        mFdEvents = events;<br>        <span class="hljs-keyword">int</span> fd = mInputConsumer.getChannel()-&gt;getFd();<br>        <span class="hljs-keyword">if</span> (events) &#123;<br>            mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, <span class="hljs-keyword">this</span>, <span class="hljs-literal">NULL</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mMessageQueue-&gt;getLooper()-&gt;removeFd(fd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">//system/core/libutils/Looper.cpp<br><span class="hljs-keyword">int</span> Looper::addFd(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> ident, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="hljs-keyword">void</span>* data) &#123;<br>  //构造native Request消息<br>          Request request;<br>        request.fd = fd;<br>        request.ident = ident;<br>        request.events = events;<br>        request.seq = mNextRequestSeq++;<br>        request.callback = callback; //NativeInputReceiver<br>        request.data = data;<br>        <span class="hljs-keyword">if</span> (mNextRequestSeq == -1) mNextRequestSeq = 0; // reserve sequence number -1<br>  <br>        struct epoll_event eventItem;<br>        request.initEventItem(&amp;eventItem);<br>       ...<br>         //在epoll实例 添加native request监听<br>        <span class="hljs-keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);         <br>  <br>       //唤醒线程<br>        scheduleEpollRebuildLocked();  <br>&#125;<br><br><span class="hljs-keyword">void</span> Looper::scheduleEpollRebuildLocked() &#123;<br>    <span class="hljs-keyword">if</span> (!mEpollRebuildRequired) &#123;<br>        mEpollRebuildRequired = <span class="hljs-literal">true</span>;<br>        wake();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这一部分涉及<code>looper</code>在<code>Handler</code>就有详细介绍，<code>wake</code>之后，<code>native request</code>相关消息触发后会回调到<code>callback-&gt;handleEvent()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/base/core/jni/android_view_InputEventReceiver.cpp<br><span class="hljs-keyword">int</span> NativeInputEventReceiver::handleEvent(<span class="hljs-keyword">int</span> receiveFd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span>* data) &#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (events &amp; ALOOPER_EVENT_INPUT) &#123; //events 就是 ALOOPER_EVENT_INPUT<br>        JNIEnv* env = AndroidRuntime::getJNIEnv();<br>        status_t status = consumeEvents(env, <span class="hljs-literal">false</span> /*consumeBatches*/, -1, <span class="hljs-literal">NULL</span>);<br>        mMessageQueue-&gt;raiseAndClearException(env, "handleReceiveCallback");<br>        <span class="hljs-keyword">return</span> status == OK || status == NO_MEMORY ? 1 : 0;<br>    &#125;<br>  ...<br>&#125;<br><br>status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env,<br>        <span class="hljs-keyword">bool</span> consumeBatches, nsecs_t frameTime, <span class="hljs-keyword">bool</span>* outConsumedBatch) &#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>        status_t status = mInputConsumer.consume(&amp;mInputEventFactory,<br>                consumeBatches, frameTime, &amp;seq, &amp;inputEvent, &amp;displayId);<br>    //将事件进行打包，避免量过大<br>        <span class="hljs-keyword">if</span> (status) &#123;<br>            <span class="hljs-keyword">if</span> (status == WOULD_BLOCK) &#123;<br>                <span class="hljs-keyword">if</span> (!skipCallbacks &amp;&amp; !mBatchedInputEventPending<br>                        &amp;&amp; mInputConsumer.hasPendingBatch()) &#123;<br>                    // There is a pending batch.  Come back later.<br>                    <span class="hljs-keyword">if</span> (!receiverObj.get()) &#123;<br>                        receiverObj.reset(jniGetReferent(env, mReceiverWeakGlobal));<br>                        <span class="hljs-keyword">if</span> (!receiverObj.get()) &#123;<br>                            ALOGW("channel '%s' ~ Receiver object was finalized "<br>                                    "without being disposed.", getInputChannelName().c_str());<br>                            <span class="hljs-keyword">return</span> DEAD_OBJECT;<br>                        &#125;<br>                    &#125;<br><br>                    mBatchedInputEventPending = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (kDebugDispatchCycle) &#123;<br>                        ALOGD("channel '%s' ~ Dispatching batched input event pending notification.",<br>                                getInputChannelName().c_str());<br>                    &#125;<br>                  //调用 InputReceiver.dispatchBatchedInputEventPending()<br>                    env-&gt;CallVoidMethod(receiverObj.get(),<br>                            gInputEventReceiverClassInfo.dispatchBatchedInputEventPending);<br>                    <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) &#123;<br>                        ALOGE("Exception dispatching batched input events.");<br>                        mBatchedInputEventPending = <span class="hljs-literal">false</span>; // <span class="hljs-keyword">try</span> again later<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> OK;<br>            &#125;<br>            ALOGE("channel '%s' ~ Failed to consume input event.  status=%d",<br>                    getInputChannelName().c_str(), status);<br>            <span class="hljs-keyword">return</span> status;<br>        &#125;    <br>    ...<br>        <span class="hljs-keyword">if</span> (!skipCallbacks) &#123;<br><br>            jobject inputEventObj;<br>            <span class="hljs-keyword">switch</span> (inputEvent-&gt;getType()) &#123;<br><br>            <span class="hljs-keyword">case</span> AINPUT_EVENT_TYPE_MOTION: &#123;<br>                <span class="hljs-keyword">if</span> (kDebugDispatchCycle) &#123;<br>                    ALOGD("channel '%s' ~ Received motion event.", getInputChannelName().c_str());<br>                &#125;<br>              //封装MotionEvent对象<br>                MotionEvent* motionEvent = <span class="hljs-keyword">static_cast</span>&lt;MotionEvent*&gt;(inputEvent);<br>                <span class="hljs-keyword">if</span> ((motionEvent-&gt;getAction() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123;<br>                    *outConsumedBatch = <span class="hljs-literal">true</span>;<br>                &#125;<br>                inputEventObj = android_view_MotionEvent_obtainAsCopy(env, motionEvent);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">default</span>:<br>                assert(<span class="hljs-literal">false</span>); // InputConsumer should prevent <span class="hljs-keyword">this</span> from ever happening<br>                inputEventObj = <span class="hljs-literal">NULL</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (inputEventObj) &#123;<br>                <span class="hljs-keyword">if</span> (kDebugDispatchCycle) &#123;<br>                    ALOGD("channel '%s' ~ Dispatching input event.", getInputChannelName().c_str());<br>                &#125;<br>              //回调到Java层的 dispatchInputEvent() <br>                env-&gt;CallVoidMethod(receiverObj.get(),<br>                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj,<br>                        displayId);<br>                <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) &#123;<br>                    ALOGE("Exception dispatching input event.");<br>                    skipCallbacks = <span class="hljs-literal">true</span>;<br>                &#125;<br>                env-&gt;DeleteLocalRef(inputEventObj);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ALOGW("channel '%s' ~ Failed to obtain event object.",<br>                        getInputChannelName().c_str());<br>                skipCallbacks = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;    <br>    <br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/libs/input/InputTransport.cpp<br>status_t InputConsumer::consume(InputEventFactoryInterface* factory,<br>        <span class="hljs-keyword">bool</span> consumeBatches, nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent,<br>        int32_t* displayId) &#123;<br>    <span class="hljs-keyword">while</span> (!*outEvent) &#123;<br>            mMsgDeferred = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            // 收到新消息<br>            status_t result = mChannel-&gt;receiveMessage(&amp;mMsg);<br>            <span class="hljs-keyword">if</span> (result) &#123;<br>                <span class="hljs-keyword">if</span> (consumeBatches || result != WOULD_BLOCK) &#123;<br>                    result = consumeBatch(factory, frameTime, outSeq, outEvent, displayId);<br>                    <span class="hljs-keyword">if</span> (*outEvent) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>WindowInputEventReceiver</code>主要执行了以下几步：</p>
<ul>
<li>初始化了<code>NativeInputReceiver</code>，调用了<code>sendFdEvents()</code>发出了消息</li>
<li>往主线程Looper添加了一条<code>Native Request</code>，且<code>callback</code>为<code>NativeInputReceiver</code></li>
<li>向Looper的<code>mEpollFd</code>添加了监听，只要收到触摸事件的消息就会调用到<code>callback-&gt;handleEvent()</code></li>
<li><code>NativeInputReceiver::handleEvent()</code>主要回调到Java层的<code>dispatchInputEvent()</code>且携带<code>InputEvent</code>回去(在触摸场景下，实际为<code>MotionEvent</code>)。</li>
</ul>
<h4 id="回调到Activity"><a href="#回调到Activity" class="headerlink" title="回调到Activity"></a>回调到Activity</h4><p><img src="/images/事件分发-回调到Activity.png" srcset="/img/loading.gif" alt="事件分发-回调到Activity"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java">//InputEventReceiver.java<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> dispatchInputEvent(<span class="hljs-keyword">int</span> seq, InputEvent event, <span class="hljs-keyword">int</span> displayId) &#123;<br>        mSeqMap.put(event.getSequenceNumber(), seq);<br>        onInputEvent(event, displayId);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> dispatchBatchedInputEventPending() &#123;<br>        onBatchedInputEventPending();<br>    &#125;<br><br><br>//ViewRootImpl.java<br><br>    <span class="hljs-keyword">final</span> class WindowInputEventReceiver extends InputEventReceiver &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onInputEvent(InputEvent event, <span class="hljs-keyword">int</span> displayId) &#123;<br>            enqueueInputEvent(event, <span class="hljs-keyword">this</span>, 0, <span class="hljs-keyword">true</span>);<br>        &#125;<br>      <br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onBatchedInputEventPending() &#123;<br>            <span class="hljs-keyword">if</span> (mUnbufferedInputDispatch) &#123;<br>                <span class="hljs-keyword">super</span>.onBatchedInputEventPending();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                scheduleConsumeBatchedInput();//按照Vsync信号进行分发<br>            &#125;<br>        &#125;<br>      <br>    &#125;<br><br>//事件<br>    <span class="hljs-keyword">void</span> scheduleConsumeBatchedInput() &#123;<br>        <span class="hljs-keyword">if</span> (!mConsumeBatchedInputScheduled) &#123;<br>            mConsumeBatchedInputScheduled = <span class="hljs-keyword">true</span>;<br>          //根据Vsync信号 进行触摸事件的回调<br>            mChoreographer.postCallback(Choreographer.CALLBACK_INPUT,<br>                    mConsumedBatchedInputRunnable, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> enqueueInputEvent(InputEvent event,<br>            InputEventReceiver receiver, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">boolean</span> processImmediately) &#123;<br>        adjustInputEventForCompatibility(event);<br>        QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);<br><br>        <span class="hljs-keyword">if</span> (processImmediately) &#123;<br>            doProcessInputEvents();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            scheduleProcessInputEvents();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> doProcessInputEvents() &#123;<br>        // Deliver all pending input events in the queue.<br>        <span class="hljs-keyword">while</span> (mPendingInputEventHead != <span class="hljs-keyword">null</span>) &#123;<br>            QueuedInputEvent q = mPendingInputEventHead;<br>            mPendingInputEventHead = q.mNext;<br>            <span class="hljs-keyword">if</span> (mPendingInputEventHead == <span class="hljs-keyword">null</span>) &#123;<br>                mPendingInputEventTail = <span class="hljs-keyword">null</span>;<br>            &#125;<br>            q.mNext = <span class="hljs-keyword">null</span>;<br><br>            <span class="hljs-keyword">if</span> (q.mEvent <span class="hljs-keyword">instanceof</span> MotionEvent) &#123;<br>                MotionEvent me = (MotionEvent)q.mEvent;<br>                <span class="hljs-keyword">if</span> (me.getHistorySize() &gt; 0) &#123;<br>                    oldestEventTime = me.getHistoricalEventTimeNano(0);<br>                &#125;<br>            &#125;<br>            mChoreographer.mFrameInfo.updateInputEventTime(eventTime, oldestEventTime);<br><br>            deliverInputEvent(q);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> deliverInputEvent(QueuedInputEvent q) &#123;<br><br>        InputStage stage;<br>        <span class="hljs-keyword">if</span> (q.shouldSendToSynthesizer()) &#123;<br>            stage = mSyntheticInputStage;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (stage != <span class="hljs-keyword">null</span>) &#123;<br>            handleWindowFocusChanged();<br>            stage.deliver(q);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          //事件分发完成后 执行<br>            finishInputEvent(q);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> class InputStage &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> deliver(QueuedInputEvent q) &#123;<br>            <span class="hljs-keyword">if</span> ((q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED) != 0) &#123;<br>                forward(q);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shouldDropInputEvent(q)) &#123;<br>                finish(q, <span class="hljs-keyword">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                apply(q, onProcess(q));<br>            &#125;<br>        &#125;      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p>此处<code>stage</code>是<code>ViewPostImeInputStage</code>，向下继续调用到<code>onProcess()</code></p>
<p><code>ViewPostImeInputStage</code>：<strong>视图处理阶段</strong>，主要处理按键、手指触摸等事件，分发的对象是View。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">//viewRootImpl.java<br>    <span class="hljs-keyword">final</span> class ViewPostImeInputStage extends InputStage &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> onProcess(QueuedInputEvent q) &#123;<br>          //按键事件<br>            <span class="hljs-keyword">if</span> (q.mEvent <span class="hljs-keyword">instanceof</span> KeyEvent) &#123;<br>                return processKeyEvent(q);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              //触摸事件<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> source = q.mEvent.getSource();<br>                <span class="hljs-keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123;<br>                    return processPointerEvent(q);<br>                &#125;<br>            &#125;<br>        &#125;<br>      <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> processPointerEvent(QueuedInputEvent q) &#123;<br>            <span class="hljs-keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;<br><br>            mAttachInfo.mUnbufferedDispatchRequested = <span class="hljs-keyword">false</span>;<br>            mAttachInfo.mHandlingPointerEvent = <span class="hljs-keyword">true</span>;<br>          //向下分发到View<br>            <span class="hljs-keyword">boolean</span> handled = mView.dispatchPointerEvent(event);<br>  <br>            return handled ? FINISH_HANDLED : FORWARD;<br>        &#125;      <br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p>此时<code>mView</code>表示的就是<code>DecorView</code>，本质就是View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">//view.java    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> dispatchPointerEvent(MotionEvent event) &#123;<br>        <span class="hljs-keyword">if</span> (event.isTouchEvent()) &#123;<br>            return dispatchTouchEvent(event);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            return dispatchGenericMotionEvent(event);<br>        &#125;<br>    &#125;<br><br>//DecorView.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> dispatchTouchEvent(MotionEvent ev) &#123;<br>        <span class="hljs-keyword">final</span> Window.Callback cb = mWindow.getCallback();<br>        return cb != <span class="hljs-keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0<br>                ? cb.dispatchTouchEvent(ev) : <span class="hljs-keyword">super</span>.dispatchTouchEvent(ev);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>mWindow.getCallback()</code>就是与Window绑定的Activity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">//Activity.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> dispatchTouchEvent(MotionEvent ev) &#123;<br>        <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;<br>            onUserInteraction();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<br>            return <span class="hljs-keyword">true</span>;<br>        &#125;<br>        return onTouchEvent(ev);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>所以经过一系列操作 让用户的屏幕触摸操作，最终走到了<code>Activity.dispatchTouchEvent()</code></p>
<p><img src="/images/触摸事件真实顺序.jpg" srcset="/img/loading.gif" alt="img"></p>
<h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><h3 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h3><p><img src="/images/MotionEvent.png" srcset="/img/loading.gif" alt="MotionEvent"></p>
<blockquote>
<p>当用户点击View或ViewGroup的时候，将会产生一个事件对象，就是<code>MotionEvent</code>。</p>
</blockquote>
<p><code>MotionEvent</code>记录了<code>事件的类型(action)、触摸的位置(x,y)以及触摸的时间等</code>。</p>
<p>事件的类型主要分为以下几种：</p>
<ul>
<li><code>ACTION_DOWN</code>：监听用户手指按下的操作，一次按下标志触摸事件的开始。</li>
<li><code>ACTION_MOVE</code>：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。</li>
<li><code>ACTION_UP</code>：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。</li>
<li><code>ACTION_CANCEL</code>：当用户保持按下操作，并把手指移动到了控件外部区域时且父View处理事件触发。</li>
</ul>
<p>用户手指触摸到屏幕到离开屏幕可能产生的事件序列如下：</p>
<p><code>ACTION_DOWN</code> -&gt; <code>ACTION_MOVE</code> -&gt; <code>ACTION_MOVE</code> -&gt; … <code>ACTION_MOVE</code> -&gt; <code>ACTION_UP</code></p>
<p><img src="/images/事件分发顺序.jpg" srcset="/img/loading.gif" alt="事件分发顺序"></p>
<h3 id="MotionEvent产生时机"><a href="#MotionEvent产生时机" class="headerlink" title="MotionEvent产生时机"></a>MotionEvent产生时机</h3><p><img src="/images/MotionEvent产生时机.png" srcset="/img/loading.gif" alt="产生时机"></p>
<p>在<code>ViewRootImpl.setView()</code>时，创建了<code>WindowInputReceiver</code>，当IMS写入事件(通过EventHub监听到<code>/dev/input/</code>)，通过一系列的操作回调到<code>dispatchInputEvent()</code>，最后走到了<code>processPointerEvent()</code>，此时把从Native层传递过来的<code>InputEvent</code>强转成<code>MotionEvent</code>，然后继续向下传递。</p>
<h3 id="MotionEvent传递顺序-事件分发顺序"><a href="#MotionEvent传递顺序-事件分发顺序" class="headerlink" title="MotionEvent传递顺序-事件分发顺序"></a>MotionEvent传递顺序-事件分发顺序</h3><p><img src="/images/事件分发顺序.png" srcset="/img/loading.gif" alt="事件分发顺序"></p>
<p>事件分发本质就是<code>MotionEvent</code>的传递过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> processPointerEvent(QueuedInputEvent q) &#123;<br>            <span class="hljs-keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;<br><br>            mAttachInfo.mUnbufferedDispatchRequested = <span class="hljs-keyword">false</span>;<br>            mAttachInfo.mHandlingPointerEvent = <span class="hljs-keyword">true</span>;<br>          //向下分发到View<br>            <span class="hljs-keyword">boolean</span> handled = mView.dispatchPointerEvent(event);<br>  <br>            return handled ? FINISH_HANDLED : FORWARD;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p><code>mView</code>就是<code>DecorView</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">//DecorView.java<br>没有实现对应方法。。。<br>向上寻找父类<br>  <br>//View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> dispatchPointerEvent(MotionEvent event) &#123;<br>        <span class="hljs-keyword">if</span> (event.isTouchEvent()) &#123;<br>            return dispatchTouchEvent(event);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            return dispatchGenericMotionEvent(event);<br>        &#125;<br>    &#125;<br>  <br><br>//DecorView.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> dispatchTouchEvent(MotionEvent ev) &#123;<br>        <span class="hljs-keyword">final</span> Window.Callback cb = mWindow.getCallback();<br>        return cb != <span class="hljs-keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0<br>                ? cb.dispatchTouchEvent(ev) : <span class="hljs-keyword">super</span>.dispatchTouchEvent(ev);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>此时<code>mWindow.getCallback()</code>指的就是<code>Activity</code></p>
<h4 id="Activity事件分发"><a href="#Activity事件分发" class="headerlink" title="Activity事件分发"></a>Activity事件分发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> dispatchTouchEvent(MotionEvent ev) &#123;<br>    <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;<br>      //在此处可以监听到 用户触摸屏幕的操作<br>        onUserInteraction();<br>    &#125;<br>   //若dispatchTouchEvent返回<span class="hljs-keyword">true</span>，事件到此结束，返回<span class="hljs-keyword">false</span>，继续向下传递<br>  //对应PhoneWindow<br>    <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<br>        return <span class="hljs-keyword">true</span>;<br>    &#125;<br>  //没有任何View去处理，交给Activity自身的onTouchEvent处理<br>    return onTouchEvent(ev);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>getWindow()</code>对应唯一实现类<code>PhoneWindow</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">//PhoneWindow.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> superDispatchTouchEvent(MotionEvent event) &#123;<br>      //mDecor 是DecorView的一个实例，DecoeView就是顶层View中的实例对象<br>        return mDecor.superDispatchTouchEvent(event);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>mDecor</code>指的就是<code>DecorView</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">//DecorView.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> superDispatchTouchEvent(MotionEvent event) &#123;<br>      //调用父类的方法即FrameLayout.dispatchTouchEvent = ViewGroup.dispatchTouchEvent()，由父类去处理事件分发<br>        return <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);//指向了 ViewGroup<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/Activity-Dispatch.png" srcset="/img/loading.gif" alt="Activity事件分发"></p>
<p>总结一下：按照上述流程图，当一个点击事件进来时，Activity上的事件流程如下：</p>
<ul>
<li>调用<code>Activity.dispatchTouchEvent()</code>，然后调用<code>onUserInteraction()</code></li>
<li>调用<code>getWindow()即PhoneWindow.superDispatchTouchEvent()</code></li>
<li>调用<code>mDecor即DecorView.superDispatchTouchEvent()</code></li>
<li>调用DecorView父类即<strong><code>ViewGroup.dispatchTouchEvent()</code></strong> 在这里实现了事件从Activity传递至ViewGroup</li>
</ul>
<h4 id="ViewGroup事件分发"><a href="#ViewGroup事件分发" class="headerlink" title="ViewGroup事件分发"></a>ViewGroup事件分发</h4><p><img src="/images/事件分发-ViewGroup.png" srcset="/img/loading.gif" alt="ViewGroup事件分发"></p>
<p>上述Activity分发后，执行到<code>ViewGroup.dispatchTouchEvent()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewGroup.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> dispatchTouchEvent(MotionEvent ev) &#123;<br>      ...<br>        <br>            <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;<br>              //发生ACTION_DOWN事件，取消并清除之前的触摸<br>                cancelAndClearTouchTargets(ev);<br>                resetTouchState();<br>            &#125;        <br>      ...<br>          //判定当前事件是否需要拦截<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intercepted;<br>            <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>                    || mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;//只有ACTION_DOWN才可以触发拦截<br>                //FLAG_DISALLOW_INTERCEPT：禁止ViewGroup拦截除了DOWN以外的事件<br>                //可由View调用requestDisallowInterceptTouchEvent设置标记<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;<br>                <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;<br>                  //调用拦截方法<br>                    intercepted = onInterceptTouchEvent(ev);<br>                    ev.setAction(action); // restore action in <span class="hljs-keyword">case</span> it was changed<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    intercepted = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>               //没有触摸targets 且 非ACTION_DOWN 需要拦截<br>                intercepted = <span class="hljs-keyword">true</span>;<br>            &#125;   <br>      ...<br>           //非取消事件 且 没被拦截<br>            <span class="hljs-keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;<br>                <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)<br>                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;//当前为 DOWN 事件<br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> actionIndex = ev.getActionIndex(); // always 0 <span class="hljs-keyword">for</span> down<br>                   //存在子View<br>                    <span class="hljs-keyword">if</span> (newTouchTarget == <span class="hljs-keyword">null</span> &amp;&amp; childrenCount != 0) &#123;<br>                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> x = ev.getX(actionIndex);<br>                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> y = ev.getY(actionIndex);<br>                      //从上往下 寻找能处理触摸事件的子View<br>                        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();<br>                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = preorderedList == <span class="hljs-keyword">null</span><br>                                &amp;&amp; isChildrenDrawingOrderEnabled();<br>                        <span class="hljs-keyword">final</span> View[] children = mChildren;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = childrenCount - 1; i &gt;= 0; i--) &#123;<br>                            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(<br>                                    childrenCount, i, customOrder);<br>                            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(<br>                                    preorderedList, children, childIndex);<br>                           //无法获取焦点，跳过循环<br>                            <span class="hljs-keyword">if</span> (childWithAccessibilityFocus != <span class="hljs-keyword">null</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (childWithAccessibilityFocus != child) &#123;<br>                                    <span class="hljs-keyword">continue</span>;<br>                                &#125;<br>                                childWithAccessibilityFocus = <span class="hljs-keyword">null</span>;<br>                                i = childrenCount - 1;<br>                            &#125;<br>                          //View不可见 或者 触摸的坐标点不在View的范围内，跳过循环<br>                            <span class="hljs-keyword">if</span> (!canViewReceivePointerEvents(child)<br>                                    || !isTransformedTouchPointInView(x, y, child, <span class="hljs-keyword">null</span>)) &#123;<br>                                ev.setTargetAccessibilityFocus(<span class="hljs-keyword">false</span>);<br>                                <span class="hljs-keyword">continue</span>;<br>                            &#125;<br><br>                            newTouchTarget = getTouchTarget(child);<br>                          //当前正在循环 ，退出当前循环<br>                            <span class="hljs-keyword">if</span> (newTouchTarget != <span class="hljs-keyword">null</span>) &#123;<br>                                // Child is already receiving touch within its bounds.<br>                                // Give it the new pointer in addition to the ones it is handling.<br>                                newTouchTarget.pointerIdBits |= idBitsToAssign;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br><br>                            resetCancelNextUpFlag(child);<br>                          ////事件传递下来后，调用dispatchTransformedTouchEvent，事件就会传递到View/ViewGroup中       <br>                            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-keyword">false</span>, child, idBitsToAssign)) &#123;<br>                                // Child wants to receive touch within its bounds.<br>                                mLastTouchDownTime = ev.getDownTime();<br>                                <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-keyword">null</span>) &#123;<br>                                    // childIndex points into presorted list, find original index<br>                                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = 0; j &lt; childrenCount; j++) &#123;<br>                                        <span class="hljs-keyword">if</span> (children[childIndex] == mChildren[j]) &#123;<br>                                            mLastTouchDownIndex = j;<br>                                            <span class="hljs-keyword">break</span>;<br>                                        &#125;<br>                                    &#125;<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    mLastTouchDownIndex = childIndex;<br>                                &#125;<br>                                mLastTouchDownX = ev.getX();<br>                                mLastTouchDownY = ev.getY();<br>                              //添加新的 touchtarget<br>                                newTouchTarget = addTouchTarget(child, idBitsToAssign);<br>                                alreadyDispatchedToNewTouchTarget = <span class="hljs-keyword">true</span>;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            ev.setTargetAccessibilityFocus(<span class="hljs-keyword">false</span>);<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-keyword">null</span>) preorderedList.clear();<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (newTouchTarget == <span class="hljs-keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;<br>                        newTouchTarget = mFirstTouchTarget;<br>                        <span class="hljs-keyword">while</span> (newTouchTarget.next != <span class="hljs-keyword">null</span>) &#123;<br>                            newTouchTarget = newTouchTarget.next;<br>                        &#125;<br>                        newTouchTarget.pointerIdBits |= idBitsToAssign;<br>                    &#125;                  <br>                &#125;<br>            &#125;<br>      <br>            // mFirstTouchTarget赋值是在通过addTouchTarget方法获取的；<br>            // 只有处理ACTION_DOWN事件，才会进入addTouchTarget方法。<br>            // 这也正是当View没有消费ACTION_DOWN事件，则不会接收其他MOVE,UP等事件的原因<br>            <span class="hljs-keyword">if</span> (mFirstTouchTarget == <span class="hljs-keyword">null</span>) &#123;<br>                // ViewGroup处理事件 当无人可以响应触摸事件<br>                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-keyword">null</span>,<br>                        TouchTarget.ALL_POINTER_IDS);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>               //如果View消费ACTION_DOWN事件，那么MOVE,UP等事件相继开始执行<br>                TouchTarget predecessor = <span class="hljs-keyword">null</span>;<br>                TouchTarget target = mFirstTouchTarget;<br>                <span class="hljs-keyword">while</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">final</span> TouchTarget next = target.next;<br>                    <span class="hljs-keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;<br>                        handled = <span class="hljs-keyword">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)<br>                                || intercepted;<br>                      //子View/ViewGroup 处理触摸事件<br>                        <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,<br>                                target.child, target.pointerIdBits)) &#123;<br>                            handled = <span class="hljs-keyword">true</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (cancelChild) &#123;<br>                            <span class="hljs-keyword">if</span> (predecessor == <span class="hljs-keyword">null</span>) &#123;<br>                                mFirstTouchTarget = next;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                predecessor.next = next;<br>                            &#125;<br>                            target.recycle();<br>                            target = next;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                    &#125;<br>                    predecessor = target;<br>                    target = next;<br>                &#125;<br>            &#125;    <br>              ...<br>        &#125;<br>        return handled;<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent()"></a>onInterceptTouchEvent()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> onInterceptTouchEvent(MotionEvent ev) &#123;<br>    <span class="hljs-keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)<br>            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN<br>            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)<br>            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;<br>        return <span class="hljs-keyword">true</span>;<br>    &#125;<br>    return <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以通过重写该方法，进行事件分发的拦截。</p>
<ul>
<li>返回true，事件被拦截，执行当前View的<code>onTouchEvent()</code></li>
<li>返回false，事件继续向下分发</li>
</ul>
<h5 id="buildTouchDispatchChildList"><a href="#buildTouchDispatchChildList" class="headerlink" title="buildTouchDispatchChildList()"></a>buildTouchDispatchChildList()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> ArrayList&lt;View&gt; buildTouchDispatchChildList() &#123;<br>        return buildOrderedChildList();<br>    &#125;<br><br>    ArrayList&lt;View&gt; buildOrderedChildList() &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childrenCount = mChildrenCount;<br>        <span class="hljs-keyword">if</span> (childrenCount &lt;= 1 || !hasChildWithZ()) return <span class="hljs-keyword">null</span>;<br><br>      //z<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = isChildrenDrawingOrderEnabled();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; childrenCount; i++) &#123;<br>            // add next child (in child order) to end of list<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<br>            <span class="hljs-keyword">final</span> View nextChild = mChildren[childIndex];<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> currentZ = nextChild.getZ();<br><br>            // 按z轴，从小到大排序所有的子视图，即z轴大的View先响应事件<br>            <span class="hljs-keyword">int</span> insertIndex = i;<br>            <span class="hljs-keyword">while</span> (insertIndex &gt; 0 &amp;&amp; mPreSortedChildren.get(insertIndex - 1).getZ() &gt; currentZ) &#123;<br>                insertIndex--;<br>            &#125;<br>            mPreSortedChildren.add(insertIndex, nextChild);<br>        &#125;<br>        return mPreSortedChildren;<br>    &#125;<br><br>//View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> getZ() &#123;<br>        return getElevation() + getTranslationZ();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>默认的事件分发顺序与绘制顺序一致，按照<code>view.getZ()</code>从大到小排序，Z值大的先绘制且先响应事件。</p>
<p>当然，这个事件分发的顺序也可以修改，只需要实现两个方法：</p>
<ul>
<li><code>setChildrenDrawingOrderEnabled(true)</code>：允许自定义顺序。<em>isChildrenDrawingOrderEnabled()返回true</em></li>
<li><code>getChildDrawingOrder()</code>：自定义当前View的顺序</li>
</ul>
<p>也可以通过<code>setElevation()</code>、<code>setTranslationZ()</code>或者<code>setZ()</code>去修改Z轴的坐标值。</p>
<h5 id="dispatchTransformedTouchEvent"><a href="#dispatchTransformedTouchEvent" class="headerlink" title="dispatchTransformedTouchEvent()"></a>dispatchTransformedTouchEvent()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> dispatchTransformedTouchEvent(MotionEvent event, <span class="hljs-keyword">boolean</span> cancel,<br>        View child, <span class="hljs-keyword">int</span> desiredPointerIdBits) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> handled;<br><br>   //发生取消事件后，不再执行后续的任何操作<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldAction = event.getAction();<br>    <span class="hljs-keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;<br>        event.setAction(MotionEvent.ACTION_CANCEL);<br>        <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;<br>            handled = <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            handled = child.dispatchTouchEvent(event);<br>        &#125;<br>        event.setAction(oldAction);<br>        return handled;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> MotionEvent transformedEvent;<br>    <span class="hljs-keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;<br>        <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span> || child.hasIdentityMatrix()) &#123;<br>            <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;<br>              //不存在子视图，调用View.dispatchTouchEvent()<br>                handled = <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> offsetX = mScrollX - child.mLeft;<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> offsetY = mScrollY - child.mTop;<br>                event.offsetLocation(offsetX, offsetY);<br>               //调用子View/ViewGroup的 dispatchTouchEvent()<br>                handled = child.dispatchTouchEvent(event);<br><br>                event.offsetLocation(-offsetX, -offsetY);<br>            &#125;<br>            return handled;<br>        &#125;<br>        transformedEvent = MotionEvent.obtain(event);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        transformedEvent = event.split(newPointerIdBits);<br>    &#125;<br><br>    // Done.<br>    transformedEvent.recycle();<br>    return handled;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>dispatchTransformedTouchEvent()</code>分为两套处理方式：</p>
<ul>
<li><code>child==null</code>：发生的情况：<code>事件被拦截</code>或<code>真的没有可执行触摸事件的子View</code>。执行<code>View.dispatchTouchEvent()</code></li>
<li><code>child!=null</code>：向下执行子View/ViewGroup的<code>dispatchTouchEvent()</code></li>
</ul>
<h5 id="addTouchTarget"><a href="#addTouchTarget" class="headerlink" title="addTouchTarget()"></a>addTouchTarget()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> TouchTarget addTouchTarget(@NonNull View child, <span class="hljs-keyword">int</span> pointerIdBits) &#123;<br>    <span class="hljs-keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);<br>    target.next = mFirstTouchTarget;<br>    mFirstTouchTarget = target;<br>    return target;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>TouchTarget</code>结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> class TouchTarget &#123;<br>    // The touched child view.<br>    <span class="hljs-keyword">public</span> View child;<br><br>    // The combined bit mask of pointer ids <span class="hljs-keyword">for</span> all pointers captured by the target.<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> pointerIdBits;<br><br>    // The next target in the target list.<br>    <span class="hljs-keyword">public</span> TouchTarget next;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>TouchTarget</code>是一个单链表结构，记录的是<strong>事件分发链</strong>。每一个元素表示<code>真正对事件消费的View</code>。</p>
<p><img src="/images/ViewGroup-Dispatch.png" srcset="/img/loading.gif" alt="ViewGroup事件分发"></p>
<p>根据上述流程图，总结一下：</p>
<ul>
<li>点击事件从上层传递到ViewGroup，先调用<code>ViewGroup.dispatchTouchEvent()</code></li>
<li>判断<code>ViewGroup.onInterceptTouchEvent()</code>是否拦截点击事件<ul>
<li>默认不拦截，则将事件继续向子View传递，然后调用<code>View.dispatchTouchEvent()</code></li>
<li>被拦截返回<code>true</code>，调用<code>super.dispatchTouchEvent()</code>返给父布局处理，并且ViewGroup自身也处理事件，比如<code>onTouch(),onClick(),onTouchEvent()</code>等事件</li>
</ul>
</li>
</ul>
<blockquote>
<p>通常情况下ViewGroup的<code>onInterceptTouchEvent()</code>返回false，不会拦截用户操作。</p>
<p>不过要注意的是 拦截的是 一个用户的操作序列：<em>从用户手指按下到手指抬起为止。</em></p>
<ul>
<li>拦截了Down事件，后续的事件都会交由<code>ViewGroup.onTouchEvent()</code>处理</li>
<li>拦截了其他事件，会给之前序列头部的<code>ACTION_DOWN</code>事件发送一个<code>ACTION_CANCEL</code>类型事件，通知子View无法执行后续事件，回归初始状态。(<strong>例如点击ListView中的一个Item的Button，再滑动ListView，Button就会恢复初始状态。</strong>)</li>
</ul>
</blockquote>
<h4 id="View事件分发"><a href="#View事件分发" class="headerlink" title="View事件分发"></a>View事件分发</h4><p><img src="/images/事件分发-View.png" srcset="/img/loading.gif" alt="View事件分发"></p>
<p>ViewGroup事件分发完毕后，由子View继续执行事件分发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> dispatchTouchEvent(MotionEvent event) &#123;<br><br>        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;<br>            <span class="hljs-keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;<br>                result = <span class="hljs-keyword">true</span>;<br>            &#125;<br>            //noinspection SimplifiableIfStatement<br>            ListenerInfo li = mListenerInfo;<br>            <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-keyword">null</span> //View设置了touch事件<br>                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED //View是可以操作的<br>                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, event)) &#123; //View.onTouch返回<span class="hljs-keyword">true</span><br>                result = <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>          //上述任一条件不满足，就会执行 onTouchEvent()<br>            <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;<br>                result = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        return result;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>dispatchTouchEvent()</code>按照如下顺序执行：</p>
<ol>
<li><code>onTouchListener.ouTouch()</code>开始执行，返回<code>true</code>表示当前事件已被消费，不需要向上执行。否则继续向下执行</li>
<li><code>onTouchEvent()</code>返回<code>true</code>表示消费事件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> onTouchEvent(MotionEvent event) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE //有点击事件 调用setOnClickListener()<br>                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) //有长按事件 调用setOnLongClickListener()<br>                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;<br>      <br>        <span class="hljs-keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;<br>            <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;<br>                setPressed(<span class="hljs-keyword">false</span>);<br>            &#125;<br>            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;<br>          //当View不可用时 直接消费事件<br>            return clickable;<br>        &#125;<br>      <br>      <span class="hljs-keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;<br>            <span class="hljs-keyword">switch</span> (action) &#123;<br>                <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>                        <span class="hljs-keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;<br>                            // This is a tap, so remove the longpress check<br>                            removeLongPressCallback();<br><br>                            <span class="hljs-keyword">if</span> (!focusTaken) &#123;<br>                                <span class="hljs-keyword">if</span> (mPerformClick == <span class="hljs-keyword">null</span>) &#123;<br>                                    mPerformClick = new PerformClick();<br>                                &#125;<br>                                <span class="hljs-keyword">if</span> (!post(mPerformClick)) &#123;<br>                                  //调用View.onClckListener<br>                                    performClickInternal();<br>                                &#125;<br>                            &#125;<br>                        &#125;                <br>            &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> performClickInternal() &#123;<br><br>        return performClick();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> performClick() &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> result;<br>        <span class="hljs-keyword">final</span> ListenerInfo li = mListenerInfo;<br>        <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="hljs-keyword">null</span>) &#123;<br>            playSoundEffect(SoundEffectConstants.CLICK);<br>            li.mOnClickListener.onClick(<span class="hljs-keyword">this</span>);<br>            result = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        return result;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/View-Dispatch.png" srcset="/img/loading.gif" alt="View事件分发"></p>
<p>根据上述流程图，总结一下：</p>
<ul>
<li>点击事件从ViewGroup传递到View，调用<code>View.dispatchTouchEvent()</code></li>
<li>判断当前View是否设置<code>OnTouchListener</code>，并且设置了<code>onTouch()</code>返回值，默认返回false<ul>
<li>返回<code>true</code>，代表事件被<code>onTouch()</code>消费，不会继续往下传递</li>
<li>返回<code>false</code>，事件继续向下传递，调用<code>View.onTouchEvent()</code>，后续若设置点击事件，则继续调用<code>performClick()</code>，最后执行<code>onClick()</code>事件</li>
</ul>
</li>
</ul>
<p>拓展：</p>
<blockquote>
<ol>
<li>如果有一个控件是<code>DISABLED</code>，注册的<code>onTouch()</code>事件不会被执行。若要监听点击事件，只能实现它的<code>onTouchEvent()</code></li>
<li>点击事件优先级： <code>onTouch()</code> &gt; <code>onTouchEvent()</code> &gt; <code>performClick()</code> &gt; <code>onClick()</code> </li>
</ol>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>根据前几节分析得出完整的事件分发顺序：</p>
<p><strong>IMS -&gt; WindowInputREceiver(ViewRootImpl) -&gt; DecorView -&gt; Activity -&gt; DecorView -&gt; viewGroup -&gt; View</strong></p>
<h4 id="事件分发核心方法"><a href="#事件分发核心方法" class="headerlink" title="事件分发核心方法"></a>事件分发核心方法</h4><p><img src="/images/事件分发核心方法.png" srcset="/img/loading.gif" alt="事件分发核心方法"></p>
<p><code>boolean dispatchTouchEvent()</code></p>
<p>用来进行事件的分发。</p>
<ul>
<li>返回<code>true</code>：事件被当前View所消费，不会向下传递</li>
<li>返回<code>false</code>：交由上一层的View的<code>onTouchEvent()</code>处理</li>
<li>返回<code>super.dispatchTouchEvent()</code>：继续向下分发事件</li>
</ul>
<p><code>boolean onInterceptTouchEvent()</code></p>
<p>用来进行事件的拦截，在<code>dispatchOnTouchEvent()</code>中调用。<strong>只有ViewGroup才可以调用</strong></p>
<ul>
<li><p>返回<code>true</code>：拦截当前事件，并交由<code>onTouchEvent()</code>去处理</p>
</li>
<li><p>返回<code>false</code>：不拦截当前事件，继续向下传递</p>
</li>
<li><p>返回<code>super.onInterceptTouchEvent()</code>：调用父类的<code>onInterceptTouchEvent()</code>，大部分情况下是<code>false</code>。</p>
<p>如果点击了子View区域，可以继续分发到<code>child.dispatchTouchEvent()</code></p>
<p>没有子View可以响应事件，执行<code>onTouchEvent()</code></p>
</li>
</ul>
<p><code>boolean onTouchEvent()</code></p>
<p>用来处理点击事件，在<code>dispatchOnTouchEvent()</code>中调用。</p>
<ul>
<li><p>返回<code>true</code>：当前View处理当前事件</p>
</li>
<li><p>返回<code>false</code>：当前View无法处理事件，交由上一层View的<code>onTouchEvent()</code>处理</p>
</li>
<li><p>返回<code>super.onTouchEvent()</code></p>
<p>当前View设置了<code>clickable/longclickable</code>，等价于返回true，当前View处理事件</p>
<p>当前View未设置<code>clickable/longclickable</code>，等价于返回false,交由上一层的<code>onTouchEvent()</code>处理。</p>
</li>
</ul>
<p>上述三个核心方法，可以用如下伪代码代替</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> dispatchTouchEvent() &#123;<br>    <span class="hljs-keyword">boolean</span> res = <span class="hljs-keyword">false</span>;<br><br>    // 是否不允许拦截事件<br>    // 如果设置了 FLAG_DISALLOW_INTERCEPT，不会拦截事件，所以在 child 里可以通过 requestDisallowInterceptTouchEvent 控制父 View 是否来拦截事件<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;<br><br>    <span class="hljs-keyword">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent()) &#123; // View 不调用这里，直接执行下面的 touchlistener 判断<br>        <span class="hljs-keyword">if</span> (touchlistener &amp;&amp; touchlistener.onTouch()) &#123;<br>            return <span class="hljs-keyword">true</span>;<br>        &#125;<br>        res = onTouchEvent(); // 里面会处理点击事件 -&gt; performClick() -&gt; clicklistener.onClick()<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DOWN) &#123; // 如果是 DOWN 事件，则遍历子 View 进行事件分发<br>        // 循环子 View 处理事件<br>        <span class="hljs-keyword">for</span> (childs) &#123;<br>            res = child.dispatchTouchEvent();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // 事件分发给 target 去处理，这里的 target 就是上一步处理 DOWN 事件的 View<br>        target.child.dispatchTouchEvent();<br>    &#125;<br>    return res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/TouchEvent-Transmit.png" srcset="/img/loading.gif" alt="事件分发"></p>
<ol>
<li>点击事件传递从<code>dispatchTouchEvent()</code>开始，在不修改默认返回值时，事件会按照嵌套层次由外向内传递，到达最内层View时，由最内层<code>View.onTouchEvent()</code>处理</li>
<li>View的点击事件触发顺序为  <code>onTouch()</code> &gt; <code>onTouchEvent()</code> &gt; <code>performClick()</code> &gt; <code>onClick()</code> </li>
<li><em>Touch事件的后续(例如<code>ACTION_MOVE</code>,<code>ACTION_UP</code>)层级传递</em><ul>
<li>若<code>dispatchTouchEvent()</code>返回true，那么能收到<code>ACTION_DOWN</code>的函数也可以收到后续事件</li>
<li>若<code>onTouchEvent()</code>返回true，那么其他事件不再往下传递，而是直接传给自己的<code>onTouchEvent()</code>并结束本次事件传递</li>
</ul>
</li>
</ol>
<blockquote>
<p>事件分发核心在于<code>ViewGroup.dispatchTouchEvent()</code>的<code>ACTION_DOWN</code>过程中找到<code>mFirstTouchTarget</code>是否为空。</p>
<p>通过遍历子View寻找<code>view.disptachTouchEvent()</code>返回<code>true</code>，就设置<code>mFirstTouchTarget</code>为该子View。</p>
<p>如果<code>mFirstTarget</code>不为空，<code>ACTION_MOVE</code>和<code>ACTION_UP</code>才会向子View传递，如果中途被<code>ViewGroup</code>拦截了事件，子View就会收到<code>ACTION_CANCEL</code>，并且<code>mFirstTouchTarget</code>为null，后续的事件只会走到<code>ViewGroup</code>。</p>
</blockquote>
<h4 id="事件分发特殊情况"><a href="#事件分发特殊情况" class="headerlink" title="事件分发特殊情况"></a>事件分发特殊情况</h4><p><img src="/images/事件分发特殊情况.png" srcset="/img/loading.gif" alt="事件分发特殊情况"></p>
<h5 id="ACTIOIN-CANCEL产生场景"><a href="#ACTIOIN-CANCEL产生场景" class="headerlink" title="ACTIOIN_CANCEL产生场景"></a><code>ACTIOIN_CANCEL</code>产生场景</h5><ol>
<li><p>子View处理了Down事件，按照设定Move与Up的事件也会交给他处理。若此时，父View拦截了事件，此时子View就会收到一个Cancel事件，并且无法接收到后续的Move与Up事件。</p>
<p>常见场景：ListView有一个Item带有Button，此时点击按钮(触发ACTION_DOWN)，再进行上下滑动，ListView就会拦截掉后续的Move事件，此时Button就会收到ACTION_CANCEL</p>
</li>
<li><p>子View收到ACTION_DOWN，但是上一个事件还没有结束(因为APP切换、ANR导致后续事件丢失)，此时也会执行ACTION_CANCEL</p>
</li>
</ol>
<h5 id="子View拦截父View事件"><a href="#子View拦截父View事件" class="headerlink" title="子View拦截父View事件"></a>子View拦截父View事件</h5><p>子View通过使用<code>requestDisallowInterceptTouchEvent(true)</code>命令<strong>指定ViewGroup不再针对事件序列进行拦截</strong>，将事件交由子View去处理。</p>
<p><em>设置<code>requestDisallowInterceptTouchEvent(true)</code>后，父类会在每次<code>ACTION_DOWN</code>的时候进行重置，避免影响其他子View的事件处理。</em></p>
<p>上述方法也是解决<code>滑动冲突</code>的一种方法：</p>
<p><code>内部拦截法</code>：通过在子类中调用<code>parent.requestDisallowInterceptTouchEvent()</code>来控制父类是否拦截事件。</p>
<p>还有一个是</p>
<p><code>外部拦截法</code>：通过重写父类的<code>onInterceptTouchEvent()</code>拦截冲突的事件。</p>
<h4 id="长按事件原理"><a href="#长按事件原理" class="headerlink" title="长按事件原理"></a>长按事件原理</h4><p>在<code>onTouchEvent()</code>收到<code>ACTION_DOWN</code>事件时，发送一个延时消息<code>mPendingCheckForLongPress()</code>，延迟<code>400ms</code>后执行。内部执行<code>performLongClick()</code>，再然后一步步调用到<code>performLongClickInternal()</code>内部执行到<code>mOnLongClickListener.onLongClick()</code></p>
<p><code>onLongClick()</code>返回<code>true</code>就会屏蔽<code>onClick()</code>执行。</p>
<h2 id="事件分发完成"><a href="#事件分发完成" class="headerlink" title="事件分发完成"></a>事件分发完成</h2><p>事件分发完毕后，执行到<code>finishInputEvent()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> onDeliverToNext(QueuedInputEvent q) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_INPUT_STAGES) &#123;<br>                Log.v(mTag, "Done with " + getClass().getSimpleName() + ". " + q);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mNext != <span class="hljs-keyword">null</span>) &#123;<br>              //有任务继续执行<br>                mNext.deliver(q);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              //无任务时 通知结束<br>                finishInputEvent(q);<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> finishInputEvent(QueuedInputEvent q) &#123;<br>        Trace.asyncTraceEnd(Trace.TRACE_TAG_VIEW, "deliverInputEvent",<br>                q.mEvent.getSequenceNumber());<br><br>        <span class="hljs-keyword">if</span> (q.mReceiver != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">boolean</span> handled = (q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED_HANDLED) != 0;<br>            q.mReceiver.finishInputEvent(q.mEvent, handled);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            q.mEvent.recycleIfNeededAfterDispatch();<br>        &#125;<br><br>        recycleQueuedInputEvent(q);<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">//InputEventReceiver.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> finishInputEvent(InputEvent event, <span class="hljs-keyword">boolean</span> handled) &#123;<br>     ...<br>      nativeFinishInputEvent(mReceiverPtr, seq, handled);<br>     ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>nativeFinishInputEvent()</code>通知事件结束到Native层</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/base/core/jni/android_view_InputEventReceiver.cpp<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> nativeFinishInputEvent(JNIEnv* env, jclass clazz, jlong receiverPtr,<br>        jint seq, jboolean handled) &#123;<br>    sp&lt;NativeInputEventReceiver&gt; receiver =<br>            <span class="hljs-keyword">reinterpret_cast</span>&lt;NativeInputEventReceiver*&gt;(receiverPtr);<br>  ...<br>    status_t status = receiver-&gt;finishInputEvent(seq, handled);<br>&#125;<br><br>status_t NativeInputEventReceiver::finishInputEvent(uint32_t seq, <span class="hljs-keyword">bool</span> handled) &#123;<br>  ...<br>    status_t status = mInputConsumer.sendFinishedSignal(seq, handled);<br>    <span class="hljs-keyword">if</span> (status) &#123;<br>        <span class="hljs-keyword">if</span> (status == WOULD_BLOCK) &#123;<br>          ...<br>            <span class="hljs-keyword">if</span> (mFinishQueue.size() == 1) &#123;<br>                setFdEvents(ALOOPER_EVENT_INPUT | ALOOPER_EVENT_OUTPUT);<br>            &#125;<br>            <span class="hljs-keyword">return</span> OK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">//frameworks/native/libs/input/InputTransport.cpp<br>status_t InputConsumer::sendFinishedSignal(uint32_t seq, <span class="hljs-keyword">bool</span> handled) &#123;<br>    ...<br>    // Send finished signals <span class="hljs-keyword">for</span> the batch sequence chain first.<br>    size_t seqChainCount = mSeqChains.size();<br>    <span class="hljs-keyword">if</span> (seqChainCount) &#123;<br>       ...<br>        status_t status = OK;<br>        <span class="hljs-keyword">while</span> (!status &amp;&amp; chainIndex &gt; 0) &#123;<br>            chainIndex--;<br>          <br>            status = sendUnchainedFinishedSignal(chainSeqs[chainIndex], handled);<br>        &#125;<br><br>    &#125;<br><br>    // Send finished signal <span class="hljs-keyword">for</span> the last message in the batch.<br>    <span class="hljs-keyword">return</span> sendUnchainedFinishedSignal(seq, handled);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">status_t InputConsumer::sendUnchainedFinishedSignal(uint32_t seq, <span class="hljs-keyword">bool</span> handled) &#123;<br>    InputMessage msg;<br>    msg.header.type = InputMessage::TYPE_FINISHED;<br>    msg.body.finished.seq = seq;<br>    msg.body.finished.handled = handled;<br>  //通过 InputChannel.sendMessage()发送消息通知<br>     <span class="hljs-keyword">return</span> mChannel-&gt;sendMessage(&amp;msg);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>InputChannel.sendMessage()</code>之后，<code>InputDispatcher</code>线程被唤醒，回调到<code>handleReceiveCallback()</code>。执行到上面的<code>InputDispatcheThread</code>相关代码。</p>
<h2 id="相关示例"><a href="#相关示例" class="headerlink" title="相关示例"></a>相关示例</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://gityuan.com/2016/12/11/input-reader/" target="_blank" rel="noopener">InputReaderThread</a></p>
<p><a href="https://cs.android.com" target="_blank" rel="noopener">Android相关源码</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/31210271" target="_blank" rel="noopener">一次触摸，Android 到底干了啥</a></p>
<p><a href="https://juejin.cn/post/6844903926446161927#heading-14" target="_blank" rel="noopener">反思|Android 事件分发机制的设计与实现</a></p>
<p><a href="https://wizardforcel.gitbooks.io/deepin-android-vol3/content/5.html" target="_blank" rel="noopener">深入理解Android卷-III</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/12/12/Android性能优化-布局优化/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android性能优化-布局优化</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/20/Android性能优化-性能监控/">
                        <span class="hidden-mobile">Android-性能监控</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
