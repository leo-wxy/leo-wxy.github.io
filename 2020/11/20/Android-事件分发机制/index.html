

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
    <meta name="description" content="当用户触摸屏幕或者按键操作。  首先触发硬件驱动，驱动收到事件后，将相应事件写入到输入设备节点 输入系统取出内核事件，封装成为KeyEvent或MotionEvent 交付给对应的Window消费该事件。     硬件中断 物理设备将数据发送给内核是通过设备驱动传输的，在dev&#x2F;input&#x2F;目录下有几个设备文件eventX。 其中event0对应的就是触摸屏，当触摸屏的驱动被挂载后，驱动程序就会">
<meta property="og:type" content="article">
<meta property="og:title" content="Android-事件分发机制">
<meta property="og:url" content="https://leo-wxy.github.io/2020/11/20/Android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="当用户触摸屏幕或者按键操作。  首先触发硬件驱动，驱动收到事件后，将相应事件写入到输入设备节点 输入系统取出内核事件，封装成为KeyEvent或MotionEvent 交付给对应的Window消费该事件。     硬件中断 物理设备将数据发送给内核是通过设备驱动传输的，在dev&#x2F;input&#x2F;目录下有几个设备文件eventX。 其中event0对应的就是触摸屏，当触摸屏的驱动被挂载后，驱动程序就会">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leo-wxy.github.io/images/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6xmind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E7%9C%9F%C2%B7%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E5%90%AF%E5%8A%A8IMS.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/IMS-EventHub.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/IMS-InputManager.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/IMS-start.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/IMS%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/event1_4.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/InputReaderThread.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/EventHub-getEvents.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/InputReaderThread-processEventsLocked.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/InputMapper%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/InputReaderThread-%E5%88%86%E5%8F%91%E4%BA%8B%E4%BB%B6.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/v2-196591e61a6bed7189d68d7a72a07f4a_1440w.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/InputReaderThread.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/InputDispatcherThread.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/InputDispatcher-dispatchOnceInnerLocked.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/event1_5.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/InputDispatcherThread.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%8F%91%E9%80%81%E8%87%B3Activity.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-InputChannel.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/InputChannel%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-InputChannel%E6%B3%A8%E5%86%8C.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/InputChannel%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/v2-1e1273f15cfdd7b81aa7a2cb819d8890_1440w.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E5%9B%9E%E8%B0%83%E5%88%B0Activity.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9C%9F%E5%AE%9E%E9%A1%BA%E5%BA%8F.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/MotionEvent.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E9%A1%BA%E5%BA%8F.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/MotionEvent%E4%BA%A7%E7%94%9F%E6%97%B6%E6%9C%BA.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E9%A1%BA%E5%BA%8F.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/Activity-Dispatch.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-ViewGroup.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/ViewGroup-Dispatch.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-View.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View-Dispatch.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/TouchEvent-Transmit.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5.png">
<meta property="article:published_time" content="2020-11-20T02:29:32.000Z">
<meta property="article:modified_time" content="2020-12-31T01:09:39.000Z">
<meta property="article:author" content="Leo-Wxy">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://leo-wxy.github.io/images/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6xmind.png">
  
  
  
  <title>Android-事件分发机制 - Wxy的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":false};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Android-事件分发机制</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-11-20 10:29" pubdate>
          2020年11月20日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          32 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Android-事件分发机制</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>当用户触摸屏幕或者按键操作。</p>
<ol>
<li>首先触发硬件驱动，驱动收到事件后，将相应事件写入到输入设备节点</li>
<li>输入系统取出内核事件，封装成为KeyEvent或MotionEvent</li>
<li>交付给对应的Window消费该事件。</li>
</ol>
</blockquote>
<p><img src="/images/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6xmind.png" srcset="/img/loading.gif" lazyload alt="事件分发机制xmind"></p>
<p><img src="/images/%E7%9C%9F%C2%B7%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91" srcset="/img/loading.gif" lazyload alt="input"></p>
<h2 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h2><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD.png" srcset="/img/loading.gif" lazyload alt="硬件中断"></p>
<p>物理设备将数据发送给内核是通过<code>设备驱动</code>传输的，在<code>dev/input/</code>目录下有几个设备文件<code>eventX</code>。</p>
<p>其中<code>event0</code>对应的就是触摸屏，当触摸屏的驱动被挂载后，驱动程序就会进行初始化。</p>
<p>当触发对应的硬件中断后，就会调用对应的处理方法，把对应事件写到<code>设备节点(/dev/input/event0)</code>中.</p>
<p><img src="/images/%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="IMS获取内核事件"><a href="#IMS获取内核事件" class="headerlink" title="IMS获取内核事件"></a>IMS获取内核事件</h2><h3 id="IMS启动过程"><a href="#IMS启动过程" class="headerlink" title="IMS启动过程"></a>IMS启动过程</h3><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E5%90%AF%E5%8A%A8IMS.png" srcset="/img/loading.gif" lazyload alt="启动IMS"></p>
<p>在<a href="/2020/11/12/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" title="Android系统启动过程">Android系统启动过程</a>有介绍系统的启动流程，其中<code>IMS</code>属于<code>system_server</code>，随着<code>system_server</code>的启动而启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SystemServer.java</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startOtherServices</span><span class="hljs-params">()</span> &#123;<br>      ...<br>        <span class="hljs-type">InputManagerService</span> <span class="hljs-variable">inputManager</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      ...<br>            traceBeginAndSlog(<span class="hljs-string">&quot;StartInputManagerService&quot;</span>);<br>      <span class="hljs-comment">//新建IMS对象</span><br>            inputManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputManagerService</span>(context);<br>            traceEnd();        <br>      <br>      <span class="hljs-comment">//启动IMS</span><br>            traceBeginAndSlog(<span class="hljs-string">&quot;StartInputManager&quot;</span>);<br>            inputManager.setWindowManagerCallbacks(wm.getInputMonitor());<span class="hljs-comment">//与window进行绑定</span><br>            inputManager.start();<br>            traceEnd();      <br>      <br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//InputManagerService.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InputManagerService</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mContext = context;<br>        <span class="hljs-built_in">this</span>.mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputManagerHandler</span>(DisplayThread.get().getLooper());<br>      ...<br>        <span class="hljs-comment">//初始化Native对象</span><br>        mPtr = nativeInit(<span class="hljs-built_in">this</span>, mContext, mHandler.getLooper().getQueue());<br><br>        LocalServices.addService(InputManagerInternal.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalService</span>());<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>nativeInit()</code>执行在Native层</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//services/core/jni/com_android_server_input_InputManagerService.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> jlong <span class="hljs-title">nativeInit</span><span class="hljs-params">(JNIEnv* env, jclass <span class="hljs-comment">/* clazz */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;<br>  <span class="hljs-comment">//获取Native的消息队列</span><br>    sp&lt;MessageQueue&gt; messageQueue = <span class="hljs-built_in">android_os_MessageQueue_getMessageQueue</span>(env, messageQueueObj);<br>  ...<br>    <span class="hljs-comment">//创建Native的 InputManager对象</span><br>    NativeInputManager* im = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NativeInputManager</span>(contextObj, serviceObj,<br>            messageQueue-&gt;<span class="hljs-built_in">getLooper</span>());<br>    <span class="hljs-comment">//增加强引用</span><br>    im-&gt;<span class="hljs-built_in">incStrong</span>(<span class="hljs-number">0</span>);<br>   <span class="hljs-comment">//返回 NativeInputManager的指针</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;jlong&gt;(im);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//services/core/jni/com_android_server_input_InputManagerService.cpp</span><br>NativeInputManager::NativeInputManager(jobject contextObj,<br>        jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) :<br>        mLooper(looper), mInteractive(<span class="hljs-literal">true</span>) &#123;<br>    JNIEnv* env = jniEnv();<br><br>    mContextObj = env-&gt;NewGlobalRef(contextObj);<br>    mServiceObj = env-&gt;NewGlobalRef(serviceObj);<span class="hljs-comment">//IMS对象</span><br><br>    &#123;<br>        AutoMutex <span class="hljs-title function_">_l</span><span class="hljs-params">(mLock)</span>;<br>        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;<br>        mLocked.pointerSpeed = <span class="hljs-number">0</span>;<br>        mLocked.pointerGesturesEnabled = <span class="hljs-literal">true</span>;<br>        mLocked.showTouches = <span class="hljs-literal">false</span>;<br>        mLocked.pointerCapture = <span class="hljs-literal">false</span>;<br>    &#125;<br>    mInteractive = <span class="hljs-literal">true</span>;<br>   <span class="hljs-comment">//初始EventHub对象</span><br>    sp&lt;EventHub&gt; eventHub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventHub</span>();<br>   <span class="hljs-comment">//初始InputManager对象</span><br>    mInputManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputManager</span>(eventHub, <span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="初始EventHub"><a href="#初始EventHub" class="headerlink" title="初始EventHub"></a>初始EventHub</h4><p><img src="/images/IMS-EventHub.png" srcset="/img/loading.gif" lazyload alt="EventHub"></p>
<p><code>EventHub</code>主要用于<strong>监控设备节点是否更新</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/EventHub.cpp</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *WAKE_LOCK_ID = <span class="hljs-string">&quot;KeyEvents&quot;</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *DEVICE_PATH = <span class="hljs-string">&quot;/dev/input&quot;</span>;<span class="hljs-comment">//设备文件</span><br><br>EventHub::<span class="hljs-built_in">EventHub</span>(<span class="hljs-type">void</span>) :<br>        <span class="hljs-built_in">mBuiltInKeyboardId</span>(NO_BUILT_IN_KEYBOARD), <span class="hljs-built_in">mNextDeviceId</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">mControllerNumbers</span>(),<br>        <span class="hljs-built_in">mOpeningDevices</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">mClosingDevices</span>(<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">mNeedToSendFinishedDeviceScan</span>(<span class="hljs-literal">false</span>),<br>        <span class="hljs-built_in">mNeedToReopenDevices</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">mNeedToScanDevices</span>(<span class="hljs-literal">true</span>),<br>        <span class="hljs-built_in">mPendingEventCount</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">mPendingEventIndex</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">mPendingINotify</span>(<span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-built_in">acquire_wake_lock</span>(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);<br><span class="hljs-comment">//创建epoll实例</span><br>    mEpollFd = <span class="hljs-built_in">epoll_create</span>(EPOLL_SIZE_HINT);<br><br><span class="hljs-comment">//创建iNotify实例</span><br>    mINotifyFd = <span class="hljs-built_in">inotify_init</span>();<br><span class="hljs-comment">//iNotify实例 监听 DEVICE_PATH </span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">inotify_add_watch</span>(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);<br>          <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> eventItem;<br>    <span class="hljs-built_in">memset</span>(&amp;eventItem, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(eventItem));<br>    eventItem.events = EPOLLIN;<br>    eventItem.data.u32 = EPOLL_ID_INOTIFY;<br><span class="hljs-comment">//epoll 监听 iNotify实例</span><br>    result = <span class="hljs-built_in">epoll_ctl</span>(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);<br><br>    <span class="hljs-type">int</span> wakeFds[<span class="hljs-number">2</span>];<br>    result = <span class="hljs-built_in">pipe</span>(wakeFds);<span class="hljs-comment">//创造管道</span><br><br>    mWakeReadPipeFd = wakeFds[<span class="hljs-number">0</span>];<br>    mWakeWritePipeFd = wakeFds[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//切换非阻塞方式进行读写</span><br>    result = <span class="hljs-built_in">fcntl</span>(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);<br>    result = <span class="hljs-built_in">fcntl</span>(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);<br><br>    eventItem.data.u32 = EPOLL_ID_WAKE;<br><span class="hljs-comment">//epoll监听 管道实例</span><br>    result = <span class="hljs-built_in">epoll_ctl</span>(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);<br><br>    <span class="hljs-type">int</span> major, minor;<br>    <span class="hljs-built_in">getLinuxRelease</span>(&amp;major, &amp;minor);<br>    <span class="hljs-comment">// EPOLLWAKEUP was introduced in kernel 3.5</span><br>    mUsingEpollWakeup = major &gt; <span class="hljs-number">3</span> || (major == <span class="hljs-number">3</span> &amp;&amp; minor &gt;= <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>EventHub</code>主要执行了以下几步：</p>
<ol>
<li>初始化<code>epoll</code>实例</li>
<li>初始化<code>iNotify</code>实例，用于监控<code>/dev/input</code>目录的变化。若发生变化，意味设备发生变化，需要处理。<code>epoll</code>添加<code>iNotify实例</code>监听</li>
<li>创建非阻塞模式的管道(<code>pipe</code>)，epoll监听管道的内容。(主要用于 唤醒InputReader线程)</li>
</ol>
<h4 id="初始InputManager"><a href="#初始InputManager" class="headerlink" title="初始InputManager"></a>初始InputManager</h4><p><img src="/images/IMS-InputManager.png" srcset="/img/loading.gif" lazyload alt="InputManager"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputManager.cpp</span><br>InputManager::<span class="hljs-built_in">InputManager</span>(<br>        <span class="hljs-type">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,<br>        <span class="hljs-type">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,<br>        <span class="hljs-type">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;<br>    mDispatcher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InputDispatcher</span>(dispatcherPolicy);<br>    mReader = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InputReader</span>(eventHub, readerPolicy, mDispatcher);<br>    <span class="hljs-built_in">initialize</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="InputDispatcher"><a href="#InputDispatcher" class="headerlink" title="InputDispatcher"></a>InputDispatcher</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputDispatcher.cpp</span><br>InputDispatcher::<span class="hljs-built_in">InputDispatcher</span>(<span class="hljs-type">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :<br>    <span class="hljs-built_in">mPolicy</span>(policy),<br>    <span class="hljs-built_in">mPendingEvent</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">mLastDropReason</span>(DROP_REASON_NOT_DROPPED),<br>    <span class="hljs-built_in">mAppSwitchSawKeyDown</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">mAppSwitchDueTime</span>(LONG_LONG_MAX),<br>    <span class="hljs-built_in">mNextUnblockedEvent</span>(<span class="hljs-literal">NULL</span>),<br>    <span class="hljs-built_in">mDispatchEnabled</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">mDispatchFrozen</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">mInputFilterEnabled</span>(<span class="hljs-literal">false</span>),<br>    <span class="hljs-built_in">mInputTargetWaitCause</span>(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;<br>    <span class="hljs-comment">//新建Looper对象</span><br>    mLooper = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Looper</span>(<span class="hljs-literal">false</span>);<br><br>    mKeyRepeatState.lastKeyEntry = <span class="hljs-literal">NULL</span>;<br><br>    policy-&gt;<span class="hljs-built_in">getDispatcherConfiguration</span>(&amp;mConfig);<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputReader.cpp</span><br>InputReader::<span class="hljs-built_in">InputReader</span>(<span class="hljs-type">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,<br>        <span class="hljs-type">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,<br>        <span class="hljs-type">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :<br>        <span class="hljs-built_in">mContext</span>(<span class="hljs-keyword">this</span>), <span class="hljs-built_in">mEventHub</span>(eventHub), <span class="hljs-built_in">mPolicy</span>(policy),<br>        <span class="hljs-built_in">mGlobalMetaState</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">mGeneration</span>(<span class="hljs-number">1</span>),<br>        <span class="hljs-built_in">mDisableVirtualKeysTimeout</span>(LLONG_MIN), <span class="hljs-built_in">mNextTimeout</span>(LLONG_MAX),<br>        <span class="hljs-built_in">mConfigurationChangesToRefresh</span>(<span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//listener 对象 就是 InputDispatcher</span><br>    mQueuedListener = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueuedInputListener</span>(listener);<br><br>    &#123; <span class="hljs-comment">// acquire lock</span><br>        AutoMutex _l(mLock);<br><br>        <span class="hljs-built_in">refreshConfigurationLocked</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">updateGlobalMetaStateLocked</span>();<br>    &#125; <span class="hljs-comment">// release lock</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>负责监听<code>InputDispatcher</code>对象</p>
<h5 id="initalize"><a href="#initalize" class="headerlink" title="initalize()"></a>initalize()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputManager.cpp</span><br><span class="hljs-keyword">void</span> InputManager::initialize() &#123;<br>    mReaderThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputReaderThread</span>(mReader);<br>    mDispatcherThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputDispatcherThread</span>(mDispatcher);<br>&#125;<br><br><span class="hljs-comment">//frameworks/native/services/inputflinger/InputDispatcher.cpp</span><br>InputDispatcherThread::InputDispatcherThread(const sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) :<br>        Thread(<span class="hljs-comment">/*canCallJava*/</span> <span class="hljs-literal">true</span>), mDispatcher(dispatcher) &#123;<br>&#125;<br><br><span class="hljs-comment">//frameworks/native/services/inputflinger/InputReader.cpp</span><br>InputReaderThread::InputReaderThread(const sp&lt;InputReaderInterface&gt;&amp; reader) :<br>        Thread(<span class="hljs-comment">/*canCallJava*/</span> <span class="hljs-literal">true</span>), mReader(reader) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>initalize()</code>主要是创建两个能访问Java代码的native线程。</p>
<blockquote>
<p>1.The InputReaderThread (called “InputReader”) reads and preprocesses raw input events,applies policy, and posts messages to a queue managed by the DispatcherThread.</p>
<p>2.The InputDispatcherThread (called “InputDispatcher”) thread waits for new events on the queue and asynchronously dispatches them to applications.</p>
</blockquote>
<h4 id="IMS启动——start"><a href="#IMS启动——start" class="headerlink" title="IMS启动——start()"></a>IMS启动——start()</h4><p><img src="/images/IMS-start.png" srcset="/img/loading.gif" lazyload alt="IMS启动"></p>
<p><code>IMS</code>初始化完毕就准备启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//InputManagerService.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        Slog.i(TAG, <span class="hljs-string">&quot;Starting input manager&quot;</span>);<br>        nativeStart(mPtr);<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//services/core/jni/com_android_server_input_InputManagerService.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">nativeStart</span><span class="hljs-params">(JNIEnv* env, jclass <span class="hljs-comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;<br>    NativeInputManager* im = <span class="hljs-built_in">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);<br><br>    <span class="hljs-type">status_t</span> result = im-&gt;<span class="hljs-built_in">getInputManager</span>()-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputManager.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">InputManager::start</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//启动InputDispatcherThread</span><br>    <span class="hljs-type">status_t</span> result = mDispatcherThread-&gt;<span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;InputDispatcher&quot;</span>, PRIORITY_URGENT_DISPLAY)<br>  <span class="hljs-comment">//启动InputReaderThread</span><br>    result = mReaderThread-&gt;<span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;InputReader&quot;</span>, PRIORITY_URGENT_DISPLAY);<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>IMS</code>启动，会带着<code>InputDispatcherThread</code>和<code>InputReaderThread</code>一起启动。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/IMS%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt="IMS结构体系"></p>
<p>IMS启动过程重点在于Native的初始化，分别创建以下对象：</p>
<ul>
<li><p><strong>EventHub</strong></p>
<p>监听并记录<code>/dev/input</code>的变化</p>
</li>
<li><p><strong>InputManager</strong></p>
<p>创建<code>InputReader</code>和<code>InputDispatcher</code>对象</p>
</li>
</ul>
<p>初始化完毕上述对象后，然后启动以下线程：</p>
<ul>
<li><strong>InputReaderThread</strong>：从<code>EventHub</code>取出事件并处理，再转发给<code>InputDispatcher</code></li>
<li><strong>InputDispatcherThread</strong>：接收来自<code>InputReader</code>的事件，并派发事件到合适的窗口(window)去处理</li>
</ul>
<p><img src="/images/event1_4.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="内核事件转发APP进程过程"><a href="#内核事件转发APP进程过程" class="headerlink" title="内核事件转发APP进程过程"></a>内核事件转发APP进程过程</h3><p><code>IMS</code>启动之后，<code>InputDispatcherThread</code>与<code>InputReaderThread</code>随之启动。</p>
<h4 id="InputReaderThread"><a href="#InputReaderThread" class="headerlink" title="InputReaderThread"></a>InputReaderThread</h4><p><img src="/images/InputReaderThread.png" srcset="/img/loading.gif" lazyload alt="InputReaderThread"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputReader.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InputReaderThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    mReader-&gt;<span class="hljs-built_in">loopOnce</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputReader::loopOnce</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>    <span class="hljs-comment">//从EventHub获取事件列表，返回的是 事件的个数。无事件时将阻塞 </span><br>    <span class="hljs-type">size_t</span> count = mEventHub-&gt;<span class="hljs-built_in">getEvents</span>(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);<br><br>    &#123; <span class="hljs-comment">// acquire lock</span><br>        AutoMutex _l(mLock);<br>        mReaderIsAliveCondition.<span class="hljs-built_in">broadcast</span>();<br><br>        <span class="hljs-keyword">if</span> (count) &#123;<br>          <span class="hljs-comment">//处理获取的事件</span><br>            <span class="hljs-built_in">processEventsLocked</span>(mEventBuffer, count);<br>        &#125;<br><br>    &#125; <span class="hljs-comment">// release lock</span><br>    ...<br>   <span class="hljs-comment">//处理完毕后发送到 InputDispatcher</span><br>    mQueuedListener-&gt;<span class="hljs-built_in">flush</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="EventHub-getEvents-获取事件"><a href="#EventHub-getEvents-获取事件" class="headerlink" title="EventHub-&gt;getEvents() 获取事件"></a>EventHub-&gt;getEvents() 获取事件</h5><p><img src="/images/EventHub-getEvents.png" srcset="/img/loading.gif" lazyload alt="EventHub-getEvents"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/EventHub.cpp</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">EventHub::getEvents</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis, RawEvent* buffer, <span class="hljs-type">size_t</span> bufferSize)</span> </span>&#123;<br>  <span class="hljs-comment">//原始事件构造</span><br>    RawEvent* event = buffer;<br>    <span class="hljs-type">size_t</span> capacity = bufferSize;  <br>  <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//开启循环</span><br>    ...<br>        <span class="hljs-keyword">if</span> (mNeedToScanDevices) &#123;<br>            mNeedToScanDevices = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">scanDevicesLocked</span>();<span class="hljs-comment">//开始扫描设备</span><br>            mNeedToSendFinishedDeviceScan = <span class="hljs-literal">true</span>;<br>        &#125;    <br>    ...<br>        <span class="hljs-keyword">while</span> (mOpeningDevices != <span class="hljs-literal">NULL</span>) &#123;<br>            Device* device = mOpeningDevices;<br>            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Reporting device opened: id=%d, name=%s\n&quot;</span>,<br>                 device-&gt;id, device-&gt;path.<span class="hljs-built_in">string</span>());<br>            mOpeningDevices = device-&gt;next;<br>            event-&gt;when = now;<br>            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="hljs-number">0</span> : device-&gt;id;<br>            event-&gt;type = DEVICE_ADDED;<span class="hljs-comment">//添加设备</span><br>            event += <span class="hljs-number">1</span>;<br>            mNeedToSendFinishedDeviceScan = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (--capacity == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;      <br>    ...<br>        <span class="hljs-keyword">while</span> (mPendingEventIndex &lt; mPendingEventCount) &#123;<br>          ...<br>            <span class="hljs-type">ssize_t</span> deviceIndex = mDevices.<span class="hljs-built_in">indexOfKey</span>(eventItem.data.u32);          <br>          ...<br>            Device* device = mDevices.<span class="hljs-built_in">valueAt</span>(deviceIndex);<br>            <span class="hljs-keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;<br>             ...<br>                    <span class="hljs-type">int32_t</span> deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="hljs-number">0</span> : device-&gt;id;<br><br>                    <span class="hljs-type">size_t</span> count = <span class="hljs-built_in">size_t</span>(readSize) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> input_event);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                      <span class="hljs-comment">//获取readBuffer的数据</span><br>                        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">input_event</span>&amp; iev = readBuffer[i];<br>                      <span class="hljs-comment">//封装成RawEvent对象</span><br>                        event-&gt;deviceId = deviceId;<br>                        event-&gt;type = iev.type;<br>                        event-&gt;code = iev.code;<br>                        event-&gt;value = iev.value;<br>                        event += <span class="hljs-number">1</span>;<br>                        capacity -= <span class="hljs-number">1</span>;                      <br>                      <br>                    &#125;<br>            &#125;<br>        &#125;<br>          ...<br>            <span class="hljs-comment">//等待input事件</span><br>           <span class="hljs-type">int</span> pollResult = <span class="hljs-built_in">epoll_wait</span>(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);<br>    <br>    ...<br>        <span class="hljs-comment">// readNotify() will modify the list of devices so this must be done after</span><br>        <span class="hljs-comment">// processing all other events to ensure that we read all remaining events</span><br>        <span class="hljs-comment">// before closing the devices.</span><br>        <span class="hljs-keyword">if</span> (mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123;<br>            mPendingINotify = <span class="hljs-literal">false</span>;<br>          <span class="hljs-comment">//从INotify事件 读取发生的事件</span><br>            <span class="hljs-built_in">readNotifyLocked</span>();<br>            deviceChanged = <span class="hljs-literal">true</span>;<br>        &#125;<br>  &#125;<br>  ...<br>      <span class="hljs-comment">// 返回读取的事件个数</span><br>    <span class="hljs-keyword">return</span> event - buffer;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>getEvents()</code>采用<code>INotify + epoll</code>监听<code>/dev/input/</code>目录下的设备节点，再转换<code>deviceId + input_event</code>为<code>RawEvent</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// frameworks/native/services/inputflinger/EventHub.h</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RawEvent</span> &#123;<br>    <span class="hljs-type">nsecs_t</span> when;<span class="hljs-comment">//事件发生的时间点</span><br>    <span class="hljs-type">int32_t</span> deviceId;<span class="hljs-comment">//设备id</span><br>    <span class="hljs-type">int32_t</span> type;<span class="hljs-comment">//事件类型</span><br>    <span class="hljs-type">int32_t</span> code;<br>    <span class="hljs-type">int32_t</span> value;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>type</code>可以为以下几种</p>
<ul>
<li><code>DEVICE_ADDED</code>：添加设备</li>
<li><code>DEVICE_REMOVED</code>：移除设备</li>
<li><code>FINISHED_DEVICE_SCAN</code>：扫描完成</li>
<li><code>type &lt; FIRST_SYNTHETIC_EVENT</code>：其他事件</li>
</ul>
<p><code>getEvents()</code>大概执行流程：</p>
<p>当<code>设备节点(/dev/input)</code>发生变化时，<code>epoll_wait()</code>会响应到对应的变化，然后<code>getEvents()</code>可以知道对应的变化。继续从<code>mINotifyFd</code>读取<code>iNotify事件</code>，进行输入设备的操作，最后生成相应的<code>RawEvent</code></p>
<blockquote>
<p>此时，EventHub从设备节点获取到了事件，并转化为<code>RawEvent</code>向下处理。</p>
</blockquote>
<h5 id="processEventsLocked-处理事件"><a href="#processEventsLocked-处理事件" class="headerlink" title="processEventsLocked() 处理事件"></a>processEventsLocked() 处理事件</h5><p><img src="/images/InputReaderThread-processEventsLocked.png" srcset="/img/loading.gif" lazyload alt="InputReaderThread-processEventsLocked"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputReader::processEventsLocked</span><span class="hljs-params">(<span class="hljs-type">const</span> RawEvent* rawEvents, <span class="hljs-type">size_t</span> count)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> RawEvent* rawEvent = rawEvents; count;) &#123;<br>        <span class="hljs-type">int32_t</span> type = rawEvent-&gt;type;<br>        <span class="hljs-type">size_t</span> batchSize = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;<br>            <span class="hljs-type">int32_t</span> deviceId = rawEvent-&gt;deviceId;<br>            <span class="hljs-keyword">while</span> (batchSize &lt; count) &#123;<br>                <span class="hljs-keyword">if</span> (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT<br>                        || rawEvent[batchSize].deviceId != deviceId) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                batchSize += <span class="hljs-number">1</span>;<br>            &#125;<br>          <span class="hljs-comment">//处理其他事件的数据</span><br>            <span class="hljs-built_in">processEventsForDeviceLocked</span>(deviceId, rawEvent, batchSize);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">switch</span> (rawEvent-&gt;type) &#123;<br>            <span class="hljs-keyword">case</span> EventHubInterface::DEVICE_ADDED:<br>                <span class="hljs-comment">//设备增加</span><br>                <span class="hljs-built_in">addDeviceLocked</span>(rawEvent-&gt;when, rawEvent-&gt;deviceId);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> EventHubInterface::DEVICE_REMOVED:<br>                <span class="hljs-comment">//设备移除</span><br>                <span class="hljs-built_in">removeDeviceLocked</span>(rawEvent-&gt;when, rawEvent-&gt;deviceId);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> EventHubInterface::FINISHED_DEVICE_SCAN:<br>                <span class="hljs-comment">//设备扫描完成</span><br>                <span class="hljs-built_in">handleConfigurationChangedLocked</span>(rawEvent-&gt;when);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">ALOG_ASSERT</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// can&#x27;t happen</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        count -= batchSize;<br>        rawEvent += batchSize;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h6 id="addDeviceLocked-添加设备"><a href="#addDeviceLocked-添加设备" class="headerlink" title="addDeviceLocked() 添加设备"></a>addDeviceLocked() 添加设备</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputReader::addDeviceLocked</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> when, <span class="hljs-type">int32_t</span> deviceId)</span> </span>&#123;<br>    <span class="hljs-type">ssize_t</span> deviceIndex = mDevices.<span class="hljs-built_in">indexOfKey</span>(deviceId);<br><br>  <span class="hljs-comment">//根据deviceId 创建设备</span><br>    InputDevice* device = <span class="hljs-built_in">createDeviceLocked</span>(deviceId, controllerNumber, identifier, classes);<br>    device-&gt;<span class="hljs-built_in">configure</span>(when, &amp;mConfig, <span class="hljs-number">0</span>);<br>    device-&gt;<span class="hljs-built_in">reset</span>(when);<br><br>  <span class="hljs-comment">//添加设备</span><br>    mDevices.<span class="hljs-built_in">add</span>(deviceId, device);<br>    <span class="hljs-built_in">bumpGenerationLocked</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">InputDevice* <span class="hljs-title">InputReader::createDeviceLocked</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> deviceId, <span class="hljs-type">int32_t</span> controllerNumber,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> InputDeviceIdentifier&amp; identifier, <span class="hljs-type">uint32_t</span> classes)</span> </span>&#123;<br>    InputDevice* device = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InputDevice</span>(&amp;mContext, deviceId, <span class="hljs-built_in">bumpGenerationLocked</span>(),<br>            controllerNumber, identifier, classes);<br>...<br>    <span class="hljs-comment">// Keyboard-like devices.  </span><br>    <span class="hljs-keyword">if</span> (keyboardSource != <span class="hljs-number">0</span>) &#123;<br>        device-&gt;<span class="hljs-built_in">addMapper</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">KeyboardInputMapper</span>(device, keyboardSource, keyboardType));<br>    &#125;<br><br>    <span class="hljs-comment">// Cursor-like devices.</span><br>    <span class="hljs-keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_CURSOR) &#123;<br>        device-&gt;<span class="hljs-built_in">addMapper</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CursorInputMapper</span>(device));<br>    &#125;<br><br>    <span class="hljs-comment">// Touchscreens and touchpad devices.</span><br>    <span class="hljs-keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_TOUCH_MT) &#123;<br>        device-&gt;<span class="hljs-built_in">addMapper</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MultiTouchInputMapper</span>(device));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (classes &amp; INPUT_DEVICE_CLASS_TOUCH) &#123;<br>        device-&gt;<span class="hljs-built_in">addMapper</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SingleTouchInputMapper</span>(device));<br>    &#125;<br>...<br><br>    <span class="hljs-keyword">return</span> device;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>addDeviceLocked()</code>主要创建<code>InputDevice</code>，并且根据不同的设备类型来创建相应的<code>InputMapper</code>。</p>
<p>根据上述代码列举对应关系：</p>
<ul>
<li><code>Keyboard-like</code>：键盘类设备 –&gt; KeyboardInputMapper</li>
<li><code>Cursor-like</code>：鼠标类设备 –&gt; CursorInputMapper</li>
<li><code>TouchScreens</code>：触摸屏设备 –&gt; MultiTouchInputMapper(多点触控) &#x2F; SingleTouchInputMapper(单点触控)</li>
</ul>
<p><img src="/images/InputMapper%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt="InputMapper对应关系"></p>
<h6 id="processEventsForDeviceLocked-处理设备事件"><a href="#processEventsForDeviceLocked-处理设备事件" class="headerlink" title="processEventsForDeviceLocked() 处理设备事件"></a>processEventsForDeviceLocked() 处理设备事件</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputReader::processEventsForDeviceLocked</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> deviceId,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> RawEvent* rawEvents, <span class="hljs-type">size_t</span> count)</span> </span>&#123;<br>    <span class="hljs-type">ssize_t</span> deviceIndex = mDevices.<span class="hljs-built_in">indexOfKey</span>(deviceId);<br><span class="hljs-comment">//获取输入设备</span><br>    InputDevice* device = mDevices.<span class="hljs-built_in">valueAt</span>(deviceIndex);<br><br>    device-&gt;<span class="hljs-built_in">process</span>(rawEvents, count);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputReader.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDevice::process</span><span class="hljs-params">(<span class="hljs-type">const</span> RawEvent* rawEvents, <span class="hljs-type">size_t</span> count)</span> </span>&#123;<br><br>    <span class="hljs-type">size_t</span> numMappers = mMappers.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> RawEvent* rawEvent = rawEvents; count != <span class="hljs-number">0</span>; rawEvent++) &#123;<br><br>        <span class="hljs-keyword">if</span> (mDropUntilNextSync) &#123;<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numMappers; i++) &#123;<br>                InputMapper* mapper = mMappers[i];<br>              <span class="hljs-comment">//获取mapper继续执行process任务</span><br>                mapper-&gt;<span class="hljs-built_in">process</span>(rawEvent);<br>            &#125;<br>        &#125;<br>        --count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以触摸屏为例，<code>mapper</code>指向<code>MultiTouchInputMapper</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MultiTouchInputMapper::process</span><span class="hljs-params">(<span class="hljs-type">const</span> RawEvent* rawEvent)</span> </span>&#123;<br>    TouchInputMapper::<span class="hljs-built_in">process</span>(rawEvent);<br><br>    mMultiTouchMotionAccumulator.<span class="hljs-built_in">process</span>(rawEvent);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TouchInputMapper::process</span><span class="hljs-params">(<span class="hljs-type">const</span> RawEvent* rawEvent)</span> </span>&#123;<br>    mCursorButtonAccumulator.<span class="hljs-built_in">process</span>(rawEvent);<br>    mCursorScrollAccumulator.<span class="hljs-built_in">process</span>(rawEvent);<br>    mTouchButtonAccumulator.<span class="hljs-built_in">process</span>(rawEvent);<br><br>    <span class="hljs-keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;<br>        <span class="hljs-built_in">sync</span>(rawEvent-&gt;when);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TouchInputMapper::dispatchPointerSimple</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> when, <span class="hljs-type">uint32_t</span> policyFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">bool</span> down, <span class="hljs-type">bool</span> hovering)</span> </span>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (mPointerSimple.down &amp;&amp; !down) &#123;<br>        mPointerSimple.down = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// Send up.</span><br>        <span class="hljs-function">NotifyMotionArgs <span class="hljs-title">args</span><span class="hljs-params">(when, getDeviceId(), mSource, policyFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">                 AMOTION_EVENT_ACTION_UP, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, metaState, mLastRawState.buttonState, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 mViewport.displayId, <span class="hljs-comment">/* deviceTimestamp */</span> <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-number">1</span>, &amp;mPointerSimple.lastProperties, &amp;mPointerSimple.lastCoords,</span></span><br><span class="hljs-params"><span class="hljs-function">                 mOrientedXPrecision, mOrientedYPrecision,</span></span><br><span class="hljs-params"><span class="hljs-function">                 mPointerSimple.downTime)</span></span>;<br>        <span class="hljs-built_in">getListener</span>()-&gt;<span class="hljs-built_in">notifyMotion</span>(&amp;args);<br>    &#125;<br>  <br>    <span class="hljs-keyword">if</span> (down) &#123;<br>        <span class="hljs-keyword">if</span> (!mPointerSimple.down) &#123;<br>            mPointerSimple.down = <span class="hljs-literal">true</span>;<br>            mPointerSimple.downTime = when;<br><br>            <span class="hljs-comment">// Send down.</span><br>            <span class="hljs-function">NotifyMotionArgs <span class="hljs-title">args</span><span class="hljs-params">(when, getDeviceId(), mSource, policyFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">                    AMOTION_EVENT_ACTION_DOWN, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, metaState, mCurrentRawState.buttonState, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                    mViewport.displayId, <span class="hljs-comment">/* deviceTimestamp */</span> <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-number">1</span>, &amp;mPointerSimple.currentProperties, &amp;mPointerSimple.currentCoords,</span></span><br><span class="hljs-params"><span class="hljs-function">                    mOrientedXPrecision, mOrientedYPrecision,</span></span><br><span class="hljs-params"><span class="hljs-function">                    mPointerSimple.downTime)</span></span>;<br>            <span class="hljs-built_in">getListener</span>()-&gt;<span class="hljs-built_in">notifyMotion</span>(&amp;args);<br>        &#125;<br><br>        <span class="hljs-comment">// Send move.</span><br>        <span class="hljs-function">NotifyMotionArgs <span class="hljs-title">args</span><span class="hljs-params">(when, getDeviceId(), mSource, policyFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">                AMOTION_EVENT_ACTION_MOVE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, metaState, mCurrentRawState.buttonState, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                mViewport.displayId, <span class="hljs-comment">/* deviceTimestamp */</span> <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-number">1</span>, &amp;mPointerSimple.currentProperties, &amp;mPointerSimple.currentCoords,</span></span><br><span class="hljs-params"><span class="hljs-function">                mOrientedXPrecision, mOrientedYPrecision,</span></span><br><span class="hljs-params"><span class="hljs-function">                mPointerSimple.downTime)</span></span>;<br>        <span class="hljs-built_in">getListener</span>()-&gt;<span class="hljs-built_in">notifyMotion</span>(&amp;args);<br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>getListener()</code>指的就是<code>mQueuedListener</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputListener.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QueuedInputListener::notifyMotion</span><span class="hljs-params">(<span class="hljs-type">const</span> NotifyMotionArgs* args)</span> </span>&#123;<br>    mArgsQueue.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">NotifyMotionArgs</span>(*args));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将触摸事件放入<code>mArgsQueue</code>，此时事件加工完成。</p>
<h5 id="QueuedInputListener-flush-发送事件"><a href="#QueuedInputListener-flush-发送事件" class="headerlink" title="QueuedInputListener.flush() 发送事件"></a>QueuedInputListener.flush() 发送事件</h5><p><img src="/images/InputReaderThread-%E5%88%86%E5%8F%91%E4%BA%8B%E4%BB%B6.png" srcset="/img/loading.gif" lazyload alt="InputReaderThread-分发事件"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputListener.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QueuedInputListener::flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> count = mArgsQueue.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        NotifyArgs* args = mArgsQueue[i];<br>        args-&gt;<span class="hljs-built_in">notify</span>(mInnerListener);<br>        <span class="hljs-keyword">delete</span> args;<br>    &#125;<br>    mArgsQueue.<span class="hljs-built_in">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>NotifyArgs</code>主要有以下几类：</p>
<ul>
<li>NotifyConfigurationChangedArgs：配置变化</li>
<li>NotifyKeyArgs：键盘事件</li>
<li>NotifyMotionArgs：触摸事件</li>
<li>NotifySwitchArgs：切换事件</li>
<li>NotifyDeviceResetArgs：设备重置事件</li>
</ul>
<p>根据上节可知<code>args</code>为<code>NotifyMotionArgs</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NotifyMotionArgs::notify</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;InputListenerInterface&gt;&amp; listener)</span> <span class="hljs-type">const</span> </span>&#123;<br>    listener-&gt;<span class="hljs-built_in">notifyMotion</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>listener</code>指的就是<code>InputDispatcher</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputDispatcher.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::notifyMotion</span><span class="hljs-params">(<span class="hljs-type">const</span> NotifyMotionArgs* args)</span> </span>&#123;<br>...<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">validateMotionEvent</span>(args-&gt;action, args-&gt;actionButton,<br>                args-&gt;pointerCount, args-&gt;pointerProperties)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">uint32_t</span> policyFlags = args-&gt;policyFlags;<br>    policyFlags |= POLICY_FLAG_TRUSTED;<br><br>    android::base::Timer t;<br>    mPolicy-&gt;<span class="hljs-built_in">interceptMotionBeforeQueueing</span>(args-&gt;eventTime, <span class="hljs-comment">/*byref*/</span> policyFlags);<br><br>    <span class="hljs-type">bool</span> needWake;<br>    &#123; <span class="hljs-comment">// acquire lock</span><br>        mLock.<span class="hljs-built_in">lock</span>();<br><br>      <span class="hljs-comment">//拦截事件分发</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">shouldSendMotionToInputFilterLocked</span>(args)) &#123;<br>            mLock.<span class="hljs-built_in">unlock</span>();<br><br>            MotionEvent event;<span class="hljs-comment">//初始化MotionEvent对象</span><br>            event.<span class="hljs-built_in">initialize</span>(args-&gt;deviceId, args-&gt;source, args-&gt;action, args-&gt;actionButton,<br>                    args-&gt;flags, args-&gt;edgeFlags, args-&gt;metaState, args-&gt;buttonState,<br>                    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, args-&gt;xPrecision, args-&gt;yPrecision,<br>                    args-&gt;downTime, args-&gt;eventTime,<br>                    args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords);<br><br>            policyFlags |= POLICY_FLAG_FILTERED;<br>            <span class="hljs-keyword">if</span> (!mPolicy-&gt;<span class="hljs-built_in">filterInputEvent</span>(&amp;event, policyFlags)) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// event was consumed by the filter</span><br>            &#125;<br><br>            mLock.<span class="hljs-built_in">lock</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// Just enqueue a new motion event.</span><br>        MotionEntry* newEntry = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MotionEntry</span>(args-&gt;eventTime,<br>                args-&gt;deviceId, args-&gt;source, policyFlags,<br>                args-&gt;action, args-&gt;actionButton, args-&gt;flags,<br>                args-&gt;metaState, args-&gt;buttonState,<br>                args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime,<br>                args-&gt;displayId,<br>                args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        needWake = <span class="hljs-built_in">enqueueInboundEventLocked</span>(newEntry);<br>        mLock.<span class="hljs-built_in">unlock</span>();<br>    &#125; <span class="hljs-comment">// release lock</span><br><br>    <span class="hljs-keyword">if</span> (needWake) &#123;<br>      <span class="hljs-comment">//唤醒消息队列</span><br>        mLooper-&gt;<span class="hljs-built_in">wake</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InputDispatcher::enqueueInboundEventLocked</span><span class="hljs-params">(EventEntry* entry)</span> </span>&#123;<br>    <span class="hljs-type">bool</span> needWake = mInboundQueue.<span class="hljs-built_in">isEmpty</span>();<br>    mInboundQueue.<span class="hljs-built_in">enqueueAtTail</span>(entry);<span class="hljs-comment">//将事件放入`mInBoundQueue`的尾部，等待处理</span><br>    <span class="hljs-built_in">traceInboundQueueLengthLocked</span>();<br><br>    <span class="hljs-keyword">switch</span> (entry-&gt;type) &#123;<br><br>    <span class="hljs-keyword">case</span> EventEntry::TYPE_MOTION: &#123;<br><br>        MotionEntry* motionEntry = <span class="hljs-built_in">static_cast</span>&lt;MotionEntry*&gt;(entry);<br>        <span class="hljs-keyword">if</span> (motionEntry-&gt;action == AMOTION_EVENT_ACTION_DOWN<br>                &amp;&amp; (motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)<br>                &amp;&amp; mInputTargetWaitCause == INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY<br>                &amp;&amp; mInputTargetWaitApplicationHandle != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-type">int32_t</span> displayId = motionEntry-&gt;displayId;<br>            <span class="hljs-type">int32_t</span> x = <span class="hljs-built_in">int32_t</span>(motionEntry-&gt;pointerCoords[<span class="hljs-number">0</span>].<br>                    <span class="hljs-built_in">getAxisValue</span>(AMOTION_EVENT_AXIS_X));<br>            <span class="hljs-type">int32_t</span> y = <span class="hljs-built_in">int32_t</span>(motionEntry-&gt;pointerCoords[<span class="hljs-number">0</span>].<br>                    <span class="hljs-built_in">getAxisValue</span>(AMOTION_EVENT_AXIS_Y));<br>            sp&lt;InputWindowHandle&gt; touchedWindowHandle = <span class="hljs-built_in">findTouchedWindowAtLocked</span>(displayId, x, y);<br>            <span class="hljs-keyword">if</span> (touchedWindowHandle != <span class="hljs-literal">NULL</span><br>                    &amp;&amp; touchedWindowHandle-&gt;inputApplicationHandle<br>                            != mInputTargetWaitApplicationHandle) &#123;<br>                <span class="hljs-comment">// User touched a different application than the one we are waiting on.</span><br>                <span class="hljs-comment">// Flag the event, and start pruning the input queue.</span><br>                mNextUnblockedEvent = motionEntry;<br>                needWake = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> needWake;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/v2-196591e61a6bed7189d68d7a72a07f4a_1440w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><code>InputReaderThread</code>主要负责<strong>事件封装转换</strong></p>
<ul>
<li><code>EventHub.getEvents()</code>：通过<code>epoll</code>监听<code>iNotify实例(监听 /dev/input/ 目录)</code>读取事件放入<code>mEventBuffer</code>，然后转换成<code>RawEvent</code></li>
<li><code>processEventsLocked()</code>：对<code>RawEvent</code>进行加工，转换成<code>NotifyMotionArgs</code></li>
<li><code>flush()</code>：将事件<code>NotifyMotionArgs</code>发送到<code>InputDispatcher</code>进行处理，最后转换成<code>MotionEntry</code>并写入到<code>InputDispatcher.mInBoundQueue</code></li>
</ul>
<p><img src="/images/InputReaderThread.jpg" srcset="/img/loading.gif" lazyload alt="InputReaderThread"></p>
<h4 id="InputDispatcherThread"><a href="#InputDispatcherThread" class="headerlink" title="InputDispatcherThread"></a>InputDispatcherThread</h4><p><img src="/images/InputDispatcherThread.png" srcset="/img/loading.gif" lazyload alt="InputDispatcherThread"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// frameworks/native/services/inputflinger/InputDispatcher.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InputDispatcherThread::threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    mDispatcher-&gt;<span class="hljs-built_in">dispatchOnce</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::dispatchOnce</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;<br>    &#123; <span class="hljs-comment">// acquire lock</span><br>        AutoMutex _l(mLock);<br>      <span class="hljs-comment">//唤醒等待线程，监听当前是否发生死锁</span><br>        mDispatcherIsAliveCondition.<span class="hljs-built_in">broadcast</span>();<br><br>       <span class="hljs-comment">//派发输入事件，`nextWakeUpTime`决定下次派发线程执行时间</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">haveCommandsLocked</span>()) &#123;<br>            <span class="hljs-built_in">dispatchOnceInnerLocked</span>(&amp;nextWakeupTime);<br>        &#125;<br><br>        <span class="hljs-comment">// Run all pending commands if there are any.</span><br>        <span class="hljs-comment">// If any commands were run then force the next poll to wake up immediately.</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">runCommandsLockedInterruptible</span>()) &#123;<br>            nextWakeupTime = LONG_LONG_MIN;<br>        &#125;<br>    &#125; <span class="hljs-comment">// release lock</span><br><br>   <span class="hljs-comment">//派发线程进入休眠状态</span><br>    <span class="hljs-type">nsecs_t</span> currentTime = <span class="hljs-built_in">now</span>();<br>    <span class="hljs-type">int</span> timeoutMillis = <span class="hljs-built_in">toMillisecondTimeoutDelay</span>(currentTime, nextWakeupTime);<br>    mLooper-&gt;<span class="hljs-built_in">pollOnce</span>(timeoutMillis);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="dispatchOnceInnerLocked-获取事件"><a href="#dispatchOnceInnerLocked-获取事件" class="headerlink" title="dispatchOnceInnerLocked() 获取事件"></a>dispatchOnceInnerLocked() 获取事件</h5><p><img src="/images/InputDispatcher-dispatchOnceInnerLocked.png" srcset="/img/loading.gif" lazyload alt="InputDispatcher-dispatchOnceInnerLocked"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::dispatchOnceInnerLocked</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;<br>    <span class="hljs-type">nsecs_t</span> currentTime = <span class="hljs-built_in">now</span>();<br><br>    <span class="hljs-comment">// Ready to start a new event.</span><br>    <span class="hljs-comment">// If we don&#x27;t already have a pending event, go grab one.</span><br>    <span class="hljs-keyword">if</span> (! mPendingEvent) &#123;<br>        <span class="hljs-keyword">if</span> (mInboundQueue.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>          <span class="hljs-comment">//派发队列为空，进入线程休眠状态</span><br>          ...<br>            <span class="hljs-comment">// Nothing to do if there is no pending event.</span><br>            <span class="hljs-keyword">if</span> (!mPendingEvent) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 从 mInBoundQueue获取事件 实质就是上一步的 MotionEntry</span><br>            mPendingEvent = mInboundQueue.<span class="hljs-built_in">dequeueAtHead</span>();<br>            <span class="hljs-built_in">traceInboundQueueLengthLocked</span>();<br>        &#125;<br>      ...<br>        <span class="hljs-comment">// 重置ANR时间</span><br>        <span class="hljs-built_in">resetANRTimeoutsLocked</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Now we have an event to dispatch.</span><br>    <span class="hljs-comment">// All events are eventually dequeued and processed this way, even if we intend to drop them.</span><br>    <span class="hljs-built_in">ALOG_ASSERT</span>(mPendingEvent != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;<br>    DropReason dropReason = DROP_REASON_NOT_DROPPED;<br>  <span class="hljs-comment">//检查事件是否需要丢弃</span><br>    <span class="hljs-keyword">if</span> (!(mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER)) &#123;<br>        dropReason = DROP_REASON_POLICY;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!mDispatchEnabled) &#123;<br>        dropReason = DROP_REASON_DISABLED;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (mPendingEvent-&gt;type) &#123;<br>    <span class="hljs-keyword">case</span> EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;<br>       ...<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> EventEntry::TYPE_DEVICE_RESET: &#123;<br>       ...<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> EventEntry::TYPE_KEY: &#123;<br>       ...<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">case</span> EventEntry::TYPE_MOTION: &#123;<br>        MotionEntry* typedEntry = <span class="hljs-built_in">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);<br>        <span class="hljs-keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;<br>            dropReason = DROP_REASON_APP_SWITCH;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED<br>                &amp;&amp; <span class="hljs-built_in">isStaleEventLocked</span>(currentTime, typedEntry)) &#123;<br>            dropReason = DROP_REASON_STALE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;<br>            dropReason = DROP_REASON_BLOCKED;<br>        &#125;<br>      <span class="hljs-comment">//分发触摸事件</span><br>        done = <span class="hljs-built_in">dispatchMotionLocked</span>(currentTime, typedEntry,<br>                &amp;dropReason, nextWakeupTime);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br><br>        <span class="hljs-comment">//准备派发下一个事件</span><br>    <span class="hljs-keyword">if</span> (done) &#123;<br>        <span class="hljs-keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;<br>            <span class="hljs-built_in">dropInboundEventLocked</span>(mPendingEvent, dropReason);<br>        &#125;<br>        mLastDropReason = dropReason;<br><br>        <span class="hljs-built_in">releasePendingEventLocked</span>();<br>        *nextWakeupTime = LONG_LONG_MIN;  <span class="hljs-comment">// force next poll to wake up immediately</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InputDispatcher::dispatchMotionLocked</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="hljs-type">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;<br><br>    <span class="hljs-type">bool</span> isPointerEvent = entry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER;<br><br>    <span class="hljs-comment">// 保存触摸事件的发送目标</span><br>    Vector&lt;InputTarget&gt; inputTargets;<br><br>    <span class="hljs-type">bool</span> conflictingPointerActions = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int32_t</span> injectionResult;<br>    <span class="hljs-keyword">if</span> (isPointerEvent) &#123;<br>        <span class="hljs-comment">// 基于坐标点的形式，如触屏，根据坐标点获取目标窗口</span><br>        injectionResult = <span class="hljs-built_in">findTouchedWindowTargetsLocked</span>(currentTime,<br>                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 无坐标点的触摸事件，例如 轨迹球</span><br>        injectionResult = <span class="hljs-built_in">findFocusedWindowTargetsLocked</span>(currentTime,<br>                entry, inputTargets, nextWakeupTime);<br>    &#125;<br><br>    <span class="hljs-built_in">addMonitoringTargetsLocked</span>(inputTargets);<br>   <span class="hljs-comment">//将 entry 分发到 对应window上</span><br>    <span class="hljs-built_in">dispatchEventLocked</span>(currentTime, entry, inputTargets);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>InputTarget</code>的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputDispatcher.h</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InputTarget</span> &#123;<br>    <span class="hljs-comment">// 连接InputDispatcher与Window的通信管道</span><br>    sp&lt;InputChannel&gt; inputChannel;<br><br>    <span class="hljs-comment">// Flags for the input target.</span><br>    <span class="hljs-type">int32_t</span> flags;<br><br>    <span class="hljs-comment">// The x and y offset to add to a MotionEvent as it is delivered.</span><br>    <span class="hljs-comment">// (ignored for KeyEvents)</span><br>    <span class="hljs-type">float</span> xOffset, yOffset;<br><br>    <span class="hljs-comment">// Scaling factor to apply to MotionEvent as it is delivered.</span><br>    <span class="hljs-comment">// (ignored for KeyEvents)</span><br>    <span class="hljs-type">float</span> scaleFactor;<br><br>    <span class="hljs-comment">// The subset of pointer ids to include in motion events dispatched to this input target</span><br>    <span class="hljs-comment">// if FLAG_SPLIT is set.</span><br>    BitSet32 pointerIds;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="dispatchEventLocked-发送事件"><a href="#dispatchEventLocked-发送事件" class="headerlink" title="dispatchEventLocked() 发送事件"></a>dispatchEventLocked() 发送事件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::dispatchEventLocked</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> currentTime,</span></span><br><span class="hljs-params"><span class="hljs-function">        EventEntry* eventEntry, <span class="hljs-type">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;<br><br>    <span class="hljs-built_in">pokeUserActivityLocked</span>(eventEntry);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; inputTargets.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">const</span> InputTarget&amp; inputTarget = inputTargets.<span class="hljs-built_in">itemAt</span>(i);<br>       <span class="hljs-comment">//根据InputTarget的InputChannel 获取 connection</span><br>        <span class="hljs-type">ssize_t</span> connectionIndex = <span class="hljs-built_in">getConnectionIndexLocked</span>(inputTarget.inputChannel);<br>        <span class="hljs-keyword">if</span> (connectionIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>            sp&lt;Connection&gt; connection = mConnectionsByFd.<span class="hljs-built_in">valueAt</span>(connectionIndex);<br>          <span class="hljs-comment">//准备分发消息</span><br>            <span class="hljs-built_in">prepareDispatchCycleLocked</span>(currentTime, connection, eventEntry, &amp;inputTarget);<br><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::prepareDispatchCycleLocked</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> currentTime,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="hljs-type">const</span> InputTarget* inputTarget)</span> </span>&#123;<br>     ...<br><br>    <span class="hljs-comment">// 将事件添加到Connections的发送队列</span><br>    <span class="hljs-built_in">enqueueDispatchEntriesLocked</span>(currentTime, connection, eventEntry, inputTarget);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::enqueueDispatchEntriesLocked</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> currentTime,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="hljs-type">const</span> InputTarget* inputTarget)</span> </span>&#123;<br>    <span class="hljs-type">bool</span> wasEmpty = connection-&gt;outboundQueue.<span class="hljs-built_in">isEmpty</span>();<br>  ...<br><br>    <span class="hljs-comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span><br>    <span class="hljs-keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-built_in">startDispatchCycleLocked</span>(currentTime, connection);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//开始循环</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::startDispatchCycleLocked</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> currentTime,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;Connection&gt;&amp; connection)</span> </span>&#123;<br><br>    <span class="hljs-keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL<br>            &amp;&amp; !connection-&gt;outboundQueue.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;<br>        dispatchEntry-&gt;deliveryTime = currentTime;<br><br>        <span class="hljs-comment">// Publish the event.</span><br>        <span class="hljs-type">status_t</span> status;<br>        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;<br>        <span class="hljs-keyword">switch</span> (eventEntry-&gt;type) &#123;<br><br><br>        <span class="hljs-keyword">case</span> EventEntry::TYPE_MOTION: &#123;<br>            MotionEntry* motionEntry = <span class="hljs-built_in">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);<br><br>            PointerCoords scaledCoords[MAX_POINTERS];<br>            <span class="hljs-type">const</span> PointerCoords* usingCoords = motionEntry-&gt;pointerCoords;<br><br>            <span class="hljs-comment">// Set the X and Y offset depending on the input source.</span><br>            <span class="hljs-type">float</span> xOffset, yOffset;<br>            <span class="hljs-keyword">if</span> ((motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)<br>                    &amp;&amp; !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123;<br>                <span class="hljs-type">float</span> scaleFactor = dispatchEntry-&gt;scaleFactor;<br>                xOffset = dispatchEntry-&gt;xOffset * scaleFactor;<br>                yOffset = dispatchEntry-&gt;yOffset * scaleFactor;<br>                <span class="hljs-keyword">if</span> (scaleFactor != <span class="hljs-number">1.0f</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;<br>                        scaledCoords[i] = motionEntry-&gt;pointerCoords[i];<br>                        scaledCoords[i].<span class="hljs-built_in">scale</span>(scaleFactor);<br>                    &#125;<br>                    usingCoords = scaledCoords;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                xOffset = <span class="hljs-number">0.0f</span>;<br>                yOffset = <span class="hljs-number">0.0f</span>;<br><br>                <span class="hljs-comment">// We don&#x27;t want the dispatch target to know.</span><br>                <span class="hljs-keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;<br>                        scaledCoords[i].<span class="hljs-built_in">clear</span>();<br>                    &#125;<br>                    usingCoords = scaledCoords;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Publish the motion event.</span><br>            status = connection-&gt;inputPublisher.<span class="hljs-built_in">publishMotionEvent</span>(dispatchEntry-&gt;seq,<br>                    motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId,<br>                    dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,<br>                    dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,<br>                    motionEntry-&gt;metaState, motionEntry-&gt;buttonState,<br>                    xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,<br>                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,<br>                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,<br>                    usingCoords);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 回收队列</span><br>        connection-&gt;outboundQueue.<span class="hljs-built_in">dequeue</span>(dispatchEntry);<br>        <span class="hljs-built_in">traceOutboundQueueLengthLocked</span>(connection);<br>        <span class="hljs-comment">// 等待执行队列</span><br>        connection-&gt;waitQueue.<span class="hljs-built_in">enqueueAtTail</span>(dispatchEntry);<br>        <span class="hljs-built_in">traceWaitQueueLengthLocked</span>(connection);<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/libs/input/InputTransport.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">InputPublisher::publishMotionEvent</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint32_t</span> seq,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> deviceId,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> source,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> displayId,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> action,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> actionButton,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> edgeFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> metaState,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span> buttonState,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">float</span> xOffset,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">float</span> yOffset,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">float</span> xPrecision,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">float</span> yPrecision,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">nsecs_t</span> downTime,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">nsecs_t</span> eventTime,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">uint32_t</span> pointerCount,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> PointerProperties* pointerProperties,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> PointerCoords* pointerCoords)</span> </span>&#123;<br><br><br>    InputMessage msg;<br>    msg.header.type = InputMessage::TYPE_MOTION;<br>    msg.body.motion.seq = seq;<br>    msg.body.motion.deviceId = deviceId;<br>    msg.body.motion.source = source;<br>    msg.body.motion.displayId = displayId;<br>    msg.body.motion.action = action;<br>    msg.body.motion.actionButton = actionButton;<br>    msg.body.motion.flags = flags;<br>    msg.body.motion.edgeFlags = edgeFlags;<br>    msg.body.motion.metaState = metaState;<br>    msg.body.motion.buttonState = buttonState;<br>    msg.body.motion.xOffset = xOffset;<br>    msg.body.motion.yOffset = yOffset;<br>    msg.body.motion.xPrecision = xPrecision;<br>    msg.body.motion.yPrecision = yPrecision;<br>    msg.body.motion.downTime = downTime;<br>    msg.body.motion.eventTime = eventTime;<br>    msg.body.motion.pointerCount = pointerCount;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; pointerCount; i++) &#123;<br>        msg.body.motion.pointers[i].properties.<span class="hljs-built_in">copyFrom</span>(pointerProperties[i]);<br>        msg.body.motion.pointers[i].coords.<span class="hljs-built_in">copyFrom</span>(pointerCoords[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mChannel-&gt;<span class="hljs-built_in">sendMessage</span>(&amp;msg);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/libs/input/InputTransport.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">InputChannel::sendMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> InputMessage* msg)</span> </span>&#123;<br> ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终通过<code>InputChannel.sendMessage()</code>发送包装好的触摸事件</p>
<blockquote>
<p>TODO</p>
</blockquote>
<h5 id="handleReceiveCallback-接收事件"><a href="#handleReceiveCallback-接收事件" class="headerlink" title="handleReceiveCallback 接收事件"></a>handleReceiveCallback 接收事件</h5><p>这一节的触发条件会在后面讲到，简单来说就是</p>
<p>后面Java层的事件分发结束，调用到<code>InputEventReceiver.finishInputEvent()</code>，会向UI进程持有的<code>InputChannel</code>写入数据，然后唤醒<code>InputDispatcher</code>线程被唤醒后执行<code>handleReceiveCallback()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputDispatcher.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InputDispatcher::handleReceiveCallback</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> events, <span class="hljs-type">void</span>* data)</span> </span>&#123;<br>  ...<br>        sp&lt;Connection&gt; connection = d-&gt;mConnectionsByFd.<span class="hljs-built_in">valueAt</span>(connectionIndex);<br>  ...<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">uint32_t</span> seq;<br>                <span class="hljs-type">bool</span> handled;<br>              <span class="hljs-comment">//从 connection 获取消息</span><br>                status = connection-&gt;inputPublisher.<span class="hljs-built_in">receiveFinishedSignal</span>(&amp;seq, &amp;handled);<br>                <span class="hljs-keyword">if</span> (status) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>              <br>                d-&gt;<span class="hljs-built_in">finishDispatchCycleLocked</span>(currentTime, connection, seq, handled);<br>                gotOne = <span class="hljs-literal">true</span>;<br>            &#125;    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::finishDispatchCycleLocked</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span> currentTime,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;Connection&gt;&amp; connection, <span class="hljs-type">uint32_t</span> seq, <span class="hljs-type">bool</span> handled)</span> </span>&#123;<br><br>    connection-&gt;inputPublisherBlocked = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (connection-&gt;status == Connection::STATUS_BROKEN<br>            || connection-&gt;status == Connection::STATUS_ZOMBIE) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Notify other system components and prepare to start the next dispatch cycle.</span><br>    <span class="hljs-built_in">onDispatchCycleFinishedLocked</span>(currentTime, connection, seq, handled);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::onDispatchCycleFinishedLocked</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">nsecs_t</span> currentTime, <span class="hljs-type">const</span> sp&lt;Connection&gt;&amp; connection, <span class="hljs-type">uint32_t</span> seq, <span class="hljs-type">bool</span> handled)</span> </span>&#123;<br>  <span class="hljs-comment">//发送命令到 doDispatchCycleFinishedLockedInterruptible</span><br>    CommandEntry* commandEntry = <span class="hljs-built_in">postCommandLocked</span>(<br>            &amp; InputDispatcher::doDispatchCycleFinishedLockedInterruptible);<br>    commandEntry-&gt;connection = connection;<br>    commandEntry-&gt;eventTime = currentTime;<br>    commandEntry-&gt;seq = seq;<br>    commandEntry-&gt;handled = handled;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::doDispatchCycleFinishedLockedInterruptible</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        CommandEntry* commandEntry)</span> </span>&#123;<br>  ...<br>        <span class="hljs-keyword">if</span> (dispatchEntry == connection-&gt;<span class="hljs-built_in">findWaitQueueEntry</span>(seq)) &#123;<br>          <span class="hljs-comment">//事件执行完毕后，从waitQueue移除事件</span><br>            connection-&gt;waitQueue.<span class="hljs-built_in">dequeue</span>(dispatchEntry);<br>            <span class="hljs-built_in">traceWaitQueueLengthLocked</span>(connection);<br>        &#125;<br><br>        <span class="hljs-comment">// 开始下一次发送循环</span><br>        <span class="hljs-built_in">startDispatchCycleLocked</span>(<span class="hljs-built_in">now</span>(), connection);  <br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/event1_5.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><code>InputReader</code>发送触摸事件到<code>InputDispatcher</code>，通过<code>findFocusedWindowTargetsLocked()</code>寻找触摸事件对应的窗口，如果没有找到就使用第一个<code>Window</code>。把结果写入<code>inputTargets</code>中，然后通过<code>publishMotionEvent</code>分发触摸事件，再通过<code>InputChannel</code>发送消息到UI线程。</p>
<p><img src="/images/InputDispatcherThread.jpg" srcset="/img/loading.gif" lazyload alt="InputDispatche"></p>
<h3 id="触摸事件发送至Activity"><a href="#触摸事件发送至Activity" class="headerlink" title="触摸事件发送至Activity"></a>触摸事件发送至Activity</h3><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%8F%91%E9%80%81%E8%87%B3Activity.png" srcset="/img/loading.gif" lazyload alt="事件分发-触摸事件发送至Activity"></p>
<p><code>InputDispatcher</code>负责分发触摸事件，最后通过<code>InputChannel-&gt;sendMessage()</code>发出消息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/libs/input/InputTransport.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">InputChannel::sendMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> InputMessage* msg)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> msgLength = msg-&gt;<span class="hljs-built_in">size</span>();<br>    InputMessage cleanMsg;<br>    msg-&gt;<span class="hljs-built_in">getSanitizedCopy</span>(&amp;cleanMsg);<br>    <span class="hljs-type">ssize_t</span> nWrite;<br>    <span class="hljs-keyword">do</span> &#123;<br>        nWrite = ::<span class="hljs-built_in">send</span>(mFd, &amp;cleanMsg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);<br>    &#125; <span class="hljs-keyword">while</span> (nWrite == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR);<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>InputChannel</code>通过<code>socket</code>发送消息。</p>
<p>既然存在<code>sendMessage()</code>就需要找到相对的<code>receiveMessage()</code>调用的地方。</p>
<blockquote>
<p>当前是<code>InputDispatcher</code>调用的<code>sendMessage()</code>，对应就需要去<code>Window</code>找<code>receiveMessage()</code></p>
</blockquote>
<h4 id="InputChannel的理解"><a href="#InputChannel的理解" class="headerlink" title="InputChannel的理解"></a>InputChannel的理解</h4><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-InputChannel.png" srcset="/img/loading.gif" lazyload alt="InputChannel"></p>
<p>本质是<code>SocketPair(非网络套接字)</code>。<code>SocketPair</code>用于实现本机内的进程间通信。</p>
<p><code>SocketPair</code>提供方法：</p>
<ul>
<li><code>socketPair()</code>：创建SocketPair，返回一对相互连接的fd</li>
<li><code>send()</code>：写入数据，可在另一个fd读取</li>
<li><code>recv()</code>：读取数据</li>
</ul>
<p><strong>非常适合用来进行进程间的交互式通讯。</strong></p>
<p><code>InputChannel</code>就是<code>SocketPair</code>的封装，分别分配给<code>InputDispatcher</code>与<code>Window</code>。</p>
<p><code>InputDispatcher</code>写入的事件，<code>Window</code>可以从自己持有的<code>InputChannel</code>获取；反向也是如此。</p>
<p><code>InputChannel</code>提供方法：位于<code>InputTransport.cpp</code>中</p>
<ul>
<li><code>openInputChannelPair()</code>：封装<code>socketPair()</code></li>
<li><code>sendMessage()</code>：封装<code>send()</code></li>
<li><code>receiveMessage()</code>：封装<code>recv()</code></li>
</ul>
<p><img src="/images/InputChannel%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="InputChannel原理"></p>
<p>最后屏幕的触摸事件都需要反映到一个Activity上，然后再一步步传递到对应的View上。所以需要先从Activity开始分析触摸事件的传递流程。</p>
<h4 id="InputChannel注册"><a href="#InputChannel注册" class="headerlink" title="InputChannel注册"></a>InputChannel注册</h4><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-InputChannel%E6%B3%A8%E5%86%8C.png" srcset="/img/loading.gif" lazyload alt="事件分发-InputChannel注册"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ActivityThread.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-type">boolean</span> finalStateRequest, <span class="hljs-type">boolean</span> isForward,</span><br><span class="hljs-params">            String reason)</span> &#123;<br>      ...<br>        wm.addView(decor, l);<br>      ...<br>    &#125;<br><br><span class="hljs-comment">// ==&gt; WindowManagerGlobal.java</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,</span><br><span class="hljs-params">            Display display, Window parentWindow)</span> &#123;<br>        <span class="hljs-comment">//新建ViewRootImpl</span><br>            root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewRootImpl</span>(view.getContext(), display);        <br>        <br>        root.setView(view, wparams, panelParentView);<br>      &#125;<br>  <br><span class="hljs-comment">// ==&gt; ViewRootImpl.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> &#123;<br>      <span class="hljs-comment">//创建InputChannel对象</span><br>        <span class="hljs-keyword">if</span> ((mWindowAttributes.inputFeatures<br>                 &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="hljs-number">0</span>) &#123;<br>            mInputChannel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputChannel</span>();<br>        &#125; <br>      <span class="hljs-comment">//创建Socket的服务端</span><br>       res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,<br>             getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,<br>             mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,<br>             mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);      <br>      <br>      <span class="hljs-comment">//创建Socket的客户端</span><br>        <span class="hljs-keyword">if</span> (mInputChannel != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mInputQueueCallback != <span class="hljs-literal">null</span>) &#123;<br>                mInputQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputQueue</span>();<br>                mInputQueueCallback.onInputQueueCreated(mInputQueue);<br>            &#125;<br>          <span class="hljs-comment">//创建WindowEventReceiver对象</span><br>            mInputEventReceiver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowInputEventReceiver</span>(mInputChannel,<br>                    Looper.myLooper());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h5 id="addToDisplay"><a href="#addToDisplay" class="headerlink" title="addToDisplay()"></a>addToDisplay()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Session.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addToDisplay</span><span class="hljs-params">(IWindow window, <span class="hljs-type">int</span> seq, WindowManager.LayoutParams attrs,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> viewVisibility, <span class="hljs-type">int</span> displayId, Rect outFrame, Rect outContentInsets,</span><br><span class="hljs-params">            Rect outStableInsets, Rect outOutsets,</span><br><span class="hljs-params">            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel)</span> &#123;<br>        <span class="hljs-keyword">return</span> mService.addWindow(<span class="hljs-built_in">this</span>, window, seq, attrs, viewVisibility, displayId, outFrame,<br>                outContentInsets, outStableInsets, outOutsets, outDisplayCutout, outInputChannel);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>其中<code>mService</code>指的就是<code>WindowManagerService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addWindow</span><span class="hljs-params">(Session session, IWindow client, <span class="hljs-type">int</span> seq,</span><br><span class="hljs-params">            LayoutParams attrs, <span class="hljs-type">int</span> viewVisibility, <span class="hljs-type">int</span> displayId, Rect outFrame,</span><br><span class="hljs-params">            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span><br><span class="hljs-params">            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel)</span> &#123;<br>      ...<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">WindowState</span> <span class="hljs-variable">win</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowState</span>(<span class="hljs-built_in">this</span>, session, client, token, parentWindow,<br>                    appOp[<span class="hljs-number">0</span>], seq, attrs, viewVisibility, session.mUid,<br>                    session.mCanAddInternalSystemWindow);<br>      ...<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">openInputChannels</span> <span class="hljs-operator">=</span> (outInputChannel != <span class="hljs-literal">null</span><br>                    &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>  (openInputChannels) &#123;<br>                win.openInputChannel(outInputChannel);<br>            &#125;      <br>      <br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>addWindow()</code>主要创建了<code>WindowState</code>对象，然后继续调用到<code>openInputChannels()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//frameworks/base/services/core/java/com/android/server/wm/WindowState.java</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">openInputChannel</span><span class="hljs-params">(InputChannel outInputChannel)</span> &#123;<br>        <span class="hljs-keyword">if</span> (mInputChannel != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Window already has an input channel.&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> getName();<br>        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);<br>        mInputChannel = inputChannels[<span class="hljs-number">0</span>];<br>        mClientChannel = inputChannels[<span class="hljs-number">1</span>];<br>        mInputWindowHandle.inputChannel = inputChannels[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (outInputChannel != <span class="hljs-literal">null</span>) &#123;<br>            mClientChannel.transferTo(outInputChannel);<br>            mClientChannel.dispose();<br>            mClientChannel = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// If the window died visible, we setup a dummy input channel, so that taps</span><br>            <span class="hljs-comment">// can still detected by input monitor channel, and we can relaunch the app.</span><br>            <span class="hljs-comment">// Create dummy event receiver that simply reports all events as handled.</span><br>            mDeadWindowEventReceiver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadWindowEventReceiver</span>(mClientChannel);<br>        &#125;<br>        mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h5 id="registerInputChannel"><a href="#registerInputChannel" class="headerlink" title="registerInputChannel()"></a>registerInputChannel()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//InputManagerService.java </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerInputChannel</span><span class="hljs-params">(InputChannel inputChannel,</span><br><span class="hljs-params">            InputWindowHandle inputWindowHandle)</span> &#123;<br>       <span class="hljs-comment">//通过Native层完成注册</span><br>        nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, <span class="hljs-literal">false</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">NativeInputManager::registerInputChannel</span><span class="hljs-params">(JNIEnv* <span class="hljs-comment">/* env */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="hljs-type">bool</span> monitor)</span> </span>&#123;<br>    <span class="hljs-built_in">ATRACE_CALL</span>();<br>  <span class="hljs-comment">//再通过 InputDispatcher 继续注册</span><br>    <span class="hljs-keyword">return</span> mInputManager-&gt;<span class="hljs-built_in">getDispatcher</span>()-&gt;<span class="hljs-built_in">registerInputChannel</span>(<br>            inputChannel, inputWindowHandle, monitor);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/services/inputflinger/InputDispatcher.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">InputDispatcher::registerInputChannel</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="hljs-type">bool</span> monitor)</span> </span>&#123;<br><br><br>    &#123; <span class="hljs-comment">// acquire lock</span><br>        AutoMutex _l(mLock);<br><br>      <span class="hljs-comment">//为传入的 InputChannel 创建Connection对象</span><br>        sp&lt;Connection&gt; connection = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Connection</span>(inputChannel, inputWindowHandle, monitor);<br><br>        <span class="hljs-type">int</span> fd = inputChannel-&gt;<span class="hljs-built_in">getFd</span>();<br>      <span class="hljs-comment">//监听connection的变化</span><br>        mConnectionsByFd.<span class="hljs-built_in">add</span>(fd, connection);<br><br>        <span class="hljs-keyword">if</span> (monitor) &#123;<br>            mMonitoringChannels.<span class="hljs-built_in">push</span>(inputChannel);<br>        &#125;<br><br>      <span class="hljs-comment">//如果发生变化，回调handleReceiveCallback方法</span><br>        mLooper-&gt;<span class="hljs-built_in">addFd</span>(fd, <span class="hljs-number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="hljs-keyword">this</span>);<br>    &#125; <span class="hljs-comment">// release lock</span><br><br>    <span class="hljs-comment">// Wake the looper because some connections have changed.</span><br>    mLooper-&gt;<span class="hljs-built_in">wake</span>();<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/InputChannel%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="InputChannel执行过程"></p>
<p><img src="/images/v2-1e1273f15cfdd7b81aa7a2cb819d8890_1440w.jpg" srcset="/img/loading.gif" lazyload alt="InputChannel对应关系"></p>
<p><code>addToDisplay()</code>主要处理两部分内容</p>
<ul>
<li><p>创建Socket pair，作为<code>InputChannel</code></p>
<p><code>socket服务端</code>保存在<code>WidnowState</code>中的<code>mInputChannel</code>中</p>
<p><code>socket客户端</code>通过<code>binder</code>传到<code>ViewRootImpl</code>中的<code>mInputChannel</code></p>
</li>
<li><p>通过<code>IMS.registerInputChannel()</code>注册<code>InputChannel</code>，监听socket服务端，收到消息后回调<code>InputDispatcher::handleReceiveCallback()</code></p>
</li>
</ul>
<h5 id="WindowInputEventReceiver"><a href="#WindowInputEventReceiver" class="headerlink" title="WindowInputEventReceiver"></a>WindowInputEventReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowInputEventReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputEventReceiver</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">WindowInputEventReceiver</span><span class="hljs-params">(InputChannel inputChannel, Looper looper)</span> &#123;<br>            <span class="hljs-built_in">super</span>(inputChannel, looper);<br>        &#125;<br>      ...<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInputEvent</span><span class="hljs-params">(InputEvent event, <span class="hljs-type">int</span> displayId)</span> &#123;<br>            enqueueInputEvent(event, <span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>        &#125;        <br>    &#125;<br><br><span class="hljs-comment">//InputeventReceiver.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InputEventReceiver</span><span class="hljs-params">(InputChannel inputChannel, Looper looper)</span> &#123;<br><br>        mInputChannel = inputChannel;<br>        mMessageQueue = looper.getQueue();<br>        mReceiverPtr = nativeInit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;InputEventReceiver&gt;(<span class="hljs-built_in">this</span>),<br>                inputChannel, mMessageQueue);<br><br>        mCloseGuard.open(<span class="hljs-string">&quot;dispose&quot;</span>);<br>    &#125;<br><br><span class="hljs-comment">//Native层调用该方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchInputEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> seq, InputEvent event, <span class="hljs-type">int</span> displayId)</span> &#123;<br>        mSeqMap.put(event.getSequenceNumber(), seq);<br>        onInputEvent(event, displayId);<br>    &#125;<br></code></pre></td></tr></table></figure>



<p>初始化 InputEventReceiver</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/base/core/jni/android_view_InputEventReceiver.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> jlong <span class="hljs-title">nativeInit</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span><br><span class="hljs-params"><span class="hljs-function">        jobject inputChannelObj, jobject messageQueueObj)</span> </span>&#123;<br>    sp&lt;InputChannel&gt; inputChannel = <span class="hljs-built_in">android_view_InputChannel_getInputChannel</span>(env,<br>            inputChannelObj);<br>    <span class="hljs-keyword">if</span> (inputChannel == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">jniThrowRuntimeException</span>(env, <span class="hljs-string">&quot;InputChannel is not initialized.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>  <span class="hljs-comment">//获取消息队列</span><br>    sp&lt;MessageQueue&gt; messageQueue = <span class="hljs-built_in">android_os_MessageQueue_getMessageQueue</span>(env, messageQueueObj);<br>    <span class="hljs-keyword">if</span> (messageQueue == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">jniThrowRuntimeException</span>(env, <span class="hljs-string">&quot;MessageQueue is not initialized.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>  <span class="hljs-comment">//创建NativeInputEventReceiver对象</span><br>    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NativeInputEventReceiver</span>(env,<br>            receiverWeak, inputChannel, messageQueue);<br>    <span class="hljs-type">status_t</span> status = receiver-&gt;<span class="hljs-built_in">initialize</span>();<br><br>    receiver-&gt;<span class="hljs-built_in">incStrong</span>(gInputEventReceiverClassInfo.clazz); <span class="hljs-comment">// retain a reference for the object</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="hljs-built_in">get</span>());<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">NativeInputEventReceiver::initialize</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">setFdEvents</span>(ALOOPER_EVENT_INPUT);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NativeInputEventReceiver::setFdEvents</span><span class="hljs-params">(<span class="hljs-type">int</span> events)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mFdEvents != events) &#123;<br>        mFdEvents = events;<br>        <span class="hljs-type">int</span> fd = mInputConsumer.<span class="hljs-built_in">getChannel</span>()-&gt;<span class="hljs-built_in">getFd</span>();<br>        <span class="hljs-keyword">if</span> (events) &#123;<br>            mMessageQueue-&gt;<span class="hljs-built_in">getLooper</span>()-&gt;<span class="hljs-built_in">addFd</span>(fd, <span class="hljs-number">0</span>, events, <span class="hljs-keyword">this</span>, <span class="hljs-literal">NULL</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mMessageQueue-&gt;<span class="hljs-built_in">getLooper</span>()-&gt;<span class="hljs-built_in">removeFd</span>(fd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//system/core/libutils/Looper.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Looper::addFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ident, <span class="hljs-type">int</span> events, <span class="hljs-type">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="hljs-type">void</span>* data)</span> </span>&#123;<br>  <span class="hljs-comment">//构造native Request消息</span><br>          Request request;<br>        request.fd = fd;<br>        request.ident = ident;<br>        request.events = events;<br>        request.seq = mNextRequestSeq++;<br>        request.callback = callback; <span class="hljs-comment">//NativeInputReceiver</span><br>        request.data = data;<br>        <span class="hljs-keyword">if</span> (mNextRequestSeq == <span class="hljs-number">-1</span>) mNextRequestSeq = <span class="hljs-number">0</span>; <span class="hljs-comment">// reserve sequence number -1</span><br>  <br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> eventItem;<br>        request.<span class="hljs-built_in">initEventItem</span>(&amp;eventItem);<br>       ...<br>         <span class="hljs-comment">//在epoll实例 添加native request监听</span><br>        <span class="hljs-type">int</span> epollResult = <span class="hljs-built_in">epoll_ctl</span>(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);         <br>  <br>       <span class="hljs-comment">//唤醒线程</span><br>        <span class="hljs-built_in">scheduleEpollRebuildLocked</span>();  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Looper::scheduleEpollRebuildLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mEpollRebuildRequired) &#123;<br>        mEpollRebuildRequired = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">wake</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这一部分涉及<code>looper</code>在<code>Handler</code>就有详细介绍，<code>wake</code>之后，<code>native request</code>相关消息触发后会回调到<code>callback-&gt;handleEvent()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/base/core/jni/android_view_InputEventReceiver.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NativeInputEventReceiver::handleEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> receiveFd, <span class="hljs-type">int</span> events, <span class="hljs-type">void</span>* data)</span> </span>&#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (events &amp; ALOOPER_EVENT_INPUT) &#123; <span class="hljs-comment">//events 就是 ALOOPER_EVENT_INPUT</span><br>        JNIEnv* env = AndroidRuntime::<span class="hljs-built_in">getJNIEnv</span>();<br>        <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">consumeEvents</span>(env, <span class="hljs-literal">false</span> <span class="hljs-comment">/*consumeBatches*/</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>);<br>        mMessageQueue-&gt;<span class="hljs-built_in">raiseAndClearException</span>(env, <span class="hljs-string">&quot;handleReceiveCallback&quot;</span>);<br>        <span class="hljs-keyword">return</span> status == OK || status == NO_MEMORY ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>  ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">NativeInputEventReceiver::consumeEvents</span><span class="hljs-params">(JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">bool</span> consumeBatches, <span class="hljs-type">nsecs_t</span> frameTime, <span class="hljs-type">bool</span>* outConsumedBatch)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">status_t</span> status = mInputConsumer.<span class="hljs-built_in">consume</span>(&amp;mInputEventFactory,<br>                consumeBatches, frameTime, &amp;seq, &amp;inputEvent, &amp;displayId);<br>    <span class="hljs-comment">//将事件进行打包，避免量过大</span><br>        <span class="hljs-keyword">if</span> (status) &#123;<br>            <span class="hljs-keyword">if</span> (status == WOULD_BLOCK) &#123;<br>                <span class="hljs-keyword">if</span> (!skipCallbacks &amp;&amp; !mBatchedInputEventPending<br>                        &amp;&amp; mInputConsumer.<span class="hljs-built_in">hasPendingBatch</span>()) &#123;<br>                    <span class="hljs-comment">// There is a pending batch.  Come back later.</span><br>                    <span class="hljs-keyword">if</span> (!receiverObj.<span class="hljs-built_in">get</span>()) &#123;<br>                        receiverObj.<span class="hljs-built_in">reset</span>(<span class="hljs-built_in">jniGetReferent</span>(env, mReceiverWeakGlobal));<br>                        <span class="hljs-keyword">if</span> (!receiverObj.<span class="hljs-built_in">get</span>()) &#123;<br>                            <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;channel &#x27;%s&#x27; ~ Receiver object was finalized &quot;</span><br>                                    <span class="hljs-string">&quot;without being disposed.&quot;</span>, <span class="hljs-built_in">getInputChannelName</span>().<span class="hljs-built_in">c_str</span>());<br>                            <span class="hljs-keyword">return</span> DEAD_OBJECT;<br>                        &#125;<br>                    &#125;<br><br>                    mBatchedInputEventPending = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (kDebugDispatchCycle) &#123;<br>                        <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;channel &#x27;%s&#x27; ~ Dispatching batched input event pending notification.&quot;</span>,<br>                                <span class="hljs-built_in">getInputChannelName</span>().<span class="hljs-built_in">c_str</span>());<br>                    &#125;<br>                  <span class="hljs-comment">//调用 InputReceiver.dispatchBatchedInputEventPending()</span><br>                    env-&gt;<span class="hljs-built_in">CallVoidMethod</span>(receiverObj.<span class="hljs-built_in">get</span>(),<br>                            gInputEventReceiverClassInfo.dispatchBatchedInputEventPending);<br>                    <span class="hljs-keyword">if</span> (env-&gt;<span class="hljs-built_in">ExceptionCheck</span>()) &#123;<br>                        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Exception dispatching batched input events.&quot;</span>);<br>                        mBatchedInputEventPending = <span class="hljs-literal">false</span>; <span class="hljs-comment">// try again later</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> OK;<br>            &#125;<br>            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;channel &#x27;%s&#x27; ~ Failed to consume input event.  status=%d&quot;</span>,<br>                    <span class="hljs-built_in">getInputChannelName</span>().<span class="hljs-built_in">c_str</span>(), status);<br>            <span class="hljs-keyword">return</span> status;<br>        &#125;    <br>    ...<br>        <span class="hljs-keyword">if</span> (!skipCallbacks) &#123;<br><br>            jobject inputEventObj;<br>            <span class="hljs-keyword">switch</span> (inputEvent-&gt;<span class="hljs-built_in">getType</span>()) &#123;<br><br>            <span class="hljs-keyword">case</span> AINPUT_EVENT_TYPE_MOTION: &#123;<br>                <span class="hljs-keyword">if</span> (kDebugDispatchCycle) &#123;<br>                    <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;channel &#x27;%s&#x27; ~ Received motion event.&quot;</span>, <span class="hljs-built_in">getInputChannelName</span>().<span class="hljs-built_in">c_str</span>());<br>                &#125;<br>              <span class="hljs-comment">//封装MotionEvent对象</span><br>                MotionEvent* motionEvent = <span class="hljs-built_in">static_cast</span>&lt;MotionEvent*&gt;(inputEvent);<br>                <span class="hljs-keyword">if</span> ((motionEvent-&gt;<span class="hljs-built_in">getAction</span>() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123;<br>                    *outConsumedBatch = <span class="hljs-literal">true</span>;<br>                &#125;<br>                inputEventObj = <span class="hljs-built_in">android_view_MotionEvent_obtainAsCopy</span>(env, motionEvent);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// InputConsumer should prevent this from ever happening</span><br>                inputEventObj = <span class="hljs-literal">NULL</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (inputEventObj) &#123;<br>                <span class="hljs-keyword">if</span> (kDebugDispatchCycle) &#123;<br>                    <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;channel &#x27;%s&#x27; ~ Dispatching input event.&quot;</span>, <span class="hljs-built_in">getInputChannelName</span>().<span class="hljs-built_in">c_str</span>());<br>                &#125;<br>              <span class="hljs-comment">//回调到Java层的 dispatchInputEvent() </span><br>                env-&gt;<span class="hljs-built_in">CallVoidMethod</span>(receiverObj.<span class="hljs-built_in">get</span>(),<br>                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj,<br>                        displayId);<br>                <span class="hljs-keyword">if</span> (env-&gt;<span class="hljs-built_in">ExceptionCheck</span>()) &#123;<br>                    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Exception dispatching input event.&quot;</span>);<br>                    skipCallbacks = <span class="hljs-literal">true</span>;<br>                &#125;<br>                env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(inputEventObj);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;channel &#x27;%s&#x27; ~ Failed to obtain event object.&quot;</span>,<br>                        <span class="hljs-built_in">getInputChannelName</span>().<span class="hljs-built_in">c_str</span>());<br>                skipCallbacks = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;    <br>    <br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/libs/input/InputTransport.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">InputConsumer::consume</span><span class="hljs-params">(InputEventFactoryInterface* factory,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">bool</span> consumeBatches, <span class="hljs-type">nsecs_t</span> frameTime, <span class="hljs-type">uint32_t</span>* outSeq, InputEvent** outEvent,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int32_t</span>* displayId)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!*outEvent) &#123;<br>            mMsgDeferred = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 收到新消息</span><br>            <span class="hljs-type">status_t</span> result = mChannel-&gt;<span class="hljs-built_in">receiveMessage</span>(&amp;mMsg);<br>            <span class="hljs-keyword">if</span> (result) &#123;<br>                <span class="hljs-keyword">if</span> (consumeBatches || result != WOULD_BLOCK) &#123;<br>                    result = <span class="hljs-built_in">consumeBatch</span>(factory, frameTime, outSeq, outEvent, displayId);<br>                    <span class="hljs-keyword">if</span> (*outEvent) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>





<p><code>WindowInputEventReceiver</code>主要执行了以下几步：</p>
<ul>
<li>初始化了<code>NativeInputReceiver</code>，调用了<code>sendFdEvents()</code>发出了消息</li>
<li>往主线程Looper添加了一条<code>Native Request</code>，且<code>callback</code>为<code>NativeInputReceiver</code></li>
<li>向Looper的<code>mEpollFd</code>添加了监听，只要收到触摸事件的消息就会调用到<code>callback-&gt;handleEvent()</code></li>
<li><code>NativeInputReceiver::handleEvent()</code>主要回调到Java层的<code>dispatchInputEvent()</code>且携带<code>InputEvent</code>回去(在触摸场景下，实际为<code>MotionEvent</code>)。</li>
</ul>
<h4 id="回调到Activity"><a href="#回调到Activity" class="headerlink" title="回调到Activity"></a>回调到Activity</h4><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E5%9B%9E%E8%B0%83%E5%88%B0Activity.png" srcset="/img/loading.gif" lazyload alt="事件分发-回调到Activity"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//InputEventReceiver.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchInputEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> seq, InputEvent event, <span class="hljs-type">int</span> displayId)</span> &#123;<br>        mSeqMap.put(event.getSequenceNumber(), seq);<br>        onInputEvent(event, displayId);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchBatchedInputEventPending</span><span class="hljs-params">()</span> &#123;<br>        onBatchedInputEventPending();<br>    &#125;<br><br><br><span class="hljs-comment">//ViewRootImpl.java</span><br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowInputEventReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputEventReceiver</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onInputEvent</span><span class="hljs-params">(InputEvent event, <span class="hljs-type">int</span> displayId)</span> &#123;<br>            enqueueInputEvent(event, <span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>        &#125;<br>      <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBatchedInputEventPending</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (mUnbufferedInputDispatch) &#123;<br>                <span class="hljs-built_in">super</span>.onBatchedInputEventPending();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                scheduleConsumeBatchedInput();<span class="hljs-comment">//按照Vsync信号进行分发</span><br>            &#125;<br>        &#125;<br>      <br>    &#125;<br><br><span class="hljs-comment">//事件</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleConsumeBatchedInput</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!mConsumeBatchedInputScheduled) &#123;<br>            mConsumeBatchedInputScheduled = <span class="hljs-literal">true</span>;<br>          <span class="hljs-comment">//根据Vsync信号 进行触摸事件的回调</span><br>            mChoreographer.postCallback(Choreographer.CALLBACK_INPUT,<br>                    mConsumedBatchedInputRunnable, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueueInputEvent</span><span class="hljs-params">(InputEvent event,</span><br><span class="hljs-params">            InputEventReceiver receiver, <span class="hljs-type">int</span> flags, <span class="hljs-type">boolean</span> processImmediately)</span> &#123;<br>        adjustInputEventForCompatibility(event);<br>        <span class="hljs-type">QueuedInputEvent</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> obtainQueuedInputEvent(event, receiver, flags);<br><br>        <span class="hljs-keyword">if</span> (processImmediately) &#123;<br>            doProcessInputEvents();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            scheduleProcessInputEvents();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doProcessInputEvents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Deliver all pending input events in the queue.</span><br>        <span class="hljs-keyword">while</span> (mPendingInputEventHead != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">QueuedInputEvent</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> mPendingInputEventHead;<br>            mPendingInputEventHead = q.mNext;<br>            <span class="hljs-keyword">if</span> (mPendingInputEventHead == <span class="hljs-literal">null</span>) &#123;<br>                mPendingInputEventTail = <span class="hljs-literal">null</span>;<br>            &#125;<br>            q.mNext = <span class="hljs-literal">null</span>;<br><br>            <span class="hljs-keyword">if</span> (q.mEvent <span class="hljs-keyword">instanceof</span> MotionEvent) &#123;<br>                <span class="hljs-type">MotionEvent</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> (MotionEvent)q.mEvent;<br>                <span class="hljs-keyword">if</span> (me.getHistorySize() &gt; <span class="hljs-number">0</span>) &#123;<br>                    oldestEventTime = me.getHistoricalEventTimeNano(<span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>            mChoreographer.mFrameInfo.updateInputEventTime(eventTime, oldestEventTime);<br><br>            deliverInputEvent(q);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deliverInputEvent</span><span class="hljs-params">(QueuedInputEvent q)</span> &#123;<br><br>        InputStage stage;<br>        <span class="hljs-keyword">if</span> (q.shouldSendToSynthesizer()) &#123;<br>            stage = mSyntheticInputStage;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (stage != <span class="hljs-literal">null</span>) &#123;<br>            handleWindowFocusChanged();<br>            stage.deliver(q);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//事件分发完成后 执行</span><br>            finishInputEvent(q);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputStage</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deliver</span><span class="hljs-params">(QueuedInputEvent q)</span> &#123;<br>            <span class="hljs-keyword">if</span> ((q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED) != <span class="hljs-number">0</span>) &#123;<br>                forward(q);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shouldDropInputEvent(q)) &#123;<br>                finish(q, <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                apply(q, onProcess(q));<br>            &#125;<br>        &#125;      <br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>此处<code>stage</code>是<code>ViewPostImeInputStage</code>，向下继续调用到<code>onProcess()</code></p>
<p><code>ViewPostImeInputStage</code>：<strong>视图处理阶段</strong>，主要处理按键、手指触摸等事件，分发的对象是View。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//viewRootImpl.java</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewPostImeInputStage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStage</span> &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">onProcess</span><span class="hljs-params">(QueuedInputEvent q)</span> &#123;<br>          <span class="hljs-comment">//按键事件</span><br>            <span class="hljs-keyword">if</span> (q.mEvent <span class="hljs-keyword">instanceof</span> KeyEvent) &#123;<br>                <span class="hljs-keyword">return</span> processKeyEvent(q);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//触摸事件</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> q.mEvent.getSource();<br>                <span class="hljs-keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> processPointerEvent(q);<br>                &#125;<br>            &#125;<br>        &#125;<br>      <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">processPointerEvent</span><span class="hljs-params">(QueuedInputEvent q)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">MotionEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> (MotionEvent)q.mEvent;<br><br>            mAttachInfo.mUnbufferedDispatchRequested = <span class="hljs-literal">false</span>;<br>            mAttachInfo.mHandlingPointerEvent = <span class="hljs-literal">true</span>;<br>          <span class="hljs-comment">//向下分发到View</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> mView.dispatchPointerEvent(event);<br>  <br>            <span class="hljs-keyword">return</span> handled ? FINISH_HANDLED : FORWARD;<br>        &#125;      <br>      <br>    &#125;<br></code></pre></td></tr></table></figure>

<p>此时<code>mView</code>表示的就是<code>DecorView</code>，本质就是View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//view.java    </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchPointerEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (event.isTouchEvent()) &#123;<br>            <span class="hljs-keyword">return</span> dispatchTouchEvent(event);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> dispatchGenericMotionEvent(event);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//DecorView.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>        <span class="hljs-keyword">final</span> Window.<span class="hljs-type">Callback</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> mWindow.getCallback();<br>        <span class="hljs-keyword">return</span> cb != <span class="hljs-literal">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="hljs-number">0</span><br>                ? cb.dispatchTouchEvent(ev) : <span class="hljs-built_in">super</span>.dispatchTouchEvent(ev);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>mWindow.getCallback()</code>就是与Window绑定的Activity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Activity.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;<br>            onUserInteraction();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> onTouchEvent(ev);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>所以经过一系列操作 让用户的屏幕触摸操作，最终走到了<code>Activity.dispatchTouchEvent()</code></p>
<p><img src="/images/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9C%9F%E5%AE%9E%E9%A1%BA%E5%BA%8F.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><h3 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h3><p><img src="/images/MotionEvent.png" srcset="/img/loading.gif" lazyload alt="MotionEvent"></p>
<blockquote>
<p>当用户点击View或ViewGroup的时候，将会产生一个事件对象，就是<code>MotionEvent</code>。</p>
</blockquote>
<p><code>MotionEvent</code>记录了<code>事件的类型(action)、触摸的位置(x,y)以及触摸的时间等</code>。</p>
<p>事件的类型主要分为以下几种：</p>
<ul>
<li><code>ACTION_DOWN</code>：监听用户手指按下的操作，一次按下标志触摸事件的开始。</li>
<li><code>ACTION_MOVE</code>：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。</li>
<li><code>ACTION_UP</code>：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。</li>
<li><code>ACTION_CANCEL</code>：当用户保持按下操作，并把手指移动到了控件外部区域时且父View处理事件触发。</li>
</ul>
<p>用户手指触摸到屏幕到离开屏幕可能产生的事件序列如下：</p>
<p><code>ACTION_DOWN</code> -&gt; <code>ACTION_MOVE</code> -&gt; <code>ACTION_MOVE</code> -&gt; … <code>ACTION_MOVE</code> -&gt; <code>ACTION_UP</code></p>
<p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E9%A1%BA%E5%BA%8F.jpg" srcset="/img/loading.gif" lazyload alt="事件分发顺序"></p>
<h3 id="MotionEvent产生时机"><a href="#MotionEvent产生时机" class="headerlink" title="MotionEvent产生时机"></a>MotionEvent产生时机</h3><p><img src="/images/MotionEvent%E4%BA%A7%E7%94%9F%E6%97%B6%E6%9C%BA.png" srcset="/img/loading.gif" lazyload alt="产生时机"></p>
<p>在<code>ViewRootImpl.setView()</code>时，创建了<code>WindowInputReceiver</code>，当IMS写入事件(通过EventHub监听到<code>/dev/input/</code>)，通过一系列的操作回调到<code>dispatchInputEvent()</code>，最后走到了<code>processPointerEvent()</code>，此时把从Native层传递过来的<code>InputEvent</code>强转成<code>MotionEvent</code>，然后继续向下传递。</p>
<h3 id="MotionEvent传递顺序-事件分发顺序"><a href="#MotionEvent传递顺序-事件分发顺序" class="headerlink" title="MotionEvent传递顺序-事件分发顺序"></a>MotionEvent传递顺序-事件分发顺序</h3><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E9%A1%BA%E5%BA%8F.png" srcset="/img/loading.gif" lazyload alt="事件分发顺序"></p>
<p>事件分发本质就是<code>MotionEvent</code>的传递过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">processPointerEvent</span><span class="hljs-params">(QueuedInputEvent q)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">MotionEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> (MotionEvent)q.mEvent;<br><br>            mAttachInfo.mUnbufferedDispatchRequested = <span class="hljs-literal">false</span>;<br>            mAttachInfo.mHandlingPointerEvent = <span class="hljs-literal">true</span>;<br>          <span class="hljs-comment">//向下分发到View</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> mView.dispatchPointerEvent(event);<br>  <br>            <span class="hljs-keyword">return</span> handled ? FINISH_HANDLED : FORWARD;<br>        &#125;      <br>      <br><br></code></pre></td></tr></table></figure>

<p><code>mView</code>就是<code>DecorView</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DecorView.java</span><br>没有实现对应方法。。。<br>向上寻找父类<br>  <br><span class="hljs-comment">//View.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchPointerEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (event.isTouchEvent()) &#123;<br>            <span class="hljs-keyword">return</span> dispatchTouchEvent(event);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> dispatchGenericMotionEvent(event);<br>        &#125;<br>    &#125;<br>  <br><br><span class="hljs-comment">//DecorView.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>        <span class="hljs-keyword">final</span> Window.<span class="hljs-type">Callback</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> mWindow.getCallback();<br>        <span class="hljs-keyword">return</span> cb != <span class="hljs-literal">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="hljs-number">0</span><br>                ? cb.dispatchTouchEvent(ev) : <span class="hljs-built_in">super</span>.dispatchTouchEvent(ev);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>此时<code>mWindow.getCallback()</code>指的就是<code>Activity</code></p>
<h4 id="Activity事件分发"><a href="#Activity事件分发" class="headerlink" title="Activity事件分发"></a>Activity事件分发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;<br>      <span class="hljs-comment">//在此处可以监听到 用户触摸屏幕的操作</span><br>        onUserInteraction();<br>    &#125;<br>   <span class="hljs-comment">//若dispatchTouchEvent返回true，事件到此结束，返回false，继续向下传递</span><br>  <span class="hljs-comment">//对应PhoneWindow</span><br>    <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  <span class="hljs-comment">//没有任何View去处理，交给Activity自身的onTouchEvent处理</span><br>    <span class="hljs-keyword">return</span> onTouchEvent(ev);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>getWindow()</code>对应唯一实现类<code>PhoneWindow</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//PhoneWindow.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>      <span class="hljs-comment">//mDecor 是DecorView的一个实例，DecoeView就是顶层View中的实例对象</span><br>        <span class="hljs-keyword">return</span> mDecor.superDispatchTouchEvent(event);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>mDecor</code>指的就是<code>DecorView</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DecorView.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>      <span class="hljs-comment">//调用父类的方法即FrameLayout.dispatchTouchEvent = ViewGroup.dispatchTouchEvent()，由父类去处理事件分发</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<span class="hljs-comment">//指向了 ViewGroup</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/Activity-Dispatch.png" srcset="/img/loading.gif" lazyload alt="Activity事件分发"></p>
<p>总结一下：按照上述流程图，当一个点击事件进来时，Activity上的事件流程如下：</p>
<ul>
<li>调用<code>Activity.dispatchTouchEvent()</code>，然后调用<code>onUserInteraction()</code></li>
<li>调用<code>getWindow()即PhoneWindow.superDispatchTouchEvent()</code></li>
<li>调用<code>mDecor即DecorView.superDispatchTouchEvent()</code></li>
<li>调用DecorView父类即**<code>ViewGroup.dispatchTouchEvent()</code>** 在这里实现了事件从Activity传递至ViewGroup</li>
</ul>
<h4 id="ViewGroup事件分发"><a href="#ViewGroup事件分发" class="headerlink" title="ViewGroup事件分发"></a>ViewGroup事件分发</h4><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-ViewGroup.png" srcset="/img/loading.gif" lazyload alt="ViewGroup事件分发"></p>
<p>上述Activity分发后，执行到<code>ViewGroup.dispatchTouchEvent()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewGroup.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>      ...<br>        <br>            <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;<br>              <span class="hljs-comment">//发生ACTION_DOWN事件，取消并清除之前的触摸</span><br>                cancelAndClearTouchTargets(ev);<br>                resetTouchState();<br>            &#125;        <br>      ...<br>          <span class="hljs-comment">//判定当前事件是否需要拦截</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> intercepted;<br>            <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>                    || mFirstTouchTarget != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//只有ACTION_DOWN才可以触发拦截</span><br>                <span class="hljs-comment">//FLAG_DISALLOW_INTERCEPT：禁止ViewGroup拦截除了DOWN以外的事件</span><br>                <span class="hljs-comment">//可由View调用requestDisallowInterceptTouchEvent设置标记</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">disallowIntercept</span> <span class="hljs-operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;<br>                  <span class="hljs-comment">//调用拦截方法</span><br>                    intercepted = onInterceptTouchEvent(ev);<br>                    ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    intercepted = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-comment">//没有触摸targets 且 非ACTION_DOWN 需要拦截</span><br>                intercepted = <span class="hljs-literal">true</span>;<br>            &#125;   <br>      ...<br>           <span class="hljs-comment">//非取消事件 且 没被拦截</span><br>            <span class="hljs-keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;<br>                <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)<br>                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;<span class="hljs-comment">//当前为 DOWN 事件</span><br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">actionIndex</span> <span class="hljs-operator">=</span> ev.getActionIndex(); <span class="hljs-comment">// always 0 for down</span><br>                   <span class="hljs-comment">//存在子View</span><br>                    <span class="hljs-keyword">if</span> (newTouchTarget == <span class="hljs-literal">null</span> &amp;&amp; childrenCount != <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> ev.getX(actionIndex);<br>                        <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> ev.getY(actionIndex);<br>                      <span class="hljs-comment">//从上往下 寻找能处理触摸事件的子View</span><br>                        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();<br>                        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">customOrder</span> <span class="hljs-operator">=</span> preorderedList == <span class="hljs-literal">null</span><br>                                &amp;&amp; isChildrenDrawingOrderEnabled();<br>                        <span class="hljs-keyword">final</span> View[] children = mChildren;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childIndex</span> <span class="hljs-operator">=</span> getAndVerifyPreorderedIndex(<br>                                    childrenCount, i, customOrder);<br>                            <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getAndVerifyPreorderedView(<br>                                    preorderedList, children, childIndex);<br>                           <span class="hljs-comment">//无法获取焦点，跳过循环</span><br>                            <span class="hljs-keyword">if</span> (childWithAccessibilityFocus != <span class="hljs-literal">null</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (childWithAccessibilityFocus != child) &#123;<br>                                    <span class="hljs-keyword">continue</span>;<br>                                &#125;<br>                                childWithAccessibilityFocus = <span class="hljs-literal">null</span>;<br>                                i = childrenCount - <span class="hljs-number">1</span>;<br>                            &#125;<br>                          <span class="hljs-comment">//View不可见 或者 触摸的坐标点不在View的范围内，跳过循环</span><br>                            <span class="hljs-keyword">if</span> (!canViewReceivePointerEvents(child)<br>                                    || !isTransformedTouchPointInView(x, y, child, <span class="hljs-literal">null</span>)) &#123;<br>                                ev.setTargetAccessibilityFocus(<span class="hljs-literal">false</span>);<br>                                <span class="hljs-keyword">continue</span>;<br>                            &#125;<br><br>                            newTouchTarget = getTouchTarget(child);<br>                          <span class="hljs-comment">//当前正在循环 ，退出当前循环</span><br>                            <span class="hljs-keyword">if</span> (newTouchTarget != <span class="hljs-literal">null</span>) &#123;<br>                                <span class="hljs-comment">// Child is already receiving touch within its bounds.</span><br>                                <span class="hljs-comment">// Give it the new pointer in addition to the ones it is handling.</span><br>                                newTouchTarget.pointerIdBits |= idBitsToAssign;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br><br>                            resetCancelNextUpFlag(child);<br>                          <span class="hljs-comment">////事件传递下来后，调用dispatchTransformedTouchEvent，事件就会传递到View/ViewGroup中       </span><br>                            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-literal">false</span>, child, idBitsToAssign)) &#123;<br>                                <span class="hljs-comment">// Child wants to receive touch within its bounds.</span><br>                                mLastTouchDownTime = ev.getDownTime();<br>                                <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-literal">null</span>) &#123;<br>                                    <span class="hljs-comment">// childIndex points into presorted list, find original index</span><br>                                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; childrenCount; j++) &#123;<br>                                        <span class="hljs-keyword">if</span> (children[childIndex] == mChildren[j]) &#123;<br>                                            mLastTouchDownIndex = j;<br>                                            <span class="hljs-keyword">break</span>;<br>                                        &#125;<br>                                    &#125;<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    mLastTouchDownIndex = childIndex;<br>                                &#125;<br>                                mLastTouchDownX = ev.getX();<br>                                mLastTouchDownY = ev.getY();<br>                              <span class="hljs-comment">//添加新的 touchtarget</span><br>                                newTouchTarget = addTouchTarget(child, idBitsToAssign);<br>                                alreadyDispatchedToNewTouchTarget = <span class="hljs-literal">true</span>;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            ev.setTargetAccessibilityFocus(<span class="hljs-literal">false</span>);<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-literal">null</span>) preorderedList.clear();<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (newTouchTarget == <span class="hljs-literal">null</span> &amp;&amp; mFirstTouchTarget != <span class="hljs-literal">null</span>) &#123;<br>                        newTouchTarget = mFirstTouchTarget;<br>                        <span class="hljs-keyword">while</span> (newTouchTarget.next != <span class="hljs-literal">null</span>) &#123;<br>                            newTouchTarget = newTouchTarget.next;<br>                        &#125;<br>                        newTouchTarget.pointerIdBits |= idBitsToAssign;<br>                    &#125;                  <br>                &#125;<br>            &#125;<br>      <br>            <span class="hljs-comment">// mFirstTouchTarget赋值是在通过addTouchTarget方法获取的；</span><br>            <span class="hljs-comment">// 只有处理ACTION_DOWN事件，才会进入addTouchTarget方法。</span><br>            <span class="hljs-comment">// 这也正是当View没有消费ACTION_DOWN事件，则不会接收其他MOVE,UP等事件的原因</span><br>            <span class="hljs-keyword">if</span> (mFirstTouchTarget == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// ViewGroup处理事件 当无人可以响应触摸事件</span><br>                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-literal">null</span>,<br>                        TouchTarget.ALL_POINTER_IDS);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-comment">//如果View消费ACTION_DOWN事件，那么MOVE,UP等事件相继开始执行</span><br>                <span class="hljs-type">TouchTarget</span> <span class="hljs-variable">predecessor</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">TouchTarget</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> mFirstTouchTarget;<br>                <span class="hljs-keyword">while</span> (target != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">TouchTarget</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> target.next;<br>                    <span class="hljs-keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;<br>                        handled = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelChild</span> <span class="hljs-operator">=</span> resetCancelNextUpFlag(target.child)<br>                                || intercepted;<br>                      <span class="hljs-comment">//子View/ViewGroup 处理触摸事件</span><br>                        <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,<br>                                target.child, target.pointerIdBits)) &#123;<br>                            handled = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (cancelChild) &#123;<br>                            <span class="hljs-keyword">if</span> (predecessor == <span class="hljs-literal">null</span>) &#123;<br>                                mFirstTouchTarget = next;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                predecessor.next = next;<br>                            &#125;<br>                            target.recycle();<br>                            target = next;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                    &#125;<br>                    predecessor = target;<br>                    target = next;<br>                &#125;<br>            &#125;    <br>              ...<br>        &#125;<br>        <span class="hljs-keyword">return</span> handled;<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>

<h5 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent()"></a>onInterceptTouchEvent()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)<br>            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN<br>            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)<br>            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以通过重写该方法，进行事件分发的拦截。</p>
<ul>
<li>返回true，事件被拦截，执行当前View的<code>onTouchEvent()</code></li>
<li>返回false，事件继续向下分发</li>
</ul>
<h5 id="buildTouchDispatchChildList"><a href="#buildTouchDispatchChildList" class="headerlink" title="buildTouchDispatchChildList()"></a>buildTouchDispatchChildList()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> ArrayList&lt;View&gt; <span class="hljs-title function_">buildTouchDispatchChildList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buildOrderedChildList();<br>    &#125;<br><br>    ArrayList&lt;View&gt; <span class="hljs-title function_">buildOrderedChildList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childrenCount</span> <span class="hljs-operator">=</span> mChildrenCount;<br>        <span class="hljs-keyword">if</span> (childrenCount &lt;= <span class="hljs-number">1</span> || !hasChildWithZ()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-comment">//z</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">customOrder</span> <span class="hljs-operator">=</span> isChildrenDrawingOrderEnabled();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;<br>            <span class="hljs-comment">// add next child (in child order) to end of list</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childIndex</span> <span class="hljs-operator">=</span> getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">nextChild</span> <span class="hljs-operator">=</span> mChildren[childIndex];<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">currentZ</span> <span class="hljs-operator">=</span> nextChild.getZ();<br><br>            <span class="hljs-comment">// 按z轴，从小到大排序所有的子视图，即z轴大的View先响应事件</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">insertIndex</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span> (insertIndex &gt; <span class="hljs-number">0</span> &amp;&amp; mPreSortedChildren.get(insertIndex - <span class="hljs-number">1</span>).getZ() &gt; currentZ) &#123;<br>                insertIndex--;<br>            &#125;<br>            mPreSortedChildren.add(insertIndex, nextChild);<br>        &#125;<br>        <span class="hljs-keyword">return</span> mPreSortedChildren;<br>    &#125;<br><br><span class="hljs-comment">//View.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getZ</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getElevation() + getTranslationZ();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>默认的事件分发顺序与绘制顺序一致，按照<code>view.getZ()</code>从大到小排序，Z值大的先绘制且先响应事件。</p>
<p>当然，这个事件分发的顺序也可以修改，只需要实现两个方法：</p>
<ul>
<li><code>setChildrenDrawingOrderEnabled(true)</code>：允许自定义顺序。<em>isChildrenDrawingOrderEnabled()返回true</em></li>
<li><code>getChildDrawingOrder()</code>：自定义当前View的顺序</li>
</ul>
<p>也可以通过<code>setElevation()</code>、<code>setTranslationZ()</code>或者<code>setZ()</code>去修改Z轴的坐标值。</p>
<h5 id="dispatchTransformedTouchEvent"><a href="#dispatchTransformedTouchEvent" class="headerlink" title="dispatchTransformedTouchEvent()"></a>dispatchTransformedTouchEvent()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTransformedTouchEvent</span><span class="hljs-params">(MotionEvent event, <span class="hljs-type">boolean</span> cancel,</span><br><span class="hljs-params">        View child, <span class="hljs-type">int</span> desiredPointerIdBits)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> handled;<br><br>   <span class="hljs-comment">//发生取消事件后，不再执行后续的任何操作</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">oldAction</span> <span class="hljs-operator">=</span> event.getAction();<br>    <span class="hljs-keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;<br>        event.setAction(MotionEvent.ACTION_CANCEL);<br>        <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span>) &#123;<br>            handled = <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            handled = child.dispatchTouchEvent(event);<br>        &#125;<br>        event.setAction(oldAction);<br>        <span class="hljs-keyword">return</span> handled;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> MotionEvent transformedEvent;<br>    <span class="hljs-keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;<br>        <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span> || child.hasIdentityMatrix()) &#123;<br>            <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-comment">//不存在子视图，调用View.dispatchTouchEvent()</span><br>                handled = <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">offsetX</span> <span class="hljs-operator">=</span> mScrollX - child.mLeft;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">offsetY</span> <span class="hljs-operator">=</span> mScrollY - child.mTop;<br>                event.offsetLocation(offsetX, offsetY);<br>               <span class="hljs-comment">//调用子View/ViewGroup的 dispatchTouchEvent()</span><br>                handled = child.dispatchTouchEvent(event);<br><br>                event.offsetLocation(-offsetX, -offsetY);<br>            &#125;<br>            <span class="hljs-keyword">return</span> handled;<br>        &#125;<br>        transformedEvent = MotionEvent.obtain(event);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        transformedEvent = event.split(newPointerIdBits);<br>    &#125;<br><br>    <span class="hljs-comment">// Done.</span><br>    transformedEvent.recycle();<br>    <span class="hljs-keyword">return</span> handled;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>dispatchTransformedTouchEvent()</code>分为两套处理方式：</p>
<ul>
<li><code>child==null</code>：发生的情况：<code>事件被拦截</code>或<code>真的没有可执行触摸事件的子View</code>。执行<code>View.dispatchTouchEvent()</code></li>
<li><code>child!=null</code>：向下执行子View&#x2F;ViewGroup的<code>dispatchTouchEvent()</code></li>
</ul>
<h5 id="addTouchTarget"><a href="#addTouchTarget" class="headerlink" title="addTouchTarget()"></a>addTouchTarget()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> TouchTarget <span class="hljs-title function_">addTouchTarget</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child, <span class="hljs-type">int</span> pointerIdBits)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">TouchTarget</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> TouchTarget.obtain(child, pointerIdBits);<br>    target.next = mFirstTouchTarget;<br>    mFirstTouchTarget = target;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>TouchTarget</code>结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TouchTarget</span> &#123;<br>    <span class="hljs-comment">// The touched child view.</span><br>    <span class="hljs-keyword">public</span> View child;<br><br>    <span class="hljs-comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pointerIdBits;<br><br>    <span class="hljs-comment">// The next target in the target list.</span><br>    <span class="hljs-keyword">public</span> TouchTarget next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>TouchTarget</code>是一个单链表结构，记录的是<strong>事件分发链</strong>。每一个元素表示<code>真正对事件消费的View</code>。</p>
<p><img src="/images/ViewGroup-Dispatch.png" srcset="/img/loading.gif" lazyload alt="ViewGroup事件分发"></p>
<p>根据上述流程图，总结一下：</p>
<ul>
<li>点击事件从上层传递到ViewGroup，先调用<code>ViewGroup.dispatchTouchEvent()</code></li>
<li>判断<code>ViewGroup.onInterceptTouchEvent()</code>是否拦截点击事件<ul>
<li>默认不拦截，则将事件继续向子View传递，然后调用<code>View.dispatchTouchEvent()</code></li>
<li>被拦截返回<code>true</code>，调用<code>super.dispatchTouchEvent()</code>返给父布局处理，并且ViewGroup自身也处理事件，比如<code>onTouch(),onClick(),onTouchEvent()</code>等事件</li>
</ul>
</li>
</ul>
<blockquote>
<p>通常情况下ViewGroup的<code>onInterceptTouchEvent()</code>返回false，不会拦截用户操作。</p>
<p>不过要注意的是 拦截的是 一个用户的操作序列：<em>从用户手指按下到手指抬起为止。</em></p>
<ul>
<li>拦截了Down事件，后续的事件都会交由<code>ViewGroup.onTouchEvent()</code>处理</li>
<li>拦截了其他事件，会给之前序列头部的<code>ACTION_DOWN</code>事件发送一个<code>ACTION_CANCEL</code>类型事件，通知子View无法执行后续事件，回归初始状态。(<strong>例如点击ListView中的一个Item的Button，再滑动ListView，Button就会恢复初始状态。</strong>)</li>
</ul>
</blockquote>
<h4 id="View事件分发"><a href="#View事件分发" class="headerlink" title="View事件分发"></a>View事件分发</h4><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-View.png" srcset="/img/loading.gif" lazyload alt="View事件分发"></p>
<p>ViewGroup事件分发完毕后，由子View继续执行事件分发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java    </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;<br>            <span class="hljs-keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;<br>                result = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">//noinspection SimplifiableIfStatement</span><br>            <span class="hljs-type">ListenerInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> mListenerInfo;<br>            <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-literal">null</span> <span class="hljs-comment">//View设置了touch事件</span><br>                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED <span class="hljs-comment">//View是可以操作的</span><br>                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-built_in">this</span>, event)) &#123; <span class="hljs-comment">//View.onTouch返回true</span><br>                result = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>          <span class="hljs-comment">//上述任一条件不满足，就会执行 onTouchEvent()</span><br>            <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;<br>                result = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>dispatchTouchEvent()</code>按照如下顺序执行：</p>
<ol>
<li><code>onTouchListener.ouTouch()</code>开始执行，返回<code>true</code>表示当前事件已被消费，不需要向上执行。否则继续向下执行</li>
<li><code>onTouchEvent()</code>返回<code>true</code>表示消费事件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">clickable</span> <span class="hljs-operator">=</span> ((viewFlags &amp; CLICKABLE) == CLICKABLE <span class="hljs-comment">//有点击事件 调用setOnClickListener()</span><br>                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) <span class="hljs-comment">//有长按事件 调用setOnLongClickListener()</span><br>                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;<br>      <br>        <span class="hljs-keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;<br>            <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="hljs-number">0</span>) &#123;<br>                setPressed(<span class="hljs-literal">false</span>);<br>            &#125;<br>            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;<br>          <span class="hljs-comment">//当View不可用时 直接消费事件</span><br>            <span class="hljs-keyword">return</span> clickable;<br>        &#125;<br>      <br>      <span class="hljs-keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;<br>            <span class="hljs-keyword">switch</span> (action) &#123;<br>                <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>                        <span class="hljs-keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;<br>                            <span class="hljs-comment">// This is a tap, so remove the longpress check</span><br>                            removeLongPressCallback();<br><br>                            <span class="hljs-keyword">if</span> (!focusTaken) &#123;<br>                                <span class="hljs-keyword">if</span> (mPerformClick == <span class="hljs-literal">null</span>) &#123;<br>                                    mPerformClick = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformClick</span>();<br>                                &#125;<br>                                <span class="hljs-keyword">if</span> (!post(mPerformClick)) &#123;<br>                                  <span class="hljs-comment">//调用View.onClckListener</span><br>                                    performClickInternal();<br>                                &#125;<br>                            &#125;<br>                        &#125;                <br>            &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">performClickInternal</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">return</span> performClick();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">performClick</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> result;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ListenerInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> mListenerInfo;<br>        <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnClickListener != <span class="hljs-literal">null</span>) &#123;<br>            playSoundEffect(SoundEffectConstants.CLICK);<br>            li.mOnClickListener.onClick(<span class="hljs-built_in">this</span>);<br>            result = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>



<p><img src="/images/View-Dispatch.png" srcset="/img/loading.gif" lazyload alt="View事件分发"></p>
<p>根据上述流程图，总结一下：</p>
<ul>
<li>点击事件从ViewGroup传递到View，调用<code>View.dispatchTouchEvent()</code></li>
<li>判断当前View是否设置<code>OnTouchListener</code>，并且设置了<code>onTouch()</code>返回值，默认返回false<ul>
<li>返回<code>true</code>，代表事件被<code>onTouch()</code>消费，不会继续往下传递</li>
<li>返回<code>false</code>，事件继续向下传递，调用<code>View.onTouchEvent()</code>，后续若设置点击事件，则继续调用<code>performClick()</code>，最后执行<code>onClick()</code>事件</li>
</ul>
</li>
</ul>
<p>拓展：</p>
<blockquote>
<ol>
<li>如果有一个控件是<code>DISABLED</code>，注册的<code>onTouch()</code>事件不会被执行。若要监听点击事件，只能实现它的<code>onTouchEvent()</code></li>
<li>点击事件优先级： <code>onTouch()</code> &gt; <code>onTouchEvent()</code> &gt; <code>performClick()</code> &gt; <code>onClick()</code></li>
</ol>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>根据前几节分析得出完整的事件分发顺序：</p>
<p><strong>IMS -&gt; WindowInputREceiver(ViewRootImpl) -&gt; DecorView -&gt; Activity -&gt; DecorView -&gt; viewGroup -&gt; View</strong></p>
<h4 id="事件分发核心方法"><a href="#事件分发核心方法" class="headerlink" title="事件分发核心方法"></a>事件分发核心方法</h4><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt="事件分发核心方法"></p>
<p><code>boolean dispatchTouchEvent()</code></p>
<p>用来进行事件的分发。</p>
<ul>
<li>返回<code>true</code>：事件被当前View所消费，不会向下传递</li>
<li>返回<code>false</code>：交由上一层的View的<code>onTouchEvent()</code>处理</li>
<li>返回<code>super.dispatchTouchEvent()</code>：继续向下分发事件</li>
</ul>
<p><code>boolean onInterceptTouchEvent()</code></p>
<p>用来进行事件的拦截，在<code>dispatchOnTouchEvent()</code>中调用。<strong>只有ViewGroup才可以调用</strong></p>
<ul>
<li><p>返回<code>true</code>：拦截当前事件，并交由<code>onTouchEvent()</code>去处理</p>
</li>
<li><p>返回<code>false</code>：不拦截当前事件，继续向下传递</p>
</li>
<li><p>返回<code>super.onInterceptTouchEvent()</code>：调用父类的<code>onInterceptTouchEvent()</code>，大部分情况下是<code>false</code>。</p>
<p>如果点击了子View区域，可以继续分发到<code>child.dispatchTouchEvent()</code></p>
<p>没有子View可以响应事件，执行<code>onTouchEvent()</code></p>
</li>
</ul>
<p><code>boolean onTouchEvent()</code></p>
<p>用来处理点击事件，在<code>dispatchOnTouchEvent()</code>中调用。</p>
<ul>
<li><p>返回<code>true</code>：当前View处理当前事件</p>
</li>
<li><p>返回<code>false</code>：当前View无法处理事件，交由上一层View的<code>onTouchEvent()</code>处理</p>
</li>
<li><p>返回<code>super.onTouchEvent()</code></p>
<p>当前View设置了<code>clickable/longclickable</code>，等价于返回true，当前View处理事件</p>
<p>当前View未设置<code>clickable/longclickable</code>，等价于返回false,交由上一层的<code>onTouchEvent()</code>处理。</p>
</li>
</ul>
<p>上述三个核心方法，可以用如下伪代码代替</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 是否不允许拦截事件</span><br>    <span class="hljs-comment">// 如果设置了 FLAG_DISALLOW_INTERCEPT，不会拦截事件，所以在 child 里可以通过 requestDisallowInterceptTouchEvent 控制父 View 是否来拦截事件</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">disallowIntercept</span> <span class="hljs-operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent()) &#123; <span class="hljs-comment">// View 不调用这里，直接执行下面的 touchlistener 判断</span><br>        <span class="hljs-keyword">if</span> (touchlistener &amp;&amp; touchlistener.onTouch()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        res = onTouchEvent(); <span class="hljs-comment">// 里面会处理点击事件 -&gt; performClick() -&gt; clicklistener.onClick()</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DOWN) &#123; <span class="hljs-comment">// 如果是 DOWN 事件，则遍历子 View 进行事件分发</span><br>        <span class="hljs-comment">// 循环子 View 处理事件</span><br>        <span class="hljs-keyword">for</span> (childs) &#123;<br>            res = child.dispatchTouchEvent();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 事件分发给 target 去处理，这里的 target 就是上一步处理 DOWN 事件的 View</span><br>        target.child.dispatchTouchEvent();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/images/TouchEvent-Transmit.png" srcset="/img/loading.gif" lazyload alt="事件分发"></p>
<ol>
<li>点击事件传递从<code>dispatchTouchEvent()</code>开始，在不修改默认返回值时，事件会按照嵌套层次由外向内传递，到达最内层View时，由最内层<code>View.onTouchEvent()</code>处理</li>
<li>View的点击事件触发顺序为  <code>onTouch()</code> &gt; <code>onTouchEvent()</code> &gt; <code>performClick()</code> &gt; <code>onClick()</code> </li>
<li><em>Touch事件的后续(例如<code>ACTION_MOVE</code>,<code>ACTION_UP</code>)层级传递</em><ul>
<li>若<code>dispatchTouchEvent()</code>返回true，那么能收到<code>ACTION_DOWN</code>的函数也可以收到后续事件</li>
<li>若<code>onTouchEvent()</code>返回true，那么其他事件不再往下传递，而是直接传给自己的<code>onTouchEvent()</code>并结束本次事件传递</li>
</ul>
</li>
</ol>
<blockquote>
<p>事件分发核心在于<code>ViewGroup.dispatchTouchEvent()</code>的<code>ACTION_DOWN</code>过程中找到<code>mFirstTouchTarget</code>是否为空。</p>
<p>通过遍历子View寻找<code>view.disptachTouchEvent()</code>返回<code>true</code>，就设置<code>mFirstTouchTarget</code>为该子View。</p>
<p>如果<code>mFirstTarget</code>不为空，<code>ACTION_MOVE</code>和<code>ACTION_UP</code>才会向子View传递，如果中途被<code>ViewGroup</code>拦截了事件，子View就会收到<code>ACTION_CANCEL</code>，并且<code>mFirstTouchTarget</code>为null，后续的事件只会走到<code>ViewGroup</code>。</p>
</blockquote>
<h4 id="事件分发特殊情况"><a href="#事件分发特殊情况" class="headerlink" title="事件分发特殊情况"></a>事件分发特殊情况</h4><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5.png" srcset="/img/loading.gif" lazyload alt="事件分发特殊情况"></p>
<h5 id="ACTIOIN-CANCEL产生场景"><a href="#ACTIOIN-CANCEL产生场景" class="headerlink" title="ACTIOIN_CANCEL产生场景"></a><code>ACTIOIN_CANCEL</code>产生场景</h5><ol>
<li><p>子View处理了Down事件，按照设定Move与Up的事件也会交给他处理。若此时，父View拦截了事件，此时子View就会收到一个Cancel事件，并且无法接收到后续的Move与Up事件。</p>
<p>常见场景：ListView有一个Item带有Button，此时点击按钮(触发ACTION_DOWN)，再进行上下滑动，ListView就会拦截掉后续的Move事件，此时Button就会收到ACTION_CANCEL</p>
</li>
<li><p>子View收到ACTION_DOWN，但是上一个事件还没有结束(因为APP切换、ANR导致后续事件丢失)，此时也会执行ACTION_CANCEL</p>
</li>
</ol>
<h5 id="子View拦截父View事件"><a href="#子View拦截父View事件" class="headerlink" title="子View拦截父View事件"></a>子View拦截父View事件</h5><p>子View通过使用<code>requestDisallowInterceptTouchEvent(true)</code>命令<strong>指定ViewGroup不再针对事件序列进行拦截</strong>，将事件交由子View去处理。</p>
<p><em>设置<code>requestDisallowInterceptTouchEvent(true)</code>后，父类会在每次<code>ACTION_DOWN</code>的时候进行重置，避免影响其他子View的事件处理。</em></p>
<p>上述方法也是解决<code>滑动冲突</code>的一种方法：</p>
<p><code>内部拦截法</code>：通过在子类中调用<code>parent.requestDisallowInterceptTouchEvent()</code>来控制父类是否拦截事件。</p>
<p>还有一个是</p>
<p><code>外部拦截法</code>：通过重写父类的<code>onInterceptTouchEvent()</code>拦截冲突的事件。</p>
<h4 id="长按事件原理"><a href="#长按事件原理" class="headerlink" title="长按事件原理"></a>长按事件原理</h4><p>在<code>onTouchEvent()</code>收到<code>ACTION_DOWN</code>事件时，发送一个延时消息<code>mPendingCheckForLongPress()</code>，延迟<code>400ms</code>后执行。内部执行<code>performLongClick()</code>，再然后一步步调用到<code>performLongClickInternal()</code>内部执行到<code>mOnLongClickListener.onLongClick()</code></p>
<p><code>onLongClick()</code>返回<code>true</code>就会屏蔽<code>onClick()</code>执行。</p>
<h2 id="事件分发完成"><a href="#事件分发完成" class="headerlink" title="事件分发完成"></a>事件分发完成</h2><p>事件分发完毕后，执行到<code>finishInputEvent()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDeliverToNext</span><span class="hljs-params">(QueuedInputEvent q)</span> &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_INPUT_STAGES) &#123;<br>                Log.v(mTag, <span class="hljs-string">&quot;Done with &quot;</span> + getClass().getSimpleName() + <span class="hljs-string">&quot;. &quot;</span> + q);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mNext != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-comment">//有任务继续执行</span><br>                mNext.deliver(q);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//无任务时 通知结束</span><br>                finishInputEvent(q);<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishInputEvent</span><span class="hljs-params">(QueuedInputEvent q)</span> &#123;<br>        Trace.asyncTraceEnd(Trace.TRACE_TAG_VIEW, <span class="hljs-string">&quot;deliverInputEvent&quot;</span>,<br>                q.mEvent.getSequenceNumber());<br><br>        <span class="hljs-keyword">if</span> (q.mReceiver != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">handled</span> <span class="hljs-operator">=</span> (q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED_HANDLED) != <span class="hljs-number">0</span>;<br>            q.mReceiver.finishInputEvent(q.mEvent, handled);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            q.mEvent.recycleIfNeededAfterDispatch();<br>        &#125;<br><br>        recycleQueuedInputEvent(q);<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//InputEventReceiver.java</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishInputEvent</span><span class="hljs-params">(InputEvent event, <span class="hljs-type">boolean</span> handled)</span> &#123;<br>     ...<br>      nativeFinishInputEvent(mReceiverPtr, seq, handled);<br>     ...<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>nativeFinishInputEvent()</code>通知事件结束到Native层</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/base/core/jni/android_view_InputEventReceiver.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">nativeFinishInputEvent</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jlong receiverPtr,</span></span><br><span class="hljs-params"><span class="hljs-function">        jint seq, jboolean handled)</span> </span>&#123;<br>    sp&lt;NativeInputEventReceiver&gt; receiver =<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;NativeInputEventReceiver*&gt;(receiverPtr);<br>  ...<br>    <span class="hljs-type">status_t</span> status = receiver-&gt;<span class="hljs-built_in">finishInputEvent</span>(seq, handled);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">NativeInputEventReceiver::finishInputEvent</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> seq, <span class="hljs-type">bool</span> handled)</span> </span>&#123;<br>  ...<br>    <span class="hljs-type">status_t</span> status = mInputConsumer.<span class="hljs-built_in">sendFinishedSignal</span>(seq, handled);<br>    <span class="hljs-keyword">if</span> (status) &#123;<br>        <span class="hljs-keyword">if</span> (status == WOULD_BLOCK) &#123;<br>          ...<br>            <span class="hljs-keyword">if</span> (mFinishQueue.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">setFdEvents</span>(ALOOPER_EVENT_INPUT | ALOOPER_EVENT_OUTPUT);<br>            &#125;<br>            <span class="hljs-keyword">return</span> OK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//frameworks/native/libs/input/InputTransport.cpp</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">InputConsumer::sendFinishedSignal</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> seq, <span class="hljs-type">bool</span> handled)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// Send finished signals for the batch sequence chain first.</span><br>    <span class="hljs-type">size_t</span> seqChainCount = mSeqChains.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (seqChainCount) &#123;<br>       ...<br>        <span class="hljs-type">status_t</span> status = OK;<br>        <span class="hljs-keyword">while</span> (!status &amp;&amp; chainIndex &gt; <span class="hljs-number">0</span>) &#123;<br>            chainIndex--;<br>          <br>            status = <span class="hljs-built_in">sendUnchainedFinishedSignal</span>(chainSeqs[chainIndex], handled);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Send finished signal for the last message in the batch.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sendUnchainedFinishedSignal</span>(seq, handled);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">InputConsumer::sendUnchainedFinishedSignal</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> seq, <span class="hljs-type">bool</span> handled)</span> </span>&#123;<br>    InputMessage msg;<br>    msg.header.type = InputMessage::TYPE_FINISHED;<br>    msg.body.finished.seq = seq;<br>    msg.body.finished.handled = handled;<br>  <span class="hljs-comment">//通过 InputChannel.sendMessage()发送消息通知</span><br>     <span class="hljs-keyword">return</span> mChannel-&gt;<span class="hljs-built_in">sendMessage</span>(&amp;msg);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>InputChannel.sendMessage()</code>之后，<code>InputDispatcher</code>线程被唤醒，回调到<code>handleReceiveCallback()</code>。执行到上面的<code>InputDispatcheThread</code>相关代码。</p>
<h2 id="相关示例"><a href="#相关示例" class="headerlink" title="相关示例"></a>相关示例</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="http://gityuan.com/2016/12/11/input-reader/">InputReaderThread</a></p>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/">Android相关源码</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31210271">一次触摸，Android 到底干了啥</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903926446161927#heading-14">反思|Android 事件分发机制的设计与实现</a></p>
<p><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/deepin-android-vol3/content/5.html">深入理解Android卷-III</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/" class="print-no-link">#Android</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Android-事件分发机制</div>
      <div>https://leo-wxy.github.io/2020/11/20/Android-事件分发机制/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Leo-Wxy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年11月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/12/12/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/" title="Android性能优化-布局优化">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android性能优化-布局优化</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/20/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/" title="Android-性能监控">
                        <span class="hidden-mobile">Android-性能监控</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
