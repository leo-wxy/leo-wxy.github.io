

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <meta name="description" content="HTTP的原理和工作机制 什么是HTTP? HyperText(可以指向其他文本的链接文本) Transfer Protocol——超文本传输协议。位于TCP/IP协议的最顶层——应用层。  从日常角度来说，在App中调用网络请求，直接就会使用到HTTP。发送数据(Request)到服务端，等待服务端数据处理完毕再返回(Response)到App，App在进行后续处理，例如页面展示等。 HTTP工">
<meta name="keywords" content="HTTP">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP的原理和工作机制">
<meta property="og:url" content="https://leo-wxy.github.io/2020/03/29/HTTP的原理和工作机制/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="HTTP的原理和工作机制 什么是HTTP? HyperText(可以指向其他文本的链接文本) Transfer Protocol——超文本传输协议。位于TCP/IP协议的最顶层——应用层。  从日常角度来说，在App中调用网络请求，直接就会使用到HTTP。发送数据(Request)到服务端，等待服务端数据处理完毕再返回(Response)到App，App在进行后续处理，例如页面展示等。 HTTP工">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTP大纲.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP优点和缺点mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTP报文结构mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP_RequestMessage.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP_ResponseMessage.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP请求方法mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP状态码mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP首部格式mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP缓存mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http缓存流程.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP-Cookiemind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/Cookie交互流程.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTPSmind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/对称密钥加解密过程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/非对称密钥加解密过程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTPS通信过程.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/中间人攻击">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP协议版本区别mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/v2-a3b152bfae26b0cfa2aa96ab2c638b4b_1440w.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/v2-bb03351e6eac392c2afd89dafcf1e90f_1440w.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/v2-fd019652daff484a0c06bbfb27404bc9_1440w.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP相关协议mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/URI结构.webp">
<meta property="og:updated_time" content="2020-12-06T06:08:23.000Z">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="HTTP的原理和工作机制">
<meta name="twitter:description" content="HTTP的原理和工作机制 什么是HTTP? HyperText(可以指向其他文本的链接文本) Transfer Protocol——超文本传输协议。位于TCP/IP协议的最顶层——应用层。  从日常角度来说，在App中调用网络请求，直接就会使用到HTTP。发送数据(Request)到服务端，等待服务端数据处理完毕再返回(Response)到App，App在进行后续处理，例如页面展示等。 HTTP工">
<meta name="twitter:image" content="https://leo-wxy.github.io/images/http/HTTP大纲.png">
  
  <title>HTTP的原理和工作机制 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.12","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="HTTP的原理和工作机制">
              
                HTTP的原理和工作机制
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-03-29 09:35" pubdate>
        2020年3月29日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      40 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">HTTP的原理和工作机制</h1>
            
            <div class="markdown-body">
              <h1 id="HTTP的原理和工作机制"><a href="#HTTP的原理和工作机制" class="headerlink" title="HTTP的原理和工作机制"></a>HTTP的原理和工作机制</h1><p><img src="/images/http/HTTP大纲.png" srcset="/img/loading.gif" lazyload="" alt="HTTP大纲"></p>
<h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h2><blockquote>
<p>HyperText(可以指向其他文本的链接文本) Transfer Protocol——超文本传输协议。位于<code>TCP/IP</code>协议的最顶层——应用层。</p>
</blockquote>
<p>从日常角度来说，在App中调用网络请求，直接就会使用到HTTP。发送数据(<code>Request</code>)到服务端，等待服务端数据处理完毕再返回(<code>Response</code>)到App，App在进行后续处理，例如页面展示等。</p>
<h3 id="HTTP工作机制"><a href="#HTTP工作机制" class="headerlink" title="HTTP工作机制"></a>HTTP工作机制</h3><h4 id="浏览器输入地址后发生了什么？"><a href="#浏览器输入地址后发生了什么？" class="headerlink" title="浏览器输入地址后发生了什么？"></a>浏览器输入地址后发生了什么？</h4><ul>
<li>浏览器向DNS服务器请求解析该url中的域名对应的IP地址</li>
<li>解析得到IP地址后，根据IP地址和端口，与服务器建立TCP连接</li>
<li>浏览器发出读取文件的HTTP请求</li>
<li>服务器对浏览器请求做出响应，返回html文本到浏览器</li>
<li>根据Header中的<code>Connection</code>判断是否需要释放TCP连接，若为<code>close</code>则关闭连接；为<code>keep-alive</code>则保持该连接一段时间，可以继续接受服务器数据</li>
<li>浏览器解析服务端返回的html文本并显示</li>
</ul>
<h3 id="HTTP特点与缺点"><a href="#HTTP特点与缺点" class="headerlink" title="HTTP特点与缺点"></a>HTTP特点与缺点</h3><p><img src="/images/HTTP优点和缺点mind.png" srcset="/img/loading.gif" lazyload="" alt="HTTP优点和缺点mind"></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>灵活可拓展<ul>
<li>只规定基本格式，没有语法的限制</li>
<li>传输形式多样性，支持文本、图片、视频等数据</li>
</ul>
</li>
<li>传输可靠，基于TCP/IP，继承其特性</li>
<li>无状态，通信过程不会记录上下文信息，每次请求都是独立的，减少了网络开销</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>无状态</p>
<p>需要长连接的场景中，需要保存信息时，导致传输大量无用的信息，这时就是缺点</p>
<p>如果只是单纯的获取数据，不需要保存信息时，反而减少了网络开销</p>
</li>
<li><p>明文传输</p>
<p>协议里的报文使用文本形式传递，为调试提供便利但是会把明文信息暴露给外界，导致请求不安全。</p>
</li>
<li><p>队头阻塞问题</p>
<p>当http开启长连接时(<code>Connection:Keep-Alive</code>)，共用同一个TCP连接，同一时刻只能处理同一个请求，当头部请求耗时过长，会导致后续请求堵塞，产生<strong>队头阻塞</strong>问题。</p>
</li>
</ul>
<h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><p><img src="/images/http/HTTP报文结构mind.png" srcset="/img/loading.gif" lazyload="" alt="HTTP报文结构mind"></p>
<h4 id="请求报文-Request"><a href="#请求报文-Request" class="headerlink" title="请求报文(Request)"></a>请求报文(<code>Request</code>)</h4><p><img src="/images/HTTP_RequestMessage.png" srcset="/img/loading.gif" lazyload="" alt="HTTP_RequestMessage"></p>
<h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><blockquote>
<p>声明请求方法、主机域名和协议版本</p>
</blockquote>
<p>基本格式： <strong>Method Request-URI HTTP-Version CRLF</strong></p>
<p>Method：表示请求方法，例如<code>GET、POST...</code></p>
<p>Request-URI：统一资源标识符，例如<code>https://leo-wxy.github.io/</code></p>
<p>HTTP-Version：HTTP协议版本，例如<code>HTTP/1.1 HTTP/2.0</code></p>
<p>CRLF：表示回车和换行，<code>\r\n</code></p>
<p>示例数据： <code>GET http://leo-wxy.github.io/ HTTP/1.1</code></p>
<h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><blockquote>
<p>声明客户端的首部信息</p>
</blockquote>
<p>参考后面章节的 <code>Headers</code></p>
<h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5><blockquote>
<p>存放客户端发送给服务端的数据信息，若为<code>GET</code>请求则没有该结构</p>
</blockquote>
<p>参考后面章节的 <code>Body</code></p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><table>
<thead>
<tr>
<th>请求行</th>
<th><strong>GET /test/index.html HTTP/1.1</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>请求头</strong></td>
<td>Host : <a href="http://www.github.io" target="_blank" rel="noopener">www.github.io</a></td>
</tr>
<tr>
<td></td>
<td>User-Agent : Mozilla/5.0</td>
</tr>
<tr>
<td><strong>空行</strong></td>
<td>(用于隔开请求头和请求体)</td>
</tr>
<tr>
<td><strong>请求体</strong></td>
<td>id=0&amp;page=1</td>
</tr>
</tbody>
</table>
<h4 id="响应报文-Response"><a href="#响应报文-Response" class="headerlink" title="响应报文(Response)"></a>响应报文(<code>Response</code>)</h4><p><img src="/images/HTTP_ResponseMessage.png" srcset="/img/loading.gif" lazyload="" alt="HTTP_ResponseMessage"></p>
<h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><blockquote>
<p>声明协议版本、状态码和描述(对状态码进行描述)</p>
</blockquote>
<p>​    基本格式： <strong>HTTP-Version Status-Code Reason-Parse CRLF</strong></p>
<p>​    HTTP-Version：HTTP协议版本，例如<code>HTTP/1.1 HTTP/2.0</code></p>
<p>​    Status-Code：服务器返回的状态码，对应上面的<a href="#响应状态码">响应状态码</a></p>
<p>​    Reason-Parse：状态码的文本描述，对应上面的<a href="#响应状态码">响应状态码</a></p>
<p>​    CRLF：表示回车和换行，<code>\r\n</code></p>
<p>​    示例数据： <code>HTTP/1.1 404 Not Found</code></p>
<h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><blockquote>
<p>声明客户端、服务端的报头信息</p>
</blockquote>
<p>参考后面章节的 <code>Headers</code></p>
<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><blockquote>
<p>存放反给客户端的数据信息</p>
</blockquote>
<p>参考后面章节的 <code>Body</code></p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><table>
<thead>
<tr>
<th>状态行</th>
<th>HTTP/1.1 200 OK</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>响应报头</strong></td>
<td>Connection : keep-alive</td>
</tr>
<tr>
<td></td>
<td>Server : Nginx</td>
</tr>
<tr>
<td><strong>空行</strong></td>
<td>(用于隔开响应头和响应正文)</td>
</tr>
<tr>
<td><strong>响应正文</strong></td>
<td>{“error”:false,”result”:1}</td>
</tr>
</tbody>
</table>
<h3 id="HTTP-Request-Methods"><a href="#HTTP-Request-Methods" class="headerlink" title="HTTP Request Methods"></a>HTTP Request Methods</h3><p><img src="/images/HTTP请求方法mind.png" srcset="/img/loading.gif" lazyload="" alt="HTTP请求方法mind.png"></p>
<blockquote>
<p>HTTP协议所定义的请求方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>作用</th>
<th>描述</th>
<th>简化</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取资源</td>
<td>客户端需要从服务器读取资源时使用<br>一般用于获取/查询信息<br>通过URL传递且参数长度是有限制的<br>请求格式 <code>/test/result?key=key&amp;page=1</code><br>请求是安全的，因为只读，不会改变服务器数据</td>
<td>用于获取资源<br> 不设置Body <br>不会改变服务器数据<br>符合<strong>幂等性</strong></td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>客户端向服务端提供信息时使用<br>可以附带数据，用于更新服务器数据<br>将请求参数封装在请求数据中，可传输大量数据<br>传参方式更加安全，但是请求是不安全的，会导致服务器数据发生改变</td>
<td>会改变服务器数据，增加或修改资源<br> 需要设置Body<br>不符合<strong>幂等性</strong></td>
</tr>
<tr>
<td>HEAD</td>
<td>获取报文首部</td>
<td>不返回报文实体部分，主要用于确认URL有效性以及资源更新日期</td>
<td>几乎与<code>GET</code>相同<br>服务器不返回Body<br>可用于下载场景，获取信息</td>
</tr>
<tr>
<td>PUT</td>
<td>上传文件</td>
<td>自身不带验证机制，存在安全性问题。<strong>一般不使用</strong></td>
<td>会改变服务器数据，只能修改资源<br>不设置Body<br>符合<strong>幂等性</strong></td>
</tr>
<tr>
<td>PATCH</td>
<td>对资源部分进行修改</td>
<td>可以部分对资源进行修改</td>
<td></td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
<td>自身不带验证机制，存在安全性问题。</td>
<td>会改变服务器数据，删除资源<br>不设置Body<br>符合<strong>幂等性</strong></td>
</tr>
<tr>
<td>OPTIONS</td>
<td>查询支持的方法</td>
<td>查询指定的URL可以提供的方法。<br>返回示例：<code>Allow: GET , POST</code></td>
<td></td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求与代理服务器通信时建立隧道</td>
<td>对通信内容进行加密后通过网络隧道传输</td>
<td></td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径</td>
<td>将通信路径返回给客户端</td>
</tr>
</tbody>
</table>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><h5 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a><strong>幂等性</strong></h5><blockquote>
<p>对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。</p>
</blockquote>
<p>HTTP请求方法中的<code>GET、PUT、DELETE</code>是满足<code>幂等性</code>的。</p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="GET和POST请求有什么区别？"><a href="#GET和POST请求有什么区别？" class="headerlink" title="GET和POST请求有什么区别？"></a>GET和POST请求有什么区别？</h5><ul>
<li>GET请求会被主动缓存下来，留下历史记录；POST不会缓存</li>
<li>GET方式提交的数据长度有限制(URL长度限制)，POST请求数据可以非常大</li>
<li>GET请求只能进行URL编码；POST没有限制</li>
<li>GET请求都是放在URL中的，安全性不高；POST可以放在请求体中，增强安全性</li>
<li><strong>(本质区别)GET请求是幂等的；POST不是</strong></li>
</ul>
<h3 id="HTTP-Status-Code"><a href="#HTTP-Status-Code" class="headerlink" title="HTTP Status Code"></a>HTTP Status Code</h3><p><img src="/images/HTTP状态码mind.png" srcset="/img/loading.gif" lazyload="" alt="HTTP状态码mind"></p>
<blockquote>
<p>位于服务端返回<strong>响应报文</strong>中的第一行，包含了状态码以及原因短语，用来告知客户端请求结果。</p>
</blockquote>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接收请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务端错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h4 id="1XX-信息状态码"><a href="#1XX-信息状态码" class="headerlink" title="1XX 信息状态码"></a>1XX 信息状态码</h4><ul>
<li>100 Continue：客户端继续发送请求</li>
<li>101 Switching Protocls：正在切换协议，可以切换HTTP 2.0</li>
</ul>
<h4 id="2XX-成功状态码"><a href="#2XX-成功状态码" class="headerlink" title="2XX 成功状态码"></a>2XX 成功状态码</h4><ul>
<li>200 OK：请求成功</li>
<li>204 No Content：请求成功，但没有body数据</li>
<li>206 Partial Content：部分内容，用于分块下载和断点续传，与<code>Content-Range</code>一起使用</li>
</ul>
<h4 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a>3XX 重定向状态码</h4><ul>
<li>301 Moved Permanently：永久性重定向 <em>常见</em></li>
<li>302 Found：临时性重定向</li>
<li>304 Not Modified：内容没有改变，与Http缓存有关</li>
</ul>
<h4 id="4XX-客户端错误状态码"><a href="#4XX-客户端错误状态码" class="headerlink" title="4XX 客户端错误状态码"></a>4XX 客户端错误状态码</h4><ul>
<li>400 Bad Request：请求报文存在语法错误</li>
<li>401 Unauthorized：未认证用户-<code>服务端不知道你是谁</code></li>
<li>403 Forbiden：请求被拒绝-<code>服务端知道你是谁，但你不配</code></li>
<li>404 Not Found：找不到对应服务器</li>
</ul>
<h4 id="5XX-服务端错误状态码"><a href="#5XX-服务端错误状态码" class="headerlink" title="5XX 服务端错误状态码"></a>5XX 服务端错误状态码</h4><ul>
<li>500 Internal Server Error：服务器执行请求发生错误</li>
<li>502 Bad Gateway：返回响应无效</li>
<li>503 Server Unavliable：服务器无法处理请求</li>
<li>504 Gateway Time-out：服务器处理请求超时</li>
</ul>
<h3 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h3><p><img src="/images/HTTP首部格式mind.png" srcset="/img/loading.gif" lazyload="" alt="HTTP首部格式mind"></p>
<blockquote>
<p>HTTP消息的元数据(metadata)，例如消息长度、格式等。</p>
</blockquote>
<h4 id="请求报文Header"><a href="#请求报文Header" class="headerlink" title="请求报文Header"></a>请求报文Header</h4><h5 id="Accept：客户端可以接受的MIME类型"><a href="#Accept：客户端可以接受的MIME类型" class="headerlink" title="Accept：客户端可以接受的MIME类型"></a><strong>Accept</strong>：客户端可以接受的MIME类型</h5><blockquote>
<p>MIME类型：描述消息内容类型的因特网标准，包含文本、图像、音频、视频以及其他应用 程序专用数据，例如PDF之类的</p>
</blockquote>
<p><code>文本类型</code>：text/html、text/css</p>
<p><code>图片文件</code>：image/gif、image/png</p>
<p><code>视频文件</code>：video/mpeg、video/mp4</p>
<p><code>应用程序二进制文件</code>：application/json、application/pdf</p>
<p>如果<code>Accept</code>包含了某类型，表示客户端可以支持该格式数据处理。</p>
<p>一般MIME类型会和<code>q</code>这个属性一起使用，</p>
<p>例如<code>Accept:text/html,application/json;q=0.9,image/webp;q=0.8,*/*;q=0.8</code></p>
<p><code>q</code>表示了<strong>媒体类型增加优先级</strong>，权重高的优先处理。</p>
<p>例如上述数据表示：</p>
<table>
<thead>
<tr>
<th>权重</th>
<th>MIME类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.0</td>
<td>text/html</td>
</tr>
<tr>
<td>0.9</td>
<td>application/json</td>
</tr>
<tr>
<td>0.8</td>
<td>Image/webp</td>
</tr>
</tbody>
</table>
<h6 id="Accept-Encoding：支持的压缩方式"><a href="#Accept-Encoding：支持的压缩方式" class="headerlink" title="Accept-Encoding：支持的压缩方式"></a><strong>Accept-Encoding</strong>：支持的压缩方式</h6><blockquote>
<p>一般都会对传输数据进行编码压缩，设置客户端可接受的压缩方式</p>
</blockquote>
<p><code>gzip</code>：由文件压缩gzip程序产生的编码格式 <strong>最常用</strong></p>
<p><code>deflate</code>：使用zlib结构和deflate算法产生的压缩格式</p>
<p><code>br</code>：使用Brotil算法的压缩格式</p>
<p>如果配置了<code>q</code>，也表示相对优先级，例如<code>Accept-Encoding:gzip;q=0.9</code></p>
<h6 id="Accept-Language：支持的语言"><a href="#Accept-Language：支持的语言" class="headerlink" title="Accept-Language：支持的语言"></a><strong>Accept-Language</strong>：支持的语言</h6><blockquote>
<p>指定客户端支持的语言</p>
</blockquote>
<p>如果配置了<code>q</code>，也表示相对优先级，例如<code>Accept-Language:zh-CN;q=0.9</code></p>
<h6 id="Accept-Charset：支持的字符集"><a href="#Accept-Charset：支持的字符集" class="headerlink" title="Accept-Charset：支持的字符集"></a><strong>Accept-Charset</strong>：支持的字符集</h6><blockquote>
<p>指定客户端支持的字符集</p>
</blockquote>
<p>如果配置了<code>q</code>，也表示相对优先级，例如<code>Accept-Charset:utf-8;q=0.9</code></p>
<p><strong>Host</strong>：请求资源所在服务器</p>
<p><strong>User-Agent</strong>：当前访问服务器的用户信息</p>
<p><strong>Range</strong>：设置下载数据的范围，可用于断点续传/多线程下载。</p>
<h4 id="响应报文Header"><a href="#响应报文Header" class="headerlink" title="响应报文Header"></a>响应报文Header</h4><p><strong>Location</strong>：重定向后的目标url</p>
<p><strong>Accept-Range</strong>：表示当前可以按照<code>bytes</code>来进行资源获取</p>
<p><strong>Content-Type</strong>：指定请求体(Body)类型/响应体返回数据类型</p>
<ul>
<li><code>text/html</code>：返回Html文本</li>
<li><code>application/json、image/jpeg</code>：返回文本或文件内容，也可用于向服务器传输文件</li>
<li><code>application/x-www-form-urlencoded</code>：普通表单类型提交，只支持传文本</li>
<li><code>multitype/form-data</code>：支持提交二进制文件，例如图片啥的</li>
<li><code>charset=utf-8</code>：表示设置的字符集 对标于<code>Accept-Charset</code></li>
</ul>
<p><strong>Content-Encoding</strong>：服务端设置的压缩格式 对标于<code>Accept-Encoding</code></p>
<p><strong>Content-Language</strong>：服务端设置的语言 对标于<code>Accept-Language</code></p>
<h4 id="通用Header-请求-响应都可以用"><a href="#通用Header-请求-响应都可以用" class="headerlink" title="通用Header(请求/响应都可以用)"></a>通用Header(请求/响应都可以用)</h4><p><strong>Content-Length</strong>：指定请求体(Body)长度/响应体返回数据长度</p>
<p><strong>Connection</strong>：允许发送的指令连接选项</p>
<ul>
<li><code>keep-alive</code>：保持连接</li>
<li><code>close</code>：通讯完成后关闭连接</li>
</ul>
<p><strong>Cache-Control</strong>：对数据进行缓存，减少从服务器获取数据次数，优化网络性能</p>
<ul>
<li><code>no-cache</code>：需要使用到<code>对比缓存</code></li>
<li><code>no-store</code>：不要缓存数据</li>
<li><code>max-age:XX</code>：缓存在XX时间后失效</li>
<li><code>private</code>：客户端可以缓存数据(个人化信息)</li>
<li><code>public</code>：客户端与中间节点都可以进行缓存(所有人都能使用)</li>
<li><code>s-maxage</code>：限定缓存在代理服务器中可以存放多久</li>
</ul>
<h3 id="HTTP-Cache"><a href="#HTTP-Cache" class="headerlink" title="HTTP Cache"></a>HTTP Cache</h3><p><img src="/images/HTTP缓存mind.png" srcset="/img/loading.gif" lazyload="" alt="HTTP缓存mind"></p>
<blockquote>
<p>Web性能优化的重要手段，主要依赖于上节中配置的<code>Header</code>。会去指定缓存的来源 </p>
</blockquote>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><blockquote>
<p>在第一次请求数据时，服务端在Header会携带<code>缓存规则信息</code>，只要符合缓存规则，就直接取缓存数据，不会重新发起请求。按照服务端给予的<code>缓存时间</code>比较，不超出则一直使用缓存数据。</p>
</blockquote>
<p>通过<code>Cache-Control</code>验证强缓存是否可用，如果设置了<code>max-age=XXX</code>，表示缓存会在<code>XXX</code>后的时间失效，在这期间只要请求资源，都会从缓存中获取数据。</p>
<p>在HTTP1.0版本使用的是<code>Expires</code>字段，存放的是一个具体的过期时间，但是存在<strong>服务器与客户端时间不同步</strong>问题，导致缓存失效时间无法确定。所以在HTTP1.1是废弃了该字段。</p>
<h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><blockquote>
<p>需要按照<code>Header</code>中的配置来判断是否需要读取缓存还是重新从服务器中拉取数据。</p>
</blockquote>
<p>按照缓存下来的数据标识，需要每次与服务器进行交互去验证<code>缓存标识</code>是否有效，有效则继续使用缓存数据即可。</p>
<p>以下则为认证时用到的<code>缓存标识</code>：</p>
<p><strong>Last-Modified/If-Modified-Since</strong></p>
<ul>
<li><code>Last-Modified</code>：服务端返回给客户端，表示资源的最后修改时间</li>
<li><code>If-Modified-Since</code>：客户端发送服务端，表示服务端返回的上次资源修改时间</li>
</ul>
<p>服务端在收到<code>If-Modified-Since</code>之后，与服务端资源进行比较</p>
<ul>
<li>若本地时间大于接收的时间，则返回<code>200</code>，需要客户端重新缓存资源</li>
<li>否则，返回<code>304</code>，表示资源没有发生变化，客户端可以继续使用本地缓存资源</li>
</ul>
<p><strong>ETag/If-None-Match</strong></p>
<ul>
<li><code>ETag</code>：服务端返回给客户端，表示当前资源在服务器的唯一标识</li>
<li><code>If-None-Match</code>：客户端发送给服务端，表示服务端说返回的资源唯一标识</li>
</ul>
<p>服务端在收到<code>If-None-Match</code>之后，进行服务器资源的唯一标识比对</p>
<ul>
<li>标识不一致，返回<code>200</code>，需要客户端重新缓存资源</li>
<li>否则，返回<code>304</code>，客户端可以继续使用本地缓存资源</li>
</ul>
<p><em>强制缓存的优先级是高于对比缓存的。</em></p>
<p><strong>Etag/If-None-Match</strong>这组标识符的优先级是高于<strong>Last-Modified/If-Modified-Since</strong>，如果存在则优先执行。</p>
<p><img src="/images/http缓存流程.jpg" srcset="/img/loading.gif" lazyload="" alt="http缓存流程"></p>
<h4 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h4><blockquote>
<p>每次客户端缓存失效都需要从源服务器获取的话，会产生较大的压力。所以引入<code>代理缓存</code>机制，由代理服务器进行数据的缓存，但代理服务器缓存过期了才从源服务器请求数据。</p>
</blockquote>
<p>缓存代理的控制分为两部分：<strong>源服务端的控制</strong>，<strong>客户端的控制</strong>。</p>
<h5 id="源服务端的控制"><a href="#源服务端的控制" class="headerlink" title="源服务端的控制"></a>源服务端的控制</h5><p>通过配置<code>Cache-Control</code>属性进行控制</p>
<p><code>Cache-Control:public</code>：允许代理服务器进行缓存</p>
<p><code>Cache-Control:private</code>：只允许客户端进行缓存</p>
<p><code>Cache-Control:s-maxage=XXX</code>：允许缓存服务器最多缓存XXX时间</p>
<p>与<code>max-age</code>的区别是，<code>max-age</code>管理的是客户端的缓存有效时间。</p>
<h5 id="客户端的控制"><a href="#客户端的控制" class="headerlink" title="客户端的控制"></a>客户端的控制</h5><p>通过在请求头配置属性进行控制</p>
<p><code>max-stale:num</code>：表示客户端在代理服务器拿到缓存时，最多允许<code>num</code>的过期时间</p>
<p><code>min-fresh:num</code>：表示代理缓存在到期<code>num</code>秒之前可以获取</p>
<p><code>only-if-cached</code>：表示客户端只从代理缓存获取数据，获取缓存无效则返回<code>504</code>超时</p>
<h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><p><img src="/images/HTTP-Cookiemind.png" srcset="/img/loading.gif" lazyload="" alt="HTTP-Cookiemind"></p>
<blockquote>
<p><code>由于HTTP协议是无状态的，不对之前发生的请求和响应进行管理。</code>Cookie就是为了解决这类问题所提供的。可以用于对用户进行认证以及保存部分信息。客户端保存本地后，后续请求就会带上该信息。</p>
</blockquote>
<p><code>Cookie</code>会根据从服务端发送的响应报文(<code>Response</code>)内的一个叫做<code>Set-Cookie</code>的<code>Header</code>信息，通知客户端保存Cookie信息。当下次再发起请求时，客户端会自动在请求报文(<code>Request</code>)中加入<code>Cookie</code>值后发送到服务端。</p>
<p><img src="/images/Cookie交互流程.jpg" srcset="/img/loading.gif" lazyload="" alt="Cookie交互流程"></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>domain</td>
<td>String</td>
<td>指定浏览器发出HTTP请求时，哪些域名需要附加Cookie信息</td>
</tr>
<tr>
<td>expires</td>
<td>Date</td>
<td>指定一个具体的Cookie到期时间，值为UTC格式</td>
</tr>
<tr>
<td>httponly</td>
<td>Boolean</td>
<td>指定该无法通过JS脚本拿到，主要是<code>Document.cookie</code>获取</td>
</tr>
<tr>
<td>maxAge</td>
<td>String</td>
<td>指定从现在开始的Cookie存在秒数，超过则失效</td>
</tr>
<tr>
<td>path</td>
<td>String</td>
<td>指定浏览器发出Http请求时，哪些路径要附带这个Cookie信息</td>
</tr>
<tr>
<td>secure</td>
<td>Boolean</td>
<td>指定浏览器只有在<code>HTTPS</code>协议下可以发送Cookie到服务器</td>
</tr>
<tr>
<td>signed</td>
<td>Boolean</td>
<td>给浏览器发送一个加密的Cookie，服务端可以校验该Cookie是否被篡改</td>
</tr>
<tr>
<td>SameSite</td>
<td>String</td>
<td>设置第三方Cookie属性</td>
</tr>
</tbody>
</table>
<p>按照功能可以将以上7个属性进行分类</p>
<h5 id="Cookie生命周期-expires-maxAge"><a href="#Cookie生命周期-expires-maxAge" class="headerlink" title="Cookie生命周期-expires,maxAge"></a>Cookie生命周期-<code>expires,maxAge</code></h5><p><code>expires</code>设置的是一个<code>Date</code>格式的时间，<code>maxAge</code>设置的是一个<code>毫秒时间戳</code>。<strong>推荐使用maxAge</strong></p>
<p>若同时指定了<code>expires</code>和<code>maxAge</code>，那么<code>maxAge</code>属性优先生效。</p>
<p><em>若不设置任一属性的值，那么该Cookie仅在当前页面生效，关闭就不会再保留。</em></p>
<h5 id="Cookie作用域-domain-path"><a href="#Cookie作用域-domain-path" class="headerlink" title="Cookie作用域-domain,path"></a>Cookie作用域-<code>domain,path</code></h5><p><code>domain</code>设置哪些域名需要附加Cookie信息，<code>path</code>设置哪些路径需要附加Cookie信息(若<code>path:&#39;/&#39;</code>表示该域名下所有路径都附加Cookie信息)。</p>
<p><em>若与任一属性值不匹配，那么请求服务端时就不会带上Cookie信息。</em></p>
<h5 id="Cookie安全性-secure-httponly-SameSite"><a href="#Cookie安全性-secure-httponly-SameSite" class="headerlink" title="Cookie安全性-secure,httponly,SameSite"></a>Cookie安全性-<code>secure,httponly,SameSite</code></h5><p><code>secure</code>设置只有在<code>HTTPS协议</code>下可以传输Cookie；<code>httponly</code>设置Cookie只能通过HTTP协议进行传输，其他方式都无法获取Cookie信息。</p>
<p><code>SameSite</code>主要为了预防<code>CSRF攻击</code>，可以设置为3个值：</p>
<ul>
<li>None：显式关闭SameSite属性，但是必须设置<code>secure:true</code>，否则设置无效</li>
<li>Lax：只能在<code>GET</code>请求下使用，请求时会携带Cookie，否则不会有信息</li>
<li>Strict：浏览器完全禁止第三方请求携带Cookie信息，只能在同一域名下生效。</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>状态记录</strong>：记录当前状态，例如用户登录，操作记录</li>
<li><strong>用户偏好</strong>：记录用户的个性化设置</li>
<li><strong>行为分析</strong>：分析用户的行为，可以了解用户喜好</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>容量缺陷</strong>：Cookie保存的诗句不能超过4K，而且浏览器会设置保存Cookie的上限</li>
<li><strong>性能缺陷</strong>：Cookie默认跟随域名一起发起请求，无论需要与否，导致性能浪费。<em>可以通过设置<code>domain</code>和<code>path</code>减少使用。</em></li>
<li><strong>安全权限</strong>：Cookie以纯文本形式进行传递，很容易被非法截获，然后进行篡改后再发给服务端，降低安全性。</li>
</ul>
<h4 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h4><ul>
<li><p><strong>XSS(跨站脚本攻击)</strong>：被JavaScript获取用户Cookie，然后发送到其他网站，就会导致Cookie泄漏，危害数据安全。</p>
<p>解决方案：在Cookie信息中添加<code>HttpOnly</code>属性，就保证当前Cookie只会用于网络请求，而不会被获取。</p>
</li>
<li><p><strong>CSRF(跨站请求伪造)</strong>：随机访问可能存有Cookie的网址，然后越权操作用户数据。</p>
<p>解决方案：</p>
<ul>
<li><p>同源检测</p>
<ul>
<li><p>使用<code>Origin Header</code>确定来源域名</p>
</li>
<li><p>使用<code>Referer Header</code>确定来源域名</p>
</li>
</ul>
</li>
<li>CSRF Token</li>
<li>SameSite Cookie属性</li>
</ul>
</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><blockquote>
<p>是以安全为目标的HTTP通信，在HTTP下加入了SSL/TLS协议，用于保障HTTP的加密传输。</p>
<p><code>TLS(传输层安全性协议)</code>：前身为<code>SSL(安全套接层)</code>，目的是为互联网通信提供安全及数据完整性保障。</p>
<p>使用<code>SSL</code>后，HTTPS就具有<strong>加密、认证，完整性保护</strong>功能</p>
</blockquote>
<h3 id="HTTPS加密"><a href="#HTTPS加密" class="headerlink" title="HTTPS加密"></a>HTTPS加密</h3><p><img src="/images/HTTPSmind.png" srcset="/img/loading.gif" lazyload="" alt="HTTPS"></p>
<h4 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h4><blockquote>
<p>采用单钥密码系统的加密方法，同一个密钥可以用作信息的加密和解密。</p>
<p>也可叫<code>单密钥加密</code>。</p>
</blockquote>
<h5 id="常用加密算法"><a href="#常用加密算法" class="headerlink" title="常用加密算法"></a>常用加密算法</h5><p>DES、AES</p>
<p><img src="/images/对称密钥加解密过程.png" srcset="/img/loading.gif" lazyload="" alt="对称密钥加解密过程"></p>
<h4 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h4><blockquote>
<p>需要两个密钥来进行加密和解密，这两个密钥分别是<strong>公钥(public key)</strong>和<strong>私钥(private key)</strong>。</p>
<p>公钥所有人都可以获得，通信方得到公钥后，就可以对发送内容进行加密，然后传递至服务端，服务端就可以利用私钥进行解密。</p>
<p>私钥还可以对服务端返回内容进行签名，利用公钥去验证签名是否正确，防止被人篡改。</p>
</blockquote>
<h5 id="常用加密算法-1"><a href="#常用加密算法-1" class="headerlink" title="常用加密算法"></a>常用加密算法</h5><p>RSA，ECC</p>
<p><img src="/images/非对称密钥加解密过程.png" srcset="/img/loading.gif" lazyload="" alt="非对称密钥加解密过程"></p>
<h4 id="混合加密-HTTPS采用方案"><a href="#混合加密-HTTPS采用方案" class="headerlink" title="混合加密(HTTPS采用方案)"></a>混合加密(HTTPS采用方案)</h4><p>采用了<code>对称加密与非对称加密</code>混合加密的形式，只用<code>对称加密</code>，会有安全隐患；只用<code>非对称加密</code>，性能消耗太大。所以需要结合两者，保证性能的同时又保证安全。</p>
<ul>
<li>客户端向服务器发送<code>client_random</code>和加密方法列表(例如RSA方法)</li>
<li>服务端收到后，返回<code>server_random</code>、加密方法(RSA)以及<code>非对称加密公钥</code>到客户端</li>
<li>客户端收到后，再生成一个<code>pre_random</code>，使用<code>非对称加密公钥</code>加密后发送给服务器</li>
<li>服务端使用<code>非对称加密私钥</code>解密后，得到的就是<code>对称加密用到的密钥</code></li>
<li>双方持有<code>对称加密用到的密钥</code>后，后续数据通信就用<code>对称加密</code>的方式进行。</li>
</ul>
<p>本质就是为了<strong>防止私钥加密的数据外传。</strong></p>
<h4 id="数字证书-解决身份伪装问题"><a href="#数字证书-解决身份伪装问题" class="headerlink" title="数字证书(解决身份伪装问题)"></a>数字证书(解决身份伪装问题)</h4><blockquote>
<p>为了向服务器证明自己的身份，可以解决身份伪装问题。</p>
</blockquote>
<p>上面两种加密方式的结合，可以实现加密传输。但是还会存在一些问题，若发生了DNS劫持，那么传输过程中的所有内容都有可能造假，不能保证安全性。</p>
<p>数字证书的使用流程大概如下：</p>
<ol>
<li>服务器首先向一个大家都信任的第三方机构(<code>CA</code>)获取授权，获取通过后获取<strong>数字证书</strong>。</li>
<li>客户端向服务器建立通信之前向服务器请求获得服务器的证书</li>
<li>服务器收到请求之后发送<strong>数字证书</strong>给客户端</li>
<li>客户端获得证书之后，向第三方机构进行验证，验证通过后进行正常的内容通信。</li>
</ol>
<p>数字证书有两个作用：</p>
<ul>
<li>服务器向客户端证明自己的身份</li>
<li>把<code>非对称加密公钥</code>传给客户端</li>
</ul>
<h5 id="CA机构"><a href="#CA机构" class="headerlink" title="CA机构"></a>CA机构</h5><p>证书颁发机构。是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p>
<h4 id="数字签名-解决数据篡改问题"><a href="#数字签名-解决数据篡改问题" class="headerlink" title="数字签名(解决数据篡改问题)"></a>数字签名(解决数据篡改问题)</h4><blockquote>
<p>功能类似写在纸上的普通签名，可以用于校验通信双方数据的准确性以及完整性。</p>
</blockquote>
<p>数字签名有两个作用：</p>
<ul>
<li>验证数据是否为意料中的对象发出</li>
<li>对数据的完整性进行验证，验证数据是否被篡改过</li>
</ul>
<p><strong>使用私钥加密(生成签名)，公钥解密(验证签名)。</strong></p>
<p>服务端对消息进行私钥加密，客户端使用服务端传递的公钥进行验证，验证通过则表示消息一致，数字签名是正确的。</p>
<p>通常会对消息进行<strong>摘要</strong>，然后拿到消息的Hash值再进行私钥签名(<code>Hash值一般都会小于消息原文</code>)，大大提升签名效率。</p>
<p><strong>哈希摘要算法</strong>：根据任意长度数据计算出固定签名长度的算法。常用的有<code>SHA256、SHA384</code>。</p>
<h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p><img src="/images/http/HTTPS通信过程.jpg" srcset="/img/loading.gif" lazyload="" alt="HTTPS通信过程"></p>
<h4 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h4><blockquote>
<p>客户端发送消息到服务端</p>
</blockquote>
<p>客户端生成随机数<code>client_random</code>，然后发送<code>TLS版本</code>，<code>加密算法列表</code>发送给服务端。</p>
<p>例如：发送消息为</p>
<ul>
<li><p><code>Random</code>：client_random</p>
</li>
<li><p><code>Version</code>：TLS 1.2</p>
</li>
<li><p><code>Cipher Suites</code>：TLS_AES_128_GCM_SHA256（<code>只是其中一种，整体是一个List型</code>）</p>
<p>服务端会从列表中选择一种加密算法，后续使用该算法进行通信。</p>
</li>
</ul>
<h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><blockquote>
<p>服务端发送消息到客户端</p>
</blockquote>
<p>服务端同样生成随机数<code>server_random</code>，以及<code>确认的TLS版本</code> 、<code>服务端选择的加密算法</code>，<code>服务器的证书信息</code>返回给客户端。</p>
<p>例如：返回消息为</p>
<ul>
<li><code>Random</code>：server_random</li>
<li><code>Cipher Suite</code>：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256（<code>返回一个来确定后续都用这种加密方式</code>）<ul>
<li>ECDHE：密钥协商算法</li>
<li>RSA：证书公钥加密算法</li>
<li>AES_128：对称加密算法以及密法长度</li>
<li>GCM：AES加密模式</li>
<li>SHA256：消息摘要算法</li>
</ul>
</li>
<li><code>Certificate</code>：返回的服务端证书信息，以及<code>非对称加密使用的公钥</code></li>
</ul>
<h4 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h4><blockquote>
<p>客户端验证数字证书以及验证通过后发送消息到服务端</p>
</blockquote>
<p>客户端验证服务端传来<code>证书</code>和<code>签名</code>是否通过，如果通过，按照协议不同有以下两种处理方式</p>
<ul>
<li><p>传统RSA版本</p>
<p>客户端再生成一个随机数<code>pre_random</code>，并且使用证书携带的RSA公钥加密，传给服务端</p>
</li>
<li><p>TLS 1.2版本</p>
<p>客户端生产<code>client_params</code>参数给服务端</p>
</li>
</ul>
<h4 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a>Server Key Exchange</h4><blockquote>
<p>服务端根据传递的参数生成对称加密使用的密钥</p>
</blockquote>
<ul>
<li><p>传统RSA版本</p>
<p>服务端接收到客户端传来的<code>pre_random</code>，使用私钥进行解密，然后拿着<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code></p>
</li>
<li><p>TLS 1.2版本</p>
<p>服务端接收到客户端传来的<code>client_params</code>，使用<code>ECDHE(椭圆曲线加密)</code>，根据已有的<code>client_params</code>和<code>server_params</code>生成最后的<code>pre_random</code>，最后使用<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code></p>
</li>
</ul>
<p>服务端生成<code>secret</code>后，给客户端发送一个收尾消息，该收尾消息包含两部分：</p>
<ul>
<li><code>Change Cipher Spec</code>：提示客户端后续消息会采用<code>secret</code>的对称加密进行传递</li>
<li><code>Finished</code>：对之前报文的所有数据进行摘要，加密后交由客户端进行解密，解密通过则表示协商成功</li>
</ul>
<h4 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h4><blockquote>
<p>客户端根据已有的参数生成对称加密使用的密钥</p>
</blockquote>
<ul>
<li><p>传统RSA版本</p>
<p>客户端根据已有的<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code></p>
</li>
<li><p>TLS 1.2版本</p>
<p>客户端通过<code>ECDHE</code>算法计算出<code>pre_random</code>，其中传入两个参数:<strong>server_params</strong>和<strong>client_params</strong>。现在你应该清楚这个两个参数的作用了吧，由于<code>ECDHE</code>基于<code>椭圆曲线离散对数</code>，这两个参数也称作<code>椭圆曲线的公钥</code>。</p>
<p>客户端根据<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code>。</p>
</li>
</ul>
<p>客户端生成<code>secret</code>后，会给服务端发送一个收尾消息，该收尾消息包含两部分：</p>
<ul>
<li><code>Change Cipher Spec</code>：提示服务器后续消息会采用<code>secret</code>的对称加密进行传递</li>
<li><code>Finished</code>：对之前报文的所有数据进行摘要，加密后交由服务端进行解密，解密通过则表示协商成功</li>
</ul>
<p>当客户端与服务端都收到<code>finished</code>消息后，客户端和服务端都会持有<code>secret</code>，后续的请求都会使用<code>secret</code>进行对称加密传递消息。</p>
<h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h3><ol>
<li>HTTPS协议握手阶段比较费时，因为需要加密/解密过程</li>
<li>SSL证书是需要收费</li>
<li>HTTPS加密范围有限，而且证书不一定是可以信任的</li>
</ol>
<h3 id="与HTTP区别"><a href="#与HTTP区别" class="headerlink" title="与HTTP区别"></a>与HTTP区别</h3><ul>
<li>https协议需要向<code>CA</code>申请证书，需要一定费用</li>
<li>http信息是明文传输，HTTPS具有安全性的ssl加密传输协议</li>
<li>http和https使用的是完全不同的连接方式，端口不同，http使用了<code>80</code>端口，https使用<code>443</code>端口</li>
<li>http连接是简单的，无状态的；HTTPS由<code>http+ssl</code>构成的可进行加密传输，身份认证的网络协议，更加安全。</li>
</ul>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><blockquote>
<p>攻击者与通信两端(服务端与客户端)分别创建独立的联系，并交换所受到的数据，使通信的两端认为他们正在通过一个私密的连接与对方直接通信，事实上整个会话都被攻击者完全控制、</p>
<p>中间人攻击者可以拦截通讯双方的通话并插入新的内容。</p>
</blockquote>
<p><img src="/images/中间人攻击" srcset="/img/loading.gif" lazyload="" alt="中间人攻击"></p>
<h4 id="如何防御中间人攻击？"><a href="#如何防御中间人攻击？" class="headerlink" title="如何防御中间人攻击？"></a>如何防御中间人攻击？</h4><ul>
<li><p>公钥基础建设PKI</p>
<p>PKI相互认证机制，服务端验证客户端，客户端验证服务端</p>
</li>
<li><p>使用复杂加密哈希函数运行计算以造成数十秒的延迟</p>
<p>如果双方通信时间过长，可以基本判断存在中间人</p>
</li>
</ul>
<h2 id="HTTP协议版本区别"><a href="#HTTP协议版本区别" class="headerlink" title="HTTP协议版本区别"></a>HTTP协议版本区别</h2><p><img src="/images/HTTP协议版本区别mind.png" srcset="/img/loading.gif" lazyload="" alt="HTTP协议版本区别mind"></p>
<h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><ul>
<li>默认短连接</li>
<li>增加了POST、HEAD命令</li>
</ul>
<h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><ul>
<li>默认长连接(默认添加Header<code>Connection:Keep-Alive</code>)</li>
<li>增加了请求方法(<code>OPTIONS、PUT、DELETE、TRACE、CONNECT</code>)</li>
<li>请求消息和响应消息都支持Host头域</li>
<li>支持chunked编码传输</li>
</ul>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul>
<li><p>头部压缩</p>
<p>针对请求头字段进行压缩，采用了<code>HPACK</code>算法</p>
<p>HPACK算法：</p>
<ul>
<li>在服务端与客户端建立哈希表，存放使用的字段，只要在传输过程传输索引值，然后按照索引表查询即可</li>
<li>对于整数和字符串进行<strong>哈夫曼编码</strong></li>
</ul>
</li>
<li><p>多路复用</p>
<p>允许同时通过单一的HTTP2连接发起多重请求，由于把HTTP通信的基本单位缩小为一个个的二进制帧，各自对应着信息。</p>
<p>被拆分为很多互不依赖的<code>二进制帧</code>后，这些<code>二进制帧</code>就可以乱序发送。</p>
<p><img src="/images/v2-a3b152bfae26b0cfa2aa96ab2c638b4b_1440w.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p>
</li>
<li><p>二进制分帧</p>
<p>HTTP/2在 应用层和传输层增加一个<code>二进制分层</code>，在该分层中将传输的信息分割为更小的消息和帧，并采用二进制格式的编码。</p>
<blockquote>
<p>HTTP队头阻塞：在同一个TCP长连接中，前面的请求没有得到响应的话，后面的请求就无法被处理，导致阻塞。</p>
<p><code>并发连接</code>：对于一个域名分配多个长连接，相当于增加了任务队列，可以分散任务。</p>
<p><code>域名分片</code>：对一个域名分配多个二级域名，但是指向同一台服务器，使并发变多。</p>
</blockquote>
<p><img src="/images/v2-bb03351e6eac392c2afd89dafcf1e90f_1440w.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p>
</li>
<li><p>服务端推送    </p>
<p>在客户端请求之前发送数据，客户端请求一个资源后，服务端判断可能还需要其他资源，就会主动发送消息到客户端，减少客户端的等待</p>
<p><img src="/images/v2-fd019652daff484a0c06bbfb27404bc9_1440w.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p>
<p>需要注意以下两点：</p>
<ul>
<li>服务端推送遵循<code>同源策略</code></li>
<li>服务端推送基于客户端的请求响应来确定的</li>
</ul>
<blockquote>
<p>当服务端需要主动推送某个资源时，便会发送一个<code>PUSH_PROMISE</code>的<code>二进制帧(Frame)</code>，里面携带了<code>Stream ID</code>，表示服务端会用这个<code>ID</code>来推送资源，客户端解析时，需要从这个ID获取资源。</p>
</blockquote>
</li>
</ul>
<h2 id="HTTP相关协议"><a href="#HTTP相关协议" class="headerlink" title="HTTP相关协议"></a>HTTP相关协议</h2><p><img src="/images/HTTP相关协议mind.png" srcset="/img/loading.gif" lazyload="" alt="HTTP相关协议mind"></p>
<h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><blockquote>
<p>提供域名到IP地址之间的解析服务，能够使人更方便地访问互联网。</p>
<p>还可以根据多个地址做负载均衡，并且选择一个就近的地点IP进行访问。</p>
</blockquote>
<h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><ol>
<li>客户端访问<code>XX.com</code>域名，先去请求本地DNS解析器</li>
<li>本地DNS解析器先去查看本地缓存是否有对应记录，若有直接使用；否则请求本地DNS服务器</li>
<li>本地DNS服务器一般部署在运营商网络中，然后本地DNS服务器也会查看是否存在本地缓存，存在则直接使用；否则递归请求根服务器</li>
<li>直到请求到顶级域名服务器，例如<code>.com</code>，查到数据后返回真实的IP地址。</li>
</ol>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><h5 id="域名缓存问题"><a href="#域名缓存问题" class="headerlink" title="域名缓存问题"></a>域名缓存问题</h5><p>由于DNS会优先获取本地缓存，如果缓存没有及时刷新，就会导致访问失败。</p>
<h5 id="域名转发问题"><a href="#域名转发问题" class="headerlink" title="域名转发问题"></a>域名转发问题</h5><p>DNS解析请求可能会被转发到其他DNS服务器进行处理，导致解析时无法判断地址，而返回一个较远IP使访问异常。</p>
<h5 id="域名更新问题"><a href="#域名更新问题" class="headerlink" title="域名更新问题"></a>域名更新问题</h5><p>忽略域名缓存IP的有效时间，导致结果更新不及时，一样会有访问异常问题</p>
<h5 id="解析延迟问题"><a href="#解析延迟问题" class="headerlink" title="解析延迟问题"></a>解析延迟问题</h5><p>DNS会进行递归解析，可能经过多个服务器，才可以获得最终结果，中间时间非常漫长</p>
<h4 id="HTTPDNS"><a href="#HTTPDNS" class="headerlink" title="HTTPDNS"></a>HTTPDNS</h4><blockquote>
<p>不走传统的DNS解析模式，自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商。需要进行DNS解析时，直接通过HTTP请求这个集群得到结果即可。</p>
</blockquote>
<h5 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h5><p>在客户端动态请求HTTPDNS服务端，获取解析的IP结果以及失效时间缓存到本地。后续在缓存未失效的情况下可直接返回对应域名的IP信息。如果没有返回信息，也可以降级回最初的LocalDNS解析方案。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote>
<p>内容分发网络(Content Delivery Network)。主要目的是<strong>改善互联网服务质量</strong>，提高用户访问网站的响应速度和成功率。</p>
</blockquote>
<p>通过权威DNS服务器来实现最优节点的选择，通过<strong>缓存</strong>来减少源站的压力</p>
<h3 id="URL-URI"><a href="#URL-URI" class="headerlink" title="URL/URI"></a>URL/URI</h3><blockquote>
<p>用户在浏览器地址栏输入的或者是App发起请求时设置的地址</p>
</blockquote>
<p><code>URI</code>：统一资源标识符，唯一的标记互联网资源</p>
<p><code>URL</code>：统一资源定位符，也就是<strong>网址</strong>，实际为<code>URI</code>的子集</p>
<h4 id="URI结构"><a href="#URI结构" class="headerlink" title="URI结构"></a>URI结构</h4><p><img src="/images/URI结构.webp" srcset="/img/loading.gif" lazyload="" alt="URI结构"></p>
<h5 id="协议类型-scheme"><a href="#协议类型-scheme" class="headerlink" title="协议类型(scheme)"></a>协议类型(<code>scheme</code>)</h5><p>比如<code>http</code>,<code>https</code>,<code>file</code>等，必须和<code>://</code>连在一起</p>
<h5 id="服务器地址-host-port"><a href="#服务器地址-host-port" class="headerlink" title="服务器地址(host:port)"></a>服务器地址(<code>host:port</code>)</h5><p>对应的是所需接受浏览器/App请求的服务器地址</p>
<h5 id="请求路径-path"><a href="#请求路径-path" class="headerlink" title="请求路径(path)"></a>请求路径(<code>path</code>)</h5><p>对应请求需要处理的位置</p>
<h5 id="查询参数-query"><a href="#查询参数-query" class="headerlink" title="查询参数(query)"></a>查询参数(<code>query</code>)</h5><p>为<code>key=value</code>这类的形式，存在多个用<code>&amp;</code>进行连接</p>
<h5 id="锚点-fragment"><a href="#锚点-fragment" class="headerlink" title="锚点(fragment)"></a>锚点(<code>fragment</code>)</h5><p>表示URI定位资源内的一个锚点，通过这个锚点可以跳转到指定位置</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">https://juejin.im/<span class="hljs-keyword">search</span>?<span class="hljs-keyword">query</span>=s#heading-1<br></code></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="">图解HTTP</a></p>
<p><a href="https://mp.weixin.qq.com/s/smYo1tECl6-TS6anKF8Jgw" target="_blank" rel="noopener">深入理解HTTPS</a></p>
<p><a href="https://juejin.im/post/5e76bd516fb9a07cce750746#heading-74" target="_blank" rel="noopener">HTTP灵魂之问</a></p>
<p><a href="https://zh.wikipedia.org/wiki/中间人攻击" target="_blank" rel="noopener">中间人攻击</a></p>
<p><a href="https://www.jianshu.com/p/52d86558ca57" target="_blank" rel="noopener">HTTP协议版本差异</a></p>
<p><a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">GET与POST区别</a></p>
<p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">CSRF防护</a></p>
<p><a href="https://www.zhihu.com/question/36514327/answer/193768864" target="_blank" rel="noopener">CDN相关</a></p>
<p><a href="https://mp.weixin.qq.com/s/KTKVu3uCC5MFlU5oylZPFA" target="_blank" rel="noopener">TCP拥塞控制详解</a></p>
<p>​            </p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/HTTP/">HTTP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/03/31/TCP-IP协议相关/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">TCP/IP协议相关</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/03/23/Android性能优化-内存优化详解/">
                        <span class="hidden-mobile">Android性能优化-内存优化详解</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>
  




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
