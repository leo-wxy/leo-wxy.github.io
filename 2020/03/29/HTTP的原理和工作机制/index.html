<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.1',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="HTTP的原理和工作机制 什么是HTTP? HyperText(可以指向其他文本的链接文本) Transfer Protocol——超文本传输协议。位于TCP/IP协议的最顶层——应用层。  从日常角度来说，在App中调用网络请求，直接就会使用到HTTP。发送数据(Request)到服务端，等待服务端数据处理完毕再返回(Response)到App，App在进行后续处理，例如页面展示等。 HTTP工">
<meta name="keywords" content="HTTP">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP的原理和工作机制">
<meta property="og:url" content="https://leo-wxy.github.io/2020/03/29/HTTP的原理和工作机制/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="HTTP的原理和工作机制 什么是HTTP? HyperText(可以指向其他文本的链接文本) Transfer Protocol——超文本传输协议。位于TCP/IP协议的最顶层——应用层。  从日常角度来说，在App中调用网络请求，直接就会使用到HTTP。发送数据(Request)到服务端，等待服务端数据处理完毕再返回(Response)到App，App在进行后续处理，例如页面展示等。 HTTP工">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTP大纲.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTP报文结构mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP_RequestMessage.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTP_ResponseMessage.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTP请求方法mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTP状态码mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTP首部格式mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTP缓存mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/http缓存流程.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTP-Cookiemind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/Cookie交互流程.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/对称密钥加解密过程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/非对称密钥加解密过程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/HTTPS通信过程.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/中间人攻击.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/http/URL组成.jpg">
<meta property="og:updated_time" content="2020-04-21T14:51:29.439Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HTTP的原理和工作机制">
<meta name="twitter:description" content="HTTP的原理和工作机制 什么是HTTP? HyperText(可以指向其他文本的链接文本) Transfer Protocol——超文本传输协议。位于TCP/IP协议的最顶层——应用层。  从日常角度来说，在App中调用网络请求，直接就会使用到HTTP。发送数据(Request)到服务端，等待服务端数据处理完毕再返回(Response)到App，App在进行后续处理，例如页面展示等。 HTTP工">
<meta name="twitter:image" content="https://leo-wxy.github.io/images/http/HTTP大纲.png">





  
  
  <link rel="canonical" href="https://leo-wxy.github.io/2020/03/29/HTTP的原理和工作机制/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>HTTP的原理和工作机制 | Wxy的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wxy的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">技术路上点滴</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leo-wxy.github.io/2020/03/29/HTTP的原理和工作机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leo-Wxy">
      <meta itemprop="description" content="如果我没有见过光明，那我本可以忍受黑暗">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wxy的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">HTTP的原理和工作机制

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-29 09:35:02" itemprop="dateCreated datePublished" datetime="2020-03-29T09:35:02+08:00">2020-03-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-04-21 22:51:29" itemprop="dateModified" datetime="2020-04-21T22:51:29+08:00">2020-04-21</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="HTTP的原理和工作机制"><a href="#HTTP的原理和工作机制" class="headerlink" title="HTTP的原理和工作机制"></a>HTTP的原理和工作机制</h1><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/HTTP大纲.png" class="full-image" alt="HTTP思维导图" title="HTTP思维导图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h2><blockquote>
<p>HyperText(可以指向其他文本的链接文本) Transfer Protocol——超文本传输协议。位于<code>TCP/IP</code>协议的最顶层——应用层。</p>
</blockquote>
<p>从日常角度来说，在App中调用网络请求，直接就会使用到HTTP。发送数据(<code>Request</code>)到服务端，等待服务端数据处理完毕再返回(<code>Response</code>)到App，App在进行后续处理，例如页面展示等。</p>
<h3 id="HTTP工作机制"><a href="#HTTP工作机制" class="headerlink" title="HTTP工作机制"></a>HTTP工作机制</h3><h4 id="浏览器输入地址后发生了什么？"><a href="#浏览器输入地址后发生了什么？" class="headerlink" title="浏览器输入地址后发生了什么？"></a>浏览器输入地址后发生了什么？</h4><ul>
<li>浏览器向DNS服务器请求解析该url中的域名对应的IP地址</li>
<li>解析得到IP地址后，根据IP地址和端口，与服务器建立TCP连接</li>
<li>浏览器发出读取文件的HTTP请求</li>
<li>服务器对浏览器请求做出响应，返回html文本到浏览器</li>
<li>根据Header中的<code>Connection</code>判断是否需要释放TCP连接，若为<code>close</code>则关闭连接；为<code>keep-alive</code>则保持该连接一段时间，可以继续接受服务器数据</li>
<li>浏览器解析服务端返回的html文本并显示</li>
</ul>
<h3 id="HTTP特点与缺点"><a href="#HTTP特点与缺点" class="headerlink" title="HTTP特点与缺点"></a>HTTP特点与缺点</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>灵活可拓展<ul>
<li>只规定基本格式，没有语法的限制</li>
<li>传输形式多样性，支持文本、图片、视频等数据</li>
</ul>
</li>
<li>传输可靠，基于TCP/IP，继承其特性</li>
<li>无状态，通信过程不会记录上下文信息，每次请求都是独立的，减少了网络开销</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>无状态</p>
<p>需要长连接的场景中，需要保存信息时，导致传输大量无用的信息，这时就是缺点</p>
<p>如果只是单纯的获取数据，不需要保存信息时，反而减少了网络开销</p>
</li>
<li><p>明文传输</p>
<p>协议里的报文使用文本形式传递，为调试提供便利但是会把明文信息暴露给外界，导致请求不安全。</p>
</li>
<li><p>队头阻塞问题</p>
<p>当http开启长连接时(<code>Connection:Keep-Alive</code>)，共用同一个TCP连接，同一时刻只能处理同一个请求，当头部请求耗时过长，会导致后续请求堵塞，产生<strong>队头阻塞</strong>问题。</p>
</li>
</ul>
<h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/HTTP报文结构mind.png" class="full-image" alt="HTTP报文结构" title="HTTP报文结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="请求报文-Request"><a href="#请求报文-Request" class="headerlink" title="请求报文(Request)"></a>请求报文(<code>Request</code>)</h4><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HTTP_RequestMessage.png" class="full-image" alt="请求报文" title="请求报文"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><blockquote>
<p>声明请求方法、主机域名和协议版本</p>
</blockquote>
<p>基本格式： <strong>Method Request-URI HTTP-Version CRLF</strong></p>
<p>Method：表示请求方法，例如<code>GET、POST...</code></p>
<p>Request-URI：统一资源标识符，例如<code>https://leo-wxy.github.io/</code></p>
<p>HTTP-Version：HTTP协议版本，例如<code>HTTP/1.1 HTTP/2.0</code></p>
<p>CRLF：表示回车和换行，<code>\r\n</code></p>
<p>示例数据： <code>GET http://leo-wxy.github.io/ HTTP/1.1</code></p>
<h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><blockquote>
<p>声明客户端的首部信息</p>
</blockquote>
<p>参考后面章节的 <code>Headers</code></p>
<h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5><blockquote>
<p>存放客户端发送给服务端的数据信息，若为<code>GET</code>请求则没有该结构</p>
</blockquote>
<p>参考后面章节的 <code>Body</code></p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><table>
<thead>
<tr>
<th>请求行</th>
<th><strong>GET /test/index.html HTTP/1.1</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>请求头</strong></td>
<td>Host : <a href="http://www.github.io" target="_blank" rel="noopener">www.github.io</a></td>
</tr>
<tr>
<td></td>
<td>User-Agent : Mozilla/5.0</td>
</tr>
<tr>
<td><strong>空行</strong></td>
<td>(用于隔开请求头和请求体)</td>
</tr>
<tr>
<td><strong>请求体</strong></td>
<td>id=0&amp;page=1</td>
</tr>
</tbody>
</table>
<h4 id="响应报文-Response"><a href="#响应报文-Response" class="headerlink" title="响应报文(Response)"></a>响应报文(<code>Response</code>)</h4><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HTTP_ResponseMessage.png" class="full-image" alt="响应报文" title="响应报文"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><blockquote>
<p>声明协议版本、状态码和描述(对状态码进行描述)</p>
</blockquote>
<p>​    基本格式： <strong>HTTP-Version Status-Code Reason-Parse CRLF</strong></p>
<p>​    HTTP-Version：HTTP协议版本，例如<code>HTTP/1.1 HTTP/2.0</code></p>
<p>​    Status-Code：服务器返回的状态码，对应上面的<a href="#响应状态码">响应状态码</a></p>
<p>​    Reason-Parse：状态码的文本描述，对应上面的<a href="#响应状态码">响应状态码</a></p>
<p>​    CRLF：表示回车和换行，<code>\r\n</code></p>
<p>​    示例数据： <code>HTTP/1.1 404 Not Found</code></p>
<h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><blockquote>
<p>声明客户端、服务端的报头信息</p>
</blockquote>
<p>参考后面章节的 <code>Headers</code></p>
<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><blockquote>
<p>存放反给客户端的数据信息</p>
</blockquote>
<p>参考后面章节的 <code>Body</code></p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><table>
<thead>
<tr>
<th>状态行</th>
<th>HTTP/1.1 200 OK</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>响应报头</strong></td>
<td>Connection : keep-alive</td>
</tr>
<tr>
<td></td>
<td>Server : Nginx</td>
</tr>
<tr>
<td><strong>空行</strong></td>
<td>(用于隔开响应头和响应正文)</td>
</tr>
<tr>
<td><strong>响应正文</strong></td>
<td>{“error”:false,”result”:1}</td>
</tr>
</tbody>
</table>
<h3 id="HTTP-Request-Methods"><a href="#HTTP-Request-Methods" class="headerlink" title="HTTP Request Methods"></a>HTTP Request Methods</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/HTTP请求方法mind.png" class="full-image" alt="HTTP请求方法" title="HTTP请求方法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p>HTTP协议所定义的请求方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>作用</th>
<th>描述</th>
<th>简化</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取资源</td>
<td>客户端需要从服务器读取资源时使用<br>一般用于获取/查询信息<br>通过URL传递且参数长度是有限制的<br>请求格式 <code>/test/result?key=key&amp;page=1</code><br>请求是安全的，因为只读，不会改变服务器数据</td>
<td>用于获取资源<br> 不设置Body <br>不会改变服务器数据<br>符合<strong>幂等性</strong></td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>客户端向服务端提供信息时使用<br>可以附带数据，用于更新服务器数据<br>将请求参数封装在请求数据中，可传输大量数据<br>传参方式更加安全，但是请求是不安全的，会导致服务器数据发生改变</td>
<td>会改变服务器数据，增加或修改资源<br> 需要设置Body<br>不符合<strong>幂等性</strong></td>
</tr>
<tr>
<td>HEAD</td>
<td>获取报文首部</td>
<td>不返回报文实体部分，主要用于确认URL有效性以及资源更新日期</td>
<td>几乎与<code>GET</code>相同<br>服务器不返回Body<br>可用于下载场景，获取信息</td>
</tr>
<tr>
<td>PUT</td>
<td>上传文件</td>
<td>自身不带验证机制，存在安全性问题。<strong>一般不使用</strong></td>
<td>会改变服务器数据，只能修改资源<br>不设置Body<br>符合<strong>幂等性</strong></td>
</tr>
<tr>
<td>PATCH</td>
<td>对资源部分进行修改</td>
<td>可以部分对资源进行修改</td>
<td></td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
<td>自身不带验证机制，存在安全性问题。</td>
<td>会改变服务器数据，删除资源<br>不设置Body<br>符合<strong>幂等性</strong></td>
</tr>
<tr>
<td>OPTIONS</td>
<td>查询支持的方法</td>
<td>查询指定的URL可以提供的方法。<br>返回示例：<code>Allow: GET , POST</code></td>
<td></td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求与代理服务器通信时建立隧道</td>
<td>对通信内容进行加密后通过网络隧道传输</td>
<td></td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径</td>
<td>将通信路径返回给客户端</td>
</tr>
</tbody>
</table>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><h5 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a><strong>幂等性</strong></h5><blockquote>
<p>对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。</p>
</blockquote>
<p>HTTP请求方法中的<code>GET、PUT、DELETE</code>是满足<code>幂等性</code>的。</p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="GET和POST请求有什么区别？"><a href="#GET和POST请求有什么区别？" class="headerlink" title="GET和POST请求有什么区别？"></a>GET和POST请求有什么区别？</h5><ul>
<li>GET请求会被主动缓存下来，留下历史记录；POST不会缓存</li>
<li>GET方式提交的数据长度有限制(URL长度限制)，POST请求数据可以非常大</li>
<li>GET请求只能进行URL编码；POST没有限制</li>
<li>GET请求都是放在URL中的，安全性不高；POST可以放在请求体中，增强安全性</li>
<li><strong>(本质区别)GET请求是幂等的；POST不是</strong></li>
</ul>
<h3 id="HTTP-Status-Code"><a href="#HTTP-Status-Code" class="headerlink" title="HTTP Status Code"></a>HTTP Status Code</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/HTTP状态码mind.png" class="full-image" alt="HTTP状态码" title="HTTP状态码"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p>位于服务端返回<strong>响应报文</strong>中的第一行，包含了状态码以及原因短语，用来告知客户端请求结果。</p>
</blockquote>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接收请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务端错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h4 id="1XX-信息状态码"><a href="#1XX-信息状态码" class="headerlink" title="1XX 信息状态码"></a>1XX 信息状态码</h4><ul>
<li>100 Continue：客户端继续发送请求</li>
<li>101 Switching Protocls：正在切换协议，可以切换HTTP 2.0</li>
</ul>
<h4 id="2XX-成功状态码"><a href="#2XX-成功状态码" class="headerlink" title="2XX 成功状态码"></a>2XX 成功状态码</h4><ul>
<li>200 OK：请求成功</li>
<li>204 No Content：请求成功，但没有body数据</li>
<li>206 Partial Content：部分内容，用于分块下载和断点续传，与<code>Content-Range</code>一起使用</li>
</ul>
<h4 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a>3XX 重定向状态码</h4><ul>
<li>301 Moved Permanently：永久性重定向 <em>常见</em></li>
<li>302 Found：临时性重定向</li>
<li>304 Not Modified：内容没有改变，与Http缓存有关</li>
</ul>
<h4 id="4XX-客户端错误状态码"><a href="#4XX-客户端错误状态码" class="headerlink" title="4XX 客户端错误状态码"></a>4XX 客户端错误状态码</h4><ul>
<li>400 Bad Request：请求报文存在语法错误</li>
<li>401 Unauthorized：未认证用户-<code>服务端不知道你是谁</code></li>
<li>403 Forbiden：请求被拒绝-<code>服务端知道你是谁，但你不配</code></li>
<li>404 Not Found：找不到对应服务器</li>
</ul>
<h4 id="5XX-服务端错误状态码"><a href="#5XX-服务端错误状态码" class="headerlink" title="5XX 服务端错误状态码"></a>5XX 服务端错误状态码</h4><ul>
<li>500 Internal Server Error：服务器执行请求发生错误</li>
<li>502 Bad Gateway：返回响应无效</li>
<li>503 Server Unavliable：服务器无法处理请求</li>
<li>504 Gateway Time-out：服务器处理请求超时</li>
</ul>
<h3 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/HTTP首部格式mind.png" class="full-image" alt="HTTP首部格式" title="HTTP首部格式"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p>HTTP消息的元数据(metadata)，例如消息长度、格式等。</p>
</blockquote>
<h4 id="请求报文Header"><a href="#请求报文Header" class="headerlink" title="请求报文Header"></a>请求报文Header</h4><h5 id="Accept：客户端可以接受的MIME类型"><a href="#Accept：客户端可以接受的MIME类型" class="headerlink" title="Accept：客户端可以接受的MIME类型"></a><strong>Accept</strong>：客户端可以接受的MIME类型</h5><blockquote>
<p>MIME类型：描述消息内容类型的因特网标准，包含文本、图像、音频、视频以及其他应用 程序专用数据，例如PDF之类的</p>
</blockquote>
<p><code>文本类型</code>：text/html、text/css</p>
<p><code>图片文件</code>：image/gif、image/png</p>
<p><code>视频文件</code>：video/mpeg、video/mp4</p>
<p><code>应用程序二进制文件</code>：application/json、application/pdf</p>
<p>如果<code>Accept</code>包含了某类型，表示客户端可以支持该格式数据处理。</p>
<p>一般MIME类型会和<code>q</code>这个属性一起使用，</p>
<p>例如<code>Accept:text/html,application/json;q=0.9,image/webp;q=0.8,*/*;q=0.8</code></p>
<p><code>q</code>表示了<strong>媒体类型增加优先级</strong>，权重高的优先处理。</p>
<p>例如上述数据表示：</p>
<table>
<thead>
<tr>
<th>权重</th>
<th>MIME类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.0</td>
<td>text/html</td>
</tr>
<tr>
<td>0.9</td>
<td>application/json</td>
</tr>
<tr>
<td>0.8</td>
<td>Image/webp</td>
</tr>
</tbody>
</table>
<h6 id="Accept-Encoding：支持的压缩方式"><a href="#Accept-Encoding：支持的压缩方式" class="headerlink" title="Accept-Encoding：支持的压缩方式"></a><strong>Accept-Encoding</strong>：支持的压缩方式</h6><blockquote>
<p>一般都会对传输数据进行编码压缩，设置客户端可接受的压缩方式</p>
</blockquote>
<p><code>gzip</code>：由文件压缩gzip程序产生的编码格式 <strong>最常用</strong></p>
<p><code>deflate</code>：使用zlib结构和deflate算法产生的压缩格式</p>
<p><code>br</code>：使用Brotil算法的压缩格式</p>
<p>如果配置了<code>q</code>，也表示相对优先级，例如<code>Accept-Encoding:gzip;q=0.9</code></p>
<h6 id="Accept-Language：支持的语言"><a href="#Accept-Language：支持的语言" class="headerlink" title="Accept-Language：支持的语言"></a><strong>Accept-Language</strong>：支持的语言</h6><blockquote>
<p>指定客户端支持的语言</p>
</blockquote>
<p>如果配置了<code>q</code>，也表示相对优先级，例如<code>Accept-Language:zh-CN;q=0.9</code></p>
<h6 id="Accept-Charset：支持的字符集"><a href="#Accept-Charset：支持的字符集" class="headerlink" title="Accept-Charset：支持的字符集"></a><strong>Accept-Charset</strong>：支持的字符集</h6><blockquote>
<p>指定客户端支持的字符集</p>
</blockquote>
<p>如果配置了<code>q</code>，也表示相对优先级，例如<code>Accept-Charset:utf-8;q=0.9</code></p>
<p><strong>Host</strong>：请求资源所在服务器</p>
<p><strong>User-Agent</strong>：当前访问服务器的用户信息</p>
<p><strong>Range</strong>：设置下载数据的范围，可用于断点续传/多线程下载。</p>
<h4 id="响应报文Header"><a href="#响应报文Header" class="headerlink" title="响应报文Header"></a>响应报文Header</h4><p><strong>Location</strong>：重定向后的目标url</p>
<p><strong>Accept-Range</strong>：表示当前可以按照<code>bytes</code>来进行资源获取</p>
<p><strong>Content-Type</strong>：指定请求体(Body)类型/响应体返回数据类型</p>
<ul>
<li><code>text/html</code>：返回Html文本</li>
<li><code>application/json、image/jpeg</code>：返回文本或文件内容，也可用于向服务器传输文件</li>
<li><code>application/x-www-form-urlencoded</code>：普通表单类型提交，只支持传文本</li>
<li><code>multitype/form-data</code>：支持提交二进制文件，例如图片啥的</li>
<li><code>charset=utf-8</code>：表示设置的字符集 对标于<code>Accept-Charset</code></li>
</ul>
<p><strong>Content-Encoding</strong>：服务端设置的压缩格式 对标于<code>Accept-Encoding</code></p>
<p><strong>Content-Language</strong>：服务端设置的语言 对标于<code>Accept-Language</code></p>
<h4 id="通用Header-请求-响应都可以用"><a href="#通用Header-请求-响应都可以用" class="headerlink" title="通用Header(请求/响应都可以用)"></a>通用Header(请求/响应都可以用)</h4><p><strong>Content-Length</strong>：指定请求体(Body)长度/响应体返回数据长度</p>
<p><strong>Connection</strong>：允许发送的指令连接选项</p>
<ul>
<li><code>keep-alive</code>：保持连接</li>
<li><code>close</code>：通讯完成后关闭连接</li>
</ul>
<p><strong>Cache-Control</strong>：对数据进行缓存，减少从服务器获取数据次数，优化网络性能</p>
<ul>
<li><code>no-cache</code>：需要使用到<code>对比缓存</code></li>
<li><code>no-store</code>：不要缓存数据</li>
<li><code>max-age:XX</code>：缓存在XX时间后失效</li>
<li><code>private</code>：客户端可以缓存数据(个人化信息)</li>
<li><code>public</code>：客户端与中间节点都可以进行缓存(所有人都能使用)</li>
<li><code>s-maxage</code>：限定缓存在代理服务器中可以存放多久</li>
</ul>
<h3 id="HTTP-Cache"><a href="#HTTP-Cache" class="headerlink" title="HTTP Cache"></a>HTTP Cache</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/HTTP缓存mind.png" class="full-image" alt="HTTP缓存" title="HTTP缓存"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p>Web性能优化的重要手段，主要依赖于上节中配置的<code>Header</code>。会去指定缓存的来源 </p>
</blockquote>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><blockquote>
<p>在第一次请求数据时，服务端在Header会携带<code>缓存规则信息</code>，只要符合缓存规则，就直接取缓存数据，不会重新发起请求。按照服务端给予的<code>缓存时间</code>比较，不超出则一直使用缓存数据。</p>
</blockquote>
<p>通过<code>Cache-Control</code>验证强缓存是否可用，如果设置了<code>max-age=XXX</code>，表示缓存会在<code>XXX</code>后的时间失效，在这期间只要请求资源，都会从缓存中获取数据。</p>
<p>在HTTP1.0版本使用的是<code>Expires</code>字段，存放的是一个具体的过期时间，但是存在<strong>服务器与客户端时间不同步</strong>问题，导致缓存失效时间无法确定。所以在HTTP1.1是废弃了该字段。</p>
<h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><blockquote>
<p>需要按照<code>Header</code>中的配置来判断是否需要读取缓存还是重新从服务器中拉取数据。</p>
</blockquote>
<p>按照缓存下来的数据标识，需要每次与服务器进行交互去验证<code>缓存标识</code>是否有效，有效则继续使用缓存数据即可。</p>
<p>以下则为认证时用到的<code>缓存标识</code>：</p>
<p><strong>Last-Modified/If-Modified-Since</strong></p>
<ul>
<li><code>Last-Modified</code>：服务端返回给客户端，表示资源的最后修改时间</li>
<li><code>If-Modified-Since</code>：客户端发送服务端，表示服务端返回的上次资源修改时间</li>
</ul>
<p>服务端在收到<code>If-Modified-Since</code>之后，与服务端资源进行比较</p>
<ul>
<li>若本地时间大于接收的时间，则返回<code>200</code>，需要客户端重新缓存资源</li>
<li>否则，返回<code>304</code>，表示资源没有发生变化，客户端可以继续使用本地缓存资源</li>
</ul>
<p><strong>ETag/If-None-Match</strong></p>
<ul>
<li><code>ETag</code>：服务端返回给客户端，表示当前资源在服务器的唯一标识</li>
<li><code>If-None-Match</code>：客户端发送给服务端，表示服务端说返回的资源唯一标识</li>
</ul>
<p>服务端在收到<code>If-None-Match</code>之后，进行服务器资源的唯一标识比对</p>
<ul>
<li>标识不一致，返回<code>200</code>，需要客户端重新缓存资源</li>
<li>否则，返回<code>304</code>，客户端可以继续使用本地缓存资源</li>
</ul>
<p><em>强制缓存的优先级是高于对比缓存的。</em></p>
<p><strong>Etag/If-None-Match</strong>这组标识符的优先级是高于<strong>Last-Modified/If-Modified-Since</strong>，如果存在则优先执行。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/http缓存流程.jpg" class="full-image" alt="HTTP缓存流程" title="HTTP缓存流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h4><blockquote>
<p>每次客户端缓存失效都需要从源服务器获取的话，会产生较大的压力。所以引入<code>代理缓存</code>机制，由代理服务器进行数据的缓存，但代理服务器缓存过期了才从源服务器请求数据。</p>
</blockquote>
<p>缓存代理的控制分为两部分：<strong>源服务端的控制</strong>，<strong>客户端的控制</strong>。</p>
<h5 id="源服务端的控制"><a href="#源服务端的控制" class="headerlink" title="源服务端的控制"></a>源服务端的控制</h5><p>通过配置<code>Cache-Control</code>属性进行控制</p>
<p><code>Cache-Control:public</code>：允许代理服务器进行缓存</p>
<p><code>Cache-Control:private</code>：只允许客户端进行缓存</p>
<p><code>Cache-Control:s-maxage=XXX</code>：允许缓存服务器最多缓存XXX时间</p>
<p>与<code>max-age</code>的区别是，<code>max-age</code>管理的是客户端的缓存有效时间。</p>
<h5 id="客户端的控制"><a href="#客户端的控制" class="headerlink" title="客户端的控制"></a>客户端的控制</h5><p>通过在请求头配置属性进行控制</p>
<p><code>max-stale:num</code>：表示客户端在代理服务器拿到缓存时，最多允许<code>num</code>的过期时间</p>
<p><code>min-fresh:num</code>：表示代理缓存在到期<code>num</code>秒之前可以获取</p>
<p><code>only-if-cached</code>：表示客户端只从代理缓存获取数据，获取缓存无效则返回<code>504</code>超时</p>
<h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/HTTP-Cookiemind.png" class="full-image" alt="HTTP Cookie" title="HTTP Cookie"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p><code>由于HTTP协议是无状态的，不对之前发生的请求和响应进行管理。</code>Cookie就是为了解决这类问题所提供的。可以用于对用户进行认证以及保存部分信息。客户端保存本地后，后续请求就会带上该信息。</p>
</blockquote>
<p><code>Cookie</code>会根据从服务端发送的响应报文(<code>Response</code>)内的一个叫做<code>Set-Cookie</code>的<code>Header</code>信息，通知客户端保存Cookie信息。当下次再发起请求时，客户端会自动在请求报文(<code>Request</code>)中加入<code>Cookie</code>值后发送到服务端。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/Cookie交互流程.jpg" class="full-image" alt="Cookie交互流程" title="Cookie交互流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>domain</td>
<td>String</td>
<td>指定浏览器发出HTTP请求时，哪些域名需要附加Cookie信息</td>
</tr>
<tr>
<td>expires</td>
<td>Date</td>
<td>指定一个具体的Cookie到期时间，值为UTC格式</td>
</tr>
<tr>
<td>httponly</td>
<td>Boolean</td>
<td>指定该无法通过JS脚本拿到，主要是<code>Document.cookie</code>获取</td>
</tr>
<tr>
<td>maxAge</td>
<td>String</td>
<td>指定从现在开始的Cookie存在秒数，超过则失效</td>
</tr>
<tr>
<td>path</td>
<td>String</td>
<td>指定浏览器发出Http请求时，哪些路径要附带这个Cookie信息</td>
</tr>
<tr>
<td>secure</td>
<td>Boolean</td>
<td>指定浏览器只有在<code>HTTPS</code>协议下可以发送Cookie到服务器</td>
</tr>
<tr>
<td>signed</td>
<td>Boolean</td>
<td>给浏览器发送一个加密的Cookie，服务端可以校验该Cookie是否被篡改</td>
</tr>
<tr>
<td>SameSite</td>
<td>String</td>
<td>设置第三方Cookie属性</td>
</tr>
</tbody>
</table>
<p>按照功能可以将以上7个属性进行分类</p>
<h5 id="Cookie生命周期-expires-maxAge"><a href="#Cookie生命周期-expires-maxAge" class="headerlink" title="Cookie生命周期-expires,maxAge"></a>Cookie生命周期-<code>expires,maxAge</code></h5><p><code>expires</code>设置的是一个<code>Date</code>格式的时间，<code>maxAge</code>设置的是一个<code>毫秒时间戳</code>。<strong>推荐使用maxAge</strong></p>
<p>若同时指定了<code>expires</code>和<code>maxAge</code>，那么<code>maxAge</code>属性优先生效。</p>
<p><em>若不设置任一属性的值，那么该Cookie仅在当前页面生效，关闭就不会再保留。</em></p>
<h5 id="Cookie作用域-domain-path"><a href="#Cookie作用域-domain-path" class="headerlink" title="Cookie作用域-domain,path"></a>Cookie作用域-<code>domain,path</code></h5><p><code>domain</code>设置哪些域名需要附加Cookie信息，<code>path</code>设置哪些路径需要附加Cookie信息(若<code>path:&#39;/&#39;</code>表示该域名下所有路径都附加Cookie信息)。</p>
<p><em>若与任一属性值不匹配，那么请求服务端时就不会带上Cookie信息。</em></p>
<h5 id="Cookie安全性-secure-httponly-SameSite"><a href="#Cookie安全性-secure-httponly-SameSite" class="headerlink" title="Cookie安全性-secure,httponly,SameSite"></a>Cookie安全性-<code>secure,httponly,SameSite</code></h5><p><code>secure</code>设置只有在<code>HTTPS协议</code>下可以传输Cookie；<code>httponly</code>设置Cookie只能通过HTTP协议进行传输，其他方式都无法获取Cookie信息。</p>
<p><code>SameSite</code>主要为了预防<code>CSRF攻击</code>，可以设置为3个值：</p>
<ul>
<li>None：显式关闭SameSite属性，但是必须设置<code>secure:true</code>，否则设置无效</li>
<li>Lax：只能在<code>GET</code>请求下使用，请求时会携带Cookie，否则不会有信息</li>
<li>Strict：浏览器完全禁止第三方请求携带Cookie信息，只能在同一域名下生效。</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>状态记录</strong>：记录当前状态，例如用户登录，操作记录</li>
<li><strong>用户偏好</strong>：记录用户的个性化设置</li>
<li><strong>行为分析</strong>：分析用户的行为，可以了解用户喜好</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>容量缺陷</strong>：Cookie保存的诗句不能超过4K，而且浏览器会设置保存Cookie的上限</li>
<li><strong>性能缺陷</strong>：Cookie默认跟随域名一起发起请求，无论需要与否，导致性能浪费。<em>可以通过设置<code>domain</code>和<code>path</code>减少使用。</em></li>
<li><strong>安全权限</strong>：Cookie以纯文本形式进行传递，很容易被非法截获，然后进行篡改后再发给服务端，降低安全性。</li>
</ul>
<h4 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h4><ul>
<li><p><strong>XSS(跨站脚本攻击)</strong>：被JavaScript获取用户Cookie，然后发送到其他网站，就会导致Cookie泄漏，危害数据安全。</p>
<p>解决方案：在Cookie信息中添加<code>HttpOnly</code>属性，就保证当前Cookie只会用于网络请求，而不会被获取。</p>
</li>
<li><p><strong>CSRF(跨站请求伪造)</strong>：随机访问可能存有Cookie的网址，然后越权操作用户数据。</p>
<p>解决方案：</p>
<ul>
<li><p>同源检测</p>
<ul>
<li><p>使用<code>Origin Header</code>确定来源域名</p>
</li>
<li><p>使用<code>Referer Header</code>确定来源域名</p>
</li>
</ul>
</li>
<li>CSRF Token</li>
<li>SameSite Cookie属性</li>
</ul>
</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><blockquote>
<p>是以安全为目标的HTTP通信，在HTTP下加入了SSL/TLS协议，用于保障HTTP的加密传输。</p>
<p><code>TLS(传输层安全性协议)</code>：前身为<code>SSL(安全套接层)</code>，目的是为互联网通信提供安全及数据完整性保障。</p>
<p>使用<code>SSL</code>后，HTTPS就具有<strong>加密、认证，完整性保护</strong>功能</p>
</blockquote>
<h3 id="HTTPS加密"><a href="#HTTPS加密" class="headerlink" title="HTTPS加密"></a>HTTPS加密</h3><h4 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h4><blockquote>
<p>采用单钥密码系统的加密方法，同一个密钥可以用作信息的加密和解密。</p>
<p>也可叫<code>单密钥加密</code>。</p>
</blockquote>
<h5 id="常用加密算法"><a href="#常用加密算法" class="headerlink" title="常用加密算法"></a>常用加密算法</h5><p>DES、AES</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/对称密钥加解密过程.png" class="full-image" alt="对称密钥加解密过程" title="对称密钥加解密过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h4><blockquote>
<p>需要两个密钥来进行加密和解密，这两个密钥分别是<strong>公钥(public key)</strong>和<strong>私钥(private key)</strong>。</p>
<p>公钥所有人都可以获得，通信方得到公钥后，就可以对发送内容进行加密，然后传递至服务端，服务端就可以利用私钥进行解密。</p>
<p>私钥还可以对服务端返回内容进行签名，利用公钥去验证签名是否正确，防止被人篡改。</p>
</blockquote>
<h5 id="常用加密算法-1"><a href="#常用加密算法-1" class="headerlink" title="常用加密算法"></a>常用加密算法</h5><p>RSA，ECC</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/非对称密钥加解密过程.png" class="full-image" alt="非对称密钥加解密过程" title="非对称密钥加解密过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="混合加密-HTTPS采用方案"><a href="#混合加密-HTTPS采用方案" class="headerlink" title="混合加密(HTTPS采用方案)"></a>混合加密(HTTPS采用方案)</h4><p>采用了<code>对称加密与非对称加密</code>混合加密的形式，只用<code>对称加密</code>，会有安全隐患；只用<code>非对称加密</code>，性能消耗太大。所以需要结合两者，保证性能的同时又保证安全。</p>
<ul>
<li>客户端向服务器发送<code>client_random</code>和加密方法列表(例如RSA方法)</li>
<li>服务端收到后，返回<code>server_random</code>、加密方法(RSA)以及<code>非对称加密公钥</code>到客户端</li>
<li>客户端收到后，再生成一个<code>pre_random</code>，使用<code>非对称加密公钥</code>加密后发送给服务器</li>
<li>服务端使用<code>非对称加密私钥</code>解密后，得到的就是<code>对称加密用到的密钥</code></li>
<li>双方持有<code>对称加密用到的密钥</code>后，后续数据通信就用<code>对称加密</code>的方式进行。</li>
</ul>
<p>本质就是为了<strong>防止私钥加密的数据外传。</strong></p>
<h4 id="数字证书-解决身份伪装问题"><a href="#数字证书-解决身份伪装问题" class="headerlink" title="数字证书(解决身份伪装问题)"></a>数字证书(解决身份伪装问题)</h4><blockquote>
<p>为了向服务器证明自己的身份，可以解决身份伪装问题。</p>
</blockquote>
<p>上面两种加密方式的结合，可以实现加密传输。但是还会存在一些问题，若发生了DNS劫持，那么传输过程中的所有内容都有可能造假，不能保证安全性。</p>
<p>数字证书的使用流程大概如下：</p>
<ol>
<li>服务器首先向一个大家都信任的第三方机构(<code>CA</code>)获取授权，获取通过后获取<strong>数字证书</strong>。</li>
<li>客户端向服务器建立通信之前向服务器请求获得服务器的证书</li>
<li>服务器收到请求之后发送<strong>数字证书</strong>给客户端</li>
<li>客户端获得证书之后，向第三方机构进行验证，验证通过后进行正常的内容通信。</li>
</ol>
<p>数字证书有两个作用：</p>
<ul>
<li>服务器向客户端证明自己的身份</li>
<li>把<code>非对称加密公钥</code>传给客户端</li>
</ul>
<h5 id="CA机构"><a href="#CA机构" class="headerlink" title="CA机构"></a>CA机构</h5><p>证书颁发机构。是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p>
<h4 id="数字签名-解决数据篡改问题"><a href="#数字签名-解决数据篡改问题" class="headerlink" title="数字签名(解决数据篡改问题)"></a>数字签名(解决数据篡改问题)</h4><blockquote>
<p>功能类似写在纸上的普通签名，可以用于校验通信双方数据的准确性以及完整性。</p>
</blockquote>
<p>数字签名有两个作用：</p>
<ul>
<li>验证数据是否为意料中的对象发出</li>
<li>对数据的完整性进行验证，验证数据是否被篡改过</li>
</ul>
<p><strong>使用私钥加密(生成签名)，公钥解密(验证签名)。</strong></p>
<p>服务端对消息进行私钥加密，客户端使用服务端传递的公钥进行验证，验证通过则表示消息一致，数字签名是正确的。</p>
<p>通常会对消息进行<strong>摘要</strong>，然后拿到消息的Hash值再进行私钥签名(<code>Hash值一般都会小于消息原文</code>)，大大提升签名效率。</p>
<p><strong>哈希摘要算法</strong>：根据任意长度数据计算出固定签名长度的算法。常用的有<code>SHA256、SHA384</code>。</p>
<h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/HTTPS通信过程.jpg" class="full-image" alt="HTTPS通信过程" title="HTTPS通信过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h4><blockquote>
<p>客户端发送消息到服务端</p>
</blockquote>
<p>客户端生成随机数<code>client_random</code>，然后发送<code>TLS版本</code>，<code>加密算法列表</code>发送给服务端。</p>
<p>例如：发送消息为</p>
<ul>
<li><p><code>Random</code>：client_random</p>
</li>
<li><p><code>Version</code>：TLS 1.2</p>
</li>
<li><p><code>Cipher Suites</code>：TLS_AES_128_GCM_SHA256（<code>只是其中一种，整体是一个List型</code>）</p>
<p>服务端会从列表中选择一种加密算法，后续使用该算法进行通信。</p>
</li>
</ul>
<h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><blockquote>
<p>服务端发送消息到客户端</p>
</blockquote>
<p>服务端同样生成随机数<code>server_random</code>，以及<code>确认的TLS版本</code> 、<code>服务端选择的加密算法</code>，<code>服务器的证书信息</code>返回给客户端。</p>
<p>例如：返回消息为</p>
<ul>
<li><code>Random</code>：server_random</li>
<li><code>Cipher Suite</code>：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256（<code>返回一个来确定后续都用这种加密方式</code>）<ul>
<li>ECDHE：密钥协商算法</li>
<li>RSA：证书公钥加密算法</li>
<li>AES_128：对称加密算法以及密法长度</li>
<li>GCM：AES加密模式</li>
<li>SHA256：消息摘要算法</li>
</ul>
</li>
<li><code>Certificate</code>：返回的服务端证书信息，以及<code>非对称加密使用的公钥</code></li>
</ul>
<h4 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h4><blockquote>
<p>客户端验证数字证书以及验证通过后发送消息到服务端</p>
</blockquote>
<p>客户端验证服务端传来<code>证书</code>和<code>签名</code>是否通过，如果通过，按照协议不同有以下两种处理方式</p>
<ul>
<li><p>传统RSA版本</p>
<p>客户端再生成一个随机数<code>pre_random</code>，并且使用证书携带的RSA公钥加密，传给服务端</p>
</li>
<li><p>TLS 1.2版本</p>
<p>客户端生产<code>client_params</code>参数给服务端</p>
</li>
</ul>
<h4 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a>Server Key Exchange</h4><blockquote>
<p>服务端根据传递的参数生成对称加密使用的密钥</p>
</blockquote>
<ul>
<li><p>传统RSA版本</p>
<p>服务端接收到客户端传来的<code>pre_random</code>，使用私钥进行解密，然后拿着<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code></p>
</li>
<li><p>TLS 1.2版本</p>
<p>服务端接收到客户端传来的<code>client_params</code>，使用<code>ECDHE(椭圆曲线加密)</code>，根据已有的<code>client_params</code>和<code>server_params</code>生成最后的<code>pre_random</code>，最后使用<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code></p>
</li>
</ul>
<p>服务端生成<code>secret</code>后，给客户端发送一个收尾消息，该收尾消息包含两部分：</p>
<ul>
<li><code>Change Cipher Spec</code>：提示客户端后续消息会采用<code>secret</code>的对称加密进行传递</li>
<li><code>Finished</code>：对之前报文的所有数据进行摘要，加密后交由客户端进行解密，解密通过则表示协商成功</li>
</ul>
<h4 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h4><blockquote>
<p>客户端根据已有的参数生成对称加密使用的密钥</p>
</blockquote>
<ul>
<li><p>传统RSA版本</p>
<p>客户端根据已有的<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code></p>
</li>
<li><p>TLS 1.2版本</p>
<p>客户端通过<code>ECDHE</code>算法计算出<code>pre_random</code>，其中传入两个参数:<strong>server_params</strong>和<strong>client_params</strong>。现在你应该清楚这个两个参数的作用了吧，由于<code>ECDHE</code>基于<code>椭圆曲线离散对数</code>，这两个参数也称作<code>椭圆曲线的公钥</code>。</p>
<p>客户端根据<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code>。</p>
</li>
</ul>
<p>客户端生成<code>secret</code>后，会给服务端发送一个收尾消息，该收尾消息包含两部分：</p>
<ul>
<li><code>Change Cipher Spec</code>：提示服务器后续消息会采用<code>secret</code>的对称加密进行传递</li>
<li><code>Finished</code>：对之前报文的所有数据进行摘要，加密后交由服务端进行解密，解密通过则表示协商成功</li>
</ul>
<p>当客户端与服务端都收到<code>finished</code>消息后，客户端和服务端都会持有<code>secret</code>，后续的请求都会使用<code>secret</code>进行对称加密传递消息。</p>
<h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h3><ol>
<li>HTTPS协议握手阶段比较费时，因为需要加密/解密过程</li>
<li>SSL证书是需要收费</li>
<li>HTTPS加密范围有限，而且证书不一定是可以信任的</li>
</ol>
<h3 id="与HTTP区别"><a href="#与HTTP区别" class="headerlink" title="与HTTP区别"></a>与HTTP区别</h3><ul>
<li>https协议需要向<code>CA</code>申请证书，需要一定费用</li>
<li>http信息是明文传输，HTTPS具有安全性的ssl加密传输协议</li>
<li>http和https使用的是完全不同的连接方式，端口不同，http使用了<code>80</code>端口，https使用<code>443</code>端口</li>
<li>http连接是简单的，无状态的；HTTPS由<code>http+ssl</code>构成的可进行加密传输，身份认证的网络协议，更加安全。</li>
</ul>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><blockquote>
<p>攻击者与通信两端(服务端与客户端)分别创建独立的联系，并交换所受到的数据，使通信的两端认为他们正在通过一个私密的连接与对方直接通信，事实上整个会话都被攻击者完全控制、</p>
<p>中间人攻击者可以拦截通讯双方的通话并插入新的内容。</p>
</blockquote>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/中间人攻击.jpg" class="full-image" alt="中间人攻击" title="中间人攻击"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="如何防御中间人攻击？"><a href="#如何防御中间人攻击？" class="headerlink" title="如何防御中间人攻击？"></a>如何防御中间人攻击？</h4><ul>
<li><p>公钥基础建设PKI</p>
<p>PKI相互认证机制，服务端验证客户端，客户端验证服务端</p>
</li>
<li><p>使用复杂加密哈希函数运行计算以造成数十秒的延迟</p>
<p>如果双方通信时间过长，可以基本判断存在中间人</p>
</li>
</ul>
<h2 id="HTTP协议版本区别"><a href="#HTTP协议版本区别" class="headerlink" title="HTTP协议版本区别"></a>HTTP协议版本区别</h2><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><ul>
<li>默认短连接</li>
<li>增加了POST、HEAD命令</li>
</ul>
<h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><ul>
<li>默认长连接(默认添加Header<code>Connection:Keep-Alive</code>)</li>
<li>增加了请求方法(<code>OPTIONS、PUT、DELETE、TRACE、CONNECT</code>)</li>
<li>请求消息和响应消息都支持Host头域</li>
<li>支持chunked编码传输</li>
</ul>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul>
<li><p>头部压缩</p>
<p>针对请求头字段进行压缩，采用了<code>HPACK</code>算法</p>
<p>HPACK算法：</p>
<ul>
<li>在服务端与客户端建立哈希表，存放使用的字段，只要在传输过程传输索引值，然后按照索引表查询即可</li>
<li>对于整数和字符串进行<strong>哈夫曼编码</strong></li>
</ul>
</li>
<li><p>多路复用</p>
<p>允许同时通过单一的HTTP2连接发起多重请求，由于把HTTP通信的基本单位缩小为一个个的二进制帧，各自对应着信息。</p>
</li>
<li><p>二进制分帧</p>
<p>HTTP/2在 应用层和传输层增加一个<code>二进制分层</code>，在该分层中将传输的信息分割为更小的消息和帧，并采用二进制格式的编码。</p>
<blockquote>
<p>HTTP队头阻塞：在同一个TCP长连接中，前面的请求没有得到响应的话，后面的请求就无法被处理，导致阻塞。</p>
<p><code>并发连接</code>：对于一个域名分配多个长连接，相当于增加了任务队列，可以分散任务。</p>
<p><code>域名分片</code>：对一个域名分配多个二级域名，但是指向同一台服务器，使并发变多。</p>
</blockquote>
</li>
<li><p>服务端推送    </p>
<p>在客户端请求之前发送数据，客户端请求一个资源后，服务端判断可能还需要其他资源，就会主动发送消息到客户端，减少客户端的等待</p>
</li>
</ul>
<h2 id="HTTP相关协议"><a href="#HTTP相关协议" class="headerlink" title="HTTP相关协议"></a>HTTP相关协议</h2><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><blockquote>
<p>提供域名到IP地址之间的解析服务，能够使人更方便地访问互联网。</p>
<p>还可以根据多个地址做负载均衡，并且选择一个就近的地点IP进行访问。</p>
</blockquote>
<h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><ol>
<li>客户端访问<code>XX.com</code>域名，先去请求本地DNS解析器</li>
<li>本地DNS解析器先去查看本地缓存是否有对应记录，若有直接使用；否则请求本地DNS服务器</li>
<li>本地DNS服务器一般部署在运营商网络中，然后本地DNS服务器也会查看是否存在本地缓存，存在则直接使用；否则递归请求根服务器</li>
<li>直到请求到顶级域名服务器，例如<code>.com</code>，查到数据后返回真实的IP地址。</li>
</ol>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><h5 id="域名缓存问题"><a href="#域名缓存问题" class="headerlink" title="域名缓存问题"></a>域名缓存问题</h5><p>由于DNS会优先获取本地缓存，如果缓存没有及时刷新，就会导致访问失败。</p>
<h5 id="域名转发问题"><a href="#域名转发问题" class="headerlink" title="域名转发问题"></a>域名转发问题</h5><p>DNS解析请求可能会被转发到其他DNS服务器进行处理，导致解析时无法判断地址，而返回一个较远IP使访问异常。</p>
<h5 id="域名更新问题"><a href="#域名更新问题" class="headerlink" title="域名更新问题"></a>域名更新问题</h5><p>忽略域名缓存IP的有效时间，导致结果更新不及时，一样会有访问异常问题</p>
<h5 id="解析延迟问题"><a href="#解析延迟问题" class="headerlink" title="解析延迟问题"></a>解析延迟问题</h5><p>DNS会进行递归解析，可能经过多个服务器，才可以获得最终结果，中间时间非常漫长</p>
<h4 id="HTTPDNS"><a href="#HTTPDNS" class="headerlink" title="HTTPDNS"></a>HTTPDNS</h4><blockquote>
<p>不走传统的DNS解析模式，自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商。需要进行DNS解析时，直接通过HTTP请求这个集群得到结果即可。</p>
</blockquote>
<h5 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h5><p>在客户端动态请求HTTPDNS服务端，获取解析的IP结果以及失效时间缓存到本地。后续在缓存未失效的情况下可直接返回对应域名的IP信息。如果没有返回信息，也可以降级回最初的LocalDNS解析方案。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote>
<p>内容分发网络(Content Delivery Network)。主要目的是<strong>改善互联网服务质量</strong>，提供用户访问网站的响应速度和成功率。</p>
</blockquote>
<h3 id="URL-URI"><a href="#URL-URI" class="headerlink" title="URL/URI"></a>URL/URI</h3><blockquote>
<p>用户在浏览器地址栏输入的或者是App发起请求时设置的地址</p>
</blockquote>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/URL组成.jpg" class="full-image" alt="URL组成" title="URL组成"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h5 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h5><p>目前分为两类：<code>HTTP</code>与<code>HTTPS</code></p>
<h5 id="服务器地址"><a href="#服务器地址" class="headerlink" title="服务器地址"></a>服务器地址</h5><p>对应的是所需接受浏览器/App请求的服务器地址</p>
<h5 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h5><p>对应请求需要处理的位置</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="">图解HTTP</a></p>
<p><a href="https://mp.weixin.qq.com/s/smYo1tECl6-TS6anKF8Jgw" target="_blank" rel="noopener">深入理解HTTPS</a></p>
<p><a href="https://juejin.im/post/5e76bd516fb9a07cce750746#heading-74" target="_blank" rel="noopener">HTTP灵魂之问</a></p>
<p><a href="[https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB](https://zh.wikipedia.org/wiki/中间人攻击">中间人攻击</a>)</p>
<p><a href="https://www.jianshu.com/p/52d86558ca57" target="_blank" rel="noopener">HTTP协议版本差异</a></p>
<p><a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">GET与POST区别</a></p>
<p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">CSRF防护</a></p>
<p>​            </p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">

      <div>
        
         <div>


    
<div style="text-align:center;color: #ccc;font-size:14px;">
------ 本文结束<i class="fa fa-heart"></i>感谢您的阅读 ------</div>

<div>    
 
 
    <ul class="post-copyright">
      <li class="post-copyright-author">
          <strong>本文作者：</strong> Leo-Wxy
      </li>
      <li class="post-copyright-link">
        <strong>本文链接：</strong>
        <a href="/2020/03/29/HTTP的原理和工作机制/" title="HTTP的原理和工作机制">2020/03/29/HTTP的原理和工作机制/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明： </strong>
        本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！
      </li>
    </ul>
  
</div>

</div>
        
      </div>

      
        <div class="post-tags">
          
            <a href="/tags/HTTP/" rel="tag"># HTTP</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/23/Android性能优化-内存优化详解/" rel="next" title="Android性能优化-内存优化详解">
                <i class="fa fa-chevron-left"></i> Android性能优化-内存优化详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/31/TCP-IP协议相关/" rel="prev" title="TCP/IP协议相关">
                TCP/IP协议相关 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Leo-Wxy">
            
              <p class="site-author-name" itemprop="name">Leo-Wxy</p>
              <div class="site-description motion-element" itemprop="description">如果我没有见过光明，那我本可以忍受黑暗</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">131</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/leo-wxy" title="GitHub &rarr; https://github.com/leo-wxy" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/xy.wang.android@gmail.com" title="E-Mail &rarr; xy.wang.android@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP的原理和工作机制"><span class="nav-number">1.</span> <span class="nav-text">HTTP的原理和工作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是HTTP"><span class="nav-number">1.1.</span> <span class="nav-text">什么是HTTP?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP工作机制"><span class="nav-number">1.1.1.</span> <span class="nav-text">HTTP工作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器输入地址后发生了什么？"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">浏览器输入地址后发生了什么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP特点与缺点"><span class="nav-number">1.1.2.</span> <span class="nav-text">HTTP特点与缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP报文结构"><span class="nav-number">1.1.3.</span> <span class="nav-text">HTTP报文结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#请求报文-Request"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">请求报文(Request)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#请求行"><span class="nav-number">1.1.3.1.1.</span> <span class="nav-text">请求行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请求头"><span class="nav-number">1.1.3.1.2.</span> <span class="nav-text">请求头</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请求体"><span class="nav-number">1.1.3.1.3.</span> <span class="nav-text">请求体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#示例"><span class="nav-number">1.1.3.1.4.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应报文-Response"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">响应报文(Response)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#状态行"><span class="nav-number">1.1.3.2.1.</span> <span class="nav-text">状态行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#响应头"><span class="nav-number">1.1.3.2.2.</span> <span class="nav-text">响应头</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#响应报文"><span class="nav-number">1.1.3.2.3.</span> <span class="nav-text">响应报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#示例-1"><span class="nav-number">1.1.3.2.4.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Request-Methods"><span class="nav-number">1.1.4.</span> <span class="nav-text">HTTP Request Methods</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tips"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#幂等性"><span class="nav-number">1.1.4.1.1.</span> <span class="nav-text">幂等性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见问题"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#GET和POST请求有什么区别？"><span class="nav-number">1.1.4.2.1.</span> <span class="nav-text">GET和POST请求有什么区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Status-Code"><span class="nav-number">1.1.5.</span> <span class="nav-text">HTTP Status Code</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1XX-信息状态码"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">1XX 信息状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2XX-成功状态码"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">2XX 成功状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3XX-重定向状态码"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">3XX 重定向状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4XX-客户端错误状态码"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">4XX 客户端错误状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5XX-服务端错误状态码"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">5XX 服务端错误状态码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Header"><span class="nav-number">1.1.6.</span> <span class="nav-text">HTTP Header</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#请求报文Header"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">请求报文Header</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Accept：客户端可以接受的MIME类型"><span class="nav-number">1.1.6.1.1.</span> <span class="nav-text">Accept：客户端可以接受的MIME类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Accept-Encoding：支持的压缩方式"><span class="nav-number">1.1.6.1.1.1.</span> <span class="nav-text">Accept-Encoding：支持的压缩方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Accept-Language：支持的语言"><span class="nav-number">1.1.6.1.1.2.</span> <span class="nav-text">Accept-Language：支持的语言</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Accept-Charset：支持的字符集"><span class="nav-number">1.1.6.1.1.3.</span> <span class="nav-text">Accept-Charset：支持的字符集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应报文Header"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">响应报文Header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通用Header-请求-响应都可以用"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">通用Header(请求/响应都可以用)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Cache"><span class="nav-number">1.1.7.</span> <span class="nav-text">HTTP Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强制缓存"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">强制缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对比缓存"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">对比缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理缓存"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">代理缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#源服务端的控制"><span class="nav-number">1.1.7.3.1.</span> <span class="nav-text">源服务端的控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#客户端的控制"><span class="nav-number">1.1.7.3.2.</span> <span class="nav-text">客户端的控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Cookie"><span class="nav-number">1.1.8.</span> <span class="nav-text">HTTP Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Cookie生命周期-expires-maxAge"><span class="nav-number">1.1.8.1.1.</span> <span class="nav-text">Cookie生命周期-expires,maxAge</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cookie作用域-domain-path"><span class="nav-number">1.1.8.1.2.</span> <span class="nav-text">Cookie作用域-domain,path</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cookie安全性-secure-httponly-SameSite"><span class="nav-number">1.1.8.1.3.</span> <span class="nav-text">Cookie安全性-secure,httponly,SameSite</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#作用"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-1"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#风险"><span class="nav-number">1.1.8.4.</span> <span class="nav-text">风险</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS"><span class="nav-number">1.2.</span> <span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS加密"><span class="nav-number">1.2.1.</span> <span class="nav-text">HTTPS加密</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对称密钥加密"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">对称密钥加密</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常用加密算法"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">常用加密算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非对称密钥加密"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">非对称密钥加密</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常用加密算法-1"><span class="nav-number">1.2.1.2.1.</span> <span class="nav-text">常用加密算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#混合加密-HTTPS采用方案"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">混合加密(HTTPS采用方案)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数字证书-解决身份伪装问题"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">数字证书(解决身份伪装问题)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CA机构"><span class="nav-number">1.2.1.4.1.</span> <span class="nav-text">CA机构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数字签名-解决数据篡改问题"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">数字签名(解决数据篡改问题)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#握手过程"><span class="nav-number">1.2.2.</span> <span class="nav-text">握手过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Client-Hello"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Client Hello</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Server-Hello"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Server Hello</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Certificate"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Certificate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Server-Key-Exchange"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">Server Key Exchange</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Client-Key-Exchange"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">Client Key Exchange</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS缺点"><span class="nav-number">1.2.3.</span> <span class="nav-text">HTTPS缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与HTTP区别"><span class="nav-number">1.2.4.</span> <span class="nav-text">与HTTP区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中间人攻击"><span class="nav-number">1.2.5.</span> <span class="nav-text">中间人攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何防御中间人攻击？"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">如何防御中间人攻击？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP协议版本区别"><span class="nav-number">1.3.</span> <span class="nav-text">HTTP协议版本区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP1-0"><span class="nav-number">1.3.1.</span> <span class="nav-text">HTTP1.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP1-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">HTTP1.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP2-0"><span class="nav-number">1.3.3.</span> <span class="nav-text">HTTP2.0</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP相关协议"><span class="nav-number">1.4.</span> <span class="nav-text">HTTP相关协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS协议"><span class="nav-number">1.4.1.</span> <span class="nav-text">DNS协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解析过程"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">解析过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存在的问题"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#域名缓存问题"><span class="nav-number">1.4.1.2.1.</span> <span class="nav-text">域名缓存问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#域名转发问题"><span class="nav-number">1.4.1.2.2.</span> <span class="nav-text">域名转发问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#域名更新问题"><span class="nav-number">1.4.1.2.3.</span> <span class="nav-text">域名更新问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解析延迟问题"><span class="nav-number">1.4.1.2.4.</span> <span class="nav-text">解析延迟问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPDNS"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">HTTPDNS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#工作模式"><span class="nav-number">1.4.1.3.1.</span> <span class="nav-text">工作模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CDN"><span class="nav-number">1.4.2.</span> <span class="nav-text">CDN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL-URI"><span class="nav-number">1.4.3.</span> <span class="nav-text">URL/URI</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#协议类型"><span class="nav-number">1.4.3.0.1.</span> <span class="nav-text">协议类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#服务器地址"><span class="nav-number">1.4.3.0.2.</span> <span class="nav-text">服务器地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请求路径"><span class="nav-number">1.4.3.0.3.</span> <span class="nav-text">请求路径</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考链接"><span class="nav-number">1.5.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo-Wxy</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.1</div>




        








        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
