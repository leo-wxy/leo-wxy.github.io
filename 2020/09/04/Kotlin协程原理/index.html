

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <meta name="description" content="在介绍了大部分概念，现在需要针对这些概念进行详细的说明以及分析。 协程是轻量级的线程  协程概念 非抢占式或协作式的计算机并发调度的实现，程序可以主动挂起或者恢复执行， 避免在异步程序中使用大量的回调，使用阻塞的方式写出非阻塞的代码。  一种全新处理并发的方式，可以在Android平台上简化异步执行的代码。 协程主要用来解决两个问题：  处理耗时任务 保证主线程安全  在后面的原理介绍中，会介绍与">
<meta name="keywords" content="Kotlin">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin协程原理">
<meta property="og:url" content="https://leo-wxy.github.io/2020/09/04/Kotlin协程原理/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="在介绍了大部分概念，现在需要针对这些概念进行详细的说明以及分析。 协程是轻量级的线程  协程概念 非抢占式或协作式的计算机并发调度的实现，程序可以主动挂起或者恢复执行， 避免在异步程序中使用大量的回调，使用阻塞的方式写出非阻塞的代码。  一种全新处理并发的方式，可以在Android平台上简化异步执行的代码。 协程主要用来解决两个问题：  处理耗时任务 保证主线程安全  在后面的原理介绍中，会介绍与">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://leo-wxy.github.io/images/Job生命周期.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/协程调度器间的差异">
<meta property="og:image" content="https://leo-wxy.github.io/images/协程异常传递流程">
<meta property="og:image" content="https://leo-wxy.github.io/images/SuperVisorJob不取消">
<meta property="og:image" content="https://leo-wxy.github.io/images/协程挂起流程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/协程恢复流程.png">
<meta property="og:updated_time" content="2020-12-20T14:08:48.000Z">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Kotlin协程原理">
<meta name="twitter:description" content="在介绍了大部分概念，现在需要针对这些概念进行详细的说明以及分析。 协程是轻量级的线程  协程概念 非抢占式或协作式的计算机并发调度的实现，程序可以主动挂起或者恢复执行， 避免在异步程序中使用大量的回调，使用阻塞的方式写出非阻塞的代码。  一种全新处理并发的方式，可以在Android平台上简化异步执行的代码。 协程主要用来解决两个问题：  处理耗时任务 保证主线程安全  在后面的原理介绍中，会介绍与">
<meta name="twitter:image" content="https://leo-wxy.github.io/images/Job生命周期.jpg">
  
  <title>Kotlin协程原理 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.12","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Kotlin协程原理">
              
                Kotlin协程原理
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-04 10:15" pubdate>
        2020年9月4日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      30k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      93 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Kotlin协程原理</h1>
            
            <div class="markdown-body">
              <p>在介绍了大部分概念，现在需要针对这些概念进行详细的说明以及分析。</p>
<blockquote><p>协程是轻量级的线程</p>
</blockquote>
<h2 id="协程概念"><a href="#协程概念" class="headerlink" title="协程概念"></a>协程概念</h2><blockquote>
<p><code>非抢占式或协作式</code>的计算机并发调度的实现，程序可以主动挂起或者恢复执行，</p>
<p>避免在异步程序中使用大量的回调，<strong>使用阻塞的方式写出非阻塞的代码。</strong></p>
</blockquote>
<p>一种全新处理并发的方式，可以在Android平台上简化异步执行的代码。</p>
<p><code>协程</code>主要用来解决两个问题：</p>
<ul>
<li><strong>处理耗时任务</strong></li>
<li><strong>保证主线程安全</strong></li>
</ul>
<p>在后面的原理介绍中，会介绍与这两个问题相关的概念。</p>
<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><blockquote>
<p>在执行过程中会涉及的一些概念，在后续源码分析也会涉及。</p>
</blockquote>
<p><code>协程体</code></p>
<p>协程中要执行的操作，是一个被<code>suspend</code>修饰的<code>lambda表达式</code></p>
<p><code>挂起函数</code></p>
<p>由<code>suspend</code>修饰的函数，只能在<code>挂起函数</code>或者<code>协程体</code>中调用。可以通过调用其他<code>挂起函数</code>挂起执行代码，而不阻塞当前执行线程。</p>
<p><code>挂起点</code></p>
<p>一般对应<code>挂起函数</code>被调用的位置</p>
<p><code>续体-Continuation</code></p>
<p>挂起的协程在<code>挂起点</code>时的状态。概念上表示<code>挂起点之后的剩余应该执行的代码</code>。</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><h3 id="协程作用域—CoroutineScope"><a href="#协程作用域—CoroutineScope" class="headerlink" title="协程作用域—CoroutineScope"></a>协程作用域—CoroutineScope</h3><blockquote>
<p>追踪每一个通过<code>launch</code>或<code>async</code>创建的协程。并且任何时候都可以通过<code>scope.cancel()</code>取消正在执行的协程。</p>
<p>可以通过<code>CoroutineScope</code>控制协程的生命周期，当Activity/Fragment关闭时，调用<code>cancel()</code>及时关闭。</p>
</blockquote>
<p><code>协程作用域</code>主要有三种：</p>
<h4 id="阻塞协程作用域"><a href="#阻塞协程作用域" class="headerlink" title="阻塞协程作用域"></a>阻塞协程作用域</h4><p>调用<code>runBlocking()</code>的线程会被阻塞直到内部协程任务执行完毕。</p>
<h4 id="全局协程作用域"><a href="#全局协程作用域" class="headerlink" title="全局协程作用域"></a>全局协程作用域</h4><p><code>GlobalScope</code>作用于整个应用的生命周期，并且无法被取消，在界面上使用时，就会导致内存泄漏。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;  <br>    <span class="hljs-comment">// 重写coroutineContext，返回一个空的协程上下文  </span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext  <br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineScope</span> </span>&#123;  <br>    <span class="hljs-comment">// 协程上下文  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext  <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="自定义作用域"><a href="#自定义作用域" class="headerlink" title="自定义作用域"></a>自定义作用域</h4><p>自定义协程作用域，可以针对性的控制避免内存泄漏。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job()<span class="hljs-comment">//协程上下文</span><br><span class="hljs-keyword">val</span> coroutineScope = CoroutineScope(coroutineContext)<span class="hljs-comment">//自定义作用域</span><br></code></pre></td></tr></table></figure>
<p>需要自定义<code>协程作用域</code>时，需要构造一个<code>CoroutineContext</code>作为参数。</p>
<p><code>CoroutineContext</code>会在下面重点介绍。</p>
<h5 id="内置的自定义作用域"><a href="#内置的自定义作用域" class="headerlink" title="内置的自定义作用域"></a>内置的自定义作用域</h5><h6 id="MainScope"><a href="#MainScope" class="headerlink" title="MainScope"></a>MainScope</h6><blockquote>
<p>为了方便开发使用，Kotlin标准库提供了<code>MainScope</code>用于快速生成<code>CoroutineScope</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MainScope</span><span class="hljs-params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)<br></code></pre></td></tr></table></figure>
<h6 id="viewModelScope"><a href="#viewModelScope" class="headerlink" title="viewModelScope"></a>viewModelScope</h6><blockquote>
<p>在AndroidX中引入的<code>viewMdoelScope</code>，在ViewModel销毁时会自动取消协程任务</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> ViewModel.viewModelScope: CoroutineScope<br>        <span class="hljs-keyword">get</span>() &#123;<br>            <span class="hljs-keyword">val</span> scope: CoroutineScope? = <span class="hljs-keyword">this</span>.getTag(JOB_KEY)<br>          <span class="hljs-comment">//缓存中读取 对应scope</span><br>            <span class="hljs-keyword">if</span> (scope != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> scope<br>            &#125;<br>           <span class="hljs-comment">//对应了ViewModel内部的实现代码</span><br>            <span class="hljs-keyword">return</span> setTagIfAbsent(JOB_KEY,<br>                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate))<br>        &#125;<br><span class="hljs-comment">//自动取消 coroutineScope</span><br><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseableCoroutineScope</span></span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext = context<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123;<br>        coroutineContext.cancel()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="协程上下文-CoroutineContext"><a href="#协程上下文-CoroutineContext" class="headerlink" title="协程上下文-CoroutineContext"></a>协程上下文-CoroutineContext</h3><blockquote>
<p>一组定义协程行为的元素，本体是一个数据结构，类似于<code>Map</code>，内部实现为<code>单链表</code></p>
</blockquote>
<p>由如下几项构成：</p>
<ul>
<li>Job：执行的任务</li>
<li>CoroutineDispatcher：协程调度器</li>
<li>CoroutineName：协程的名称，主要用于调试</li>
<li>CoroutineExceptionHandler：处理未被捕获的异常。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineContext</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E?<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fold</span><span class="hljs-params">(initial: <span class="hljs-type">R</span>, operation: (<span class="hljs-type">R</span>, <span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: CoroutineContext =<br>        <span class="hljs-comment">//空实现直接返回</span><br>        <span class="hljs-keyword">if</span> (context === EmptyCoroutineContext) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> <br>           <span class="hljs-comment">// 遍历context集合</span><br>            context.fold(<span class="hljs-keyword">this</span>) &#123; acc, element -&gt; <span class="hljs-comment">//acc 当前上下文集合 element context集合的元素</span><br>                <span class="hljs-keyword">val</span> removed = acc.minusKey(element.key) <span class="hljs-comment">//移除对应集合的元素</span><br>                <span class="hljs-keyword">if</span> (removed === EmptyCoroutineContext) element <span class="hljs-keyword">else</span> &#123; <br>                    <span class="hljs-keyword">val</span> interceptor = removed[ContinuationInterceptor] <span class="hljs-comment">//获取拦截器</span><br>                    <span class="hljs-keyword">if</span> (interceptor == <span class="hljs-literal">null</span>) CombinedContext(removed, element) <span class="hljs-comment">//生成最后的CombinedContext节点</span><br>                  <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//拦截器永远位于 链表尾部</span><br>                        <span class="hljs-keyword">val</span> left = removed.minusKey(ContinuationInterceptor)<br>                        <span class="hljs-keyword">if</span> (left === EmptyCoroutineContext) CombinedContext(element, interceptor) <span class="hljs-keyword">else</span><br>                            CombinedContext(CombinedContext(left, element), interceptor)<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minusKey</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="自定义CoroutineContext"><a href="#自定义CoroutineContext" class="headerlink" title="自定义CoroutineContext"></a>自定义CoroutineContext</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job() + CoroutineName(<span class="hljs-string">"name"</span>)<span class="hljs-comment">//协程上下文</span><br></code></pre></td></tr></table></figure>
<p><code>CoroutineContext</code>通过<code>+</code>进行元素的合并，<code>+</code>右侧的元素会覆盖左侧的元素。</p>
<p><code>CoroutineContext</code>存储方式为<code>左向链表</code>，链表的每一个节点都是<code>CombinedContext</code>，当存在<code>协程拦截器</code>时，永远处于链表的最后。</p>
<p>经过上述的<code>plus</code>操作后，最后得到一个完整的<code>CoroutineContext</code>对象。</p>
<h4 id="CoroutineContext的父子关系"><a href="#CoroutineContext的父子关系" class="headerlink" title="CoroutineContext的父子关系"></a>CoroutineContext的父子关系</h4><blockquote>
<p>每个协程都会有一个父对象，协程的父级<code>CoroutineContext</code>和父协程的<code>CoroutineContext</code>是不一致的。</p>
</blockquote>
<p><strong>父级上下文 = 默认值 + 继承的<code>CoroutineContext</code>+参数</strong></p>
<p><code>默认值</code>：一些元素包含的默认值，例如默认<code>Dispatcher</code>就是<code>Dispatchers.Default</code></p>
<p><code>继承的CoroutineContext</code>：父协程的<code>CoroutineContenxt</code></p>
<p><code>参数</code>：后续子协程配置的参数，如上文所示组成部分，新添加的参数会覆盖前面的对应配置。</p>
<h3 id="协程执行任务-Job"><a href="#协程执行任务-Job" class="headerlink" title="协程执行任务-Job"></a>协程执行任务-Job</h3><blockquote>
<p>用于处理协程，封装了协程需要执行的代码逻辑，并且负责管理协程的生命周期。</p>
<p>通过<code>协程构造器</code>创建的协程都会返回一个<code>Job实例</code>。</p>
</blockquote>
<p>主要有以下几种生命周期：</p>
<ul>
<li><code>New</code> 新建任务</li>
<li><code>Active</code> 任务活跃</li>
<li><code>Completing</code> 任务完成中</li>
<li><code>Cancelling</code> 任务取消中</li>
<li><code>Cancelled</code> 任务已取消</li>
<li><code>Completed</code> 任务已完成</li>
</ul>
<p><img src="/images/Job生命周期.jpg" srcset="/img/loading.gif" lazyload alt="Job生命周期"></p>
<p><code>Job</code>内提供了<code>isActive()</code>、<code>isCancelled()</code>和<code>isCompleted()</code>等属性用于判断协程的状态。</p>
<p><a href="#协程取消-Cancel">协程取消</a>会更多的分析<code>Job</code>相关。</p>
<h3 id="协程调度器-CoroutineDispatcher"><a href="#协程调度器-CoroutineDispatcher" class="headerlink" title="协程调度器-CoroutineDispatcher"></a>协程调度器-CoroutineDispatcher</h3><blockquote>
<p><code>Dispatchers</code>是协程中提供的<code>线程调度器</code>，用来切换线程，指定协程运行的线程。</p>
</blockquote>
<p>默认提供了四种调度器</p>
<h4 id="Dispatchers-Default"><a href="#Dispatchers-Default" class="headerlink" title="Dispatchers.Default"></a>Dispatchers.Default</h4><blockquote>
<p>默认调度器，适合处理后台运算，为<code>CPU密集型</code>任务调度器</p>
</blockquote>
<h4 id="Dispatchers-IO-仅JVM可用"><a href="#Dispatchers-IO-仅JVM可用" class="headerlink" title="Dispatchers.IO(仅JVM可用)"></a>Dispatchers.IO(仅JVM可用)</h4><blockquote>
<p>适合执行IO相关操作，例如<code>读写文件</code>等，为<code>IO密集型</code>任务调度器</p>
</blockquote>
<h4 id="Dispatchers-Main"><a href="#Dispatchers-Main" class="headerlink" title="Dispatchers.Main"></a>Dispatchers.Main</h4><blockquote>
<p>UI调度器，根据执行平台的不同会初始化为对应平台的UI线程调度器。</p>
<p>在Android中，就会通过<code>Handler</code>调度任务到<code>UI线程</code>执行。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//加载各平台下定义的MainDispatcherFactory</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadMainDispatcher</span><span class="hljs-params">()</span></span>: MainCoroutineDispatcher &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> factories = <span class="hljs-keyword">if</span> (FAST_SERVICE_LOADER_ENABLED) &#123;<br>                FastServiceLoader.loadMainDispatcherFactory()<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// We are explicitly using the</span><br>                <span class="hljs-comment">// `ServiceLoader.load(MyClass::class.java, MyClass::class.java.classLoader).iterator()`</span><br>                <span class="hljs-comment">// form of the ServiceLoader call to enable R8 optimization when compiled on Android.</span><br>                ServiceLoader.load(<br>                        MainDispatcherFactory::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>,<br>                        <span class="hljs-type">MainDispatcherFactory::class.java.classLoader</span></span><br>                ).iterator().asSequence().toList()<br>            &#125;<br>            <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">"ConstantConditionIf"</span>)</span><br>            factories.maxBy &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)<br>                ?: createMissingDispatcher()<br>        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;<br>            <span class="hljs-comment">// Service loader can throw an exception as well</span><br>            createMissingDispatcher(e)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadMainDispatcherFactory</span><span class="hljs-params">()</span></span>: List&lt;MainDispatcherFactory&gt; &#123;<br>        <span class="hljs-keyword">val</span> clz = MainDispatcherFactory::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span></span><br>        <span class="hljs-keyword">if</span> (!ANDROID_DETECTED) &#123;<br>            <span class="hljs-keyword">return</span> load(clz, clz.classLoader)<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> result = ArrayList&lt;MainDispatcherFactory&gt;(<span class="hljs-number">2</span>)<br>          <span class="hljs-comment">//加载对应类名的类</span><br>            createInstanceOf(clz, <span class="hljs-string">"kotlinx.coroutines.android.AndroidDispatcherFactory"</span>)?.apply &#123; result.add(<span class="hljs-keyword">this</span>) &#125;<br>            createInstanceOf(clz, <span class="hljs-string">"kotlinx.coroutines.test.internal.TestMainDispatcherFactory"</span>)?.apply &#123; result.add(<span class="hljs-keyword">this</span>) &#125;<br>            result<br>        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;<br>            <span class="hljs-comment">// Fallback to the regular SL in case of any unexpected exception</span><br>            load(clz, clz.classLoader)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>按照类名去加载，Android下的名为<code>kotlinx.coroutions.android.AndroidDispatcherFactory</code>的类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在Android编译完成后，可以读取到该类</span><br><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidDispatcherFactory</span> : <span class="hljs-type">MainDispatcherFactory &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDispatcher</span><span class="hljs-params">(allFactories: <span class="hljs-type">List</span>&lt;<span class="hljs-type">MainDispatcherFactory</span>&gt;)</span></span> = HandlerContext(Looper.getMainLooper().asHandler(async = <span class="hljs-literal">true</span>), <span class="hljs-string">"Main"</span>)<br>&#125;<br><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerContext</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler: Handler,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> invokeImmediately: <span class="hljs-built_in">Boolean</span><br>) : HandlerDispatcher(), Delay &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<br>        handler: Handler,<br>        name: String? = <span class="hljs-literal">null</span><br>    ) : <span class="hljs-keyword">this</span>(handler, name, <span class="hljs-literal">false</span>)<br><br>    <span class="hljs-comment">//android中需要向主looper进行提交调度</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isDispatchNeeded</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> !invokeImmediately || Looper.myLooper() != handler.looper<br>    &#125;<br><br>    <span class="hljs-comment">//通过持有主线程looper的handler进行调度</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>        handler.post(block)<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="Dispatchers-Main-immediate"><a href="#Dispatchers-Main-immediate" class="headerlink" title="Dispatchers.Main.immediate"></a>Dispatchers.Main.immediate</h5><blockquote>
<p>适用于<code>响应一个UI事件后从而启动一个协程时</code>，会在下一帧中去立即执行任务。</p>
</blockquote>
<h4 id="Dispatchers-Unconfined"><a href="#Dispatchers-Unconfined" class="headerlink" title="Dispatchers.Unconfined"></a>Dispatchers.Unconfined</h4><blockquote>
<p>非限制的调度器，在遇到第一个挂起函数前的代码运行在原线程中，执行挂起函数后，就切换线程运行。</p>
</blockquote>
<p><img src="/images/协程调度器间的差异" srcset="/img/loading.gif" lazyload alt="调度器间的差异"></p>
<h4 id="自定义调度器"><a href="#自定义调度器" class="headerlink" title="自定义调度器"></a>自定义调度器</h4><blockquote>
<p><code>Default</code>和<code>IO</code>的底层实现都依赖于<code>线程池</code>，执行到<code>挂起函数</code>时还是会发生线程的切换，可以通过<code>自定义调度器</code>减少这类切换的发生。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myDispatcher= Executors.newSingleThreadExecutor&#123; r -&gt; Thread(r, <span class="hljs-string">"MyThread"</span>) &#125;.asCoroutineDispatcher() <span class="hljs-comment">//转换线程池到 Dispatcher</span><br></code></pre></td></tr></table></figure>
<h3 id="协程拦截器-ContinuationInterceptor"><a href="#协程拦截器-ContinuationInterceptor" class="headerlink" title="协程拦截器-ContinuationInterceptor"></a>协程拦截器-ContinuationInterceptor</h3><blockquote>
<p><code>ContinuationInterceptor</code>是一个拦截器的接口定义，用于控制协程的执行流程。</p>
<p>在<code>CoroutineContext</code>中，实现了<code>ContinuationInterceptor</code>接口的类，永远会处于最后一位，保证不会被其他类覆盖。</p>
<p><strong>协程拦截器只能存在一个！</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// ContinuationInterceptor.kt</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ContinuationInterceptor</span> : <span class="hljs-type">CoroutineContext.Element &#123;  </span></span><br>     <span class="hljs-comment">// 实现CoroutineContext.Element接口，说明自身是CoroutineContext上下文集合的一个元素类型  </span><br>     <span class="hljs-comment">// 定义伴生对象Key作为集合中的索引key，可直接通过类名访问该伴生对象  </span><br>     <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;  <br>   <br>     <span class="hljs-comment">// 传入一个Continuation对象，并返回一个新的Continuation对象  </span><br>     <span class="hljs-comment">// 在协程中，这里的传参continuation就是协程体编译后Continuation对象  </span><br>     <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;  <br>   <br>     <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">releaseInterceptedContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;*&gt;)</span></span> &#123;  <br>         <br>     ...  <br> &#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>CoroutineDispatcher</code>就是基于<code>ContinuationInterceptor</code>所实现的。</p>
<h3 id="协程异常处理-CoroutineExceptionHandler"><a href="#协程异常处理-CoroutineExceptionHandler" class="headerlink" title="协程异常处理-CoroutineExceptionHandler"></a>协程异常处理-CoroutineExceptionHandler</h3><blockquote>
<p><strong>所有未被捕获的异常一定会抛出，无论使用哪种Job!!!</strong></p>
</blockquote>
<p>当一个协程由于一个异常而运行失败时，它会传播这个异常并传递给他的父级。</p>
<p><img src="/images/协程异常传递流程" srcset="/img/loading.gif" lazyload alt="△ 协程中的异常会通过协程的层级不断传播"></p>
<p>主要执行以下几步：</p>
<ol>
<li>取消它的子级任务</li>
<li>取消自己的任务</li>
<li>把异常继续向上传递到自己的父级</li>
</ol>
<h4 id="SupervisorJob"><a href="#SupervisorJob" class="headerlink" title="SupervisorJob"></a>SupervisorJob</h4><p>使用<code>Job</code>时，若发生异常会导致异常传递，使得所有的任务都会被取消。</p>
<p>使用<code>SupervisorJob</code>，一个子协程运行失败不会传播异常，<code>只会影响自身</code>，其他任务都不会受到影响。</p>
<p><strong>SupervisorJob只有在<code>supervisorScope</code>或<code>CoroutineScope(SupervisorJob())</code>内执行才可以生效。</strong></p>
<p><img src="/images/SuperVisorJob不取消" srcset="/img/loading.gif" lazyload alt="SupervisorJob 不会取消它其他的子级"></p>
<p><code>CoroutineScope(SupervisorJob())</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> scope = CoroutineScope(SupervisorJob())<br>scope.launch&#123;<br>  <span class="hljs-comment">//child 1</span><br>&#125;<br>scope.launch&#123;<br>  <span class="hljs-comment">//child 2</span><br>&#125;<br><span class="hljs-comment">//若child1 发生异常不会影响 child2</span><br></code></pre></td></tr></table></figure>
<p><code>supervisorScope</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">supervisorScope &#123;<br>    launch &#123;<br>        <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"123"</span>)<br>    &#125;<br>    launch &#123;<br>        System.err.println(<span class="hljs-number">3</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用这两种方式都可以保证异常不向上传播</p>
<h4 id="Job-VS-SupervisorJob"><a href="#Job-VS-SupervisorJob" class="headerlink" title="Job VS SupervisorJob"></a>Job VS SupervisorJob</h4><blockquote>
<p>如果想在出现错误时不会退出父级和其他平级的协程，就要使用<code>SupervisorJob</code>或<code>supervisorScope</code></p>
</blockquote>
<h4 id="局部异常捕获"><a href="#局部异常捕获" class="headerlink" title="局部异常捕获"></a>局部异常捕获</h4><p>根据不同的<code>协程构造器</code>，处理方式也不尽相同</p>
<h5 id="launch"><a href="#launch" class="headerlink" title="launch()"></a><code>launch()</code></h5><p>主要采用<code>try{}catch{}</code>的形式进行异常捕获</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">scope.launch &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        codeThatCanThrowExceptions()<br>    &#125; <span class="hljs-keyword">catch</span>(e: Exception) &#123;<br>        <span class="hljs-comment">// 处理异常</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong><code>launch()</code>时，异常会在第一时间被抛出。</strong></p>
<h5 id="async-await"><a href="#async-await" class="headerlink" title="async/await()"></a><code>async/await()</code></h5><p><strong>只有当<code>async()</code>作为根协程时，不会自动抛出异常，而是要等到<code>await()</code>执行时才抛出异常。</strong></p>
<p><code>根协程</code>：<code>coroutintScope</code>或<code>supervisorScope</code>的直接子协程，或者类似<code>scope.async()</code>这种实现。</p>
<p>这种情况下可以通过<code>try{}catch{}</code>捕获异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//supervisorScope</span><br>coroutineScope&#123;<br>  <span class="hljs-keyword">val</span> deferred = async&#123;<br>    <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"123"</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时不会执行任何</p>
<p>只有在调用<code>.await()</code>时才会抛出异常，此时就可以添加<code>try{}catch{}</code>捕获异常。</p>
<p><strong>针对<code>async()</code>这种情况，最有效的方式就是<code>async()</code>内部进行<code>try{}catch{}</code></strong></p>
<h4 id="全局异常捕获"><a href="#全局异常捕获" class="headerlink" title="全局异常捕获"></a>全局异常捕获</h4><blockquote>
<p>类似Java，协程也提供了捕获全局异常(<code>未声明捕获异常</code>)的方式</p>
</blockquote>
<p>Java的全局异常捕获方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> UncaughtExceptionHandler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;<br>        <span class="hljs-comment">//TODO 异常处理</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h5 id="协程内全局异常捕获方式"><a href="#协程内全局异常捕获方式" class="headerlink" title="协程内全局异常捕获方式"></a>协程内全局异常捕获方式</h5><p>主要使用的是<code>CoroutineExceptionHandler</code>，可以帮助处理一些<code>未捕获的异常</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;<br>    log(<span class="hljs-string">"Throws an exception with message: <span class="hljs-subst">$&#123;throwable.message&#125;</span>"</span>)<br>&#125;<br><br><span class="hljs-keyword">val</span> context = Dispatchers.Main + Job() + exceptionHandler<br><span class="hljs-keyword">val</span> scope = CoroutineScope(context)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        scope.launch &#123;<br>            launch &#123;<br>                <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"1234"</span>)<br>            &#125;<br>            delay(<span class="hljs-number">1000</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时就会捕获到<code>NPE</code>。</p>
<p>需要<code>CoroutineExceptionHandler</code>生效需要两个条件：</p>
<ol>
<li>异常是被自动抛出异常的协程所抛出的。(<strong>只能是 launch()，async()这种是不可以的</strong>)</li>
<li>必须在<code>根协程</code>中，<code>coroutintScope</code>或<code>supervisorScope</code>的直接子协程，或者类似<code>scope.async()</code>这种实现。</li>
</ol>
<h5 id="真·全局异常捕获"><a href="#真·全局异常捕获" class="headerlink" title="真·全局异常捕获"></a>真·全局异常捕获</h5><p>上面说到的<code>CoroutineExceptionHandler</code>只能在协程内部使用，无法兼顾其他协程的异常情况。此时就需要使用另一种方式，使用<code>ServiceLoader</code>实现全局内协程异常捕获</p>
<p>实现这个功能需要如下几步：</p>
<ol>
<li>新建全局<code>CoroutineExceptionHandler</code>类</li>
<li>在<code>classPath</code>中注册该类<ul>
<li>在<code>src/main/</code>目录下的，<code>resources/META-INF/services</code>文件夹</li>
<li>新建<code>kotlinx.coroutines.CoroutineExceptionHandler</code>文件</li>
<li>文件内写入自定义的全局<code>CoroutineExceptionHandler</code>完整类名</li>
</ul>
</li>
</ol>
<p><strong>同样这种配置方式也只对launch()生效。</strong></p>
<p>这里主要应用了<strong>SPI机制</strong></p>
<blockquote>
<p>全称为<code>Service Provider Interface</code>，JDK内置的一种服务提供发现机制，主要源码实现在<code>java.util.ServiceLoader</code></p>
</blockquote>
<p>使用过程：</p>
<p>需要在<code>resources/META-INF/services</code>目录下创建与服务同名的<strong>全限定名</strong>相同的文件，然后在文件中写入<strong>服务提供者的全限定名</strong>。</p>
<p>原理简介：</p>
<p>主要通过反射调用配置的类进行实例化，反射成功后存入缓存，后续使用直接从缓存重新读取。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li><p><strong>协程内部异常处理流程</strong></p>
<ul>
<li><p>在作用域内使用<code>try..catch</code>可以直接捕获子线程中的异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">try</span>&#123;<br>  launch&#123;<br>    <br>  &#125;<br>  <br>  async&#123;<br>    <br>  &#125;<br>&#125;<span class="hljs-keyword">catch</span>&#123;...&#125;&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>如果未设置异常捕获，则会走<code>全局异常捕获流程</code>(<strong>只在<code>launch</code>创建协程下生效</strong>)</p>
<ul>
<li>若设置<code>CoroutineExceptionHandler</code>则处理。<strong>必须在根协程下才可以生效</strong></li>
<li>没配置，向<code>GlobalExceptionHandler</code>进行处理，该配置是全局的，对所有协程任务生效</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p><strong>异常传播在不同作用域的表现</strong></p>
<ul>
<li><code>GlobalScope</code>：异常不会向外传递，因为已经是<code>根协程</code></li>
<li><code>coroutineScope</code>：异常进行<code>双向传递</code>，父协程和子协程都会被取消</li>
<li><code>supervisorScope</code>：异常进行<code>单向传递</code>，只有父协程向子协程传递异常，子协程会被取消，父协程不受影响</li>
</ul>
</li>
<li><p><code>launch/join</code>和<code>async/await</code>表现不同</p>
<p><code>launch/join</code>关注的是<strong>任务是否执行完成</strong>，<code>async/await</code>关注的是<strong>任务的执行结果</strong>，所以在局部异常捕获的时候，两种创建方式的异常捕获也会有区别</p>
</li>
<li><p>想要避免异常传播，就要使用<code>SupervisorJob</code>；不在意就用<code>Job</code></p>
</li>
</ol>
<h3 id="协程构造器-CoroutineBuilder"><a href="#协程构造器-CoroutineBuilder" class="headerlink" title="协程构造器-CoroutineBuilder"></a>协程构造器-CoroutineBuilder</h3><blockquote>
<p>主要负责构造一个协程并启动它</p>
</blockquote>
<p>常用的有两种方法</p>
<h4 id="launch-重点分析"><a href="#launch-重点分析" class="headerlink" title="launch(重点分析)"></a>launch(重点分析)</h4><blockquote>
<p>默认创建一个新的协程，并返回<code>Job</code>对象，通过<code>Job</code>管理协程。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(<br>    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,<br>    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,<br>    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span><br>)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)<br>    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)<br>        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span><br>        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)<br>    coroutine.start(start, coroutine, block)<br>    <span class="hljs-keyword">return</span> coroutine<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要有三个参数：</p>
<ul>
<li><code>context</code>：就是前面介绍的<code>CoroutineContext</code></li>
<li><code>start</code>：<a href="#协程启动模式-CoroutineStart">协程启动模式</a></li>
<li><code>block</code>：需要执行的任务，由<code>suspend</code>修饰</li>
</ul>
<h5 id="newCoroutineContext"><a href="#newCoroutineContext" class="headerlink" title="newCoroutineContext"></a>newCoroutineContext</h5><blockquote>
<p>将传参的<code>context</code>与<code>ContextScope</code>配置的<code>context</code>进行合并，并返回一个新的<code>context</code>。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">newCoroutineContext</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;<br>    <span class="hljs-keyword">val</span> combined = coroutineContext + context<br>    <span class="hljs-keyword">val</span> debug = <span class="hljs-keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="hljs-keyword">else</span> combined<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="hljs-literal">null</span>)<br>        debug + Dispatchers.Default <span class="hljs-keyword">else</span> debug<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="StandaloneCoroutine-LazyStandaloneCoroutine"><a href="#StandaloneCoroutine-LazyStandaloneCoroutine" class="headerlink" title="StandaloneCoroutine/LazyStandaloneCoroutine"></a>StandaloneCoroutine/LazyStandaloneCoroutine</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandaloneCoroutine</span></span>(<br>    parentContext: CoroutineContext,<br>    active: <span class="hljs-built_in">Boolean</span><br>) : AbstractCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt;(parentContext, active) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        handleCoroutineException(context, exception)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>继承<code>AbstractCoroutine</code>且重写了<code>handleJobException()</code>，这也是为什么<code>CoroutineExceptionHandler</code>可以监听到异常的原因。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyStandaloneCoroutine</span></span>(<br>    parentContext: CoroutineContext,<br>    block: <span class="hljs-keyword">suspend</span> CoroutineScope.() -&gt; <span class="hljs-built_in">Unit</span><br>) : StandaloneCoroutine(parentContext, active = <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> block: (<span class="hljs-keyword">suspend</span> CoroutineScope.() -&gt; <span class="hljs-built_in">Unit</span>)? = block<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> block = checkNotNull(<span class="hljs-keyword">this</span>.block) &#123; <span class="hljs-string">"Already started"</span> &#125;<br>        <span class="hljs-keyword">this</span>.block = <span class="hljs-literal">null</span><br>        block.startCoroutineCancellable(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>LazyStandaloneCoroutine</code>重写了<code>onStart()</code>，只有在调用到<code>start()/join()</code>等方法才会执行。</p>
<h5 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h5><blockquote>
<p>启动协程任务</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//AbstractCoroutine.kt</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">start</span><span class="hljs-params">(start: <span class="hljs-type">CoroutineStart</span>, receiver: <span class="hljs-type">R</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>)</span></span> &#123;<br>        initParentJob()<br>        start(block, receiver, <span class="hljs-keyword">this</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>调用到<code>CoroutineStart.invoke()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//CoroutineStart.kt</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">invoke</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>, receiver: <span class="hljs-type">R</span>, completion: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> =<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>            CoroutineStart.DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)<br>            CoroutineStart.ATOMIC -&gt; block.startCoroutine(receiver, completion)<br>            CoroutineStart.UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)<br>            CoroutineStart.LAZY -&gt; <span class="hljs-built_in">Unit</span> <span class="hljs-comment">// will start lazily</span><br>        &#125;<br></code></pre></td></tr></table></figure>
<p>默认使用<code>CoroutineStart.DEFAULT</code>，以这个作为示例分析</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//Cancellable.kt</span><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> (R)</span></span> -&gt; T).startCoroutineCancellable(receiver: R, completion: Continuation&lt;T&gt;) =<br>    runSafely(completion) &#123;<br>        createCoroutineUnintercepted(receiver, completion)<br>      .intercepted()<br>      .resumeCancellable(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>主要流程分为三步：</p>
<h6 id="createCoroutineUninterecpted"><a href="#createCoroutineUninterecpted" class="headerlink" title="createCoroutineUninterecpted"></a>createCoroutineUninterecpted</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//IntrinsicsJvm.kt</span><br><span class="hljs-meta">@SinceKotlin(<span class="hljs-meta-string">"1.3"</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">val</span> probeCompletion = probeCoroutineCreated(completion)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> BaseContinuationImpl)<br>        create(probeCompletion)<br>    <span class="hljs-keyword">else</span><br>        createCoroutineFromSuspendFunction(probeCompletion) &#123;<br>            (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要是为了创建<code>Continuation</code>对象</p>
<h6 id="intercepted"><a href="#intercepted" class="headerlink" title="intercepted"></a>intercepted</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;T&gt; =<br>    (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="hljs-keyword">this</span><br><br><br><span class="hljs-comment">//ContinuationImpl.kt</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =<br>        intercepted<br>            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)<br>                .also &#123; intercepted = it &#125;<br></code></pre></td></tr></table></figure>
<p>如果设置了<code>ContinutionInterceptor</code>，就获取并执行<code>interceptContinuation()</code>。</p>
<h6 id="resumeCancellable"><a href="#resumeCancellable" class="headerlink" title="resumeCancellable"></a>resumeCancellable</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resumeCancellable</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">is</span> DispatchedContinuation -&gt; resumeCancellable(value)<br>    <span class="hljs-keyword">else</span> -&gt; resume(value)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>进行线程调度或者事件拦截处理，然后协程就开始启动了。</p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><h3 id="协程启动模式-CoroutineStart"><a href="#协程启动模式-CoroutineStart" class="headerlink" title="协程启动模式-CoroutineStart"></a>协程启动模式-CoroutineStart</h3><blockquote>
<p>控制协程创建后的调用规则</p>
</blockquote>
<h4 id="CoroutineStart-DEFAULT"><a href="#CoroutineStart-DEFAULT" class="headerlink" title="CoroutineStart.DEFAULT"></a>CoroutineStart.DEFAULT</h4><blockquote>
<p>协程的默认启动模式，为<code>饿汉式调用</code>。在调用协程后，会立即进入调度状态。</p>
<p><em>可以在调度前被取消。</em></p>
</blockquote>
<h4 id="CoroutineStart-LAZY"><a href="#CoroutineStart-LAZY" class="headerlink" title="CoroutineStart.LAZY"></a>CoroutineStart.LAZY</h4><blockquote>
<p><code>懒汉式调用</code>，只有需要执行时才会执行。</p>
<p>通过调用以下方法就可以进入调度状态。</p>
<ul>
<li><code>job.start()</code>：启动协程</li>
<li><code>job.join</code>：启动协程并等待任务执行结束</li>
<li><code>job.await()</code></li>
</ul>
</blockquote>
<h4 id="CoroutineStart-ATOMIC"><a href="#CoroutineStart-ATOMIC" class="headerlink" title="CoroutineStart.ATOMIC"></a>CoroutineStart.ATOMIC</h4><blockquote>
<p>协程创建后，立即开始调度。</p>
<p><strong>在执行到第一个挂起点之前不会响应<code>cancel()</code></strong></p>
</blockquote>
<h4 id="CoroutineStart-UNDISPATCHED"><a href="#CoroutineStart-UNDISPATCHED" class="headerlink" title="CoroutineStart.UNDISPATCHED"></a>CoroutineStart.UNDISPATCHED</h4><blockquote>
<p>协程创建后，立即开始调度</p>
<p><strong>直到遇到第一个挂起点之前，都会在当前线程中执行。</strong></p>
</blockquote>
<h3 id="协程取消-Cancel"><a href="#协程取消-Cancel" class="headerlink" title="协程取消-Cancel"></a>协程取消-Cancel</h3><blockquote>
<p>取消协程可以针对<code>CoroutineScope</code>或<code>Job</code>去执行。</p>
</blockquote>
<h4 id="取消作用域下所有协程"><a href="#取消作用域下所有协程" class="headerlink" title="取消作用域下所有协程"></a>取消作用域下所有协程</h4><blockquote>
<p>调用<code>CoroutineScope.cancel()</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> scope = CoroutineScope(context)<br><br>...<br><span class="hljs-keyword">if</span>(scope.isActive)&#123; <span class="hljs-comment">//判断当前scope是否活跃</span><br>  scope.cancel()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>适用于页面关闭时，需要回收资源的情况</p>
<p><strong>不能在已取消的作用域中再次启动新的协程。</strong></p>
<h4 id="取消单个协程"><a href="#取消单个协程" class="headerlink" title="取消单个协程"></a>取消单个协程</h4><blockquote>
<p>针对<code>Job</code>进行取消，调用<code>cancel()</code>可以取消正在运行的协程</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//官方示例代码</span><br><span class="hljs-keyword">val</span> job = launch &#123;<br>    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>        println(<span class="hljs-string">"I'm sleeping <span class="hljs-variable">$i</span> ..."</span>)<br>        delay(<span class="hljs-number">500L</span>)<br>    &#125;<br>&#125;<br>delay(<span class="hljs-number">1300L</span>) <span class="hljs-comment">// 等待一段时间</span><br>println(<span class="hljs-string">"main: I'm tired of waiting!"</span>)<br>job.cancel() <span class="hljs-comment">// 取消 job</span><br>job.join() <span class="hljs-comment">// 等待 job 结束</span><br>println(<span class="hljs-string">"main: Now I can quit."</span>)<br></code></pre></td></tr></table></figure>
<h5 id="协程之间的关系"><a href="#协程之间的关系" class="headerlink" title="协程之间的关系"></a>协程之间的关系</h5><blockquote>
<p>协程是存在着父子关系的，<strong>取消父协程时，也会取消所有子协程</strong></p>
</blockquote>
<p>主要有以下三种关系：</p>
<ol>
<li><p><code>父协程</code>调用<code>cancel()</code>或触发异常时，会立即取消所有<code>子协程</code>；<code>子协程</code>调用<code>cancel()</code>不影响父协程及兄弟协程的执行</p>
<blockquote>
<p>在底层实现中，子协程通过抛出异常的方式将取消的情况通知到父协程。</p>
<p>父协程通过传入的异常来决定是否处理异常，如果异常为<code>CancellationException</code>就不做处理。</p>
</blockquote>
</li>
<li><p><code>父协程</code>必须等到所有<code>子协程</code>完成才算完成</p>
</li>
<li><p><code>子协程</code>抛出未捕获的异常时，默认情况下会取消<code>父协程</code>(<code>superVisorJob</code>和<code>CancellationException</code>除外)</p>
</li>
</ol>
<h4 id="使协程可以取消"><a href="#使协程可以取消" class="headerlink" title="使协程可以取消"></a>使协程可以取消</h4><blockquote>
<p>协程处理任务的代码必须是<strong>协作式</strong>的，需要配合<code>协程取消</code>进行了处理。</p>
</blockquote>
<p>需要在任务处理期间<code>定期检查协程是否已被取消</code>，或者在处理耗时任务之前就<code>检查当前协程是否已取消</code>。</p>
<p>目前只有<code>kotlinx.coroutines</code>所有的挂起函数都是<code>可取消的</code>，例如<code>delay()</code>、<code>yield()</code>等，这些都不需要去检查协程是否已取消。</p>
<p>因此要使<code>协程可以被取消</code>，可以使用以下两种方法：</p>
<ul>
<li>通过<code>job.isActive</code>或<code>ensureActive()</code>检查协程状态</li>
<li>内部使用<code>delay()</code>或<code>yield()</code>等挂起函数——核心在于<code>suspendCoroutineUninterceptedOrReturn</code></li>
</ul>
<h5 id="检查Job的活跃状态-isActive"><a href="#检查Job的活跃状态-isActive" class="headerlink" title="检查Job的活跃状态-isActive"></a>检查Job的活跃状态-isActive</h5><blockquote>
<p>在协程执行过程中，添加<code>isActive</code>检查协程状态，若<code>!isActive</code>就不向下执行任务。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> job = scope.launch&#123;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">5</span> &amp;&amp; isActive)&#123;<br>    Log.e(<span class="hljs-string">"test"</span>,<span class="hljs-string">"now value = <span class="hljs-subst">$&#123;i++&#125;</span>"</span>)<br>  &#125;<br>&#125;<br><br>...<br>job.cancel()<br></code></pre></td></tr></table></figure>
<p>还有一种方式就是<code>ensureActive()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Job.<span class="hljs-title">ensureActive</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isActive) <span class="hljs-keyword">throw</span> getCancellationException()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用<code>ensureActive()</code>可以不用手动去检测<code>isActive</code>，通过直接抛出异常来结束任务。</p>
<h5 id="使用挂起函数"><a href="#使用挂起函数" class="headerlink" title="使用挂起函数"></a>使用挂起函数</h5><blockquote>
<p><code>挂起函数</code>：<code>delay()</code>、<code>yield()</code>等函数，内部核心实现为<code>suspendCancellableCoroutine</code></p>
</blockquote>
<h6 id="delay"><a href="#delay" class="headerlink" title="delay()"></a>delay()</h6><blockquote>
<p>让协程挂起，而且不会阻塞CPU。类似于<code>Thread.sleep()</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (timeMillis &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// don't delay</span><br>    <span class="hljs-keyword">return</span> suspendCancellableCoroutine <span class="hljs-symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; -&gt;<br>        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h6><blockquote>
<p>挂起当前协程，然后将协程分发到<code>Dispatcher</code>队列，可以让该协程所在线程或线程池可以运行其他协程逻辑，然后等待<code>Dispatcher</code>空闲的时候继续执行原来的协程任务。类似于<code>Thread.yield()</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> = suspendCoroutineUninterceptedOrReturn <span class="hljs-symbol">sc@</span> &#123; uCont -&gt;<br>    <span class="hljs-keyword">val</span> context = uCont.context<br>    context.checkCompletion()<br>    <span class="hljs-keyword">val</span> cont = uCont.intercepted() <span class="hljs-keyword">as</span>? DispatchedContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-built_in">Unit</span><br>    <span class="hljs-keyword">if</span> (!cont.dispatcher.isDispatchNeeded(context)) &#123;<br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-keyword">if</span> (cont.yieldUndispatched()) COROUTINE_SUSPENDED <span class="hljs-keyword">else</span> <span class="hljs-built_in">Unit</span><br>    &#125;<br>    cont.dispatchYield(<span class="hljs-built_in">Unit</span>)<br>    COROUTINE_SUSPENDED<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineContext.<span class="hljs-title">checkCompletion</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> job = <span class="hljs-keyword">get</span>(Job)<br>    <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">null</span> &amp;&amp; !job.isActive) <span class="hljs-keyword">throw</span> job.getCancellationException()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>执行<code>yield()</code>时，会优先检测任务的完成状态，如果<code>!job.isActive</code>直接抛出<code>CancellableException</code></p>
<h6 id="suspendCoroutineUninterceptedOrReturn"><a href="#suspendCoroutineUninterceptedOrReturn" class="headerlink" title="suspendCoroutineUninterceptedOrReturn"></a>suspendCoroutineUninterceptedOrReturn</h6><blockquote>
<p>主要作用为<code>获取当前协程的实例，并且挂起当前协程或者不挂起直接返回结果</code>。</p>
</blockquote>
<p>根据上述源码发现，<code>挂起函数</code>的关键在于<code>suspendCoroutineUninterceptedOrReturn</code>，只要使用了该方法，就可以成为<code>挂起函数</code>。</p>
<p>通过做转换的时候，可以使用系统提供的两个转换函数：</p>
<ul>
<li><code>suspendCoroutine</code></li>
<li><code>suspendCancellableCoroutine</code><em>推荐使用</em></li>
</ul>
<h4 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h4><h5 id="suspendCoroutine"><a href="#suspendCoroutine" class="headerlink" title="suspendCoroutine"></a>suspendCoroutine</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;String&gt; &#123; continuation -&gt;<br>    <span class="hljs-keyword">if</span> (...) &#123;<br>        continuation.resume(<span class="hljs-string">"11"</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        continuation.resumeWithException(NullPointerException(<span class="hljs-string">"123"</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="suspendCancellableCoroutine"><a href="#suspendCancellableCoroutine" class="headerlink" title="suspendCancellableCoroutine"></a>suspendCancellableCoroutine</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> aa = <span class="hljs-number">0</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ttt</span><span class="hljs-params">()</span></span> = suspendCancellableCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; cancellableContinuation -&gt;<br>    <span class="hljs-keyword">if</span> (aa == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//执行完毕抛出结果</span><br>        cancellableContinuation.resume(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 执行过程异常捕获</span><br>            log(<span class="hljs-string">"aaa <span class="hljs-subst">$&#123;it.message&#125;</span>"</span>)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cancellableContinuation.resumeWithException(IllegalArgumentException(<span class="hljs-string">"123"</span>))<br>    &#125;<br><br>    cancellableContinuation.invokeOnCancellation &#123;<br>       <span class="hljs-comment">//协程任务执行cancel时，回调该方法</span><br>        log(<span class="hljs-string">"我被取消了"</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以通过<code>continuation.invokeCancellation()</code>执行取消操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(<br>    <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span><br>)</span></span>: T =<br>    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;<br>        <span class="hljs-keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)<br>        <span class="hljs-comment">/*<br>         * For non-atomic cancellation we setup parent-child relationship immediately<br>         * in case when `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but<br>         * properly supports cancellation.<br>         */</span><br>        cancellable.initCancellability()<br>        block(cancellable)<br>        cancellable.getResult()<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="禁止取消"><a href="#禁止取消" class="headerlink" title="禁止取消"></a>禁止取消</h4><blockquote>
<p>当任务被取消时，挂起函数会收到<code>CancellationException</code>后续如果需要执行一些其他的挂起函数任务将无法执行。</p>
</blockquote>
<p>对挂起函数调用<code>withContext(NonCancellable)</code>，保证挂起函数正常执行。</p>
<p>关键在于<code>isActive</code>永远为<code>true</code></p>
<h4 id="超时取消"><a href="#超时取消" class="headerlink" title="超时取消"></a>超时取消</h4><blockquote>
<p>大部分取消协程的原因都是<strong>超出了预期的执行时间</strong>，此时就会去触发取消的操作。</p>
</blockquote>
<p>对挂起函数调用<code>withTimeout(XX)</code>或<code>withTimeoutOrNull(XX)</code>，唯一的区别就是后者会返回<code>null</code>而不是抛出异常。</p>
<h2 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h2><h3 id="Dispatchers原理"><a href="#Dispatchers原理" class="headerlink" title="Dispatchers原理"></a>Dispatchers原理</h3><p>无论是<code>Dispatchers.Default</code>或者<code>IO</code>都是<code>CoroutineDispatcher</code>的子类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">public abstract class CoroutineDispatcher :<br>    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123;<br>    //线程调度，指定协程在某一线程上运行<br>    public abstract fun dispatch(context: CoroutineContext, block: Runnable)      <br>    //封装 Continuation 为 DispatchedContinuation<br>    public final override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; =<br>        DispatchedContinuation(this, continuation)<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>CoroutineDispatacher</code>继承<code>AbstractCoroutineContextElement</code>类，还实现了<code>ContinuationInterceptor</code>接口。</p>
<h4 id="DispatchedContinuation"><a href="#DispatchedContinuation" class="headerlink" title="DispatchedContinuation"></a>DispatchedContinuation</h4><blockquote>
<p>代理协程体Continuation对象并持有线程调度器，负责<strong>使用线程调度器将协程体调度到执行的线程执行</strong>。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DispatchedContinuation</span>&lt;<span class="hljs-type">in T</span>&gt;</span>(<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> dispatcher: CoroutineDispatcher,<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;<br>) : DispatchedTask&lt;T&gt;(MODE_ATOMIC_DEFAULT), CoroutineStackFrame, Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br>  <br>  <br>     <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;  <br>         <span class="hljs-keyword">val</span> context = continuation.context  <br>         <span class="hljs-keyword">val</span> state = result.toState()  <br>         <span class="hljs-comment">// 是否需要线程调度  </span><br>         <span class="hljs-keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;  <br>             _state = state  <br>             resumeMode = MODE_ATOMIC_DEFAULT  <br>             <span class="hljs-comment">// dispatch 调度线程，第二个参数是一个Runnable类型，这里传参this也就是DispatchedContinuation自身  </span><br>             <span class="hljs-comment">// DispatchedContinuation实际上也是一个Runnable对象，调用调度器的dispatch方法之后就可以使这个runnable在指定的线程运行了  </span><br>             dispatcher.dispatch(context, <span class="hljs-keyword">this</span>)  <br>         &#125; <span class="hljs-keyword">else</span> &#123;  <br>             executeUnconfined(state, MODE_ATOMIC_DEFAULT) &#123;  <br>                 withCoroutineContext(<span class="hljs-keyword">this</span>.context, countOrElement) &#123;  <br>                     <span class="hljs-comment">// 不需要调度，执行协程体的resumeWith  </span><br>                     continuation.resumeWith(result)  <br>                 &#125;  <br>             &#125;  <br>         &#125;  <br>     &#125;  <br>      <span class="hljs-comment">// 默认启动模式  </span><br>      <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeCancellableWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;  <br>         <span class="hljs-keyword">val</span> state = result.toState()  <br>         <span class="hljs-keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;  <br>             _state = state  <br>             resumeMode = MODE_CANCELLABLE  <br>             dispatcher.dispatch(context, <span class="hljs-keyword">this</span>)  <br>         &#125; <span class="hljs-keyword">else</span> &#123;  <br>             executeUnconfined(state, MODE_CANCELLABLE) &#123;  <br>                 <span class="hljs-keyword">if</span> (!resumeCancelled()) &#123;  <br>                     resumeUndispatchedWith(result)  <br>                 &#125;  <br>             &#125;  <br>         &#125;  <br>     &#125;    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>DispatchedContinuation</code>用两个参数构建</p>
<ul>
<li><code>dispatcher</code>：拦截器</li>
<li><code>continuation</code>：协程体类对象</li>
</ul>
<p>其中<code>resumeWith()</code>和<code>resumeCancellableWith()</code>负责协程的启动。</p>
<p>//TODO 先挂着</p>
<h3 id="协程启动流程"><a href="#协程启动流程" class="headerlink" title="协程启动流程"></a>协程启动流程</h3><ol>
<li>通过<code>CoroutineScope.launch()</code>创建一个协程，默认启动模式为<code>ControutineStart.DEFAULT</code>，创建一个<code>StandaloneCoroutine</code>协程对象</li>
<li>执行<code>StandaloneCoroutine.start()</code>实质执行到<code>AbstractCoroutine.start()</code>，继续触发到<code>CoroutineStart.invoke()</code></li>
<li>由于默认调度器为<code>Dispatchers.Default</code>，所以执行到了<code>startCoroutineCancellable()</code></li>
<li><code>startCoroutineCancellable()</code>内部主要有三次调用<ul>
<li><code>createCoroutineUnintercepted()</code>：创建一个协程体类对象</li>
<li><code>intercepted</code>：将协程体类包装成<code>DispatchedContinuation</code>对象</li>
<li><code>resumeCancellableWith()</code>：通过<code>Default</code>调用到<code>resumeCancellableWith()</code></li>
</ul>
</li>
<li>实际调用到了<code>DispatchContinuation.resumeCancellableWith()</code>，最后执行到<code>Continuation.resumeWith()</code>执行协程任务。</li>
</ol>
<h3 id="协程挂起-恢复原理"><a href="#协程挂起-恢复原理" class="headerlink" title="协程挂起/恢复原理"></a>协程挂起/恢复原理</h3><blockquote>
<p>挂起的特点：<strong>不阻塞线程</strong>。挂起的本质<strong>切线程</strong>，并且在相应逻辑处理完毕之后，再重新切回线程。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loginUser</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>  <span class="hljs-keyword">val</span> user = logUserIn(userId, password)<br>  <span class="hljs-keyword">val</span> userDb = logUserIn(user)<br>  <span class="hljs-keyword">return</span> userDb<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logUserIn</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>)</span></span>: String<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logUserIn</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span>: String<br></code></pre></td></tr></table></figure>
<p>反编译后得到</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loginUser</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>, completion: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span> &#123;<br>  <span class="hljs-keyword">val</span> user = logUserIn(userId, password)<br>  <span class="hljs-keyword">val</span> userDb = logUserIn(user)<br>  completion.resume(userDb)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用<code>挂起函数</code>或者<code>suspend lambda表达式</code>时，都会一个<code>隐式参数</code>传入，这个参数是<code>Continuation</code>类型。</p>
<blockquote>
<p>CPS：续体传递风格</p>
<p>在每个<code>挂起函数</code>与<code>suspend lambda表达式</code>都会附加一个<code>Continuation</code>参数，并且是用来代替<code>suspend</code></p>
</blockquote>
<h4 id="Continuation接口"><a href="#Continuation接口" class="headerlink" title="Continuation接口"></a>Continuation接口</h4><p><code>挂起函数</code>通过<code>Continuation</code>在方法间互相通信，基本实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Continuation</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(value: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Unit</span> =<br>    resumeWith(Result.success(value))<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resumeWithException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Unit</span> =<br>    resumeWith(Result.failure(exception))<br></code></pre></td></tr></table></figure>
<p>后续添加<code>resume(value)</code>和<code>resumeWithException(exception)</code>可以方便的获取结果，而不需要从<code>Result</code>解析。</p>
<p><code>Continuation</code>主要有以下参数和方法</p>
<ul>
<li><code>context</code>：内部使用的<code>CoroutineContext</code></li>
<li><code>resumeWith()</code>：恢复协程的执行，同时传入一个<code>Result</code>。内部包括了<code>计算结果</code>或<code>过程中发生的异常</code></li>
</ul>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><blockquote>
<p>Kotlin编译器会确定函数何时可以在内部挂起，每个挂起点都会被声明为有限状态机的一个状态，每个状态用<code>label</code>表示</p>
</blockquote>
<p>查看反编译后源码，内部源码大概如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">loginUser</span><span class="hljs-params">(@NotNull String userId, @NotNull String password, @NotNull Continuation $completion)</span> </span>&#123;<br>     Object $continuation;<br>     label27: &#123;<br>        <span class="hljs-keyword">if</span> ($completion <span class="hljs-keyword">instanceof</span> &lt;undefinedtype&gt;) &#123;<br>           $continuation = (&lt;undefinedtype&gt;)$completion;<br>           <span class="hljs-keyword">if</span> ((((&lt;undefinedtype&gt;)$continuation).label &amp; Integer.MIN_VALUE) != <span class="hljs-number">0</span>) &#123;<br>              ((&lt;undefinedtype&gt;)$continuation).label -= Integer.MIN_VALUE;<br>              <span class="hljs-keyword">break</span> label27;<br>           &#125;<br>        &#125;<br><br>        $continuation = <span class="hljs-keyword">new</span> ContinuationImpl($completion) &#123;<br>           <span class="hljs-comment">// $FF: synthetic field</span><br>           Object result;<br>           <span class="hljs-keyword">int</span> label;<br>           Object L$<span class="hljs-number">0</span>;<br>           Object L$<span class="hljs-number">1</span>;<br>           Object L$<span class="hljs-number">2</span>;<br>           Object L$<span class="hljs-number">3</span>;<br><br>           <span class="hljs-meta">@Nullable</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(@NotNull Object $result)</span> </span>&#123;<br>              <span class="hljs-keyword">this</span>.result = $result;<br>              <span class="hljs-keyword">this</span>.label |= Integer.MIN_VALUE;<br>              <span class="hljs-keyword">return</span> MyClass.<span class="hljs-keyword">this</span>.loginUser((String)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, <span class="hljs-keyword">this</span>);<br>           &#125;<br>        &#125;;<br>     &#125;<br><br>     Object var10000;<br>     label22: &#123;<br>        Object $result = ((&lt;undefinedtype&gt;)$continuation).result;<br>        Object var8 = IntrinsicsKt.getCOROUTINE_SUSPENDED();<br>        String user;<br>        <span class="hljs-keyword">switch</span>(((&lt;undefinedtype&gt;)$continuation).label) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-comment">//错误检查</span><br>           ResultKt.throwOnFailure($result);<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">0</span> = <span class="hljs-keyword">this</span>;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">1</span> = userId;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">2</span> = password;<br>            <span class="hljs-comment">//设置 label为1 下次执行切换到 case 1</span><br>           ((&lt;undefinedtype&gt;)$continuation).label = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//当前状态机执行的流程</span><br>           var10000 = <span class="hljs-keyword">this</span>.logUserIn(userId, password, (Continuation)$continuation);<br>           <span class="hljs-keyword">if</span> (var10000 == var8) &#123;<br>              <span class="hljs-keyword">return</span> var8;<br>           &#125;<br>           <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>           password = (String)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">2</span>;<br>           userId = (String)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">this</span> = (MyClass)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">0</span>;<br>           ResultKt.throwOnFailure($result);<br>           user = (String)var10000;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">0</span> = <span class="hljs-keyword">this</span>;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">1</span> = userId;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">2</span> = password;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">3</span> = user;<br>           ((&lt;undefinedtype&gt;)$continuation).label = <span class="hljs-number">2</span>;<br>            var10000 = <span class="hljs-keyword">this</span>.logUserIn(user, (Continuation)$continuation);<br>           <span class="hljs-keyword">if</span> (var10000 == var8) &#123;<br>              <span class="hljs-keyword">return</span> var8;<br>           &#125;             <br>           var10000 = $result;<br>           <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>           user = (String)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">3</span>;<br>           password = (String)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">2</span>;<br>           userId = (String)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">1</span>;<br>           MyClass var9 = (MyClass)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">0</span>;<br>           ResultKt.throwOnFailure($result);<br>           var10000 = $result;<br>           <span class="hljs-keyword">break</span> label22;<br>        <span class="hljs-keyword">default</span>:<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"call to 'resume' before 'invoke' with coroutine"</span>);<br>        &#125;<br><br>     &#125;<br><br>     String userDb = (String)var10000;<br>     <span class="hljs-keyword">return</span> userDb;<br>  &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Kotlin编译器将每个<code>挂起函数</code>转换为一个状态机，在每次函数需要挂起时使用回调并进行优化。</p>
</blockquote>
<p>观察上述源码发现主要有几个关键点</p>
<h5 id="ContinuationImpl"><a href="#ContinuationImpl" class="headerlink" title="ContinuationImpl"></a>ContinuationImpl</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContinuationImpl</span></span>(<br>    completion: Continuation&lt;Any?&gt;?,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _context: CoroutineContext?<br>) : BaseContinuationImpl(completion) &#123;<br>    <span class="hljs-keyword">constructor</span>(completion: Continuation&lt;Any?&gt;?) : <span class="hljs-keyword">this</span>(completion, completion?.context)<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = _context!!<br><br>    <span class="hljs-meta">@Transient</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> intercepted: Continuation&lt;Any?&gt;? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =<br>        intercepted<br>            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)<br>                .also &#123; intercepted = it &#125;<br><br>&#125;<br><br><span class="hljs-comment">//其中 invokeSuspend()是由BaseContinuationImpl实现</span><br></code></pre></td></tr></table></figure>
<figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseContinuationImpl</span></span>(<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> completion: Continuation&lt;Any?&gt;?<br>) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> current = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">var</span> param = result<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            probeCoroutineResumed(current)<br>            with(current) &#123;<br>                <span class="hljs-keyword">val</span> completion = completion!! <br>                <span class="hljs-keyword">val</span> outcome: Result&lt;Any?&gt; =<br>                    <span class="hljs-keyword">try</span> &#123;<br>                      <span class="hljs-comment">//调用 invokeSuspend 真正执行协程体</span><br>                        <span class="hljs-keyword">val</span> outcome = invokeSuspend(param)<br>                      <span class="hljs-comment">//如果返回值为 CORPUTINE_SUSPENDED ，需要执行挂起操作</span><br>                        <span class="hljs-keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="hljs-keyword">return</span><br>                      <span class="hljs-comment">//协程体执行成功</span><br>                        Result.success(outcome)<br>                    &#125; <span class="hljs-keyword">catch</span> (exception: Throwable) &#123;<br>                      <span class="hljs-comment">//协程体执行异常</span><br>                        Result.failure(exception)<br>                    &#125;<br>                releaseIntercepted() <span class="hljs-comment">// this state machine instance is terminating</span><br>                <span class="hljs-keyword">if</span> (completion <span class="hljs-keyword">is</span> BaseContinuationImpl) &#123;<br>                    <span class="hljs-comment">// unrolling recursion via loop</span><br>                    current = completion<br>                    param = outcome<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-comment">//此处表示 StandaloneCoroutine</span><br>                    completion.resumeWith(outcome)<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span>: Any?<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>invokeSuspend()</code>执行的就是<code>协程体</code>，当<code>invokeSuspend()</code>返回值为<code>COROUTINE_SUSPENDED</code>时，执行<code>return操作</code>，协程体的操作也会被结束，所以<code>COROUTINE_SUSPENDED</code>也表示<strong>协程发生挂起</strong>。</p>
<h4 id="协程挂起"><a href="#协程挂起" class="headerlink" title="协程挂起"></a>协程挂起</h4><blockquote>
<p>通过挂起函数将协程挂起，此处拿<code>withContext()</code>进行分析</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">withContext</span><span class="hljs-params">(<br>    context: <span class="hljs-type">CoroutineContext</span>,<br>    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span><br>)</span></span>: T = suspendCoroutineUninterceptedOrReturn <span class="hljs-symbol">sc@</span> &#123; uCont -&gt;<br><br>    <span class="hljs-keyword">val</span> oldContext = uCont.context<br>    <span class="hljs-keyword">val</span> newContext = oldContext + context<br>   <span class="hljs-comment">//检查协程是否活跃</span><br>    newContext.checkCompletion()<br><br>    <span class="hljs-keyword">if</span> (newContext === oldContext) &#123;<br>        <span class="hljs-keyword">val</span> coroutine = ScopeCoroutine(newContext, uCont) <span class="hljs-comment">// MODE_DIRECT</span><br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) &#123;<br>        <span class="hljs-keyword">val</span> coroutine = UndispatchedCoroutine(newContext, uCont) <span class="hljs-comment">// MODE_UNDISPATCHED</span><br>        <span class="hljs-comment">// There are changes in the context, so this thread needs to be updated</span><br>        withCoroutineContext(newContext, <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine = DispatchedCoroutine(newContext, uCont) <span class="hljs-comment">// MODE_CANCELLABLE</span><br>    coroutine.initParentJob()<br>   <span class="hljs-comment">//coroutine 为 DispatchedCoroutine，持有需要恢复的协程                                                 </span><br>    block.startCoroutineCancellable(coroutine, coroutine)<br>    <span class="hljs-comment">//返回结果为 挂起 还是完成                                              </span><br>    coroutine.getResult()<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight Kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">//DispatchedCoroutine.kt</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>: Any? &#123;<br>      <span class="hljs-comment">//需要挂起，则返回COROUTINE_SUSPENDED</span><br>        <span class="hljs-keyword">if</span> (trySuspend()) <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>        <span class="hljs-comment">// otherwise, onCompletionInternal was already invoked &amp; invoked tryResume, and the result is in the state</span><br>        <span class="hljs-keyword">val</span> state = <span class="hljs-keyword">this</span>.state.unboxState()<br>        <span class="hljs-keyword">if</span> (state <span class="hljs-keyword">is</span> CompletedExceptionally) <span class="hljs-keyword">throw</span> state.cause<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">"UNCHECKED_CAST"</span>)</span><br>        <span class="hljs-keyword">return</span> state <span class="hljs-keyword">as</span> T<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">trySuspend</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        _decision.loop &#123; decision -&gt;<br>            <span class="hljs-keyword">when</span> (decision) &#123;<br>                UNDECIDED -&gt; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._decision.compareAndSet(UNDECIDED, SUSPENDED)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                RESUMED -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">"Already suspended"</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>协程是否挂起，关键在于<strong>是否返回COROUTINE_SUSPENDED</strong>，在<code>getResult()</code>中就是判断<code>trySuspend()</code>是否返回<code>true</code>。</p>
</blockquote>
<p><img src="/images/协程挂起流程.png" srcset="/img/loading.gif" lazyload alt="协程挂起"></p>
<h4 id="协程恢复"><a href="#协程恢复" class="headerlink" title="协程恢复"></a>协程恢复</h4><p>在<code>withContext()</code>中调用<code>startCoroutine()</code>传入了两个参数，其中第二个表示<code>协程完成的回调</code>。</p>
<p>当协程完成的时候会调用<code>resumeWith()</code>，然后层层传递到<code>JobSupport.afterCompletion()</code>，最后执行到<code>DispatchedCoroutine</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterCompletionInternal</span><span class="hljs-params">(state: <span class="hljs-type">Any</span>?, mode: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (tryResume()) <span class="hljs-keyword">return</span> <span class="hljs-comment">// completed before getResult invocation -- bail out</span><br>    <span class="hljs-comment">// otherwise, getResult has already commenced, i.e. completed later or in other thread</span><br>    <span class="hljs-keyword">super</span>.afterCompletionInternal(state, mode)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryResume</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    _decision.loop &#123; decision -&gt;<br>        <span class="hljs-keyword">when</span> (decision) &#123;<br>            UNDECIDED -&gt; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._decision.compareAndSet(UNDECIDED, RESUMED)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            SUSPENDED -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">"Already resumed"</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>afterCompletionInternal()</code>判断协程是否被挂起，若挂起则恢复已被挂起的协程。</p>
<p>然后再回到执行线程上，就会继续执行<code>invokeSuspend()</code>直到执行结束。</p>
<p><img src="/images/协程恢复流程.png" srcset="/img/loading.gif" lazyload alt="协程恢复"></p>
<h3 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h3><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md" target="_blank" rel="noopener">Kotlin/Keep</a></p>
<p><a href="https://juejin.cn/user/2277843822969863" target="_blank" rel="noopener">Android_开发者</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&amp;mid=2247495170&amp;idx=1&amp;sn=b54e233699fd7bba0e940e2837258002&amp;chksm=f9f279d1ce85f0c741857443332c20a82caedc24d8ea798219c2098c2d09ee58e11a6aba9296&amp;mpshare=1&amp;scene=23&amp;srcid=1212Jz0IsITrVDTTTBRNCn0j&amp;sharer_sharetime=1607751713936&amp;sharer_shareid=65073698ab9ac2983b955fa53b4ff585%23rd" target="_blank" rel="noopener">Kotlin协程原理解析</a></p>
<p><a href="https://juejin.cn/post/6883652600462327821#heading-10" target="_blank" rel="noopener">图解协程：suspend</a></p>
<!-- https://juejin.cn/post/6890348438873964551#heading-1 -->
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Kotlin/">Kotlin</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/13/Java-AbstractQueuedSynchronizer简介/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java-AbstractQueuedSynchronizer简介</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/08/14/WebRTC音频处理模块相关/">
                        <span class="hidden-mobile">WebRTC音频处理模块相关</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>
  




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
