

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
    <meta name="description" content="在Kotlin-协程介绍了大部分概念，现在需要针对这些概念进行详细的说明以及分析。 协程是轻量级的线程   阅读地图（按问题定位） 1. 协程是什么：概念与术语 2. 协程怎么运行：核心组件与调度 3. 协程怎么用好：构造、启动、取消 4. 协程为什么能挂起：原理实现 5. 知识点总结（可口述） 6. 参考与延伸     展开子目录（细分知识点）   协程概念 概念介绍 协程与线程的关系（易混点）">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin协程原理">
<meta property="og:url" content="https://leo-wxy.github.io/2020/09/04/Kotlin%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="在Kotlin-协程介绍了大部分概念，现在需要针对这些概念进行详细的说明以及分析。 协程是轻量级的线程   阅读地图（按问题定位） 1. 协程是什么：概念与术语 2. 协程怎么运行：核心组件与调度 3. 协程怎么用好：构造、启动、取消 4. 协程为什么能挂起：原理实现 5. 知识点总结（可口述） 6. 参考与延伸     展开子目录（细分知识点）   协程概念 概念介绍 协程与线程的关系（易混点）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leo-wxy.github.io/images/Job%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B">
<meta property="og:image" content="https://leo-wxy.github.io/images/SuperVisorJob%E4%B8%8D%E5%8F%96%E6%B6%88">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E5%8D%8F%E7%A8%8B%E6%8C%82%E8%B5%B7%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/%E5%8D%8F%E7%A8%8B%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B.png">
<meta property="article:published_time" content="2020-09-04T02:15:08.000Z">
<meta property="article:modified_time" content="2026-02-27T13:59:00.535Z">
<meta property="article:author" content="Leo-Wxy">
<meta property="article:tag" content="Kotlin">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://leo-wxy.github.io/images/Job%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg">
  
  
  
  <title>Kotlin协程原理 - Wxy的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":false};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Kotlin协程原理</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-09-04 10:15" pubdate>
          2020年9月4日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          9.9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          31 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Kotlin协程原理</h1>
            
            
              <div class="markdown-body">
                
                <p>在<a href="/2020/04/12/Kotlin%E5%8D%8F%E7%A8%8B%E4%BD%93%E9%AA%8C/" title="Kotlin-协程">Kotlin-协程</a>介绍了大部分概念，现在需要针对这些概念进行详细的说明以及分析。</p>
<blockquote><p>协程是轻量级的线程</p>
</blockquote>

<h2 id="阅读地图（按问题定位）"><a href="#阅读地图（按问题定位）" class="headerlink" title="阅读地图（按问题定位）"></a>阅读地图（按问题定位）</h2><ul>
<li><a href="#sec-1">1. 协程是什么：概念与术语</a></li>
<li><a href="#sec-2">2. 协程怎么运行：核心组件与调度</a></li>
<li><a href="#sec-3">3. 协程怎么用好：构造、启动、取消</a></li>
<li><a href="#sec-4">4. 协程为什么能挂起：原理实现</a></li>
<li><a href="#sec-5">5. 知识点总结（可口述）</a></li>
<li><a href="#sec-6">6. 参考与延伸</a></li>
</ul>
<details>
  <summary>展开子目录（细分知识点）</summary>

<ul>
<li><a href="#sec-1-concept">协程概念</a></li>
<li><a href="#sec-1-terms">概念介绍</a></li>
<li><a href="#sec-1-thread-vs-coroutine">协程与线程的关系（易混点）</a></li>
<li><a href="#sec-2-scope">协程作用域—CoroutineScope</a></li>
<li><a href="#sec-2-context">协程上下文-CoroutineContext</a></li>
<li><a href="#sec-2-job">协程执行任务-Job</a></li>
<li><a href="#sec-2-dispatcher">协程调度器-CoroutineDispatcher</a></li>
<li><a href="#sec-2-dispatcher-performance">调度器与性能（补充）</a></li>
<li><a href="#sec-2-interceptor">协程拦截器-ContinuationInterceptor</a></li>
<li><a href="#sec-2-exception">协程异常处理-CoroutineExceptionHandler</a></li>
<li><a href="#sec-2-exception-deep">异常语义深水区（补充）</a></li>
<li><a href="#sec-3-structured">结构化并发决策（补充）</a></li>
<li><a href="#sec-3-choice">协程工具选型（launch &#x2F; async &#x2F; withContext）</a></li>
<li><a href="#sec-3-flow">Flow 体系（Flow &#x2F; StateFlow &#x2F; SharedFlow &#x2F; Channel）</a></li>
<li><a href="#sec-3-primitives">并发原语（Mutex &#x2F; Semaphore &#x2F; Channel &#x2F; select）</a></li>
<li><a href="#sec-3-builder">协程构造器-CoroutineBuilder</a></li>
<li><a href="#sec-3-start">协程启动模式-CoroutineStart</a></li>
<li><a href="#sec-3-cancel">协程取消-Cancel</a></li>
<li><a href="#sec-3-cancel-deep">取消语义深水区（补充）</a></li>
<li><a href="#sec-3-android-practice">Android 使用建议（工程实践）</a></li>
<li><a href="#sec-3-antipatterns">常见反模式与修正建议</a></li>
<li><a href="#sec-4-dispatcher-principle">Dispatchers原理</a></li>
<li><a href="#sec-4-start-flow">协程启动流程</a></li>
<li><a href="#sec-4-suspend-resume">协程挂起&#x2F;恢复原理</a></li>
<li><a href="#sec-4-concurrency">协程并发</a></li>
<li><a href="#sec-4-test-observability">测试与可观测性（补充）</a></li>
<li><a href="#sec-5-principle-30">协程原理速答（30秒）</a></li>
<li><a href="#sec-5-principle-2m">协程原理展开（2分钟）</a></li>
<li><a href="#sec-5-faq">高频追问知识点（补充）</a></li>
</ul>
</details>

<p><a id="sec-1"></a></p>
<h2 id="一、协程是什么（概念与术语）"><a href="#一、协程是什么（概念与术语）" class="headerlink" title="一、协程是什么（概念与术语）"></a>一、协程是什么（概念与术语）</h2><p><a id="sec-1-concept"></a></p>
<h3 id="协程概念"><a href="#协程概念" class="headerlink" title="协程概念"></a>协程概念</h3><blockquote>
<p><code>非抢占式或协作式</code>的计算机并发调度的实现，程序可以主动挂起或者恢复执行，</p>
<p>避免在异步程序中使用大量的回调，<strong>使用阻塞的方式写出非阻塞的代码。</strong></p>
</blockquote>
<p>一种全新处理并发的方式，可以在Android平台上简化异步执行的代码。</p>
<p><code>协程</code>主要用来解决两个问题：</p>
<ul>
<li><strong>处理耗时任务</strong></li>
<li><strong>保证主线程安全</strong></li>
</ul>
<p>在后面的原理介绍中，会介绍与这两个问题相关的概念。</p>
<p><a id="sec-1-terms"></a></p>
<h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><blockquote>
<p>在执行过程中会涉及的一些概念，在后续源码分析也会涉及。</p>
</blockquote>
<p><code>协程体</code></p>
<p>协程中要执行的操作，是一个被<code>suspend</code>修饰的<code>lambda表达式</code></p>
<p><code>挂起函数</code></p>
<p>由<code>suspend</code>修饰的函数，只能在<code>挂起函数</code>或者<code>协程体</code>中调用。可以通过调用其他<code>挂起函数</code>挂起执行代码，而不阻塞当前执行线程。</p>
<p><code>挂起点</code></p>
<p>一般对应<code>挂起函数</code>被调用的位置</p>
<p><code>续体-Continuation</code></p>
<p>挂起的协程在<code>挂起点</code>时的状态。概念上表示<code>挂起点之后的剩余应该执行的代码</code>。</p>
<p><a id="sec-1-thread-vs-coroutine"></a></p>
<h3 id="协程与线程的关系（易混点）"><a href="#协程与线程的关系（易混点）" class="headerlink" title="协程与线程的关系（易混点）"></a>协程与线程的关系（易混点）</h3><p>协程常被描述为“轻量级线程”，更准确地说：协程是运行在线程之上的任务抽象，线程仍然是最终执行载体。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>调度单位</td>
<td>操作系统调度</td>
<td>用户态（库&#x2F;运行时）调度</td>
</tr>
<tr>
<td>创建与切换成本</td>
<td>相对更高</td>
<td>相对更低</td>
</tr>
<tr>
<td>阻塞影响</td>
<td>阻塞会占住线程</td>
<td>挂起不会阻塞线程</td>
</tr>
<tr>
<td>并发规模</td>
<td>数量受限（线程资源）</td>
<td>可创建大量任务（但不是无限）</td>
</tr>
<tr>
<td>生命周期管理</td>
<td>需手动管理</td>
<td>借助<code>CoroutineScope</code>结构化管理</td>
</tr>
</tbody></table>
<p>补充：</p>
<ul>
<li>协程“轻量”不等于“无成本”，大量协程仍会带来调度和内存开销。</li>
<li>协程是否切线程，取决于<code>CoroutineDispatcher</code>和挂起点恢复位置。</li>
<li>挂起函数是“让出执行权”，不是“停止线程运行”。</li>
</ul>
<p><a id="sec-2"></a></p>
<h2 id="二、协程怎么运行（核心组件与调度）"><a href="#二、协程怎么运行（核心组件与调度）" class="headerlink" title="二、协程怎么运行（核心组件与调度）"></a>二、协程怎么运行（核心组件与调度）</h2><p><a id="sec-2-scope"></a></p>
<h3 id="协程作用域—CoroutineScope"><a href="#协程作用域—CoroutineScope" class="headerlink" title="协程作用域—CoroutineScope"></a>协程作用域—CoroutineScope</h3><blockquote>
<p>追踪每一个通过<code>launch</code>或<code>async</code>创建的协程。并且任何时候都可以通过<code>scope.cancel()</code>取消正在执行的协程。</p>
<p>可以通过<code>CoroutineScope</code>控制协程的生命周期，当Activity&#x2F;Fragment关闭时，调用<code>cancel()</code>及时关闭。</p>
</blockquote>
<p><code>协程作用域</code>主要有三种：</p>
<h4 id="阻塞协程作用域"><a href="#阻塞协程作用域" class="headerlink" title="阻塞协程作用域"></a>阻塞协程作用域</h4><p>调用<code>runBlocking()</code>的线程会被阻塞直到内部协程任务执行完毕。</p>
<h4 id="全局协程作用域"><a href="#全局协程作用域" class="headerlink" title="全局协程作用域"></a>全局协程作用域</h4><p><code>GlobalScope</code>作用于整个应用生命周期，不会随页面生命周期自动取消。它并非“无法取消”，但如果缺少显式管理，在界面上使用时很容易导致任务泄漏或状态错乱。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;  <br>    <span class="hljs-comment">// 重写coroutineContext，返回一个空的协程上下文  </span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext  <br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoroutineScope</span> &#123;  <br>    <span class="hljs-comment">// 协程上下文  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext  <br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="自定义作用域"><a href="#自定义作用域" class="headerlink" title="自定义作用域"></a>自定义作用域</h4><p>自定义协程作用域，可以针对性的控制避免内存泄漏。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job()<span class="hljs-comment">//协程上下文</span><br><span class="hljs-keyword">val</span> coroutineScope = CoroutineScope(coroutineContext)<span class="hljs-comment">//自定义作用域</span><br></code></pre></td></tr></table></figure>

<p>需要自定义<code>协程作用域</code>时，需要构造一个<code>CoroutineContext</code>作为参数。</p>
<p><code>CoroutineContext</code>会在下面重点介绍。</p>
<h5 id="内置的自定义作用域"><a href="#内置的自定义作用域" class="headerlink" title="内置的自定义作用域"></a>内置的自定义作用域</h5><h6 id="MainScope"><a href="#MainScope" class="headerlink" title="MainScope"></a>MainScope</h6><blockquote>
<p>为了方便开发使用，Kotlin标准库提供了<code>MainScope</code>用于快速生成<code>CoroutineScope</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MainScope</span><span class="hljs-params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)<br></code></pre></td></tr></table></figure>



<h6 id="viewModelScope"><a href="#viewModelScope" class="headerlink" title="viewModelScope"></a>viewModelScope</h6><blockquote>
<p>在AndroidX中引入的<code>viewModelScope</code>，在ViewModel销毁时会自动取消协程任务</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> ViewModel.viewModelScope: CoroutineScope<br>        <span class="hljs-keyword">get</span>() &#123;<br>            <span class="hljs-keyword">val</span> scope: CoroutineScope? = <span class="hljs-keyword">this</span>.getTag(JOB_KEY)<br>          <span class="hljs-comment">//缓存中读取 对应scope</span><br>            <span class="hljs-keyword">if</span> (scope != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> scope<br>            &#125;<br>           <span class="hljs-comment">//对应了ViewModel内部的实现代码</span><br>            <span class="hljs-keyword">return</span> setTagIfAbsent(JOB_KEY,<br>                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate))<br>        &#125;<br><span class="hljs-comment">//自动取消 coroutineScope</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CloseableCoroutineScope</span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext = context<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123;<br>        coroutineContext.cancel()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><a id="sec-2-context"></a></p>
<h3 id="协程上下文-CoroutineContext"><a href="#协程上下文-CoroutineContext" class="headerlink" title="协程上下文-CoroutineContext"></a>协程上下文-CoroutineContext</h3><blockquote>
<p>一组定义协程行为的元素，本体是一个数据结构，类似于<code>Map</code>，内部实现为<code>单链表</code></p>
</blockquote>
<p>由如下几项构成：</p>
<ul>
<li>Job：执行的任务</li>
<li>CoroutineDispatcher：协程调度器</li>
<li>CoroutineName：协程的名称，主要用于调试</li>
<li>CoroutineExceptionHandler：处理未被捕获的异常。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoroutineContext</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E?<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fold</span><span class="hljs-params">(initial: <span class="hljs-type">R</span>, operation: (<span class="hljs-type">R</span>, <span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: CoroutineContext =<br>        <span class="hljs-comment">//空实现直接返回</span><br>        <span class="hljs-keyword">if</span> (context === EmptyCoroutineContext) <span class="hljs-keyword">this</span> <span class="hljs-keyword">else</span> <br>           <span class="hljs-comment">// 遍历context集合</span><br>            context.fold(<span class="hljs-keyword">this</span>) &#123; acc, element -&gt; <span class="hljs-comment">//acc 当前上下文集合 element context集合的元素</span><br>                <span class="hljs-keyword">val</span> removed = acc.minusKey(element.key) <span class="hljs-comment">//移除对应集合的元素</span><br>                <span class="hljs-keyword">if</span> (removed === EmptyCoroutineContext) element <span class="hljs-keyword">else</span> &#123; <br>                    <span class="hljs-keyword">val</span> interceptor = removed[ContinuationInterceptor] <span class="hljs-comment">//获取拦截器</span><br>                    <span class="hljs-keyword">if</span> (interceptor == <span class="hljs-literal">null</span>) CombinedContext(removed, element) <span class="hljs-comment">//生成最后的CombinedContext节点</span><br>                  <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//拦截器永远位于 链表尾部</span><br>                        <span class="hljs-keyword">val</span> left = removed.minusKey(ContinuationInterceptor)<br>                        <span class="hljs-keyword">if</span> (left === EmptyCoroutineContext) CombinedContext(element, interceptor) <span class="hljs-keyword">else</span><br>                            CombinedContext(CombinedContext(left, element), interceptor)<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minusKey</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="自定义CoroutineContext"><a href="#自定义CoroutineContext" class="headerlink" title="自定义CoroutineContext"></a>自定义CoroutineContext</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job() + CoroutineName(<span class="hljs-string">&quot;name&quot;</span>)<span class="hljs-comment">//协程上下文</span><br></code></pre></td></tr></table></figure>

<p><code>CoroutineContext</code>通过<code>+</code>进行元素的合并，<code>+</code>右侧的元素会覆盖左侧的元素。</p>
<p><code>CoroutineContext</code>存储方式为<code>左向链表</code>，链表的每一个节点都是<code>CombinedContext</code>，当存在<code>协程拦截器</code>时，永远处于链表的最后。</p>
<p>经过上述的<code>plus</code>操作后，最后得到一个完整的<code>CoroutineContext</code>对象。</p>
<h4 id="CoroutineContext的父子关系"><a href="#CoroutineContext的父子关系" class="headerlink" title="CoroutineContext的父子关系"></a>CoroutineContext的父子关系</h4><blockquote>
<p>每个协程都会有一个父对象，协程的父级<code>CoroutineContext</code>和父协程的<code>CoroutineContext</code>是不一致的。</p>
</blockquote>
<p><strong>父级上下文 &#x3D; 默认值 + 继承的<code>CoroutineContext</code>+参数</strong></p>
<p><code>默认值</code>：一些元素包含的默认值，例如默认<code>Dispatcher</code>就是<code>Dispatchers.Default</code></p>
<p><code>继承的CoroutineContext</code>：父协程的<code>CoroutineContenxt</code></p>
<p><code>参数</code>：后续子协程配置的参数，如上文所示组成部分，新添加的参数会覆盖前面的对应配置。</p>
<p><a id="sec-2-job"></a></p>
<h3 id="协程执行任务-Job"><a href="#协程执行任务-Job" class="headerlink" title="协程执行任务-Job"></a>协程执行任务-Job</h3><blockquote>
<p>用于处理协程，封装了协程需要执行的代码逻辑，并且负责管理协程的生命周期。</p>
<p>通过<code>协程构造器</code>创建的协程都会返回一个<code>Job实例</code>。</p>
</blockquote>
<p>主要有以下几种生命周期：</p>
<ul>
<li><code>New</code> 新建任务</li>
<li><code>Active</code> 任务活跃</li>
<li><code>Completing</code> 任务完成中</li>
<li><code>Cancelling</code> 任务取消中</li>
<li><code>Cancelled</code> 任务已取消</li>
<li><code>Completed</code> 任务已完成</li>
</ul>
<p><img src="/images/Job%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" srcset="/img/loading.gif" lazyload alt="Job生命周期"></p>
<p><code>Job</code>内提供了<code>isActive()</code>、<code>isCancelled()</code>和<code>isCompleted()</code>等属性用于判断协程的状态。</p>
<p><a href="#sec-3-cancel">协程取消</a>会更多的分析<code>Job</code>相关。</p>
<p><a id="sec-2-dispatcher"></a></p>
<h3 id="协程调度器-CoroutineDispatcher"><a href="#协程调度器-CoroutineDispatcher" class="headerlink" title="协程调度器-CoroutineDispatcher"></a>协程调度器-CoroutineDispatcher</h3><blockquote>
<p><code>Dispatchers</code>是协程中提供的<code>线程调度器</code>，用来切换线程，指定协程运行的线程。</p>
</blockquote>
<p>默认提供了四种调度器</p>
<h4 id="Dispatchers-Default"><a href="#Dispatchers-Default" class="headerlink" title="Dispatchers.Default"></a>Dispatchers.Default</h4><blockquote>
<p>默认调度器，适合处理后台运算，为<code>CPU密集型</code>任务调度器</p>
</blockquote>
<h4 id="Dispatchers-IO-仅JVM可用"><a href="#Dispatchers-IO-仅JVM可用" class="headerlink" title="Dispatchers.IO(仅JVM可用)"></a>Dispatchers.IO(仅JVM可用)</h4><blockquote>
<p>适合执行IO相关操作，例如<code>读写文件</code>等，为<code>IO密集型</code>任务调度器</p>
</blockquote>
<h4 id="Dispatchers-Main"><a href="#Dispatchers-Main" class="headerlink" title="Dispatchers.Main"></a>Dispatchers.Main</h4><blockquote>
<p>UI调度器，根据执行平台的不同会初始化为对应平台的UI线程调度器。</p>
<p>在Android中，就会通过<code>Handler</code>调度任务到<code>UI线程</code>执行。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//加载各平台下定义的MainDispatcherFactory</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadMainDispatcher</span><span class="hljs-params">()</span></span>: MainCoroutineDispatcher &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> factories = <span class="hljs-keyword">if</span> (FAST_SERVICE_LOADER_ENABLED) &#123;<br>                FastServiceLoader.loadMainDispatcherFactory()<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// We are explicitly using the</span><br>                <span class="hljs-comment">// `ServiceLoader.load(MyClass::class.java, MyClass::class.java.classLoader).iterator()`</span><br>                <span class="hljs-comment">// form of the ServiceLoader call to enable R8 optimization when compiled on Android.</span><br>                ServiceLoader.load(<br>                        MainDispatcherFactory::<span class="hljs-keyword">class</span>.java,<br>                        MainDispatcherFactory::<span class="hljs-keyword">class</span>.java.classLoader<br>                ).iterator().asSequence().toList()<br>            &#125;<br>            <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;ConstantConditionIf&quot;</span>)</span><br>            factories.maxBy &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)<br>                ?: createMissingDispatcher()<br>        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;<br>            <span class="hljs-comment">// Service loader can throw an exception as well</span><br>            createMissingDispatcher(e)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadMainDispatcherFactory</span><span class="hljs-params">()</span></span>: List&lt;MainDispatcherFactory&gt; &#123;<br>        <span class="hljs-keyword">val</span> clz = MainDispatcherFactory::<span class="hljs-keyword">class</span>.java<br>        <span class="hljs-keyword">if</span> (!ANDROID_DETECTED) &#123;<br>            <span class="hljs-keyword">return</span> load(clz, clz.classLoader)<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> result = ArrayList&lt;MainDispatcherFactory&gt;(<span class="hljs-number">2</span>)<br>          <span class="hljs-comment">//加载对应类名的类</span><br>            createInstanceOf(clz, <span class="hljs-string">&quot;kotlinx.coroutines.android.AndroidDispatcherFactory&quot;</span>)?.apply &#123; result.add(<span class="hljs-keyword">this</span>) &#125;<br>            createInstanceOf(clz, <span class="hljs-string">&quot;kotlinx.coroutines.test.internal.TestMainDispatcherFactory&quot;</span>)?.apply &#123; result.add(<span class="hljs-keyword">this</span>) &#125;<br>            result<br>        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;<br>            <span class="hljs-comment">// Fallback to the regular SL in case of any unexpected exception</span><br>            load(clz, clz.classLoader)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>按照类名去加载，Android下的名为<code>kotlinx.coroutines.android.AndroidDispatcherFactory</code>的类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在Android编译完成后，可以读取到该类</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidDispatcherFactory</span> : <span class="hljs-type">MainDispatcherFactory</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDispatcher</span><span class="hljs-params">(allFactories: <span class="hljs-type">List</span>&lt;<span class="hljs-type">MainDispatcherFactory</span>&gt;)</span></span> = HandlerContext(Looper.getMainLooper().asHandler(async = <span class="hljs-literal">true</span>), <span class="hljs-string">&quot;Main&quot;</span>)<br>&#125;<br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerContext</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler: Handler,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> invokeImmediately: <span class="hljs-built_in">Boolean</span><br>) : HandlerDispatcher(), Delay &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<br>        handler: Handler,<br>        name: String? = <span class="hljs-literal">null</span><br>    ) : <span class="hljs-keyword">this</span>(handler, name, <span class="hljs-literal">false</span>)<br><br>    <span class="hljs-comment">//android中需要向主looper进行提交调度</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isDispatchNeeded</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> !invokeImmediately || Looper.myLooper() != handler.looper<br>    &#125;<br><br>    <span class="hljs-comment">//通过持有主线程looper的handler进行调度</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;<br>        handler.post(block)<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="Dispatchers-Main-immediate"><a href="#Dispatchers-Main-immediate" class="headerlink" title="Dispatchers.Main.immediate"></a>Dispatchers.Main.immediate</h5><blockquote>
<p>适用于<code>响应UI事件后立即执行后续逻辑</code>的场景：当当前线程已经是<code>Main</code>线程时会立刻执行而不是再次分发；如果不在<code>Main</code>线程，行为与<code>Dispatchers.Main</code>一致。</p>
</blockquote>
<h4 id="Dispatchers-Unconfined"><a href="#Dispatchers-Unconfined" class="headerlink" title="Dispatchers.Unconfined"></a>Dispatchers.Unconfined</h4><blockquote>
<p>非限制的调度器，在遇到第一个挂起函数前的代码运行在原线程中，执行挂起函数后，就切换线程运行。</p>
</blockquote>
<p><img src="/images/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82" srcset="/img/loading.gif" lazyload alt="调度器间的差异"></p>
<h4 id="自定义调度器"><a href="#自定义调度器" class="headerlink" title="自定义调度器"></a>自定义调度器</h4><blockquote>
<p><code>Default</code>和<code>IO</code>的底层实现都依赖于<code>线程池</code>，执行到<code>挂起函数</code>时还是会发生线程的切换，可以通过<code>自定义调度器</code>减少这类切换的发生。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myDispatcher= Executors.newSingleThreadExecutor&#123; r -&gt; Thread(r, <span class="hljs-string">&quot;MyThread&quot;</span>) &#125;.asCoroutineDispatcher() <span class="hljs-comment">//转换线程池到 Dispatcher</span><br><br></code></pre></td></tr></table></figure>



<p><a id="sec-2-dispatcher-performance"></a></p>
<h3 id="调度器与性能（补充）"><a href="#调度器与性能（补充）" class="headerlink" title="调度器与性能（补充）"></a>调度器与性能（补充）</h3><ul>
<li><code>Dispatchers.Default</code> 与 <code>Dispatchers.IO</code> 都基于共享调度体系，IO 任务过量会影响整体调度公平性。</li>
<li><code>withContext</code> 每次切换都存在调度开销，细粒度频繁切换会放大性能损耗。</li>
<li>对高并发 IO 场景建议限流，避免把线程池和下游资源（DB&#x2F;网络）同时打满。</li>
<li><code>Dispatchers.Main.immediate</code> 适合“已经在主线程且希望避免二次分发”的场景。</li>
<li><code>Dispatchers.Unconfined</code> 更适合调试&#x2F;框架层场景，业务代码中应谨慎使用。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 限制并发度，避免 IO 峰值放大</span><br><span class="hljs-keyword">val</span> dbDispatcher = Dispatchers.IO.limitedParallelism(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>

<p><a id="sec-2-interceptor"></a></p>
<h3 id="协程拦截器-ContinuationInterceptor"><a href="#协程拦截器-ContinuationInterceptor" class="headerlink" title="协程拦截器-ContinuationInterceptor"></a>协程拦截器-ContinuationInterceptor</h3><blockquote>
<p><code>ContinuationInterceptor</code>是一个拦截器的接口定义，用于控制协程的执行流程。</p>
<p>在<code>CoroutineContext</code>中，实现了<code>ContinuationInterceptor</code>接口的类，永远会处于最后一位，保证不会被其他类覆盖。</p>
<p><strong>协程拦截器只能存在一个！</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// ContinuationInterceptor.kt</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ContinuationInterceptor</span> : <span class="hljs-type">CoroutineContext.Element</span> &#123;  <br>     <span class="hljs-comment">// 实现CoroutineContext.Element接口，说明自身是CoroutineContext上下文集合的一个元素类型  </span><br>     <span class="hljs-comment">// 定义伴生对象Key作为集合中的索引key，可直接通过类名访问该伴生对象  </span><br>     <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;  <br>   <br>     <span class="hljs-comment">// 传入一个Continuation对象，并返回一个新的Continuation对象  </span><br>     <span class="hljs-comment">// 在协程中，这里的传参continuation就是协程体编译后Continuation对象  </span><br>     <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;  <br>   <br>     <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">releaseInterceptedContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;*&gt;)</span></span> &#123;  <br>         <br>     ...  <br> &#125;  <br></code></pre></td></tr></table></figure>

<p>其中<code>CoroutineDispatcher</code>就是基于<code>ContinuationInterceptor</code>所实现的。</p>
<p><a id="sec-2-exception"></a></p>
<h3 id="协程异常处理-CoroutineExceptionHandler"><a href="#协程异常处理-CoroutineExceptionHandler" class="headerlink" title="协程异常处理-CoroutineExceptionHandler"></a>协程异常处理-CoroutineExceptionHandler</h3><blockquote>
<p><strong>所有未被捕获的异常一定会抛出，无论使用哪种Job!!!</strong></p>
</blockquote>
<p>当一个协程由于一个异常而运行失败时，它会传播这个异常并传递给他的父级。</p>
<p><img src="/images/%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B" srcset="/img/loading.gif" lazyload alt="△ 协程中的异常会通过协程的层级不断传播"></p>
<p>主要执行以下几步：</p>
<ol>
<li>取消它的子级任务</li>
<li>取消自己的任务</li>
<li>把异常继续向上传递到自己的父级</li>
</ol>
<h4 id="SupervisorJob"><a href="#SupervisorJob" class="headerlink" title="SupervisorJob"></a>SupervisorJob</h4><p>使用<code>Job</code>时，若发生异常会导致异常传递，使得所有的任务都会被取消。</p>
<p>使用<code>SupervisorJob</code>，一个子协程运行失败不会传播异常，<code>只会影响自身</code>，其他任务都不会受到影响。</p>
<p><strong>SupervisorJob只有在<code>supervisorScope</code>或<code>CoroutineScope(SupervisorJob())</code>内执行才可以生效。</strong></p>
<p><img src="/images/SuperVisorJob%E4%B8%8D%E5%8F%96%E6%B6%88" srcset="/img/loading.gif" lazyload alt="SupervisorJob 不会取消它其他的子级"></p>
<p><code>CoroutineScope(SupervisorJob())</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> scope = CoroutineScope(SupervisorJob())<br>scope.launch&#123;<br>  <span class="hljs-comment">//child 1</span><br>&#125;<br>scope.launch&#123;<br>  <span class="hljs-comment">//child 2</span><br>&#125;<br><span class="hljs-comment">//若child1 发生异常不会影响 child2</span><br></code></pre></td></tr></table></figure>

<p><code>supervisorScope</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">supervisorScope &#123;<br>    launch &#123;<br>        <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">&quot;123&quot;</span>)<br>    &#125;<br>    launch &#123;<br>        System.err.println(<span class="hljs-number">3</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>使用这两种方式都可以保证异常不向上传播</p>
<h4 id="Job-VS-SupervisorJob"><a href="#Job-VS-SupervisorJob" class="headerlink" title="Job VS SupervisorJob"></a>Job VS SupervisorJob</h4><blockquote>
<p>如果想在出现错误时不会退出父级和其他平级的协程，就要使用<code>SupervisorJob</code>或<code>supervisorScope</code></p>
</blockquote>
<h4 id="局部异常捕获"><a href="#局部异常捕获" class="headerlink" title="局部异常捕获"></a>局部异常捕获</h4><p>根据不同的<code>协程构造器</code>，处理方式也不尽相同</p>
<h5 id="launch"><a href="#launch" class="headerlink" title="launch()"></a><code>launch()</code></h5><p>主要采用<code>try&#123;&#125;catch&#123;&#125;</code>的形式进行异常捕获</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">scope.launch &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        codeThatCanThrowExceptions()<br>    &#125; <span class="hljs-keyword">catch</span>(e: Exception) &#123;<br>        <span class="hljs-comment">// 处理异常</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>launch()</code>时，异常会在第一时间被抛出。</strong></p>
<h5 id="async-await"><a href="#async-await" class="headerlink" title="async/await()"></a><code>async/await()</code></h5><p><strong>只有当<code>async()</code>作为根协程时，不会自动抛出异常，而是要等到<code>await()</code>执行时才抛出异常。</strong></p>
<p><code>根协程</code>：<code>coroutineScope</code>或<code>supervisorScope</code>的直接子协程，或者类似<code>scope.async()</code>这种实现。</p>
<p>这种情况下可以通过<code>try&#123;&#125;catch&#123;&#125;</code>捕获异常</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//supervisorScope</span><br>coroutineScope&#123;<br>  <span class="hljs-keyword">val</span> deferred = async&#123;<br>    <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">&quot;123&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时不会执行任何</p>
<p>只有在调用<code>.await()</code>时才会抛出异常，此时就可以添加<code>try&#123;&#125;catch&#123;&#125;</code>捕获异常。</p>
<p><strong>针对<code>async()</code>这种情况，最有效的方式就是<code>async()</code>内部进行<code>try&#123;&#125;catch&#123;&#125;</code></strong></p>
<h4 id="全局异常捕获"><a href="#全局异常捕获" class="headerlink" title="全局异常捕获"></a>全局异常捕获</h4><blockquote>
<p>类似Java，协程也提供了捕获全局异常(<code>未声明捕获异常</code>)的方式</p>
</blockquote>
<p>Java的全局异常捕获方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UncaughtExceptionHandler</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>        <span class="hljs-comment">//TODO 异常处理</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>



<h5 id="协程内全局异常捕获方式"><a href="#协程内全局异常捕获方式" class="headerlink" title="协程内全局异常捕获方式"></a>协程内全局异常捕获方式</h5><p>主要使用的是<code>CoroutineExceptionHandler</code>，可以帮助处理一些<code>未捕获的异常</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;<br>    log(<span class="hljs-string">&quot;Throws an exception with message: <span class="hljs-subst">$&#123;throwable.message&#125;</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">val</span> context = Dispatchers.Main + Job() + exceptionHandler<br><span class="hljs-keyword">val</span> scope = CoroutineScope(context)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        scope.launch &#123;<br>            launch &#123;<br>                <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">&quot;1234&quot;</span>)<br>            &#125;<br>            delay(<span class="hljs-number">1000</span>)<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>此时就会捕获到<code>NPE</code>。</p>
<p>需要<code>CoroutineExceptionHandler</code>生效通常需要两个条件：</p>
<ol>
<li>异常是<code>未被捕获</code>的异常（协程体内没有被<code>try/catch</code>处理）。</li>
<li>异常发生在会向外抛出的协程上（典型是<code>launch</code>根协程）。<code>async</code>会把异常封装到<code>Deferred</code>，通常需要在<code>await()</code>时处理。</li>
</ol>
<h5 id="真·全局异常捕获"><a href="#真·全局异常捕获" class="headerlink" title="真·全局异常捕获"></a>真·全局异常捕获</h5><p>上面说到的<code>CoroutineExceptionHandler</code>只能在协程内部使用，无法兼顾其他协程的异常情况。此时就需要使用另一种方式，使用<code>ServiceLoader</code>实现全局内协程异常捕获</p>
<p>实现这个功能需要如下几步：</p>
<ol>
<li>新建全局<code>CoroutineExceptionHandler</code>类</li>
<li>在<code>classPath</code>中注册该类<ul>
<li>在<code>src/main/</code>目录下的，<code>resources/META-INF/services</code>文件夹</li>
<li>新建<code>kotlinx.coroutines.CoroutineExceptionHandler</code>文件</li>
<li>文件内写入自定义的全局<code>CoroutineExceptionHandler</code>完整类名</li>
</ul>
</li>
</ol>
<p><strong>同样，这种配置方式只处理未被捕获异常；<code>async</code>的异常仍需通过<code>await()</code>或局部<code>try/catch</code>处理。</strong></p>
<p>这里主要应用了<strong>SPI机制</strong></p>
<blockquote>
<p>全称为<code>Service Provider Interface</code>，JDK内置的一种服务提供发现机制，主要源码实现在<code>java.util.ServiceLoader</code></p>
</blockquote>
<p>使用过程：</p>
<p>需要在<code>resources/META-INF/services</code>目录下创建与服务同名的<strong>全限定名</strong>相同的文件，然后在文件中写入<strong>服务提供者的全限定名</strong>。</p>
<p>原理简介：</p>
<p>主要通过反射调用配置的类进行实例化，反射成功后存入缓存，后续使用直接从缓存重新读取。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li><p><strong>协程内部异常处理流程</strong></p>
<ul>
<li><p>在作用域内使用<code>try..catch</code>可以直接捕获子线程中的异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">try</span>&#123;<br>  launch&#123;<br>    <br>  &#125;<br>  <br>  async&#123;<br>    <br>  &#125;<br>&#125;<span class="hljs-keyword">catch</span>&#123;...&#125;&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>如果未做局部异常处理，未被捕获异常会走<code>全局异常捕获流程</code>（典型是<code>launch</code>根协程）</p>
<ul>
<li>若设置<code>CoroutineExceptionHandler</code>则处理。<strong>通常需要在根协程（或最终汇聚到根协程的上下文）配置才可生效</strong></li>
<li>没配置，向<code>GlobalExceptionHandler</code>进行处理，该配置是全局的，对所有协程任务生效</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>异常传播在不同作用域的表现</strong></p>
<ul>
<li><code>GlobalScope</code>：异常不会向外传递，因为已经是<code>根协程</code></li>
<li><code>coroutineScope</code>：异常进行<code>双向传递</code>，父协程和子协程都会被取消</li>
<li><code>supervisorScope</code>：异常进行<code>单向传递</code>，只有父协程向子协程传递异常，子协程会被取消，父协程不受影响</li>
</ul>
</li>
<li><p><code>launch/join</code>和<code>async/await</code>表现不同</p>
<p><code>launch/join</code>关注的是<strong>任务是否执行完成</strong>，<code>async/await</code>关注的是<strong>任务的执行结果</strong>，所以在局部异常捕获的时候，两种创建方式的异常捕获也会有区别</p>
</li>
<li><p>想要避免异常传播，就要使用<code>SupervisorJob</code>；不在意就用<code>Job</code></p>
</li>
</ol>
<p><a id="sec-2-exception-deep"></a></p>
<h3 id="异常语义深水区（补充）"><a href="#异常语义深水区（补充）" class="headerlink" title="异常语义深水区（补充）"></a>异常语义深水区（补充）</h3><table>
<thead>
<tr>
<th>场景</th>
<th>结果</th>
<th>处理建议</th>
</tr>
</thead>
<tbody><tr>
<td><code>launch</code> 根协程未捕获异常</td>
<td>立即向上抛出，触发父级取消链路</td>
<td>局部<code>try/catch</code>优先，必要时配合<code>CoroutineExceptionHandler</code></td>
</tr>
<tr>
<td><code>async</code> 未 <code>await()</code></td>
<td>异常会留在 <code>Deferred</code>，调用方感知可能延后</td>
<td>确保<code>await()</code>或在<code>async</code>内部处理异常</td>
</tr>
<tr>
<td>抛出 <code>CancellationException</code></td>
<td>视为正常取消语义，不等同业务失败</td>
<td>清理资源后继续向外抛，避免误吞取消信号</td>
</tr>
<tr>
<td><code>supervisorScope</code> 子协程异常</td>
<td>默认不取消其他同级子协程</td>
<td>适用于“局部失败可接受”的聚合任务</td>
</tr>
</tbody></table>
<p>补充：异常处理顺序建议是“局部处理 -&gt; 作用域处理 -&gt; 全局兜底”，避免把业务异常全部压到全局处理器。</p>
<p><a id="sec-3"></a></p>
<h2 id="三、协程怎么用好（构造、启动与取消）"><a href="#三、协程怎么用好（构造、启动与取消）" class="headerlink" title="三、协程怎么用好（构造、启动与取消）"></a>三、协程怎么用好（构造、启动与取消）</h2><p><a id="sec-3-structured"></a></p>
<h3 id="结构化并发决策（补充）"><a href="#结构化并发决策（补充）" class="headerlink" title="结构化并发决策（补充）"></a>结构化并发决策（补充）</h3><table>
<thead>
<tr>
<th>目标</th>
<th>推荐作用域&#x2F;模型</th>
<th>失败行为</th>
</tr>
</thead>
<tbody><tr>
<td>全部成功才算成功</td>
<td><code>coroutineScope</code> + <code>async/awaitAll</code></td>
<td>一个失败，整体快速失败</td>
</tr>
<tr>
<td>允许部分失败继续执行</td>
<td><code>supervisorScope</code> + 独立异常处理</td>
<td>失败子任务不影响其他子任务</td>
</tr>
<tr>
<td>长生命周期后台任务</td>
<td>显式 <code>CoroutineScope(Job/SupervisorJob + Dispatcher)</code></td>
<td>由作用域统一管理取消</td>
</tr>
</tbody></table>
<p>实践要点：</p>
<ul>
<li>子任务必须可追踪（有作用域、有<code>Job</code>、可取消）。</li>
<li>作用域退出前应完成“等待、取消、清理”三件事。</li>
<li>不要在业务层随意创建新的根作用域，避免协程漂移。</li>
</ul>
<p><a id="sec-3-choice"></a></p>
<h3 id="协程工具选型（launch-async-withContext）"><a href="#协程工具选型（launch-async-withContext）" class="headerlink" title="协程工具选型（launch &#x2F; async &#x2F; withContext）"></a>协程工具选型（launch &#x2F; async &#x2F; withContext）</h3><table>
<thead>
<tr>
<th>场景</th>
<th>推荐方式</th>
<th>原因</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>只关心执行，不关心结果</td>
<td><code>launch</code></td>
<td>语义直接，便于通过<code>Job</code>取消</td>
<td><code>Job</code></td>
</tr>
<tr>
<td>需要并发并汇总结果</td>
<td><code>async</code> + <code>await/awaitAll</code></td>
<td>可并行执行并拿到结果</td>
<td><code>Deferred&lt;T&gt;</code></td>
</tr>
<tr>
<td>单段任务切线程并返回结果</td>
<td><code>withContext</code></td>
<td>结构清晰，避免不必要并发</td>
<td>直接返回 <code>T</code></td>
</tr>
</tbody></table>
<p>常见误区：</p>
<ul>
<li><code>withContext</code>不是并发模型，它是“切上下文执行一段代码”。</li>
<li><code>async</code>不是默认更快，若没有并发需求，<code>withContext</code>更简单可控。</li>
<li>在父协程中混用过多<code>launch</code>而不追踪<code>Job</code>，容易导致状态不可控。</li>
</ul>
<p>推荐写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 单任务切线程</span><br><span class="hljs-keyword">val</span> user = withContext(Dispatchers.IO) &#123; api.loadUser() &#125;<br><br><span class="hljs-comment">// 并发聚合</span><br><span class="hljs-keyword">val</span> result = coroutineScope &#123;<br>    <span class="hljs-keyword">val</span> a = async(Dispatchers.IO) &#123; api.a() &#125;<br>    <span class="hljs-keyword">val</span> b = async(Dispatchers.IO) &#123; api.b() &#125;<br>    awaitAll(a, b)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a id="sec-3-flow"></a></p>
<h3 id="Flow-体系（Flow-StateFlow-SharedFlow-Channel）"><a href="#Flow-体系（Flow-StateFlow-SharedFlow-Channel）" class="headerlink" title="Flow 体系（Flow &#x2F; StateFlow &#x2F; SharedFlow &#x2F; Channel）"></a>Flow 体系（Flow &#x2F; StateFlow &#x2F; SharedFlow &#x2F; Channel）</h3><table>
<thead>
<tr>
<th>类型</th>
<th>冷&#x2F;热</th>
<th>数据语义</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>Flow&lt;T&gt;</code></td>
<td>冷流</td>
<td>每次收集重新执行上游</td>
<td>请求链路、转换流水线</td>
</tr>
<tr>
<td><code>StateFlow&lt;T&gt;</code></td>
<td>热流</td>
<td>始终持有最新状态（<code>value</code>）</td>
<td>UI 状态驱动</td>
</tr>
<tr>
<td><code>SharedFlow&lt;T&gt;</code></td>
<td>热流</td>
<td>广播事件，可配置<code>replay</code></td>
<td>一次性事件、多订阅分发</td>
</tr>
<tr>
<td><code>Channel&lt;T&gt;</code></td>
<td>热通道</td>
<td>点对点发送接收（队列）</td>
<td>生产者-消费者模型</td>
</tr>
</tbody></table>
<p>使用建议：</p>
<ul>
<li>状态流优先用<code>StateFlow</code>，事件流优先用<code>SharedFlow</code>。</li>
<li>高频流场景按需使用<code>buffer</code>、<code>conflate</code>、<code>collectLatest</code>降低背压影响。</li>
<li>UI 收集前可结合<code>distinctUntilChanged</code>减少重复渲染。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = MutableStateFlow(UiState.Loading)<br><span class="hljs-keyword">val</span> state: StateFlow&lt;UiState&gt; = _state<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _events = MutableSharedFlow&lt;UiEvent&gt;(extraBufferCapacity = <span class="hljs-number">1</span>)<br><span class="hljs-keyword">val</span> events: SharedFlow&lt;UiEvent&gt; = _events<br></code></pre></td></tr></table></figure>

<p><a id="sec-3-primitives"></a></p>
<h3 id="并发原语（Mutex-Semaphore-Channel-select）"><a href="#并发原语（Mutex-Semaphore-Channel-select）" class="headerlink" title="并发原语（Mutex &#x2F; Semaphore &#x2F; Channel &#x2F; select）"></a>并发原语（Mutex &#x2F; Semaphore &#x2F; Channel &#x2F; select）</h3><table>
<thead>
<tr>
<th>原语</th>
<th>作用</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>Mutex</code></td>
<td>互斥访问共享资源</td>
<td>保护共享可变状态</td>
</tr>
<tr>
<td><code>Semaphore</code></td>
<td>限制并发数量</td>
<td>批量请求限流</td>
</tr>
<tr>
<td><code>Channel</code></td>
<td>协程间消息通道</td>
<td>生产消费、任务管道</td>
</tr>
<tr>
<td><code>select</code></td>
<td>多路等待与竞速</td>
<td>超时竞速、多个源择优</td>
</tr>
</tbody></table>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> mutex = Mutex()<br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">incSafely</span><span class="hljs-params">()</span></span> &#123;<br>    mutex.withLock &#123;<br>        counter++<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a id="sec-3-builder"></a></p>
<h3 id="协程构造器-CoroutineBuilder"><a href="#协程构造器-CoroutineBuilder" class="headerlink" title="协程构造器-CoroutineBuilder"></a>协程构造器-CoroutineBuilder</h3><blockquote>
<p>主要负责构造一个协程并启动它</p>
</blockquote>
<p>常用的有两种方法</p>
<h4 id="launch-重点分析"><a href="#launch-重点分析" class="headerlink" title="launch(重点分析)"></a>launch(重点分析)</h4><blockquote>
<p>默认创建一个新的协程，并返回<code>Job</code>对象，通过<code>Job</code>管理协程。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span><br><span class="hljs-params"><span class="hljs-function">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Job &#123;<br>    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)<br>    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)<br>        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span><br>        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)<br>    coroutine.start(start, coroutine, block)<br>    <span class="hljs-keyword">return</span> coroutine<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要有三个参数：</p>
<ul>
<li><code>context</code>：就是前面介绍的<code>CoroutineContext</code></li>
<li><code>start</code>：<a href="#sec-3-start">协程启动模式</a></li>
<li><code>block</code>：需要执行的任务，由<code>suspend</code>修饰</li>
</ul>
<h5 id="newCoroutineContext"><a href="#newCoroutineContext" class="headerlink" title="newCoroutineContext"></a>newCoroutineContext</h5><blockquote>
<p>将传参的<code>context</code>与<code>ContextScope</code>配置的<code>context</code>进行合并，并返回一个新的<code>context</code>。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">newCoroutineContext</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;<br>    <span class="hljs-keyword">val</span> combined = coroutineContext + context<br>    <span class="hljs-keyword">val</span> debug = <span class="hljs-keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="hljs-keyword">else</span> combined<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="hljs-literal">null</span>)<br>        debug + Dispatchers.Default <span class="hljs-keyword">else</span> debug<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="StandaloneCoroutine-LazyStandaloneCoroutine"><a href="#StandaloneCoroutine-LazyStandaloneCoroutine" class="headerlink" title="StandaloneCoroutine&#x2F;LazyStandaloneCoroutine"></a>StandaloneCoroutine&#x2F;LazyStandaloneCoroutine</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StandaloneCoroutine</span>(<br>    parentContext: CoroutineContext,<br>    active: <span class="hljs-built_in">Boolean</span><br>) : AbstractCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt;(parentContext, active) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        handleCoroutineException(context, exception)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继承<code>AbstractCoroutine</code>且重写了<code>handleJobException()</code>，这也是为什么<code>CoroutineExceptionHandler</code>可以监听到异常的原因。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyStandaloneCoroutine</span>(<br>    parentContext: CoroutineContext,<br>    block: <span class="hljs-keyword">suspend</span> CoroutineScope.() -&gt; <span class="hljs-built_in">Unit</span><br>) : StandaloneCoroutine(parentContext, active = <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> block: (<span class="hljs-keyword">suspend</span> CoroutineScope.() -&gt; <span class="hljs-built_in">Unit</span>)? = block<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> block = checkNotNull(<span class="hljs-keyword">this</span>.block) &#123; <span class="hljs-string">&quot;Already started&quot;</span> &#125;<br>        <span class="hljs-keyword">this</span>.block = <span class="hljs-literal">null</span><br>        block.startCoroutineCancellable(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>LazyStandaloneCoroutine</code>重写了<code>onStart()</code>，只有在调用到<code>start()/join()</code>等方法才会执行。</p>
<h5 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h5><blockquote>
<p>启动协程任务</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//AbstractCoroutine.kt</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">start</span><span class="hljs-params">(start: <span class="hljs-type">CoroutineStart</span>, receiver: <span class="hljs-type">R</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>)</span></span> &#123;<br>        initParentJob()<br>        start(block, receiver, <span class="hljs-keyword">this</span>)<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>调用到<code>CoroutineStart.invoke()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//CoroutineStart.kt</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">invoke</span><span class="hljs-params">(block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>, receiver: <span class="hljs-type">R</span>, completion: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> =<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>            CoroutineStart.DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)<br>            CoroutineStart.ATOMIC -&gt; block.startCoroutine(receiver, completion)<br>            CoroutineStart.UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)<br>            CoroutineStart.LAZY -&gt; <span class="hljs-built_in">Unit</span> <span class="hljs-comment">// will start lazily</span><br>        &#125;<br><br></code></pre></td></tr></table></figure>

<p>默认使用<code>CoroutineStart.DEFAULT</code>，以这个作为示例分析</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//Cancellable.kt</span><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> (R)</span></span> -&gt; T).startCoroutineCancellable(receiver: R, completion: Continuation&lt;T&gt;) =<br>    runSafely(completion) &#123;<br>        createCoroutineUnintercepted(receiver, completion)<br>      .intercepted()<br>      .resumeCancellable(<span class="hljs-built_in">Unit</span>)<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>主要流程分为三步：</p>
<h6 id="createCoroutineUninterecpted"><a href="#createCoroutineUninterecpted" class="headerlink" title="createCoroutineUninterecpted"></a>createCoroutineUninterecpted</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//IntrinsicsJvm.kt</span><br><span class="hljs-meta">@SinceKotlin(<span class="hljs-string">&quot;1.3&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; &#123;<br>    <span class="hljs-keyword">val</span> probeCompletion = probeCoroutineCreated(completion)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> BaseContinuationImpl)<br>        create(probeCompletion)<br>    <span class="hljs-keyword">else</span><br>        createCoroutineFromSuspendFunction(probeCompletion) &#123;<br>            (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要是为了创建<code>Continuation</code>对象</p>
<h6 id="intercepted"><a href="#intercepted" class="headerlink" title="intercepted"></a>intercepted</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;T&gt; =<br>    (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="hljs-keyword">this</span><br><br><br><span class="hljs-comment">//ContinuationImpl.kt</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =<br>        intercepted<br>            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)<br>                .also &#123; intercepted = it &#125;<br></code></pre></td></tr></table></figure>

<p>如果设置了<code>ContinuationInterceptor</code>，就获取并执行<code>interceptContinuation()</code>。</p>
<h6 id="resumeCancellable"><a href="#resumeCancellable" class="headerlink" title="resumeCancellable"></a>resumeCancellable</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resumeCancellable</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = <span class="hljs-keyword">when</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">is</span> DispatchedContinuation -&gt; resumeCancellable(value)<br>    <span class="hljs-keyword">else</span> -&gt; resume(value)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进行线程调度或者事件拦截处理，然后协程就开始启动了。</p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p><a id="sec-3-start"></a></p>
<h3 id="协程启动模式-CoroutineStart"><a href="#协程启动模式-CoroutineStart" class="headerlink" title="协程启动模式-CoroutineStart"></a>协程启动模式-CoroutineStart</h3><blockquote>
<p>控制协程创建后的调用规则</p>
</blockquote>
<h4 id="CoroutineStart-DEFAULT"><a href="#CoroutineStart-DEFAULT" class="headerlink" title="CoroutineStart.DEFAULT"></a>CoroutineStart.DEFAULT</h4><blockquote>
<p>协程的默认启动模式，为<code>饿汉式调用</code>。在调用协程后，会立即进入调度状态。</p>
<p><em>可以在调度前被取消。</em></p>
</blockquote>
<h4 id="CoroutineStart-LAZY"><a href="#CoroutineStart-LAZY" class="headerlink" title="CoroutineStart.LAZY"></a>CoroutineStart.LAZY</h4><blockquote>
<p><code>懒汉式调用</code>，只有需要执行时才会执行。</p>
<p>通过调用以下方法就可以进入调度状态。</p>
<ul>
<li><code>job.start()</code>：启动协程</li>
<li><code>job.join</code>：启动协程并等待任务执行结束</li>
<li><code>job.await()</code></li>
</ul>
</blockquote>
<h4 id="CoroutineStart-ATOMIC"><a href="#CoroutineStart-ATOMIC" class="headerlink" title="CoroutineStart.ATOMIC"></a>CoroutineStart.ATOMIC</h4><blockquote>
<p>协程创建后，立即开始调度。</p>
<p><strong>在执行到第一个挂起点之前不会响应<code>cancel()</code></strong></p>
</blockquote>
<h4 id="CoroutineStart-UNDISPATCHED"><a href="#CoroutineStart-UNDISPATCHED" class="headerlink" title="CoroutineStart.UNDISPATCHED"></a>CoroutineStart.UNDISPATCHED</h4><blockquote>
<p>协程创建后，立即开始调度</p>
<p><strong>直到遇到第一个挂起点之前，都会在当前线程中执行。</strong></p>
</blockquote>
<p><a id="sec-3-cancel"></a></p>
<h3 id="协程取消-Cancel"><a href="#协程取消-Cancel" class="headerlink" title="协程取消-Cancel"></a>协程取消-Cancel</h3><blockquote>
<p>取消协程可以针对<code>CoroutineScope</code>或<code>Job</code>去执行。</p>
</blockquote>
<h4 id="取消作用域下所有协程"><a href="#取消作用域下所有协程" class="headerlink" title="取消作用域下所有协程"></a>取消作用域下所有协程</h4><blockquote>
<p>调用<code>CoroutineScope.cancel()</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> scope = CoroutineScope(context)<br><br>...<br><span class="hljs-keyword">if</span>(scope.isActive)&#123; <span class="hljs-comment">//判断当前scope是否活跃</span><br>  scope.cancel()<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>适用于页面关闭时，需要回收资源的情况</p>
<p><strong>不能在已取消的作用域中再次启动新的协程。</strong></p>
<h4 id="取消单个协程"><a href="#取消单个协程" class="headerlink" title="取消单个协程"></a>取消单个协程</h4><blockquote>
<p>针对<code>Job</code>进行取消，调用<code>cancel()</code>可以取消正在运行的协程</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//官方示例代码</span><br><span class="hljs-keyword">val</span> job = launch &#123;<br>    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;<br>        println(<span class="hljs-string">&quot;I&#x27;m sleeping <span class="hljs-variable">$i</span> ...&quot;</span>)<br>        delay(<span class="hljs-number">500L</span>)<br>    &#125;<br>&#125;<br>delay(<span class="hljs-number">1300L</span>) <span class="hljs-comment">// 等待一段时间</span><br>println(<span class="hljs-string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)<br>job.cancel() <span class="hljs-comment">// 取消 job</span><br>job.join() <span class="hljs-comment">// 等待 job 结束</span><br>println(<span class="hljs-string">&quot;main: Now I can quit.&quot;</span>)<br></code></pre></td></tr></table></figure>

<h5 id="协程之间的关系"><a href="#协程之间的关系" class="headerlink" title="协程之间的关系"></a>协程之间的关系</h5><blockquote>
<p>协程是存在着父子关系的，<strong>取消父协程时，也会取消所有子协程</strong></p>
</blockquote>
<p>主要有以下三种关系：</p>
<ol>
<li><p><code>父协程</code>调用<code>cancel()</code>或触发异常时，会立即取消所有<code>子协程</code>；<code>子协程</code>调用<code>cancel()</code>不影响父协程及兄弟协程的执行</p>
<blockquote>
<p>在底层实现中，子协程通过抛出异常的方式将取消的情况通知到父协程。</p>
<p>父协程通过传入的异常来决定是否处理异常，如果异常为<code>CancellationException</code>就不做处理。</p>
</blockquote>
</li>
<li><p><code>父协程</code>必须等到所有<code>子协程</code>完成才算完成</p>
</li>
<li><p><code>子协程</code>抛出未捕获的异常时，默认情况下会取消<code>父协程</code>(<code>superVisorJob</code>和<code>CancellationException</code>除外)</p>
</li>
</ol>
<h4 id="使协程可以取消"><a href="#使协程可以取消" class="headerlink" title="使协程可以取消"></a>使协程可以取消</h4><blockquote>
<p>协程处理任务的代码必须是<strong>协作式</strong>的，需要配合<code>协程取消</code>进行了处理。</p>
</blockquote>
<p>需要在任务处理期间<code>定期检查协程是否已被取消</code>，或者在处理耗时任务之前就<code>检查当前协程是否已取消</code>。</p>
<p>目前只有<code>kotlinx.coroutines</code>所有的挂起函数都是<code>可取消的</code>，例如<code>delay()</code>、<code>yield()</code>等，这些都不需要去检查协程是否已取消。</p>
<p>因此要使<code>协程可以被取消</code>，可以使用以下两种方法：</p>
<ul>
<li>通过<code>job.isActive</code>或<code>ensureActive()</code>检查协程状态</li>
<li>内部使用<code>delay()</code>或<code>yield()</code>等挂起函数——核心在于<code>suspendCoroutineUninterceptedOrReturn</code></li>
</ul>
<h5 id="检查Job的活跃状态-isActive"><a href="#检查Job的活跃状态-isActive" class="headerlink" title="检查Job的活跃状态-isActive"></a>检查Job的活跃状态-isActive</h5><blockquote>
<p>在协程执行过程中，添加<code>isActive</code>检查协程状态，若<code>!isActive</code>就不向下执行任务。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> job = scope.launch&#123;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">5</span> &amp;&amp; isActive)&#123;<br>    Log.e(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;now value = <span class="hljs-subst">$&#123;i++&#125;</span>&quot;</span>)<br>  &#125;<br>&#125;<br><br>...<br>job.cancel()<br></code></pre></td></tr></table></figure>

<p>还有一种方式就是<code>ensureActive()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Job.<span class="hljs-title">ensureActive</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isActive) <span class="hljs-keyword">throw</span> getCancellationException()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用<code>ensureActive()</code>可以不用手动去检测<code>isActive</code>，通过直接抛出异常来结束任务。</p>
<h5 id="使用挂起函数"><a href="#使用挂起函数" class="headerlink" title="使用挂起函数"></a>使用挂起函数</h5><blockquote>
<p><code>挂起函数</code>：<code>delay()</code>、<code>yield()</code>等函数，内部核心实现为<code>suspendCancellableCoroutine</code></p>
</blockquote>
<h6 id="delay"><a href="#delay" class="headerlink" title="delay()"></a>delay()</h6><blockquote>
<p>让协程挂起，而且不会阻塞CPU。类似于<code>Thread.sleep()</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (timeMillis &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// don&#x27;t delay</span><br>    <span class="hljs-keyword">return</span> suspendCancellableCoroutine <span class="hljs-symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; -&gt;<br>        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h6><blockquote>
<p>挂起当前协程，然后将协程分发到<code>Dispatcher</code>队列，可以让该协程所在线程或线程池可以运行其他协程逻辑，然后等待<code>Dispatcher</code>空闲的时候继续执行原来的协程任务。类似于<code>Thread.yield()</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> = suspendCoroutineUninterceptedOrReturn <span class="hljs-symbol">sc@</span> &#123; uCont -&gt;<br>    <span class="hljs-keyword">val</span> context = uCont.context<br>    context.checkCompletion()<br>    <span class="hljs-keyword">val</span> cont = uCont.intercepted() <span class="hljs-keyword">as</span>? DispatchedContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; ?: <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-built_in">Unit</span><br>    <span class="hljs-keyword">if</span> (!cont.dispatcher.isDispatchNeeded(context)) &#123;<br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> <span class="hljs-keyword">if</span> (cont.yieldUndispatched()) COROUTINE_SUSPENDED <span class="hljs-keyword">else</span> <span class="hljs-built_in">Unit</span><br>    &#125;<br>    cont.dispatchYield(<span class="hljs-built_in">Unit</span>)<br>    COROUTINE_SUSPENDED<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineContext.<span class="hljs-title">checkCompletion</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> job = <span class="hljs-keyword">get</span>(Job)<br>    <span class="hljs-keyword">if</span> (job != <span class="hljs-literal">null</span> &amp;&amp; !job.isActive) <span class="hljs-keyword">throw</span> job.getCancellationException()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行<code>yield()</code>时，会优先检测任务的完成状态，如果<code>!job.isActive</code>直接抛出<code>CancellableException</code></p>
<h6 id="suspendCoroutineUninterceptedOrReturn"><a href="#suspendCoroutineUninterceptedOrReturn" class="headerlink" title="suspendCoroutineUninterceptedOrReturn"></a>suspendCoroutineUninterceptedOrReturn</h6><blockquote>
<p>主要作用为<code>获取当前协程的实例，并且挂起当前协程或者不挂起直接返回结果</code>。</p>
</blockquote>
<p>根据上述源码发现，<code>挂起函数</code>的关键在于<code>suspendCoroutineUninterceptedOrReturn</code>，只要使用了该方法，就可以成为<code>挂起函数</code>。</p>
<p>通过做转换的时候，可以使用系统提供的两个转换函数：</p>
<ul>
<li><code>suspendCoroutine</code></li>
<li><code>suspendCancellableCoroutine</code><em>推荐使用</em></li>
</ul>
<h4 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h4><h5 id="suspendCoroutine"><a href="#suspendCoroutine" class="headerlink" title="suspendCoroutine"></a>suspendCoroutine</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> = suspendCoroutine&lt;String&gt; &#123; continuation -&gt;<br>    <span class="hljs-keyword">if</span> (...) &#123;<br>        continuation.resume(<span class="hljs-string">&quot;11&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        continuation.resumeWithException(NullPointerException(<span class="hljs-string">&quot;123&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="suspendCancellableCoroutine"><a href="#suspendCancellableCoroutine" class="headerlink" title="suspendCancellableCoroutine"></a>suspendCancellableCoroutine</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> aa = <span class="hljs-number">0</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ttt</span><span class="hljs-params">()</span></span> = suspendCancellableCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; cancellableContinuation -&gt;<br>    <span class="hljs-keyword">if</span> (aa == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//执行完毕抛出结果</span><br>        cancellableContinuation.resume(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 执行过程异常捕获</span><br>            log(<span class="hljs-string">&quot;aaa <span class="hljs-subst">$&#123;it.message&#125;</span>&quot;</span>)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cancellableContinuation.resumeWithException(IllegalArgumentException(<span class="hljs-string">&quot;123&quot;</span>))<br>    &#125;<br><br>    cancellableContinuation.invokeOnCancellation &#123;<br>       <span class="hljs-comment">//协程任务执行cancel时，回调该方法</span><br>        log(<span class="hljs-string">&quot;我被取消了&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以通过<code>continuation.invokeCancellation()</code>执行取消操作</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: T =<br>    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;<br>        <span class="hljs-keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * For non-atomic cancellation we setup parent-child relationship immediately</span><br><span class="hljs-comment">         * in case when `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but</span><br><span class="hljs-comment">         * properly supports cancellation.</span><br><span class="hljs-comment">         */</span><br>        cancellable.initCancellability()<br>        block(cancellable)<br>        cancellable.getResult()<br>    &#125;<br></code></pre></td></tr></table></figure>



<h4 id="禁止取消"><a href="#禁止取消" class="headerlink" title="禁止取消"></a>禁止取消</h4><blockquote>
<p>当任务被取消时，挂起函数会收到<code>CancellationException</code>后续如果需要执行一些其他的挂起函数任务将无法执行。</p>
</blockquote>
<p>对挂起函数调用<code>withContext(NonCancellable)</code>，保证挂起函数正常执行。</p>
<p>关键在于<code>isActive</code>永远为<code>true</code></p>
<h4 id="超时取消"><a href="#超时取消" class="headerlink" title="超时取消"></a>超时取消</h4><blockquote>
<p>大部分取消协程的原因都是<strong>超出了预期的执行时间</strong>，此时就会去触发取消的操作。</p>
</blockquote>
<p>对挂起函数调用<code>withTimeout(XX)</code>或<code>withTimeoutOrNull(XX)</code>，唯一的区别就是后者会返回<code>null</code>而不是抛出异常。</p>
<p><a id="sec-3-cancel-deep"></a></p>
<h3 id="取消语义深水区（补充）"><a href="#取消语义深水区（补充）" class="headerlink" title="取消语义深水区（补充）"></a>取消语义深水区（补充）</h3><ul>
<li>取消是<strong>协作式</strong>的：可取消挂起点或主动检查<code>isActive</code>后，协程才会及时停止。</li>
<li><code>CancellationException</code>通常代表控制流，不建议当成普通业务异常吞掉。</li>
<li>在<code>finally</code>中调用挂起函数时，默认仍会受取消影响，需要<code>withContext(NonCancellable)</code>兜底。</li>
<li>使用<code>suspendCancellableCoroutine</code>对接回调时，务必实现<code>invokeOnCancellation</code>释放资源。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">try</span> &#123;<br>    doWork()<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    withContext(NonCancellable) &#123;<br>        closeResource()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a id="sec-3-android-practice"></a></p>
<h3 id="Android-使用建议（工程实践）"><a href="#Android-使用建议（工程实践）" class="headerlink" title="Android 使用建议（工程实践）"></a>Android 使用建议（工程实践）</h3><ul>
<li>页面生命周期相关任务优先使用<code>viewModelScope</code>或<code>lifecycleScope</code>，避免<code>GlobalScope</code>。</li>
<li>UI 更新统一放在<code>Dispatchers.Main</code>，IO&#x2F;网络放在<code>Dispatchers.IO</code>。</li>
<li>对关键请求增加超时边界：<code>withTimeout</code>或<code>withTimeoutOrNull</code>。</li>
<li>对可并发任务优先用<code>coroutineScope + async/awaitAll</code>，对“局部失败可接受”场景用<code>supervisorScope</code>。</li>
<li>长循环或计算任务增加<code>isActive/ensureActive</code>检查，提升取消响应速度。</li>
<li><code>Flow</code>收集优先使用<code>repeatOnLifecycle</code>，避免页面不可见时持续收集。</li>
<li>Compose 场景区分<code>LaunchedEffect</code>与<code>rememberCoroutineScope</code>的职责边界。</li>
</ul>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">viewModelScope.launch &#123;<br>    <span class="hljs-keyword">val</span> profile = withContext(Dispatchers.IO) &#123; repository.loadProfile() &#125;<br>    _uiState.value = UiState.Success(profile)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a id="sec-3-antipatterns"></a></p>
<h3 id="常见反模式与修正建议"><a href="#常见反模式与修正建议" class="headerlink" title="常见反模式与修正建议"></a>常见反模式与修正建议</h3><table>
<thead>
<tr>
<th>反模式</th>
<th>风险</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>页面层直接用<code>GlobalScope</code></td>
<td>生命周期失控、任务泄漏</td>
<td>使用<code>viewModelScope/lifecycleScope</code></td>
</tr>
<tr>
<td><code>async</code>创建后不<code>await</code></td>
<td>异常与结果丢失</td>
<td>明确<code>await</code>或改用<code>launch</code></td>
</tr>
<tr>
<td>高频小任务频繁<code>withContext</code></td>
<td>调度开销放大</td>
<td>合并批处理，减少切换次数</td>
</tr>
<tr>
<td>吞掉<code>CancellationException</code></td>
<td>取消链路被破坏</td>
<td>仅清理资源后向外抛出</td>
</tr>
<tr>
<td>多处随意新建根<code>CoroutineScope</code></td>
<td>并发关系不可追踪</td>
<td>统一作用域入口，结构化管理</td>
</tr>
</tbody></table>
<p><a id="sec-4"></a></p>
<h2 id="四、协程为什么能挂起（原理实现）"><a href="#四、协程为什么能挂起（原理实现）" class="headerlink" title="四、协程为什么能挂起（原理实现）"></a>四、协程为什么能挂起（原理实现）</h2><p><a id="sec-4-dispatcher-principle"></a></p>
<h3 id="Dispatchers原理"><a href="#Dispatchers原理" class="headerlink" title="Dispatchers原理"></a>Dispatchers原理</h3><p>无论是<code>Dispatchers.Default</code>或者<code>IO</code>都是<code>CoroutineDispatcher</code>的子类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineDispatcher</span> :<br>    <span class="hljs-type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;<br>    <span class="hljs-comment">//线程调度，指定协程在某一线程上运行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span>      <br>    <span class="hljs-comment">//封装 Continuation 为 DispatchedContinuation</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =<br>        DispatchedContinuation(<span class="hljs-keyword">this</span>, continuation)<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>CoroutineDispatacher</code>继承<code>AbstractCoroutineContextElement</code>类，还实现了<code>ContinuationInterceptor</code>接口。</p>
<h4 id="DispatchedContinuation"><a href="#DispatchedContinuation" class="headerlink" title="DispatchedContinuation"></a>DispatchedContinuation</h4><blockquote>
<p>代理协程体Continuation对象并持有线程调度器，负责<strong>使用线程调度器将协程体调度到执行的线程执行</strong>。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispatchedContinuation</span>&lt;<span class="hljs-type">in T</span>&gt;(<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> dispatcher: CoroutineDispatcher,<br>    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;<br>) : DispatchedTask&lt;T&gt;(MODE_ATOMIC_DEFAULT), CoroutineStackFrame, Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br>  <br>  <br>     <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;  <br>         <span class="hljs-keyword">val</span> context = continuation.context  <br>         <span class="hljs-keyword">val</span> state = result.toState()  <br>         <span class="hljs-comment">// 是否需要线程调度  </span><br>         <span class="hljs-keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;  <br>             _state = state  <br>             resumeMode = MODE_ATOMIC_DEFAULT  <br>             <span class="hljs-comment">// dispatch 调度线程，第二个参数是一个Runnable类型，这里传参this也就是DispatchedContinuation自身  </span><br>             <span class="hljs-comment">// DispatchedContinuation实际上也是一个Runnable对象，调用调度器的dispatch方法之后就可以使这个runnable在指定的线程运行了  </span><br>             dispatcher.dispatch(context, <span class="hljs-keyword">this</span>)  <br>         &#125; <span class="hljs-keyword">else</span> &#123;  <br>             executeUnconfined(state, MODE_ATOMIC_DEFAULT) &#123;  <br>                 withCoroutineContext(<span class="hljs-keyword">this</span>.context, countOrElement) &#123;  <br>                     <span class="hljs-comment">// 不需要调度，执行协程体的resumeWith  </span><br>                     continuation.resumeWith(result)  <br>                 &#125;  <br>             &#125;  <br>         &#125;  <br>     &#125;  <br>      <span class="hljs-comment">// 默认启动模式  </span><br>      <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeCancellableWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;  <br>         <span class="hljs-keyword">val</span> state = result.toState()  <br>         <span class="hljs-keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;  <br>             _state = state  <br>             resumeMode = MODE_CANCELLABLE  <br>             dispatcher.dispatch(context, <span class="hljs-keyword">this</span>)  <br>         &#125; <span class="hljs-keyword">else</span> &#123;  <br>             executeUnconfined(state, MODE_CANCELLABLE) &#123;  <br>                 <span class="hljs-keyword">if</span> (!resumeCancelled()) &#123;  <br>                     resumeUndispatchedWith(result)  <br>                 &#125;  <br>             &#125;  <br>         &#125;  <br>     &#125;    <br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>DispatchedContinuation</code>用两个参数构建</p>
<ul>
<li><code>dispatcher</code>：拦截器</li>
<li><code>continuation</code>：协程体类对象</li>
</ul>
<p>其中<code>resumeWith()</code>和<code>resumeCancellableWith()</code>负责协程的启动。</p>
<p>补充：<code>resumeWith()</code>用于普通恢复；<code>resumeCancellableWith()</code>会在恢复前额外检查取消状态，并按可取消模式进行调度。</p>
<p><a id="sec-4-start-flow"></a></p>
<h3 id="协程启动流程"><a href="#协程启动流程" class="headerlink" title="协程启动流程"></a>协程启动流程</h3><ol>
<li>通过<code>CoroutineScope.launch()</code>创建一个协程，默认启动模式为<code>CoroutineStart.DEFAULT</code>，创建一个<code>StandaloneCoroutine</code>协程对象</li>
<li>执行<code>StandaloneCoroutine.start()</code>实质执行到<code>AbstractCoroutine.start()</code>，继续触发到<code>CoroutineStart.invoke()</code></li>
<li>由于默认调度器为<code>Dispatchers.Default</code>，所以执行到了<code>startCoroutineCancellable()</code></li>
<li><code>startCoroutineCancellable()</code>内部主要有三次调用<ul>
<li><code>createCoroutineUnintercepted()</code>：创建一个协程体类对象</li>
<li><code>intercepted</code>：将协程体类包装成<code>DispatchedContinuation</code>对象</li>
<li><code>resumeCancellableWith()</code>：通过<code>Default</code>调用到<code>resumeCancellableWith()</code></li>
</ul>
</li>
<li>实际调用到了<code>DispatchedContinuation.resumeCancellableWith()</code>，最后执行到<code>Continuation.resumeWith()</code>执行协程任务。</li>
</ol>
<p><a id="sec-4-suspend-resume"></a></p>
<h3 id="协程挂起-恢复原理"><a href="#协程挂起-恢复原理" class="headerlink" title="协程挂起&#x2F;恢复原理"></a>协程挂起&#x2F;恢复原理</h3><blockquote>
<p>挂起的特点：<strong>不阻塞线程</strong>。挂起的本质<strong>切线程</strong>，并且在相应逻辑处理完毕之后，再重新切回线程。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loginUser</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>  <span class="hljs-keyword">val</span> user = logUserIn(userId, password)<br>  <span class="hljs-keyword">val</span> userDb = logUserIn(user)<br>  <span class="hljs-keyword">return</span> userDb<br>&#125;<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logUserIn</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>)</span></span>: String<br><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logUserIn</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span>: String<br></code></pre></td></tr></table></figure>

<p>反编译后得到</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loginUser</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>, completion: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span> &#123;<br>  <span class="hljs-keyword">val</span> user = logUserIn(userId, password)<br>  <span class="hljs-keyword">val</span> userDb = logUserIn(user)<br>  completion.resume(userDb)<br>&#125;<br></code></pre></td></tr></table></figure>



<p>调用<code>挂起函数</code>或者<code>suspend lambda表达式</code>时，都会一个<code>隐式参数</code>传入，这个参数是<code>Continuation</code>类型。</p>
<blockquote>
<p>CPS：续体传递风格</p>
<p>在每个<code>挂起函数</code>与<code>suspend lambda表达式</code>都会附加一个<code>Continuation</code>参数，并且是用来代替<code>suspend</code></p>
</blockquote>
<h4 id="Continuation接口"><a href="#Continuation接口" class="headerlink" title="Continuation接口"></a>Continuation接口</h4><p><code>挂起函数</code>通过<code>Continuation</code>在方法间互相通信，基本实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Continuation</span>&lt;<span class="hljs-type">in T</span>&gt; &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(value: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Unit</span> =<br>    resumeWith(Result.success(value))<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resumeWithException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Unit</span> =<br>    resumeWith(Result.failure(exception))<br><br></code></pre></td></tr></table></figure>

<p>后续添加<code>resume(value)</code>和<code>resumeWithException(exception)</code>可以方便的获取结果，而不需要从<code>Result</code>解析。</p>
<p><code>Continuation</code>主要有以下参数和方法</p>
<ul>
<li><code>context</code>：内部使用的<code>CoroutineContext</code></li>
<li><code>resumeWith()</code>：恢复协程的执行，同时传入一个<code>Result</code>。内部包括了<code>计算结果</code>或<code>过程中发生的异常</code></li>
</ul>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><blockquote>
<p>Kotlin编译器会确定函数何时可以在内部挂起，每个挂起点都会被声明为有限状态机的一个状态，每个状态用<code>label</code>表示</p>
</blockquote>
<p>查看反编译后源码，内部源码大概如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">loginUser</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String userId, <span class="hljs-meta">@NotNull</span> String password, <span class="hljs-meta">@NotNull</span> Continuation $completion)</span> &#123;<br>     Object $continuation;<br>     label27: &#123;<br>        <span class="hljs-keyword">if</span> ($completion <span class="hljs-keyword">instanceof</span> &lt;undefinedtype&gt;) &#123;<br>           $continuation = (&lt;undefinedtype&gt;)$completion;<br>           <span class="hljs-keyword">if</span> ((((&lt;undefinedtype&gt;)$continuation).label &amp; Integer.MIN_VALUE) != <span class="hljs-number">0</span>) &#123;<br>              ((&lt;undefinedtype&gt;)$continuation).label -= Integer.MIN_VALUE;<br>              <span class="hljs-keyword">break</span> label27;<br>           &#125;<br>        &#125;<br><br>        $continuation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContinuationImpl</span>($completion) &#123;<br>           <span class="hljs-comment">// $FF: synthetic field</span><br>           Object result;<br>           <span class="hljs-type">int</span> label;<br>           Object L$<span class="hljs-number">0</span>;<br>           Object L$<span class="hljs-number">1</span>;<br>           Object L$<span class="hljs-number">2</span>;<br>           Object L$<span class="hljs-number">3</span>;<br><br>           <span class="hljs-meta">@Nullable</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">invokeSuspend</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Object $result)</span> &#123;<br>              <span class="hljs-built_in">this</span>.result = $result;<br>              <span class="hljs-built_in">this</span>.label |= Integer.MIN_VALUE;<br>              <span class="hljs-keyword">return</span> MyClass.<span class="hljs-built_in">this</span>.loginUser((String)<span class="hljs-literal">null</span>, (String)<span class="hljs-literal">null</span>, <span class="hljs-built_in">this</span>);<br>           &#125;<br>        &#125;;<br>     &#125;<br><br>     Object var10000;<br>     label22: &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">$result</span> <span class="hljs-operator">=</span> ((&lt;undefinedtype&gt;)$continuation).result;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">var8</span> <span class="hljs-operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();<br>        String user;<br>        <span class="hljs-keyword">switch</span>(((&lt;undefinedtype&gt;)$continuation).label) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-comment">//错误检查</span><br>           ResultKt.throwOnFailure($result);<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">0</span> = <span class="hljs-built_in">this</span>;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">1</span> = userId;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">2</span> = password;<br>            <span class="hljs-comment">//设置 label为1 下次执行切换到 case 1</span><br>           ((&lt;undefinedtype&gt;)$continuation).label = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//当前状态机执行的流程</span><br>           var10000 = <span class="hljs-built_in">this</span>.logUserIn(userId, password, (Continuation)$continuation);<br>           <span class="hljs-keyword">if</span> (var10000 == var8) &#123;<br>              <span class="hljs-keyword">return</span> var8;<br>           &#125;<br>           <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>           password = (String)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">2</span>;<br>           userId = (String)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">1</span>;<br>           <span class="hljs-built_in">this</span> = (MyClass)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">0</span>;<br>           ResultKt.throwOnFailure($result);<br>           user = (String)var10000;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">0</span> = <span class="hljs-built_in">this</span>;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">1</span> = userId;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">2</span> = password;<br>           ((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">3</span> = user;<br>           ((&lt;undefinedtype&gt;)$continuation).label = <span class="hljs-number">2</span>;<br>            var10000 = <span class="hljs-built_in">this</span>.logUserIn(user, (Continuation)$continuation);<br>           <span class="hljs-keyword">if</span> (var10000 == var8) &#123;<br>              <span class="hljs-keyword">return</span> var8;<br>           &#125;             <br>           var10000 = $result;<br>           <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>           user = (String)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">3</span>;<br>           password = (String)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">2</span>;<br>           userId = (String)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">1</span>;<br>           <span class="hljs-type">MyClass</span> <span class="hljs-variable">var9</span> <span class="hljs-operator">=</span> (MyClass)((&lt;undefinedtype&gt;)$continuation).L$<span class="hljs-number">0</span>;<br>           ResultKt.throwOnFailure($result);<br>           var10000 = $result;<br>           <span class="hljs-keyword">break</span> label22;<br>        <span class="hljs-keyword">default</span>:<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);<br>        &#125;<br><br>     &#125;<br><br>     <span class="hljs-type">String</span> <span class="hljs-variable">userDb</span> <span class="hljs-operator">=</span> (String)var10000;<br>     <span class="hljs-keyword">return</span> userDb;<br>  &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Kotlin编译器将每个<code>挂起函数</code>转换为一个状态机，在每次函数需要挂起时使用回调并进行优化。</p>
</blockquote>
<p>观察上述源码发现主要有几个关键点</p>
<h5 id="ContinuationImpl"><a href="#ContinuationImpl" class="headerlink" title="ContinuationImpl"></a>ContinuationImpl</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContinuationImpl</span>(<br>    completion: Continuation&lt;Any?&gt;?,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _context: CoroutineContext?<br>) : BaseContinuationImpl(completion) &#123;<br>    <span class="hljs-keyword">constructor</span>(completion: Continuation&lt;Any?&gt;?) : <span class="hljs-keyword">this</span>(completion, completion?.context)<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = _context!!<br><br>    <span class="hljs-meta">@Transient</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> intercepted: Continuation&lt;Any?&gt;? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercepted</span><span class="hljs-params">()</span></span>: Continuation&lt;Any?&gt; =<br>        intercepted<br>            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="hljs-keyword">this</span>) ?: <span class="hljs-keyword">this</span>)<br>                .also &#123; intercepted = it &#125;<br><br>&#125;<br><br><span class="hljs-comment">//其中 invokeSuspend()是由BaseContinuationImpl实现</span><br><br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseContinuationImpl</span>(<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> completion: Continuation&lt;Any?&gt;?<br>) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> current = <span class="hljs-keyword">this</span><br>        <span class="hljs-keyword">var</span> param = result<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            probeCoroutineResumed(current)<br>            with(current) &#123;<br>                <span class="hljs-keyword">val</span> completion = completion!! <br>                <span class="hljs-keyword">val</span> outcome: Result&lt;Any?&gt; =<br>                    <span class="hljs-keyword">try</span> &#123;<br>                      <span class="hljs-comment">//调用 invokeSuspend 真正执行协程体</span><br>                        <span class="hljs-keyword">val</span> outcome = invokeSuspend(param)<br>                      <span class="hljs-comment">//如果返回值为 CORPUTINE_SUSPENDED ，需要执行挂起操作</span><br>                        <span class="hljs-keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="hljs-keyword">return</span><br>                      <span class="hljs-comment">//协程体执行成功</span><br>                        Result.success(outcome)<br>                    &#125; <span class="hljs-keyword">catch</span> (exception: Throwable) &#123;<br>                      <span class="hljs-comment">//协程体执行异常</span><br>                        Result.failure(exception)<br>                    &#125;<br>                releaseIntercepted() <span class="hljs-comment">// this state machine instance is terminating</span><br>                <span class="hljs-keyword">if</span> (completion <span class="hljs-keyword">is</span> BaseContinuationImpl) &#123;<br>                    <span class="hljs-comment">// unrolling recursion via loop</span><br>                    current = completion<br>                    param = outcome<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-comment">//此处表示 StandaloneCoroutine</span><br>                    completion.resumeWith(outcome)<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invokeSuspend</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Any</span>?&gt;)</span></span>: Any?<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>invokeSuspend()</code>执行的就是<code>协程体</code>，当<code>invokeSuspend()</code>返回值为<code>COROUTINE_SUSPENDED</code>时，执行<code>return操作</code>，协程体的操作也会被结束，所以<code>COROUTINE_SUSPENDED</code>也表示<strong>协程发生挂起</strong>。</p>
<h4 id="协程挂起"><a href="#协程挂起" class="headerlink" title="协程挂起"></a>协程挂起</h4><blockquote>
<p>通过挂起函数将协程挂起，此处拿<code>withContext()</code>进行分析</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">withContext</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    context: <span class="hljs-type">CoroutineContext</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: T = suspendCoroutineUninterceptedOrReturn <span class="hljs-symbol">sc@</span> &#123; uCont -&gt;<br><br>    <span class="hljs-keyword">val</span> oldContext = uCont.context<br>    <span class="hljs-keyword">val</span> newContext = oldContext + context<br>   <span class="hljs-comment">//检查协程是否活跃</span><br>    newContext.checkCompletion()<br><br>    <span class="hljs-keyword">if</span> (newContext === oldContext) &#123;<br>        <span class="hljs-keyword">val</span> coroutine = ScopeCoroutine(newContext, uCont) <span class="hljs-comment">// MODE_DIRECT</span><br>        <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) &#123;<br>        <span class="hljs-keyword">val</span> coroutine = UndispatchedCoroutine(newContext, uCont) <span class="hljs-comment">// MODE_UNDISPATCHED</span><br>        <span class="hljs-comment">// There are changes in the context, so this thread needs to be updated</span><br>        withCoroutineContext(newContext, <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span><span class="hljs-symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> coroutine = DispatchedCoroutine(newContext, uCont) <span class="hljs-comment">// MODE_CANCELLABLE</span><br>    coroutine.initParentJob()<br>   <span class="hljs-comment">//coroutine 为 DispatchedCoroutine，持有需要恢复的协程                                                 </span><br>    block.startCoroutineCancellable(coroutine, coroutine)<br>    <span class="hljs-comment">//返回结果为 挂起 还是完成                                              </span><br>    coroutine.getResult()<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">//DispatchedCoroutine.kt</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>: Any? &#123;<br>      <span class="hljs-comment">//需要挂起，则返回COROUTINE_SUSPENDED</span><br>        <span class="hljs-keyword">if</span> (trySuspend()) <span class="hljs-keyword">return</span> COROUTINE_SUSPENDED<br>        <span class="hljs-comment">// otherwise, onCompletionInternal was already invoked &amp; invoked tryResume, and the result is in the state</span><br>        <span class="hljs-keyword">val</span> state = <span class="hljs-keyword">this</span>.state.unboxState()<br>        <span class="hljs-keyword">if</span> (state <span class="hljs-keyword">is</span> CompletedExceptionally) <span class="hljs-keyword">throw</span> state.cause<br>        <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">return</span> state <span class="hljs-keyword">as</span> T<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">trySuspend</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        _decision.loop &#123; decision -&gt;<br>            <span class="hljs-keyword">when</span> (decision) &#123;<br>                UNDECIDED -&gt; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._decision.compareAndSet(UNDECIDED, SUSPENDED)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                RESUMED -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;Already suspended&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>协程是否挂起，关键在于<strong>是否返回COROUTINE_SUSPENDED</strong>，在<code>getResult()</code>中就是判断<code>trySuspend()</code>是否返回<code>true</code>。</p>
</blockquote>
<p><img src="/images/%E5%8D%8F%E7%A8%8B%E6%8C%82%E8%B5%B7%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="协程挂起"></p>
<h4 id="协程恢复"><a href="#协程恢复" class="headerlink" title="协程恢复"></a>协程恢复</h4><p>在<code>withContext()</code>中调用<code>startCoroutine()</code>传入了两个参数，其中第二个表示<code>协程完成的回调</code>。</p>
<p>当协程完成的时候会调用<code>resumeWith()</code>，然后层层传递到<code>JobSupport.afterCompletion()</code>，最后执行到<code>DispatchedCoroutine</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterCompletionInternal</span><span class="hljs-params">(state: <span class="hljs-type">Any</span>?, mode: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (tryResume()) <span class="hljs-keyword">return</span> <span class="hljs-comment">// completed before getResult invocation -- bail out</span><br>    <span class="hljs-comment">// otherwise, getResult has already commenced, i.e. completed later or in other thread</span><br>    <span class="hljs-keyword">super</span>.afterCompletionInternal(state, mode)<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryResume</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    _decision.loop &#123; decision -&gt;<br>        <span class="hljs-keyword">when</span> (decision) &#123;<br>            UNDECIDED -&gt; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._decision.compareAndSet(UNDECIDED, RESUMED)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            SUSPENDED -&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;Already resumed&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>afterCompletionInternal()</code>判断协程是否被挂起，若挂起则恢复已被挂起的协程。</p>
<p>然后再回到执行线程上，就会继续执行<code>invokeSuspend()</code>直到执行结束。</p>
<p><img src="/images/%E5%8D%8F%E7%A8%8B%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="协程恢复"></p>
<p><a id="sec-4-concurrency"></a></p>
<h3 id="协程并发"><a href="#协程并发" class="headerlink" title="协程并发"></a>协程并发</h3><p>协程并发建议优先使用<code>结构化并发</code>：在同一个作用域内启动并行任务，并在作用域退出前统一等待结果或处理异常。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadAll</span><span class="hljs-params">()</span></span>: List&lt;String&gt; = coroutineScope &#123;<br>    <span class="hljs-keyword">val</span> a = async(Dispatchers.IO) &#123; requestA() &#125;<br>    <span class="hljs-keyword">val</span> b = async(Dispatchers.IO) &#123; requestB() &#125;<br>    awaitAll(a, b)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>并发任务推荐放在<code>coroutineScope</code>中，失败会自动取消同级任务，避免悬挂任务。</li>
<li>如果希望“一个子任务失败不影响其他子任务”，可使用<code>supervisorScope</code>。</li>
<li>IO 并发建议配合限流（如<code>limitedParallelism</code>或<code>Semaphore</code>），避免无限并发导致线程池拥塞。</li>
</ul>
<p><a id="sec-4-test-observability"></a></p>
<h3 id="测试与可观测性（补充）"><a href="#测试与可观测性（补充）" class="headerlink" title="测试与可观测性（补充）"></a>测试与可观测性（补充）</h3><ul>
<li>单元测试推荐使用<code>runTest</code>与<code>StandardTestDispatcher</code>，通过虚拟时间驱动挂起逻辑。</li>
<li>对延时与超时场景，使用<code>advanceTimeBy</code>&#x2F;<code>advanceUntilIdle</code>验证行为。</li>
<li>为关键协程增加<code>CoroutineName</code>，方便日志与问题定位。</li>
<li>调试复杂并发问题时，可结合协程调试工具或协程 dump 快照观察挂起链路。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">timeout_case</span><span class="hljs-params">()</span></span> = runTest &#123;<br>    <span class="hljs-keyword">val</span> result = withTimeoutOrNull(<span class="hljs-number">1000</span>) &#123;<br>        delay(<span class="hljs-number">2000</span>)<br>        <span class="hljs-number">1</span><br>    &#125;<br>    assert(result == <span class="hljs-literal">null</span>)<br>&#125;<br></code></pre></td></tr></table></figure>



<p><a id="sec-5"></a></p>
<h2 id="五、知识点总结（可口述）"><a href="#五、知识点总结（可口述）" class="headerlink" title="五、知识点总结（可口述）"></a>五、知识点总结（可口述）</h2><p><a id="sec-5-principle-30"></a></p>
<h3 id="协程原理速答（30秒）"><a href="#协程原理速答（30秒）" class="headerlink" title="协程原理速答（30秒）"></a>协程原理速答（30秒）</h3><p>协程原理可以概括为：<strong>编译期状态机 + 运行时调度</strong>。</p>
<ul>
<li><code>suspend</code>函数会被编译器转换为 CPS 形式，增加<code>Continuation</code>参数。</li>
<li>每个挂起点会被拆成状态机的一个<code>label</code>分支。</li>
<li>执行到挂起点返回<code>COROUTINE_SUSPENDED</code>，协程挂起但线程不阻塞。</li>
<li>异步结果返回后，通过<code>resumeWith</code>恢复执行，并按<code>label</code>继续后续逻辑。</li>
<li><code>CoroutineDispatcher</code>通过<code>ContinuationInterceptor</code>决定恢复在哪个线程执行。</li>
</ul>
<p><a id="sec-5-principle-2m"></a></p>
<h3 id="协程原理展开（2分钟）"><a href="#协程原理展开（2分钟）" class="headerlink" title="协程原理展开（2分钟）"></a>协程原理展开（2分钟）</h3><p>可以按这条主线理解：</p>
<ol>
<li><strong>创建阶段</strong>：<code>launch/async</code>创建协程对象，绑定<code>CoroutineContext</code>（<code>Job + Dispatcher + ...</code>）。</li>
<li><strong>编译转换</strong>：<code>suspend</code>函数被转成状态机，挂起点对应<code>label</code>，本质是可恢复的函数调用链。</li>
<li><strong>启动执行</strong>：协程启动时会创建并包装<code>Continuation</code>，必要时被<code>Dispatcher</code>拦截调度。</li>
<li><strong>挂起时机</strong>：遇到可挂起点返回<code>COROUTINE_SUSPENDED</code>，当前调用栈退出，线程可执行其他任务。</li>
<li><strong>恢复执行</strong>：回调或结果就绪后触发<code>resumeWith</code>，状态机按上次<code>label</code>继续执行。</li>
<li><strong>生命周期管理</strong>：<code>Job</code>树维护父子协程关系，取消是协作式，异常按层级传播（<code>SupervisorJob</code>可隔离子任务失败）。</li>
</ol>
<p><a id="sec-5-faq"></a></p>
<h3 id="高频追问知识点（补充）"><a href="#高频追问知识点（补充）" class="headerlink" title="高频追问知识点（补充）"></a>高频追问知识点（补充）</h3><ul>
<li><strong>挂起 vs 阻塞</strong>：挂起是让出执行权，不占线程；阻塞会占住线程直到完成。</li>
<li><strong>协程为什么轻量</strong>：创建与切换主要在用户态完成，通常比线程上下文切换成本低。</li>
<li><strong>为什么<code>async</code>异常常在<code>await()</code>暴露</strong>：异常被封装在<code>Deferred</code>中，读取结果时才抛出。</li>
<li><strong>取消为什么不一定立刻生效</strong>：取消是协作式，需要挂起点或主动检查<code>isActive/ensureActive</code>。</li>
<li><strong><code>Main.immediate</code>意义</strong>：已在主线程时避免二次分发，减少一跳调度延迟。</li>
</ul>
<p><a id="sec-6"></a></p>
<h2 id="六、参考与延伸"><a href="#六、参考与延伸" class="headerlink" title="六、参考与延伸"></a>六、参考与延伸</h2><p><a target="_blank" rel="noopener" href="https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md">Kotlin&#x2F;Keep</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/user/2277843822969863">Android_开发者</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&mid=2247495170&idx=1&sn=b54e233699fd7bba0e940e2837258002&chksm=f9f279d1ce85f0c741857443332c20a82caedc24d8ea798219c2098c2d09ee58e11a6aba9296&mpshare=1&scene=23&srcid=1212Jz0IsITrVDTTTBRNCn0j&sharer_sharetime=1607751713936&sharer_shareid=65073698ab9ac2983b955fa53b4ff585%23rd">Kotlin协程原理解析</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6883652600462327821#heading-10">图解协程：suspend</a></p>
<!-- https://juejin.cn/post/6890348438873964551#heading-1 -->

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Kotlin/" class="print-no-link">#Kotlin</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Kotlin协程原理</div>
      <div>https://leo-wxy.github.io/2020/09/04/Kotlin协程原理/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Leo-Wxy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年9月4日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/13/Java-AbstractQueuedSynchronizer%E7%AE%80%E4%BB%8B/" title="Java-AbstractQueuedSynchronizer简介">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java-AbstractQueuedSynchronizer简介</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/08/14/WebRTC%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3/" title="WebRTC音频处理模块相关">
                        <span class="hidden-mobile">WebRTC音频处理模块相关</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
